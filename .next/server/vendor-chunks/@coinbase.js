"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@coinbase";
exports.ids = ["vendor-chunks/@coinbase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ACTION_DECORATOR_KEY = void 0;\nexports.CreateAction = CreateAction;\nconst wallet_providers_1 = __webpack_require__(/*! ../wallet-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst analytics_1 = __webpack_require__(/*! ../analytics */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/analytics/index.js\");\n__webpack_require__(/*! reflect-metadata */ \"(ssr)/./node_modules/reflect-metadata/Reflect.js\");\n/**\n * Metadata key for the action decorator\n */\nexports.ACTION_DECORATOR_KEY = Symbol(\"agentkit:action\");\n/**\n * Decorator to embed metadata on class methods to indicate they are actions accessible to the agent\n *\n * @param params - The parameters for the action decorator\n * @returns A decorator function\n *\n * @example\n * ```typescript\n * class MyActionProvider extends ActionProvider {\n *   @CreateAction({ name: \"my_action\", description: \"My action\", schema: myActionSchema })\n *   public myAction(args: z.infer<typeof myActionSchema>) {\n *     // ...\n *   }\n * }\n * ```\n */\nfunction CreateAction(params) {\n    return (target, propertyKey, descriptor) => {\n        const prefixedActionName = `${target.constructor.name}_${params.name}`;\n        const originalMethod = descriptor.value;\n        const { isWalletProvider } = validateActionMethodArguments(target, propertyKey);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        descriptor.value = function (...args) {\n            let walletMetrics = {};\n            if (isWalletProvider) {\n                walletMetrics = {\n                    wallet_provider: args[0].getName(),\n                    wallet_address: args[0].getAddress(),\n                    network_id: args[0].getNetwork().networkId,\n                    chain_id: args[0].getNetwork().chainId,\n                    protocol_family: args[0].getNetwork().protocolFamily,\n                };\n            }\n            (0, analytics_1.sendAnalyticsEvent)({\n                name: \"agent_action_invocation\",\n                action: \"invoke_action\",\n                component: \"agent_action\",\n                action_name: prefixedActionName,\n                class_name: target.constructor.name,\n                method_name: propertyKey,\n                ...walletMetrics,\n            });\n            return originalMethod.apply(this, args);\n        };\n        const existingMetadata = Reflect.getMetadata(exports.ACTION_DECORATOR_KEY, target.constructor) || new Map();\n        const metaData = {\n            name: prefixedActionName,\n            description: params.description,\n            schema: params.schema,\n            invoke: descriptor.value,\n            walletProvider: isWalletProvider,\n        };\n        existingMetadata.set(propertyKey, metaData);\n        Reflect.defineMetadata(exports.ACTION_DECORATOR_KEY, existingMetadata, target.constructor);\n        return target;\n    };\n}\n/**\n * Validates the arguments of an action method\n *\n * @param target - The target object\n * @param propertyKey - The property key\n * @returns An object containing the wallet provider flag\n */\nfunction validateActionMethodArguments(target, propertyKey) {\n    const className = target instanceof Object ? target.constructor.name : undefined;\n    const params = Reflect.getMetadata(\"design:paramtypes\", target, propertyKey);\n    if (params == null) {\n        throw new Error(`Failed to get parameters for action method ${propertyKey} on class ${className}`);\n    }\n    if (params.length > 2) {\n        throw new Error(`Action method ${propertyKey} on class ${className} has more than 2 parameters`);\n    }\n    const walletProviderParam = params.find(param => {\n        if (!param || !param.prototype) {\n            return false;\n        }\n        if (param === wallet_providers_1.WalletProvider)\n            return true;\n        return param.prototype instanceof wallet_providers_1.WalletProvider;\n    });\n    return {\n        isWalletProvider: !!walletProviderParam,\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hY3Rpb25EZWNvcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLG9CQUFvQjtBQUNwQiwyQkFBMkIsbUJBQU8sQ0FBQyxtR0FBcUI7QUFDeEQsb0JBQW9CLG1CQUFPLENBQUMscUZBQWM7QUFDMUMsbUJBQU8sQ0FBQywwRUFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxRUFBcUU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3QkFBd0IsR0FBRyxZQUFZO0FBQzdFO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsYUFBYSxXQUFXLFVBQVU7QUFDeEc7QUFDQTtBQUNBLHlDQUF5QyxhQUFhLFdBQVcsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2FjdGlvbkRlY29yYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQUNUSU9OX0RFQ09SQVRPUl9LRVkgPSB2b2lkIDA7XG5leHBvcnRzLkNyZWF0ZUFjdGlvbiA9IENyZWF0ZUFjdGlvbjtcbmNvbnN0IHdhbGxldF9wcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuLi93YWxsZXQtcHJvdmlkZXJzXCIpO1xuY29uc3QgYW5hbHl0aWNzXzEgPSByZXF1aXJlKFwiLi4vYW5hbHl0aWNzXCIpO1xucmVxdWlyZShcInJlZmxlY3QtbWV0YWRhdGFcIik7XG4vKipcbiAqIE1ldGFkYXRhIGtleSBmb3IgdGhlIGFjdGlvbiBkZWNvcmF0b3JcbiAqL1xuZXhwb3J0cy5BQ1RJT05fREVDT1JBVE9SX0tFWSA9IFN5bWJvbChcImFnZW50a2l0OmFjdGlvblwiKTtcbi8qKlxuICogRGVjb3JhdG9yIHRvIGVtYmVkIG1ldGFkYXRhIG9uIGNsYXNzIG1ldGhvZHMgdG8gaW5kaWNhdGUgdGhleSBhcmUgYWN0aW9ucyBhY2Nlc3NpYmxlIHRvIHRoZSBhZ2VudFxuICpcbiAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGFjdGlvbiBkZWNvcmF0b3JcbiAqIEByZXR1cm5zIEEgZGVjb3JhdG9yIGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNsYXNzIE15QWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBBY3Rpb25Qcm92aWRlciB7XG4gKiAgIEBDcmVhdGVBY3Rpb24oeyBuYW1lOiBcIm15X2FjdGlvblwiLCBkZXNjcmlwdGlvbjogXCJNeSBhY3Rpb25cIiwgc2NoZW1hOiBteUFjdGlvblNjaGVtYSB9KVxuICogICBwdWJsaWMgbXlBY3Rpb24oYXJnczogei5pbmZlcjx0eXBlb2YgbXlBY3Rpb25TY2hlbWE+KSB7XG4gKiAgICAgLy8gLi4uXG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBDcmVhdGVBY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZWZpeGVkQWN0aW9uTmFtZSA9IGAke3RhcmdldC5jb25zdHJ1Y3Rvci5uYW1lfV8ke3BhcmFtcy5uYW1lfWA7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgY29uc3QgeyBpc1dhbGxldFByb3ZpZGVyIH0gPSB2YWxpZGF0ZUFjdGlvbk1ldGhvZEFyZ3VtZW50cyh0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBsZXQgd2FsbGV0TWV0cmljcyA9IHt9O1xuICAgICAgICAgICAgaWYgKGlzV2FsbGV0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICB3YWxsZXRNZXRyaWNzID0ge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRfcHJvdmlkZXI6IGFyZ3NbMF0uZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICB3YWxsZXRfYWRkcmVzczogYXJnc1swXS5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtfaWQ6IGFyZ3NbMF0uZ2V0TmV0d29yaygpLm5ldHdvcmtJZCxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5faWQ6IGFyZ3NbMF0uZ2V0TmV0d29yaygpLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sX2ZhbWlseTogYXJnc1swXS5nZXROZXR3b3JrKCkucHJvdG9jb2xGYW1pbHksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBhbmFseXRpY3NfMS5zZW5kQW5hbHl0aWNzRXZlbnQpKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFnZW50X2FjdGlvbl9pbnZvY2F0aW9uXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcImludm9rZV9hY3Rpb25cIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IFwiYWdlbnRfYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uX25hbWU6IHByZWZpeGVkQWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBjbGFzc19uYW1lOiB0YXJnZXQuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICAgICAgICBtZXRob2RfbmFtZTogcHJvcGVydHlLZXksXG4gICAgICAgICAgICAgICAgLi4ud2FsbGV0TWV0cmljcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBleGlzdGluZ01ldGFkYXRhID0gUmVmbGVjdC5nZXRNZXRhZGF0YShleHBvcnRzLkFDVElPTl9ERUNPUkFUT1JfS0VZLCB0YXJnZXQuY29uc3RydWN0b3IpIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgbWV0YURhdGEgPSB7XG4gICAgICAgICAgICBuYW1lOiBwcmVmaXhlZEFjdGlvbk5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogcGFyYW1zLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgc2NoZW1hOiBwYXJhbXMuc2NoZW1hLFxuICAgICAgICAgICAgaW52b2tlOiBkZXNjcmlwdG9yLnZhbHVlLFxuICAgICAgICAgICAgd2FsbGV0UHJvdmlkZXI6IGlzV2FsbGV0UHJvdmlkZXIsXG4gICAgICAgIH07XG4gICAgICAgIGV4aXN0aW5nTWV0YWRhdGEuc2V0KHByb3BlcnR5S2V5LCBtZXRhRGF0YSk7XG4gICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoZXhwb3J0cy5BQ1RJT05fREVDT1JBVE9SX0tFWSwgZXhpc3RpbmdNZXRhZGF0YSwgdGFyZ2V0LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGFyZ3VtZW50cyBvZiBhbiBhY3Rpb24gbWV0aG9kXG4gKlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gcHJvcGVydHlLZXkgLSBUaGUgcHJvcGVydHkga2V5XG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgd2FsbGV0IHByb3ZpZGVyIGZsYWdcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVBY3Rpb25NZXRob2RBcmd1bWVudHModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRhcmdldCBpbnN0YW5jZW9mIE9iamVjdCA/IHRhcmdldC5jb25zdHJ1Y3Rvci5uYW1lIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHBhcmFtcyA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IHBhcmFtZXRlcnMgZm9yIGFjdGlvbiBtZXRob2QgJHtwcm9wZXJ0eUtleX0gb24gY2xhc3MgJHtjbGFzc05hbWV9YCk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdGlvbiBtZXRob2QgJHtwcm9wZXJ0eUtleX0gb24gY2xhc3MgJHtjbGFzc05hbWV9IGhhcyBtb3JlIHRoYW4gMiBwYXJhbWV0ZXJzYCk7XG4gICAgfVxuICAgIGNvbnN0IHdhbGxldFByb3ZpZGVyUGFyYW0gPSBwYXJhbXMuZmluZChwYXJhbSA9PiB7XG4gICAgICAgIGlmICghcGFyYW0gfHwgIXBhcmFtLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbSA9PT0gd2FsbGV0X3Byb3ZpZGVyc18xLldhbGxldFByb3ZpZGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBwYXJhbS5wcm90b3R5cGUgaW5zdGFuY2VvZiB3YWxsZXRfcHJvdmlkZXJzXzEuV2FsbGV0UHJvdmlkZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNXYWxsZXRQcm92aWRlcjogISF3YWxsZXRQcm92aWRlclBhcmFtLFxuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ActionProvider = void 0;\nconst actionDecorator_1 = __webpack_require__(/*! ./actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\n/**\n * ActionProvider is the abstract base class for all action providers.\n *\n * @abstract\n */\nclass ActionProvider {\n    /**\n     * The constructor for the action provider.\n     *\n     * @param name - The name of the action provider.\n     * @param actionProviders - The action providers to combine.\n     */\n    constructor(name, \n    // Update parameter type to match property type\n    actionProviders) {\n        this.name = name;\n        this.actionProviders = actionProviders;\n    }\n    /**\n     * Gets the actions of the action provider bound to the given wallet provider.\n     *\n     * @param walletProvider - The wallet provider.\n     * @returns The actions of the action provider.\n     */\n    getActions(walletProvider) {\n        const actions = [];\n        const actionProviders = [this, ...this.actionProviders];\n        for (const actionProvider of actionProviders) {\n            const actionsMetadataMap = Reflect.getMetadata(actionDecorator_1.ACTION_DECORATOR_KEY, actionProvider.constructor);\n            if (!actionsMetadataMap) {\n                if (!(actionProvider instanceof ActionProvider)) {\n                    console.warn(`Warning: ${actionProvider} is not an instance of ActionProvider.`);\n                }\n                else {\n                    console.warn(`Warning: ${actionProvider} has no actions.`);\n                }\n                continue;\n            }\n            for (const actionMetadata of actionsMetadataMap.values()) {\n                actions.push({\n                    name: actionMetadata.name,\n                    description: actionMetadata.description,\n                    schema: actionMetadata.schema,\n                    invoke: schemaArgs => {\n                        const args = [];\n                        if (actionMetadata.walletProvider) {\n                            args[0] = walletProvider;\n                        }\n                        args.push(schemaArgs);\n                        return actionMetadata.invoke.apply(actionProvider, args);\n                    },\n                });\n            }\n        }\n        return actions;\n    }\n}\nexports.ActionProvider = ActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsMEJBQTBCLG1CQUFPLENBQUMsMkdBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvYWN0aW9uUHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFjdGlvblByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25EZWNvcmF0b3JcIik7XG4vKipcbiAqIEFjdGlvblByb3ZpZGVyIGlzIHRoZSBhYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhbGwgYWN0aW9uIHByb3ZpZGVycy5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgQWN0aW9uUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIGFjdGlvbiBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGFjdGlvbiBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0gYWN0aW9uUHJvdmlkZXJzIC0gVGhlIGFjdGlvbiBwcm92aWRlcnMgdG8gY29tYmluZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBcbiAgICAvLyBVcGRhdGUgcGFyYW1ldGVyIHR5cGUgdG8gbWF0Y2ggcHJvcGVydHkgdHlwZVxuICAgIGFjdGlvblByb3ZpZGVycykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFjdGlvblByb3ZpZGVycyA9IGFjdGlvblByb3ZpZGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYWN0aW9ucyBvZiB0aGUgYWN0aW9uIHByb3ZpZGVyIGJvdW5kIHRvIHRoZSBnaXZlbiB3YWxsZXQgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0UHJvdmlkZXIgLSBUaGUgd2FsbGV0IHByb3ZpZGVyLlxuICAgICAqIEByZXR1cm5zIFRoZSBhY3Rpb25zIG9mIHRoZSBhY3Rpb24gcHJvdmlkZXIuXG4gICAgICovXG4gICAgZ2V0QWN0aW9ucyh3YWxsZXRQcm92aWRlcikge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0gW107XG4gICAgICAgIGNvbnN0IGFjdGlvblByb3ZpZGVycyA9IFt0aGlzLCAuLi50aGlzLmFjdGlvblByb3ZpZGVyc107XG4gICAgICAgIGZvciAoY29uc3QgYWN0aW9uUHJvdmlkZXIgb2YgYWN0aW9uUHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25zTWV0YWRhdGFNYXAgPSBSZWZsZWN0LmdldE1ldGFkYXRhKGFjdGlvbkRlY29yYXRvcl8xLkFDVElPTl9ERUNPUkFUT1JfS0VZLCBhY3Rpb25Qcm92aWRlci5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBpZiAoIWFjdGlvbnNNZXRhZGF0YU1hcCkge1xuICAgICAgICAgICAgICAgIGlmICghKGFjdGlvblByb3ZpZGVyIGluc3RhbmNlb2YgQWN0aW9uUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogJHthY3Rpb25Qcm92aWRlcn0gaXMgbm90IGFuIGluc3RhbmNlIG9mIEFjdGlvblByb3ZpZGVyLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiAke2FjdGlvblByb3ZpZGVyfSBoYXMgbm8gYWN0aW9ucy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbk1ldGFkYXRhIG9mIGFjdGlvbnNNZXRhZGF0YU1hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGFjdGlvbk1ldGFkYXRhLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBhY3Rpb25NZXRhZGF0YS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBhY3Rpb25NZXRhZGF0YS5zY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIGludm9rZTogc2NoZW1hQXJncyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uTWV0YWRhdGEud2FsbGV0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzBdID0gd2FsbGV0UHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goc2NoZW1hQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uTWV0YWRhdGEuaW52b2tlLmFwcGx5KGFjdGlvblByb3ZpZGVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkFjdGlvblByb3ZpZGVyID0gQWN0aW9uUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/alchemyTokenPricesActionProvider.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/alchemyTokenPricesActionProvider.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.alchemyTokenPricesActionProvider = exports.AlchemyTokenPricesActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/schemas.js\");\n/**\n * AlchemyTokenPricesActionProvider is an action provider for fetching token prices via the Alchemy Prices API.\n * This provider enables querying current and historical token prices using symbols or addresses.\n *\n */\nclass AlchemyTokenPricesActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Creates a new instance of AlchemyTokenPricesActionProvider\n     *\n     * @param config - Configuration options including the API key\n     */\n    constructor(config = {}) {\n        super(\"alchemyTokenPrices\", []);\n        config.apiKey || (config.apiKey = process.env.ALCHEMY_API_KEY);\n        if (!config.apiKey) {\n            throw new Error(\"ALCHEMY_API_KEY is not configured.\");\n        }\n        this.apiKey = config.apiKey;\n        this.baseUrl = \"https://api.g.alchemy.com/prices/v1\";\n    }\n    /**\n     * Fetch current token prices for one or more token symbols.\n     *\n     * @param args - The arguments containing an array of token symbols.\n     * @returns A JSON string with the token prices or an error message.\n     */\n    async tokenPricesBySymbol(args) {\n        try {\n            // Build query parameters: for each symbol add a separate query parameter\n            const params = new URLSearchParams();\n            for (const symbol of args.symbols) {\n                params.append(\"symbols\", symbol);\n            }\n            const url = `${this.baseUrl}/${this.apiKey}/tokens/by-symbol?${params.toString()}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    Accept: \"application/json\",\n                },\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            const data = await response.json();\n            return `Successfully fetched token prices by symbol:\\n${JSON.stringify(data, null, 2)}`;\n        }\n        catch (error) {\n            return `Error fetching token prices by symbol: ${error}`;\n        }\n    }\n    /**\n     * Fetch current token prices for one or more tokens identified by network and address pairs.\n     *\n     * @param args - The arguments containing an array of token network/address pairs.\n     * @returns A JSON string with the token prices or an error message.\n     */\n    async tokenPricesByAddress(args) {\n        try {\n            const url = `${this.baseUrl}/${this.apiKey}/tokens/by-address`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    Accept: \"application/json\",\n                    \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify(args),\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            const data = await response.json();\n            return `Successfully fetched token prices by address:\\n${JSON.stringify(data, null, 2)}`;\n        }\n        catch (error) {\n            return `Error fetching token prices by address: ${error}`;\n        }\n    }\n    /**\n     * Checks if the Alchemy Prices action provider supports the given network.\n     * Since the API works with multiple networks, this always returns true.\n     *\n     * @returns Always returns true.\n     */\n    supportsNetwork() {\n        return true;\n    }\n}\nexports.AlchemyTokenPricesActionProvider = AlchemyTokenPricesActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"token_prices_by_symbol\",\n        description: `\nThis tool will fetch current prices for one or more tokens using their symbols via the Alchemy Prices API.\n\nA successful response will return a JSON payload similar to:\n{\n  \"data\": [\n    {\n      \"symbol\": \"ETH\",\n      \"prices\": [\n        {\n          \"currency\": \"usd\",\n          \"value\": \"2873.490923459\",\n          \"lastUpdatedAt\": \"2025-02-03T23:46:40Z\"\n        }\n      ]\n    }\n  ]\n}\n\nA failure response will return an error message with details.\n    `,\n        schema: schemas_1.AlchemyTokenPricesBySymbolSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], AlchemyTokenPricesActionProvider.prototype, \"tokenPricesBySymbol\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"token_prices_by_address\",\n        description: `\nThis tool will fetch current prices for tokens using network and address pairs via the Alchemy Prices API.\n\nA successful response will return a JSON payload similar to:\n{\n  \"data\": [\n    {\n      \"network\": \"eth-mainnet\",\n      \"address\": \"0xYourTokenAddress\",\n      \"prices\": [\n        {\n          \"currency\": \"usd\",\n          \"value\": \"1234.56\",\n          \"lastUpdatedAt\": \"2025-02-03T23:46:40Z\"\n        }\n      ]\n    }\n  ]\n}\n\nA failure response will return an error message with details.\n    `,\n        schema: schemas_1.AlchemyTokenPricesByAddressSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], AlchemyTokenPricesActionProvider.prototype, \"tokenPricesByAddress\", null);\n/**\n * Factory function to create a new AlchemyTokenPricesActionProvider instance.\n *\n * @param config - The configuration options for the provider.\n * @returns A new instance of AlchemyTokenPricesActionProvider.\n */\nconst alchemyTokenPricesActionProvider = (config) => new AlchemyTokenPricesActionProvider(config);\nexports.alchemyTokenPricesActionProvider = alchemyTokenPricesActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hbGNoZW15L2FsY2hlbXlUb2tlblByaWNlc0FjdGlvblByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3Q0FBd0MsR0FBRyx3Q0FBd0M7QUFDbkYsY0FBYyxtQkFBTyxDQUFDLHVEQUFLO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLDBHQUFtQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsbUdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYSxHQUFHLFlBQVksb0JBQW9CLGtCQUFrQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQSxvRUFBb0UsOEJBQThCO0FBQ2xHO0FBQ0E7QUFDQSw2REFBNkQsTUFBTTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhLEdBQUcsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0EscUVBQXFFLDhCQUE4QjtBQUNuRztBQUNBO0FBQ0EsOERBQThELE1BQU07QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvYWxjaGVteS9hbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFsY2hlbXlUb2tlblByaWNlc0FjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5BbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCBhY3Rpb25EZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25EZWNvcmF0b3JcIik7XG5jb25zdCBzY2hlbWFzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFzXCIpO1xuLyoqXG4gKiBBbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlciBpcyBhbiBhY3Rpb24gcHJvdmlkZXIgZm9yIGZldGNoaW5nIHRva2VuIHByaWNlcyB2aWEgdGhlIEFsY2hlbXkgUHJpY2VzIEFQSS5cbiAqIFRoaXMgcHJvdmlkZXIgZW5hYmxlcyBxdWVyeWluZyBjdXJyZW50IGFuZCBoaXN0b3JpY2FsIHRva2VuIHByaWNlcyB1c2luZyBzeW1ib2xzIG9yIGFkZHJlc3Nlcy5cbiAqXG4gKi9cbmNsYXNzIEFsY2hlbXlUb2tlblByaWNlc0FjdGlvblByb3ZpZGVyIGV4dGVuZHMgYWN0aW9uUHJvdmlkZXJfMS5BY3Rpb25Qcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBBbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlclxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBpbmNsdWRpbmcgdGhlIEFQSSBrZXlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcihcImFsY2hlbXlUb2tlblByaWNlc1wiLCBbXSk7XG4gICAgICAgIGNvbmZpZy5hcGlLZXkgfHwgKGNvbmZpZy5hcGlLZXkgPSBwcm9jZXNzLmVudi5BTENIRU1ZX0FQSV9LRVkpO1xuICAgICAgICBpZiAoIWNvbmZpZy5hcGlLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFMQ0hFTVlfQVBJX0tFWSBpcyBub3QgY29uZmlndXJlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcGlLZXkgPSBjb25maWcuYXBpS2V5O1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSBcImh0dHBzOi8vYXBpLmcuYWxjaGVteS5jb20vcHJpY2VzL3YxXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGN1cnJlbnQgdG9rZW4gcHJpY2VzIGZvciBvbmUgb3IgbW9yZSB0b2tlbiBzeW1ib2xzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgdG9rZW4gc3ltYm9scy5cbiAgICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIHdpdGggdGhlIHRva2VuIHByaWNlcyBvciBhbiBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHRva2VuUHJpY2VzQnlTeW1ib2woYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQnVpbGQgcXVlcnkgcGFyYW1ldGVyczogZm9yIGVhY2ggc3ltYm9sIGFkZCBhIHNlcGFyYXRlIHF1ZXJ5IHBhcmFtZXRlclxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzeW1ib2wgb2YgYXJncy5zeW1ib2xzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInN5bWJvbHNcIiwgc3ltYm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0vJHt0aGlzLmFwaUtleX0vdG9rZW5zL2J5LXN5bWJvbD8ke3BhcmFtcy50b1N0cmluZygpfWA7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSBmZXRjaGVkIHRva2VuIHByaWNlcyBieSBzeW1ib2w6XFxuJHtKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBmZXRjaGluZyB0b2tlbiBwcmljZXMgYnkgc3ltYm9sOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggY3VycmVudCB0b2tlbiBwcmljZXMgZm9yIG9uZSBvciBtb3JlIHRva2VucyBpZGVudGlmaWVkIGJ5IG5ldHdvcmsgYW5kIGFkZHJlc3MgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgY29udGFpbmluZyBhbiBhcnJheSBvZiB0b2tlbiBuZXR3b3JrL2FkZHJlc3MgcGFpcnMuXG4gICAgICogQHJldHVybnMgQSBKU09OIHN0cmluZyB3aXRoIHRoZSB0b2tlbiBwcmljZXMgb3IgYW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBhc3luYyB0b2tlblByaWNlc0J5QWRkcmVzcyhhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9LyR7dGhpcy5hcGlLZXl9L3Rva2Vucy9ieS1hZGRyZXNzYDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYXJncyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGBTdWNjZXNzZnVsbHkgZmV0Y2hlZCB0b2tlbiBwcmljZXMgYnkgYWRkcmVzczpcXG4ke0pTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGZldGNoaW5nIHRva2VuIHByaWNlcyBieSBhZGRyZXNzOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBBbGNoZW15IFByaWNlcyBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICogU2luY2UgdGhlIEFQSSB3b3JrcyB3aXRoIG11bHRpcGxlIG5ldHdvcmtzLCB0aGlzIGFsd2F5cyByZXR1cm5zIHRydWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbHdheXMgcmV0dXJucyB0cnVlLlxuICAgICAqL1xuICAgIHN1cHBvcnRzTmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5BbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlciA9IEFsY2hlbXlUb2tlblByaWNlc0FjdGlvblByb3ZpZGVyO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcInRva2VuX3ByaWNlc19ieV9zeW1ib2xcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCB3aWxsIGZldGNoIGN1cnJlbnQgcHJpY2VzIGZvciBvbmUgb3IgbW9yZSB0b2tlbnMgdXNpbmcgdGhlaXIgc3ltYm9scyB2aWEgdGhlIEFsY2hlbXkgUHJpY2VzIEFQSS5cblxuQSBzdWNjZXNzZnVsIHJlc3BvbnNlIHdpbGwgcmV0dXJuIGEgSlNPTiBwYXlsb2FkIHNpbWlsYXIgdG86XG57XG4gIFwiZGF0YVwiOiBbXG4gICAge1xuICAgICAgXCJzeW1ib2xcIjogXCJFVEhcIixcbiAgICAgIFwicHJpY2VzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiY3VycmVuY3lcIjogXCJ1c2RcIixcbiAgICAgICAgICBcInZhbHVlXCI6IFwiMjg3My40OTA5MjM0NTlcIixcbiAgICAgICAgICBcImxhc3RVcGRhdGVkQXRcIjogXCIyMDI1LTAyLTAzVDIzOjQ2OjQwWlwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIF1cbn1cblxuQSBmYWlsdXJlIHJlc3BvbnNlIHdpbGwgcmV0dXJuIGFuIGVycm9yIG1lc3NhZ2Ugd2l0aCBkZXRhaWxzLlxuICAgIGAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkFsY2hlbXlUb2tlblByaWNlc0J5U3ltYm9sU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEFsY2hlbXlUb2tlblByaWNlc0FjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJ0b2tlblByaWNlc0J5U3ltYm9sXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcInRva2VuX3ByaWNlc19ieV9hZGRyZXNzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgd2lsbCBmZXRjaCBjdXJyZW50IHByaWNlcyBmb3IgdG9rZW5zIHVzaW5nIG5ldHdvcmsgYW5kIGFkZHJlc3MgcGFpcnMgdmlhIHRoZSBBbGNoZW15IFByaWNlcyBBUEkuXG5cbkEgc3VjY2Vzc2Z1bCByZXNwb25zZSB3aWxsIHJldHVybiBhIEpTT04gcGF5bG9hZCBzaW1pbGFyIHRvOlxue1xuICBcImRhdGFcIjogW1xuICAgIHtcbiAgICAgIFwibmV0d29ya1wiOiBcImV0aC1tYWlubmV0XCIsXG4gICAgICBcImFkZHJlc3NcIjogXCIweFlvdXJUb2tlbkFkZHJlc3NcIixcbiAgICAgIFwicHJpY2VzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiY3VycmVuY3lcIjogXCJ1c2RcIixcbiAgICAgICAgICBcInZhbHVlXCI6IFwiMTIzNC41NlwiLFxuICAgICAgICAgIFwibGFzdFVwZGF0ZWRBdFwiOiBcIjIwMjUtMDItMDNUMjM6NDY6NDBaXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgXVxufVxuXG5BIGZhaWx1cmUgcmVzcG9uc2Ugd2lsbCByZXR1cm4gYW4gZXJyb3IgbWVzc2FnZSB3aXRoIGRldGFpbHMuXG4gICAgYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuQWxjaGVteVRva2VuUHJpY2VzQnlBZGRyZXNzU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEFsY2hlbXlUb2tlblByaWNlc0FjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJ0b2tlblByaWNlc0J5QWRkcmVzc1wiLCBudWxsKTtcbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgYSBuZXcgQWxjaGVteVRva2VuUHJpY2VzQWN0aW9uUHJvdmlkZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBwcm92aWRlci5cbiAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIEFsY2hlbXlUb2tlblByaWNlc0FjdGlvblByb3ZpZGVyLlxuICovXG5jb25zdCBhbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlciA9IChjb25maWcpID0+IG5ldyBBbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlcihjb25maWcpO1xuZXhwb3J0cy5hbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlciA9IGFsY2hlbXlUb2tlblByaWNlc0FjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/alchemyTokenPricesActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./alchemyTokenPricesActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/alchemyTokenPricesActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/schemas.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hbGNoZW15L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxxSkFBb0M7QUFDekQsYUFBYSxtQkFBTyxDQUFDLG1HQUFXIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2FsY2hlbXkvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NoZW1hc1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/schemas.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/schemas.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AlchemyTokenPricesByAddressSchema = exports.AlchemyTokenPricesBySymbolSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\n/**\n * Input schema for fetching token prices by symbol.\n *\n * The API expects a list of token symbols.\n */\nexports.AlchemyTokenPricesBySymbolSchema = zod_1.z\n    .object({\n    symbols: zod_1.z\n        .array(zod_1.z.string())\n        .min(1, \"At least one token symbol is required. Example: ETH, BTC, SOL, etc.\")\n        .max(25, \"A maximum of 25 token symbols can be provided.\"),\n})\n    .describe(\"Input schema for fetching token prices by symbol from Alchemy\");\n/**\n * Input schema for fetching token prices by address.\n *\n * The API expects an object with an array of addresses, where each address contains\n * a network identifier and a token contract address.\n */\nexports.AlchemyTokenPricesByAddressSchema = zod_1.z\n    .object({\n    addresses: zod_1.z\n        .array(zod_1.z.object({\n        network: zod_1.z.string().describe(\"Network identifier (e.g., eth-mainnet, base-mainnet etc.)\"),\n        address: zod_1.z.string().describe(\"Token contract address\"),\n    }))\n        .min(1, \"At least one address is required.\")\n        .max(25, \"A maximum of 25 addresses can be provided.\"),\n})\n    .describe(\"Input schema for fetching token prices by address from Alchemy\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hbGNoZW15L3NjaGVtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUNBQXlDLEdBQUcsd0NBQXdDO0FBQ3BGLGNBQWMsbUJBQU8sQ0FBQyx1REFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2FsY2hlbXkvc2NoZW1hcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWxjaGVteVRva2VuUHJpY2VzQnlBZGRyZXNzU2NoZW1hID0gZXhwb3J0cy5BbGNoZW15VG9rZW5QcmljZXNCeVN5bWJvbFNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBmZXRjaGluZyB0b2tlbiBwcmljZXMgYnkgc3ltYm9sLlxuICpcbiAqIFRoZSBBUEkgZXhwZWN0cyBhIGxpc3Qgb2YgdG9rZW4gc3ltYm9scy5cbiAqL1xuZXhwb3J0cy5BbGNoZW15VG9rZW5QcmljZXNCeVN5bWJvbFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBzeW1ib2xzOiB6b2RfMS56XG4gICAgICAgIC5hcnJheSh6b2RfMS56LnN0cmluZygpKVxuICAgICAgICAubWluKDEsIFwiQXQgbGVhc3Qgb25lIHRva2VuIHN5bWJvbCBpcyByZXF1aXJlZC4gRXhhbXBsZTogRVRILCBCVEMsIFNPTCwgZXRjLlwiKVxuICAgICAgICAubWF4KDI1LCBcIkEgbWF4aW11bSBvZiAyNSB0b2tlbiBzeW1ib2xzIGNhbiBiZSBwcm92aWRlZC5cIiksXG59KVxuICAgIC5kZXNjcmliZShcIklucHV0IHNjaGVtYSBmb3IgZmV0Y2hpbmcgdG9rZW4gcHJpY2VzIGJ5IHN5bWJvbCBmcm9tIEFsY2hlbXlcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgZmV0Y2hpbmcgdG9rZW4gcHJpY2VzIGJ5IGFkZHJlc3MuXG4gKlxuICogVGhlIEFQSSBleHBlY3RzIGFuIG9iamVjdCB3aXRoIGFuIGFycmF5IG9mIGFkZHJlc3Nlcywgd2hlcmUgZWFjaCBhZGRyZXNzIGNvbnRhaW5zXG4gKiBhIG5ldHdvcmsgaWRlbnRpZmllciBhbmQgYSB0b2tlbiBjb250cmFjdCBhZGRyZXNzLlxuICovXG5leHBvcnRzLkFsY2hlbXlUb2tlblByaWNlc0J5QWRkcmVzc1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBhZGRyZXNzZXM6IHpvZF8xLnpcbiAgICAgICAgLmFycmF5KHpvZF8xLnoub2JqZWN0KHtcbiAgICAgICAgbmV0d29yazogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIk5ldHdvcmsgaWRlbnRpZmllciAoZS5nLiwgZXRoLW1haW5uZXQsIGJhc2UtbWFpbm5ldCBldGMuKVwiKSxcbiAgICAgICAgYWRkcmVzczogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRva2VuIGNvbnRyYWN0IGFkZHJlc3NcIiksXG4gICAgfSkpXG4gICAgICAgIC5taW4oMSwgXCJBdCBsZWFzdCBvbmUgYWRkcmVzcyBpcyByZXF1aXJlZC5cIilcbiAgICAgICAgLm1heCgyNSwgXCJBIG1heGltdW0gb2YgMjUgYWRkcmVzc2VzIGNhbiBiZSBwcm92aWRlZC5cIiksXG59KVxuICAgIC5kZXNjcmliZShcIklucHV0IHNjaGVtYSBmb3IgZmV0Y2hpbmcgdG9rZW4gcHJpY2VzIGJ5IGFkZHJlc3MgZnJvbSBBbGNoZW15XCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/schemas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/basenameActionProvider.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/basename/basenameActionProvider.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.basenameActionProvider = exports.BasenameActionProvider = void 0;\nconst viem_1 = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_cjs/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/constants.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/schemas.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\n/**\n * Action provider for registering Basenames.\n */\nclass BasenameActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructs a new BasenameActionProvider.\n     */\n    constructor() {\n        super(\"basename\", []);\n        /**\n         * Checks if the Basename action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Basename action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.networkId === \"base-mainnet\" || network.networkId === \"base-sepolia\";\n    }\n    /**\n     * Registers a Basename.\n     *\n     * @param wallet - The wallet to use for the registration.\n     * @param args - The arguments for the registration.\n     * @returns A string indicating the success or failure of the registration.\n     */\n    async register(wallet, args) {\n        const address = wallet.getAddress();\n        const isMainnet = wallet.getNetwork().networkId === \"base-mainnet\";\n        const suffix = isMainnet ? \".base.eth\" : \".basetest.eth\";\n        if (!args.basename.endsWith(suffix)) {\n            args.basename += suffix;\n        }\n        const l2ResolverAddress = isMainnet ? constants_1.L2_RESOLVER_ADDRESS_MAINNET : constants_1.L2_RESOLVER_ADDRESS_TESTNET;\n        const addressData = (0, viem_1.encodeFunctionData)({\n            abi: constants_1.L2_RESOLVER_ABI,\n            functionName: \"setAddr\",\n            args: [(0, viem_1.namehash)(args.basename), address],\n        });\n        const nameData = (0, viem_1.encodeFunctionData)({\n            abi: constants_1.L2_RESOLVER_ABI,\n            functionName: \"setName\",\n            args: [(0, viem_1.namehash)(args.basename), args.basename],\n        });\n        try {\n            const contractAddress = isMainnet\n                ? constants_1.BASENAMES_REGISTRAR_CONTROLLER_ADDRESS_MAINNET\n                : constants_1.BASENAMES_REGISTRAR_CONTROLLER_ADDRESS_TESTNET;\n            const hash = await wallet.sendTransaction({\n                to: contractAddress,\n                data: (0, viem_1.encodeFunctionData)({\n                    abi: constants_1.REGISTRAR_ABI,\n                    functionName: \"register\",\n                    args: [\n                        {\n                            name: args.basename.replace(suffix, \"\"),\n                            owner: address,\n                            duration: constants_1.REGISTRATION_DURATION,\n                            resolver: l2ResolverAddress,\n                            data: [addressData, nameData],\n                            reverseRecord: true,\n                        },\n                    ],\n                }),\n                value: (0, viem_1.parseEther)(args.amount),\n            });\n            await wallet.waitForTransactionReceipt(hash);\n            return `Successfully registered basename ${args.basename} for address ${address}`;\n        }\n        catch (error) {\n            return `Error registering basename: Error: ${error}`;\n        }\n    }\n}\nexports.BasenameActionProvider = BasenameActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"register_basename\",\n        description: `\nThis tool will register a Basename for the agent. The agent should have a wallet associated to register a Basename.\nWhen your network ID is 'base-mainnet' (also sometimes known simply as 'base'), the name must end with .base.eth, and when your network ID is 'base-sepolia', it must ends with .basetest.eth.\nDo not suggest any alternatives and never try to register a Basename with another postfix. The prefix of the name must be unique so if the registration of the\nBasename fails, you should prompt to try again with a more unique name.\n`,\n        schema: schemas_1.RegisterBasenameSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], BasenameActionProvider.prototype, \"register\", null);\nconst basenameActionProvider = () => new BasenameActionProvider();\nexports.basenameActionProvider = basenameActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9iYXNlbmFtZS9iYXNlbmFtZUFjdGlvblByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDL0QsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyx1REFBSztBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELG9CQUFvQixtQkFBTyxDQUFDLHdHQUFhO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLG9HQUFXO0FBQ3JDLDJCQUEyQixtQkFBTyxDQUFDLHNHQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLHVEQUF1RCxlQUFlLGNBQWMsUUFBUTtBQUM1RjtBQUNBO0FBQ0EseURBQXlELE1BQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvYmFzZW5hbWUvYmFzZW5hbWVBY3Rpb25Qcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJhc2VuYW1lQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLkJhc2VuYW1lQWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCB2aWVtXzEgPSByZXF1aXJlKFwidmllbVwiKTtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCBhY3Rpb25EZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25EZWNvcmF0b3JcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHNjaGVtYXNfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYXNcIik7XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbi8qKlxuICogQWN0aW9uIHByb3ZpZGVyIGZvciByZWdpc3RlcmluZyBCYXNlbmFtZXMuXG4gKi9cbmNsYXNzIEJhc2VuYW1lQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEJhc2VuYW1lQWN0aW9uUHJvdmlkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiYmFzZW5hbWVcIiwgW10pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBCYXNlbmFtZSBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuZXR3b3JrIC0gVGhlIG5ldHdvcmsgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIEJhc2VuYW1lIGFjdGlvbiBwcm92aWRlciBzdXBwb3J0cyB0aGUgbmV0d29yaywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdXBwb3J0c05ldHdvcmsgPSAobmV0d29yaykgPT4gbmV0d29yay5uZXR3b3JrSWQgPT09IFwiYmFzZS1tYWlubmV0XCIgfHwgbmV0d29yay5uZXR3b3JrSWQgPT09IFwiYmFzZS1zZXBvbGlhXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIEJhc2VuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgdG8gdXNlIGZvciB0aGUgcmVnaXN0cmF0aW9uLlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIHJlZ2lzdHJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBzdWNjZXNzIG9yIGZhaWx1cmUgb2YgdGhlIHJlZ2lzdHJhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyByZWdpc3Rlcih3YWxsZXQsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHdhbGxldC5nZXRBZGRyZXNzKCk7XG4gICAgICAgIGNvbnN0IGlzTWFpbm5ldCA9IHdhbGxldC5nZXROZXR3b3JrKCkubmV0d29ya0lkID09PSBcImJhc2UtbWFpbm5ldFwiO1xuICAgICAgICBjb25zdCBzdWZmaXggPSBpc01haW5uZXQgPyBcIi5iYXNlLmV0aFwiIDogXCIuYmFzZXRlc3QuZXRoXCI7XG4gICAgICAgIGlmICghYXJncy5iYXNlbmFtZS5lbmRzV2l0aChzdWZmaXgpKSB7XG4gICAgICAgICAgICBhcmdzLmJhc2VuYW1lICs9IHN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsMlJlc29sdmVyQWRkcmVzcyA9IGlzTWFpbm5ldCA/IGNvbnN0YW50c18xLkwyX1JFU09MVkVSX0FERFJFU1NfTUFJTk5FVCA6IGNvbnN0YW50c18xLkwyX1JFU09MVkVSX0FERFJFU1NfVEVTVE5FVDtcbiAgICAgICAgY29uc3QgYWRkcmVzc0RhdGEgPSAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5MMl9SRVNPTFZFUl9BQkksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwic2V0QWRkclwiLFxuICAgICAgICAgICAgYXJnczogWygwLCB2aWVtXzEubmFtZWhhc2gpKGFyZ3MuYmFzZW5hbWUpLCBhZGRyZXNzXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5hbWVEYXRhID0gKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuTDJfUkVTT0xWRVJfQUJJLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcInNldE5hbWVcIixcbiAgICAgICAgICAgIGFyZ3M6IFsoMCwgdmllbV8xLm5hbWVoYXNoKShhcmdzLmJhc2VuYW1lKSwgYXJncy5iYXNlbmFtZV0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gaXNNYWlubmV0XG4gICAgICAgICAgICAgICAgPyBjb25zdGFudHNfMS5CQVNFTkFNRVNfUkVHSVNUUkFSX0NPTlRST0xMRVJfQUREUkVTU19NQUlOTkVUXG4gICAgICAgICAgICAgICAgOiBjb25zdGFudHNfMS5CQVNFTkFNRVNfUkVHSVNUUkFSX0NPTlRST0xMRVJfQUREUkVTU19URVNUTkVUO1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHdhbGxldC5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHRvOiBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YTogKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5SRUdJU1RSQVJfQUJJLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwicmVnaXN0ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGFyZ3MuYmFzZW5hbWUucmVwbGFjZShzdWZmaXgsIFwiXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBjb25zdGFudHNfMS5SRUdJU1RSQVRJT05fRFVSQVRJT04sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXI6IGwyUmVzb2x2ZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFthZGRyZXNzRGF0YSwgbmFtZURhdGFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VSZWNvcmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAoMCwgdmllbV8xLnBhcnNlRXRoZXIpKGFyZ3MuYW1vdW50KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgd2FsbGV0LndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSByZWdpc3RlcmVkIGJhc2VuYW1lICR7YXJncy5iYXNlbmFtZX0gZm9yIGFkZHJlc3MgJHthZGRyZXNzfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIHJlZ2lzdGVyaW5nIGJhc2VuYW1lOiBFcnJvcjogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlbmFtZUFjdGlvblByb3ZpZGVyID0gQmFzZW5hbWVBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJyZWdpc3Rlcl9iYXNlbmFtZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIHdpbGwgcmVnaXN0ZXIgYSBCYXNlbmFtZSBmb3IgdGhlIGFnZW50LiBUaGUgYWdlbnQgc2hvdWxkIGhhdmUgYSB3YWxsZXQgYXNzb2NpYXRlZCB0byByZWdpc3RlciBhIEJhc2VuYW1lLlxuV2hlbiB5b3VyIG5ldHdvcmsgSUQgaXMgJ2Jhc2UtbWFpbm5ldCcgKGFsc28gc29tZXRpbWVzIGtub3duIHNpbXBseSBhcyAnYmFzZScpLCB0aGUgbmFtZSBtdXN0IGVuZCB3aXRoIC5iYXNlLmV0aCwgYW5kIHdoZW4geW91ciBuZXR3b3JrIElEIGlzICdiYXNlLXNlcG9saWEnLCBpdCBtdXN0IGVuZHMgd2l0aCAuYmFzZXRlc3QuZXRoLlxuRG8gbm90IHN1Z2dlc3QgYW55IGFsdGVybmF0aXZlcyBhbmQgbmV2ZXIgdHJ5IHRvIHJlZ2lzdGVyIGEgQmFzZW5hbWUgd2l0aCBhbm90aGVyIHBvc3RmaXguIFRoZSBwcmVmaXggb2YgdGhlIG5hbWUgbXVzdCBiZSB1bmlxdWUgc28gaWYgdGhlIHJlZ2lzdHJhdGlvbiBvZiB0aGVcbkJhc2VuYW1lIGZhaWxzLCB5b3Ugc2hvdWxkIHByb21wdCB0byB0cnkgYWdhaW4gd2l0aCBhIG1vcmUgdW5pcXVlIG5hbWUuXG5gLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5SZWdpc3RlckJhc2VuYW1lU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgQmFzZW5hbWVBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwicmVnaXN0ZXJcIiwgbnVsbCk7XG5jb25zdCBiYXNlbmFtZUFjdGlvblByb3ZpZGVyID0gKCkgPT4gbmV3IEJhc2VuYW1lQWN0aW9uUHJvdmlkZXIoKTtcbmV4cG9ydHMuYmFzZW5hbWVBY3Rpb25Qcm92aWRlciA9IGJhc2VuYW1lQWN0aW9uUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/basenameActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/constants.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/basename/constants.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.REGISTRAR_ABI = exports.L2_RESOLVER_ABI = exports.REGISTRATION_DURATION = exports.L2_RESOLVER_ADDRESS_TESTNET = exports.L2_RESOLVER_ADDRESS_MAINNET = exports.BASENAMES_REGISTRAR_CONTROLLER_ADDRESS_TESTNET = exports.BASENAMES_REGISTRAR_CONTROLLER_ADDRESS_MAINNET = void 0;\n// Contract addresses\nexports.BASENAMES_REGISTRAR_CONTROLLER_ADDRESS_MAINNET = \"0x4cCb0BB02FCABA27e82a56646E81d8c5bC4119a5\";\nexports.BASENAMES_REGISTRAR_CONTROLLER_ADDRESS_TESTNET = \"0x49aE3cC2e3AA768B1e5654f5D3C6002144A59581\";\nexports.L2_RESOLVER_ADDRESS_MAINNET = \"0xC6d566A56A1aFf6508b41f6c90ff131615583BCD\";\nexports.L2_RESOLVER_ADDRESS_TESTNET = \"0x6533C94869D28fAA8dF77cc63f9e2b2D6Cf77eBA\";\n// Default registration duration (1 year in seconds)\nexports.REGISTRATION_DURATION = 31557600n;\n// Relevant ABI for L2 Resolver Contract.\nexports.L2_RESOLVER_ABI = [\n    {\n        inputs: [\n            { internalType: \"bytes32\", name: \"node\", type: \"bytes32\" },\n            { internalType: \"address\", name: \"a\", type: \"address\" },\n        ],\n        name: \"setAddr\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"bytes32\", name: \"node\", type: \"bytes32\" },\n            { internalType: \"string\", name: \"newName\", type: \"string\" },\n        ],\n        name: \"setName\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n];\n// Relevant ABI for Basenames Registrar Controller Contract.\nexports.REGISTRAR_ABI = [\n    {\n        inputs: [\n            {\n                components: [\n                    {\n                        internalType: \"string\",\n                        name: \"name\",\n                        type: \"string\",\n                    },\n                    {\n                        internalType: \"address\",\n                        name: \"owner\",\n                        type: \"address\",\n                    },\n                    {\n                        internalType: \"uint256\",\n                        name: \"duration\",\n                        type: \"uint256\",\n                    },\n                    {\n                        internalType: \"address\",\n                        name: \"resolver\",\n                        type: \"address\",\n                    },\n                    {\n                        internalType: \"bytes[]\",\n                        name: \"data\",\n                        type: \"bytes[]\",\n                    },\n                    {\n                        internalType: \"bool\",\n                        name: \"reverseRecord\",\n                        type: \"bool\",\n                    },\n                ],\n                internalType: \"struct RegistrarController.RegisterRequest\",\n                name: \"request\",\n                type: \"tuple\",\n            },\n        ],\n        name: \"register\",\n        outputs: [],\n        stateMutability: \"payable\",\n        type: \"function\",\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9iYXNlbmFtZS9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsNkJBQTZCLEdBQUcsbUNBQW1DLEdBQUcsbUNBQW1DLEdBQUcsc0RBQXNELEdBQUcsc0RBQXNEO0FBQzdRO0FBQ0Esc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLHdEQUF3RDtBQUN0RSxjQUFjLHFEQUFxRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLHdEQUF3RDtBQUN0RSxjQUFjLHlEQUF5RDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2Jhc2VuYW1lL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUkVHSVNUUkFSX0FCSSA9IGV4cG9ydHMuTDJfUkVTT0xWRVJfQUJJID0gZXhwb3J0cy5SRUdJU1RSQVRJT05fRFVSQVRJT04gPSBleHBvcnRzLkwyX1JFU09MVkVSX0FERFJFU1NfVEVTVE5FVCA9IGV4cG9ydHMuTDJfUkVTT0xWRVJfQUREUkVTU19NQUlOTkVUID0gZXhwb3J0cy5CQVNFTkFNRVNfUkVHSVNUUkFSX0NPTlRST0xMRVJfQUREUkVTU19URVNUTkVUID0gZXhwb3J0cy5CQVNFTkFNRVNfUkVHSVNUUkFSX0NPTlRST0xMRVJfQUREUkVTU19NQUlOTkVUID0gdm9pZCAwO1xuLy8gQ29udHJhY3QgYWRkcmVzc2VzXG5leHBvcnRzLkJBU0VOQU1FU19SRUdJU1RSQVJfQ09OVFJPTExFUl9BRERSRVNTX01BSU5ORVQgPSBcIjB4NGNDYjBCQjAyRkNBQkEyN2U4MmE1NjY0NkU4MWQ4YzViQzQxMTlhNVwiO1xuZXhwb3J0cy5CQVNFTkFNRVNfUkVHSVNUUkFSX0NPTlRST0xMRVJfQUREUkVTU19URVNUTkVUID0gXCIweDQ5YUUzY0MyZTNBQTc2OEIxZTU2NTRmNUQzQzYwMDIxNDRBNTk1ODFcIjtcbmV4cG9ydHMuTDJfUkVTT0xWRVJfQUREUkVTU19NQUlOTkVUID0gXCIweEM2ZDU2NkE1NkExYUZmNjUwOGI0MWY2YzkwZmYxMzE2MTU1ODNCQ0RcIjtcbmV4cG9ydHMuTDJfUkVTT0xWRVJfQUREUkVTU19URVNUTkVUID0gXCIweDY1MzNDOTQ4NjlEMjhmQUE4ZEY3N2NjNjNmOWUyYjJENkNmNzdlQkFcIjtcbi8vIERlZmF1bHQgcmVnaXN0cmF0aW9uIGR1cmF0aW9uICgxIHllYXIgaW4gc2Vjb25kcylcbmV4cG9ydHMuUkVHSVNUUkFUSU9OX0RVUkFUSU9OID0gMzE1NTc2MDBuO1xuLy8gUmVsZXZhbnQgQUJJIGZvciBMMiBSZXNvbHZlciBDb250cmFjdC5cbmV4cG9ydHMuTDJfUkVTT0xWRVJfQUJJID0gW1xuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwibm9kZVwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImFcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJzZXRBZGRyXCIsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcIm5vZGVcIiwgdHlwZTogXCJieXRlczMyXCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcIm5ld05hbWVcIiwgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcInNldE5hbWVcIixcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuXTtcbi8vIFJlbGV2YW50IEFCSSBmb3IgQmFzZW5hbWVzIFJlZ2lzdHJhciBDb250cm9sbGVyIENvbnRyYWN0LlxuZXhwb3J0cy5SRUdJU1RSQVJfQUJJID0gW1xuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm93bmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiZHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJyZXNvbHZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJieXRlc1tdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImRhdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNbXVwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJyZXZlcnNlUmVjb3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJ1Y3QgUmVnaXN0cmFyQ29udHJvbGxlci5SZWdpc3RlclJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcInJlZ2lzdGVyXCIsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwicGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbl07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/basename/index.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./basenameActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/basenameActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/schemas.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9iYXNlbmFtZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsa0lBQTBCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyxvR0FBVyIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9iYXNlbmFtZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2VuYW1lQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NjaGVtYXNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/schemas.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/basename/schemas.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RegisterBasenameSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\n/**\n * Input schema for registering a Basename.\n */\nexports.RegisterBasenameSchema = zod_1.z\n    .object({\n    basename: zod_1.z.string().describe(\"The Basename to assign to the agent\"),\n    amount: zod_1.z.string().default(\"0.002\").describe(\"The amount of ETH to pay for registration\"),\n})\n    .strip()\n    .describe(\"Instructions for registering a Basename\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9iYXNlbmFtZS9zY2hlbWFzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixjQUFjLG1CQUFPLENBQUMsdURBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2Jhc2VuYW1lL3NjaGVtYXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlZ2lzdGVyQmFzZW5hbWVTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgcmVnaXN0ZXJpbmcgYSBCYXNlbmFtZS5cbiAqL1xuZXhwb3J0cy5SZWdpc3RlckJhc2VuYW1lU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGJhc2VuYW1lOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIEJhc2VuYW1lIHRvIGFzc2lnbiB0byB0aGUgYWdlbnRcIiksXG4gICAgYW1vdW50OiB6b2RfMS56LnN0cmluZygpLmRlZmF1bHQoXCIwLjAwMlwiKS5kZXNjcmliZShcIlRoZSBhbW91bnQgb2YgRVRIIHRvIHBheSBmb3IgcmVnaXN0cmF0aW9uXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIkluc3RydWN0aW9ucyBmb3IgcmVnaXN0ZXJpbmcgYSBCYXNlbmFtZVwiKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/schemas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpApiActionProvider.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpApiActionProvider.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.cdpApiActionProvider = exports.CdpApiActionProvider = void 0;\nconst package_json_1 = __webpack_require__(/*! ../../../package.json */ \"(ssr)/./node_modules/@coinbase/agentkit/package.json\");\nconst coinbase_sdk_1 = __webpack_require__(/*! @coinbase/coinbase-sdk */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/schemas.js\");\n/**\n * CdpApiActionProvider is an action provider for CDP API.\n *\n * This provider is used for any action that uses the CDP API, but does not require a CDP Wallet.\n */\nclass CdpApiActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the CdpApiActionProvider class.\n     *\n     * @param config - The configuration options for the CdpApiActionProvider.\n     */\n    constructor(config = {}) {\n        super(\"cdp_api\", []);\n        /**\n         * Checks if the Cdp action provider supports the given network.\n         *\n         * @param _ - The network to check.\n         * @returns True if the Cdp action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (_) => true;\n        if (config.apiKeyName && config.apiKeyPrivateKey) {\n            coinbase_sdk_1.Coinbase.configure({\n                apiKeyName: config.apiKeyName,\n                privateKey: config.apiKeyPrivateKey,\n                source: \"agentkit\",\n                sourceVersion: package_json_1.version,\n            });\n        }\n        else {\n            coinbase_sdk_1.Coinbase.configureFromJson();\n        }\n    }\n    /**\n     * Check the reputation of an address.\n     *\n     * @param args - The input arguments for the action\n     * @returns A string containing reputation data or error message\n     */\n    async addressReputation(args) {\n        try {\n            const address = new coinbase_sdk_1.ExternalAddress(args.network, args.address);\n            const reputation = await address.reputation();\n            return reputation.toString();\n        }\n        catch (error) {\n            return `Error checking address reputation: ${error}`;\n        }\n    }\n    /**\n     * Requests test tokens from the faucet for the default address in the wallet.\n     *\n     * @param walletProvider - The wallet provider to request funds from.\n     * @param args - The input arguments for the action.\n     * @returns A confirmation message with transaction details.\n     */\n    async faucet(walletProvider, args) {\n        try {\n            const address = new coinbase_sdk_1.ExternalAddress(walletProvider.getNetwork().networkId, walletProvider.getAddress());\n            const faucetTx = await address.faucet(args.assetId || undefined);\n            const result = await faucetTx.wait();\n            return `Received ${args.assetId || \"ETH\"} from the faucet. Transaction: ${result.getTransactionLink()}`;\n        }\n        catch (error) {\n            return `Error requesting faucet funds: ${error}`;\n        }\n    }\n}\nexports.CdpApiActionProvider = CdpApiActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"address_reputation\",\n        description: `\nThis tool checks the reputation of an address on a given network. It takes:\n\n- network: The network to check the address on (e.g. \"base-mainnet\")\n- address: The Ethereum address to check\n`,\n        schema: schemas_1.AddressReputationSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CdpApiActionProvider.prototype, \"addressReputation\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"request_faucet_funds\",\n        description: `This tool will request test tokens from the faucet for the default address in the wallet. It takes the wallet and asset ID as input.\nIf no asset ID is provided the faucet defaults to ETH. Faucet is only allowed on 'base-sepolia' and can only provide asset ID 'eth' or 'usdc'.\nYou are not allowed to faucet with any other network or asset ID. If you are on another network, suggest that the user sends you some ETH\nfrom another wallet and provide the user with your wallet details.`,\n        schema: schemas_1.RequestFaucetFundsSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CdpApiActionProvider.prototype, \"faucet\", null);\nconst cdpApiActionProvider = (config = {}) => new CdpApiActionProvider(config);\nexports.cdpApiActionProvider = cdpApiActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvY2RwQXBpQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDRCQUE0QjtBQUMzRCx1QkFBdUIsbUJBQU8sQ0FBQyxtRkFBdUI7QUFDdEQsdUJBQXVCLG1CQUFPLENBQUMseUZBQXdCO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyx1REFBSztBQUMzQiwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQseUJBQXlCLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3BELDJCQUEyQixtQkFBTyxDQUFDLHNHQUF3QjtBQUMzRCxrQkFBa0IsbUJBQU8sQ0FBQywrRkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE1BQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUIsZ0NBQWdDLDRCQUE0QjtBQUNsSDtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLDRCQUE0QiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvY2RwQXBpQWN0aW9uUHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jZHBBcGlBY3Rpb25Qcm92aWRlciA9IGV4cG9ydHMuQ2RwQXBpQWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBwYWNrYWdlX2pzb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wYWNrYWdlLmpzb25cIik7XG5jb25zdCBjb2luYmFzZV9zZGtfMSA9IHJlcXVpcmUoXCJAY29pbmJhc2UvY29pbmJhc2Utc2RrXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3QgYWN0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25Qcm92aWRlclwiKTtcbmNvbnN0IHdhbGxldF9wcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi93YWxsZXQtcHJvdmlkZXJzXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbi8qKlxuICogQ2RwQXBpQWN0aW9uUHJvdmlkZXIgaXMgYW4gYWN0aW9uIHByb3ZpZGVyIGZvciBDRFAgQVBJLlxuICpcbiAqIFRoaXMgcHJvdmlkZXIgaXMgdXNlZCBmb3IgYW55IGFjdGlvbiB0aGF0IHVzZXMgdGhlIENEUCBBUEksIGJ1dCBkb2VzIG5vdCByZXF1aXJlIGEgQ0RQIFdhbGxldC5cbiAqL1xuY2xhc3MgQ2RwQXBpQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIENkcEFwaUFjdGlvblByb3ZpZGVyIGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBDZHBBcGlBY3Rpb25Qcm92aWRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcihcImNkcF9hcGlcIiwgW10pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBDZHAgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gXyAtIFRoZSBuZXR3b3JrIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBDZHAgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBuZXR3b3JrLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRzTmV0d29yayA9IChfKSA9PiB0cnVlO1xuICAgICAgICBpZiAoY29uZmlnLmFwaUtleU5hbWUgJiYgY29uZmlnLmFwaUtleVByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIGNvaW5iYXNlX3Nka18xLkNvaW5iYXNlLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgYXBpS2V5TmFtZTogY29uZmlnLmFwaUtleU5hbWUsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogY29uZmlnLmFwaUtleVByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgc291cmNlOiBcImFnZW50a2l0XCIsXG4gICAgICAgICAgICAgICAgc291cmNlVmVyc2lvbjogcGFja2FnZV9qc29uXzEudmVyc2lvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29pbmJhc2Vfc2RrXzEuQ29pbmJhc2UuY29uZmlndXJlRnJvbUpzb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGUgcmVwdXRhdGlvbiBvZiBhbiBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgY29udGFpbmluZyByZXB1dGF0aW9uIGRhdGEgb3IgZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIGFkZHJlc3NSZXB1dGF0aW9uKGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgY29pbmJhc2Vfc2RrXzEuRXh0ZXJuYWxBZGRyZXNzKGFyZ3MubmV0d29yaywgYXJncy5hZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcHV0YXRpb24gPSBhd2FpdCBhZGRyZXNzLnJlcHV0YXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybiByZXB1dGF0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGNoZWNraW5nIGFkZHJlc3MgcmVwdXRhdGlvbjogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIHRlc3QgdG9rZW5zIGZyb20gdGhlIGZhdWNldCBmb3IgdGhlIGRlZmF1bHQgYWRkcmVzcyBpbiB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byByZXF1ZXN0IGZ1bmRzIGZyb20uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgY29uZmlybWF0aW9uIG1lc3NhZ2Ugd2l0aCB0cmFuc2FjdGlvbiBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGZhdWNldCh3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IG5ldyBjb2luYmFzZV9zZGtfMS5FeHRlcm5hbEFkZHJlc3Mod2FsbGV0UHJvdmlkZXIuZ2V0TmV0d29yaygpLm5ldHdvcmtJZCwgd2FsbGV0UHJvdmlkZXIuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgICAgIGNvbnN0IGZhdWNldFR4ID0gYXdhaXQgYWRkcmVzcy5mYXVjZXQoYXJncy5hc3NldElkIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmYXVjZXRUeC53YWl0KCk7XG4gICAgICAgICAgICByZXR1cm4gYFJlY2VpdmVkICR7YXJncy5hc3NldElkIHx8IFwiRVRIXCJ9IGZyb20gdGhlIGZhdWNldC4gVHJhbnNhY3Rpb246ICR7cmVzdWx0LmdldFRyYW5zYWN0aW9uTGluaygpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIHJlcXVlc3RpbmcgZmF1Y2V0IGZ1bmRzOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNkcEFwaUFjdGlvblByb3ZpZGVyID0gQ2RwQXBpQWN0aW9uUHJvdmlkZXI7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiYWRkcmVzc19yZXB1dGF0aW9uXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgY2hlY2tzIHRoZSByZXB1dGF0aW9uIG9mIGFuIGFkZHJlc3Mgb24gYSBnaXZlbiBuZXR3b3JrLiBJdCB0YWtlczpcblxuLSBuZXR3b3JrOiBUaGUgbmV0d29yayB0byBjaGVjayB0aGUgYWRkcmVzcyBvbiAoZS5nLiBcImJhc2UtbWFpbm5ldFwiKVxuLSBhZGRyZXNzOiBUaGUgRXRoZXJldW0gYWRkcmVzcyB0byBjaGVja1xuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuQWRkcmVzc1JlcHV0YXRpb25TY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3ZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgQ2RwQXBpQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImFkZHJlc3NSZXB1dGF0aW9uXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcInJlcXVlc3RfZmF1Y2V0X2Z1bmRzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgVGhpcyB0b29sIHdpbGwgcmVxdWVzdCB0ZXN0IHRva2VucyBmcm9tIHRoZSBmYXVjZXQgZm9yIHRoZSBkZWZhdWx0IGFkZHJlc3MgaW4gdGhlIHdhbGxldC4gSXQgdGFrZXMgdGhlIHdhbGxldCBhbmQgYXNzZXQgSUQgYXMgaW5wdXQuXG5JZiBubyBhc3NldCBJRCBpcyBwcm92aWRlZCB0aGUgZmF1Y2V0IGRlZmF1bHRzIHRvIEVUSC4gRmF1Y2V0IGlzIG9ubHkgYWxsb3dlZCBvbiAnYmFzZS1zZXBvbGlhJyBhbmQgY2FuIG9ubHkgcHJvdmlkZSBhc3NldCBJRCAnZXRoJyBvciAndXNkYycuXG5Zb3UgYXJlIG5vdCBhbGxvd2VkIHRvIGZhdWNldCB3aXRoIGFueSBvdGhlciBuZXR3b3JrIG9yIGFzc2V0IElELiBJZiB5b3UgYXJlIG9uIGFub3RoZXIgbmV0d29yaywgc3VnZ2VzdCB0aGF0IHRoZSB1c2VyIHNlbmRzIHlvdSBzb21lIEVUSFxuZnJvbSBhbm90aGVyIHdhbGxldCBhbmQgcHJvdmlkZSB0aGUgdXNlciB3aXRoIHlvdXIgd2FsbGV0IGRldGFpbHMuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuUmVxdWVzdEZhdWNldEZ1bmRzU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgQ2RwQXBpQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImZhdWNldFwiLCBudWxsKTtcbmNvbnN0IGNkcEFwaUFjdGlvblByb3ZpZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBuZXcgQ2RwQXBpQWN0aW9uUHJvdmlkZXIoY29uZmlnKTtcbmV4cG9ydHMuY2RwQXBpQWN0aW9uUHJvdmlkZXIgPSBjZHBBcGlBY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpApiActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpWalletActionProvider.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpWalletActionProvider.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.cdpWalletActionProvider = exports.CdpWalletActionProvider = void 0;\nconst coinbase_sdk_1 = __webpack_require__(/*! @coinbase/coinbase-sdk */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/constants.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/schemas.js\");\n/**\n * CdpWalletActionProvider is an action provider for Cdp.\n *\n * This provider is used for any action that requires a CDP Wallet.\n */\nclass CdpWalletActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the CdpWalletActionProvider class.\n     *\n     * @param config - The configuration options for the CdpWalletActionProvider.\n     */\n    constructor(config = {}) {\n        super(\"cdp_wallet\", []);\n        /**\n         * Checks if the Cdp action provider supports the given network.\n         *\n         * @param _ - The network to check.\n         * @returns True if the Cdp action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (_) => true;\n        if (config.apiKeyName && config.apiKeyPrivateKey) {\n            coinbase_sdk_1.Coinbase.configure({ apiKeyName: config.apiKeyName, privateKey: config.apiKeyPrivateKey });\n        }\n        else {\n            coinbase_sdk_1.Coinbase.configureFromJson();\n        }\n    }\n    /**\n     * Deploys a contract.\n     *\n     * @param walletProvider - The wallet provider to deploy the contract from\n     * @param args - The input arguments for the action\n     * @returns A message containing the deployed contract address and details\n     */\n    async deployContract(walletProvider, args) {\n        try {\n            const solidityVersion = constants_1.SolidityVersions[args.solidityVersion];\n            const contract = await walletProvider.deployContract({\n                solidityVersion: solidityVersion,\n                solidityInputJson: args.solidityInputJson,\n                contractName: args.contractName,\n                constructorArgs: args.constructorArgs ?? {},\n            });\n            const result = await contract.wait();\n            return `Deployed contract ${args.contractName} at address ${result.getContractAddress()}. Transaction link: ${result\n                .getTransaction()\n                .getTransactionLink()}`;\n        }\n        catch (error) {\n            return `Error deploying contract: ${error}`;\n        }\n    }\n    /**\n     * Deploys an NFT (ERC-721) token collection onchain from the wallet.\n     *\n     * @param walletProvider - The wallet provider to deploy the NFT from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the NFT token deployment details.\n     */\n    async deployNFT(walletProvider, args) {\n        try {\n            const nftContract = await walletProvider.deployNFT({\n                name: args.name,\n                symbol: args.symbol,\n                baseURI: args.baseURI,\n            });\n            const result = await nftContract.wait();\n            const transaction = result.getTransaction();\n            const networkId = walletProvider.getNetwork().networkId;\n            const contractAddress = result.getContractAddress();\n            return [\n                `Deployed NFT Collection ${args.name}:`,\n                `- to address ${contractAddress}`,\n                `- on network ${networkId}.`,\n                `Transaction hash: ${transaction.getTransactionHash()}`,\n                `Transaction link: ${transaction.getTransactionLink()}`,\n            ].join(\"\\n\");\n        }\n        catch (error) {\n            return `Error deploying NFT: ${error}`;\n        }\n    }\n    /**\n     * Deploys a token.\n     *\n     * @param walletProvider - The wallet provider to deploy the token.\n     * @param args - The arguments for the token deployment.\n     * @returns The deployed token.\n     */\n    async deployToken(walletProvider, args) {\n        try {\n            const tokenContract = await walletProvider.deployToken({\n                name: args.name,\n                symbol: args.symbol,\n                totalSupply: args.totalSupply,\n            });\n            const result = await tokenContract.wait();\n            return `Deployed ERC20 token contract ${args.name} (${args.symbol}) with total supply of ${args.totalSupply} tokens at address ${result.getContractAddress()}. Transaction link: ${result\n                .getTransaction()\n                .getTransactionLink()}`;\n        }\n        catch (error) {\n            return `Error deploying token: ${error}`;\n        }\n    }\n    /**\n     * Trades a specified amount of a from asset to a to asset for the wallet.\n     *\n     * @param walletProvider - The wallet provider to trade the asset from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the trade details.\n     */\n    async trade(walletProvider, args) {\n        try {\n            const tradeResult = await walletProvider.createTrade({\n                amount: args.amount,\n                fromAssetId: args.fromAssetId,\n                toAssetId: args.toAssetId,\n            });\n            const result = await tradeResult.wait();\n            return `Traded ${args.amount} of ${args.fromAssetId} for ${result.getToAmount()} of ${args.toAssetId}.\\nTransaction hash for the trade: ${result\n                .getTransaction()\n                .getTransactionHash()}\\nTransaction link for the trade: ${result\n                .getTransaction()\n                .getTransactionLink()}`;\n        }\n        catch (error) {\n            return `Error trading assets: ${error}`;\n        }\n    }\n}\nexports.CdpWalletActionProvider = CdpWalletActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"deploy_contract\",\n        description: `\nDeploys smart contract with required args: solidity version (string), solidity input json (string), contract name (string), and optional constructor args (Dict[str, Any])\n\nInput json structure:\n{\"language\":\"Solidity\",\"settings\":{\"remappings\":[],\"outputSelection\":{\"*\":{\"*\":[\"abi\",\"evm.bytecode\"]}}},\"sources\":{}}\n\nYou must set the outputSelection to {\"*\":{\"*\":[\"abi\",\"evm.bytecode\"]}} in the settings. The solidity version must be >= 0.8.0 and <= 0.8.28.\n\nSources should contain one or more contracts with the following structure:\n{\"contract_name.sol\":{\"content\":\"contract code\"}}\n\nThe contract code should be escaped. Contracts cannot import from external contracts but can import from one another.\n\nConstructor args are required if the contract has a constructor. They are a key-value\nmap where the key is the arg name and the value is the arg value. Encode uint/int/bytes/string/address values as strings, boolean values as true/false. For arrays/tuples, encode based on contained type.`,\n        schema: schemas_1.DeployContractSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.CdpWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CdpWalletActionProvider.prototype, \"deployContract\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"deploy_nft\",\n        description: `This tool will deploy an NFT (ERC-721) contract onchain from the wallet. \n  It takes the name of the NFT collection, the symbol of the NFT collection, and the base URI for the token metadata as inputs.`,\n        schema: schemas_1.DeployNftSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.CdpWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CdpWalletActionProvider.prototype, \"deployNFT\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"deploy_token\",\n        description: `This tool will deploy an ERC20 token smart contract. It takes the token name, symbol, and total supply as input. \nThe token will be deployed using the wallet's default address as the owner and initial token holder.`,\n        schema: schemas_1.DeployTokenSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.CdpWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CdpWalletActionProvider.prototype, \"deployToken\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"trade\",\n        description: `This tool will trade a specified amount of a 'from asset' to a 'to asset' for the wallet.\nIt takes the following inputs:\n- The amount of the 'from asset' to trade\n- The from asset ID to trade \n- The asset ID to receive from the trade\n\nImportant notes:\n- Trades are only supported on mainnet networks (ie, 'base-mainnet', 'base', 'ethereum-mainnet', 'ethereum', etc.)\n- Never allow trades on any non-mainnet network (ie, 'base-sepolia', 'ethereum-sepolia', etc.)\n- When selling a native asset (e.g. 'eth' on base-mainnet), ensure there is sufficient balance to pay for the trade AND the gas cost of this trade`,\n        schema: schemas_1.TradeSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.CdpWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CdpWalletActionProvider.prototype, \"trade\", null);\nconst cdpWalletActionProvider = (config = {}) => new CdpWalletActionProvider(config);\nexports.cdpWalletActionProvider = cdpWalletActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvY2RwV2FsbGV0QWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQixHQUFHLCtCQUErQjtBQUNqRSx1QkFBdUIsbUJBQU8sQ0FBQyx5RkFBd0I7QUFDdkQsY0FBYyxtQkFBTyxDQUFDLHVEQUFLO0FBQzNCLDBCQUEwQixtQkFBTyxDQUFDLDRHQUFvQjtBQUN0RCx5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMkJBQTJCLG1CQUFPLENBQUMsc0dBQXdCO0FBQzNELG9CQUFvQixtQkFBTyxDQUFDLG1HQUFhO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLCtGQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG9FQUFvRTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxhQUFhO0FBQ2I7QUFDQSx3Q0FBd0MsbUJBQW1CLGFBQWEsNEJBQTRCLHNCQUFzQjtBQUMxSDtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRCxnQ0FBZ0MsZ0JBQWdCO0FBQ2hELGdDQUFnQyxVQUFVO0FBQzFDLHFDQUFxQyxpQ0FBaUM7QUFDdEUscUNBQXFDLGlDQUFpQztBQUN0RTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvREFBb0QsV0FBVyxHQUFHLFlBQVkseUJBQXlCLGtCQUFrQixvQkFBb0IsNEJBQTRCLHNCQUFzQjtBQUMvTDtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNkJBQTZCLGFBQWEsS0FBSyxrQkFBa0IsTUFBTSxzQkFBc0IsS0FBSyxlQUFlLHFDQUFxQztBQUN0SjtBQUNBLHNDQUFzQyxvQ0FBb0M7QUFDMUU7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxrQ0FBa0MsbUNBQW1DLEtBQUssNkJBQTZCOztBQUV4RyxxQ0FBcUMsS0FBSyw2QkFBNkI7O0FBRXZFO0FBQ0EsQ0FBQyxxQkFBcUI7O0FBRXRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QywrQkFBK0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvY2RwL2NkcFdhbGxldEFjdGlvblByb3ZpZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2RwV2FsbGV0QWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLkNkcFdhbGxldEFjdGlvblByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgY29pbmJhc2Vfc2RrXzEgPSByZXF1aXJlKFwiQGNvaW5iYXNlL2NvaW5iYXNlLXNka1wiKTtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGFjdGlvbkRlY29yYXRvcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvbkRlY29yYXRvclwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbi8qKlxuICogQ2RwV2FsbGV0QWN0aW9uUHJvdmlkZXIgaXMgYW4gYWN0aW9uIHByb3ZpZGVyIGZvciBDZHAuXG4gKlxuICogVGhpcyBwcm92aWRlciBpcyB1c2VkIGZvciBhbnkgYWN0aW9uIHRoYXQgcmVxdWlyZXMgYSBDRFAgV2FsbGV0LlxuICovXG5jbGFzcyBDZHBXYWxsZXRBY3Rpb25Qcm92aWRlciBleHRlbmRzIGFjdGlvblByb3ZpZGVyXzEuQWN0aW9uUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgQ2RwV2FsbGV0QWN0aW9uUHJvdmlkZXIgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIENkcFdhbGxldEFjdGlvblByb3ZpZGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKFwiY2RwX3dhbGxldFwiLCBbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIENkcCBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBfIC0gVGhlIG5ldHdvcmsgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIENkcCBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIG5ldHdvcmssIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcG9ydHNOZXR3b3JrID0gKF8pID0+IHRydWU7XG4gICAgICAgIGlmIChjb25maWcuYXBpS2V5TmFtZSAmJiBjb25maWcuYXBpS2V5UHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgY29pbmJhc2Vfc2RrXzEuQ29pbmJhc2UuY29uZmlndXJlKHsgYXBpS2V5TmFtZTogY29uZmlnLmFwaUtleU5hbWUsIHByaXZhdGVLZXk6IGNvbmZpZy5hcGlLZXlQcml2YXRlS2V5IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29pbmJhc2Vfc2RrXzEuQ29pbmJhc2UuY29uZmlndXJlRnJvbUpzb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBsb3lzIGEgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0UHJvdmlkZXIgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIHRvIGRlcGxveSB0aGUgY29udHJhY3QgZnJvbVxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGlucHV0IGFyZ3VtZW50cyBmb3IgdGhlIGFjdGlvblxuICAgICAqIEByZXR1cm5zIEEgbWVzc2FnZSBjb250YWluaW5nIHRoZSBkZXBsb3llZCBjb250cmFjdCBhZGRyZXNzIGFuZCBkZXRhaWxzXG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95Q29udHJhY3Qod2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNvbGlkaXR5VmVyc2lvbiA9IGNvbnN0YW50c18xLlNvbGlkaXR5VmVyc2lvbnNbYXJncy5zb2xpZGl0eVZlcnNpb25dO1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBhd2FpdCB3YWxsZXRQcm92aWRlci5kZXBsb3lDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgc29saWRpdHlWZXJzaW9uOiBzb2xpZGl0eVZlcnNpb24sXG4gICAgICAgICAgICAgICAgc29saWRpdHlJbnB1dEpzb246IGFyZ3Muc29saWRpdHlJbnB1dEpzb24sXG4gICAgICAgICAgICAgICAgY29udHJhY3ROYW1lOiBhcmdzLmNvbnRyYWN0TmFtZSxcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvckFyZ3M6IGFyZ3MuY29uc3RydWN0b3JBcmdzID8/IHt9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC53YWl0KCk7XG4gICAgICAgICAgICByZXR1cm4gYERlcGxveWVkIGNvbnRyYWN0ICR7YXJncy5jb250cmFjdE5hbWV9IGF0IGFkZHJlc3MgJHtyZXN1bHQuZ2V0Q29udHJhY3RBZGRyZXNzKCl9LiBUcmFuc2FjdGlvbiBsaW5rOiAke3Jlc3VsdFxuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2FjdGlvbigpXG4gICAgICAgICAgICAgICAgLmdldFRyYW5zYWN0aW9uTGluaygpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGRlcGxveWluZyBjb250cmFjdDogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYW4gTkZUIChFUkMtNzIxKSB0b2tlbiBjb2xsZWN0aW9uIG9uY2hhaW4gZnJvbSB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byBkZXBsb3kgdGhlIE5GVCBmcm9tLlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGlucHV0IGFyZ3VtZW50cyBmb3IgdGhlIGFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIG1lc3NhZ2UgY29udGFpbmluZyB0aGUgTkZUIHRva2VuIGRlcGxveW1lbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lORlQod2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5mdENvbnRyYWN0ID0gYXdhaXQgd2FsbGV0UHJvdmlkZXIuZGVwbG95TkZUKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBhcmdzLm5hbWUsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBhcmdzLnN5bWJvbCxcbiAgICAgICAgICAgICAgICBiYXNlVVJJOiBhcmdzLmJhc2VVUkksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5mdENvbnRyYWN0LndhaXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gcmVzdWx0LmdldFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrSWQgPSB3YWxsZXRQcm92aWRlci5nZXROZXR3b3JrKCkubmV0d29ya0lkO1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gcmVzdWx0LmdldENvbnRyYWN0QWRkcmVzcygpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBgRGVwbG95ZWQgTkZUIENvbGxlY3Rpb24gJHthcmdzLm5hbWV9OmAsXG4gICAgICAgICAgICAgICAgYC0gdG8gYWRkcmVzcyAke2NvbnRyYWN0QWRkcmVzc31gLFxuICAgICAgICAgICAgICAgIGAtIG9uIG5ldHdvcmsgJHtuZXR3b3JrSWR9LmAsXG4gICAgICAgICAgICAgICAgYFRyYW5zYWN0aW9uIGhhc2g6ICR7dHJhbnNhY3Rpb24uZ2V0VHJhbnNhY3Rpb25IYXNoKCl9YCxcbiAgICAgICAgICAgICAgICBgVHJhbnNhY3Rpb24gbGluazogJHt0cmFuc2FjdGlvbi5nZXRUcmFuc2FjdGlvbkxpbmsoKX1gLFxuICAgICAgICAgICAgXS5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBkZXBsb3lpbmcgTkZUOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byBkZXBsb3kgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIHRva2VuIGRlcGxveW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIGRlcGxveWVkIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGRlcGxveVRva2VuKHdhbGxldFByb3ZpZGVyLCBhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkNvbnRyYWN0ID0gYXdhaXQgd2FsbGV0UHJvdmlkZXIuZGVwbG95VG9rZW4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IGFyZ3MubmFtZSxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IGFyZ3Muc3ltYm9sLFxuICAgICAgICAgICAgICAgIHRvdGFsU3VwcGx5OiBhcmdzLnRvdGFsU3VwcGx5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0b2tlbkNvbnRyYWN0LndhaXQoKTtcbiAgICAgICAgICAgIHJldHVybiBgRGVwbG95ZWQgRVJDMjAgdG9rZW4gY29udHJhY3QgJHthcmdzLm5hbWV9ICgke2FyZ3Muc3ltYm9sfSkgd2l0aCB0b3RhbCBzdXBwbHkgb2YgJHthcmdzLnRvdGFsU3VwcGx5fSB0b2tlbnMgYXQgYWRkcmVzcyAke3Jlc3VsdC5nZXRDb250cmFjdEFkZHJlc3MoKX0uIFRyYW5zYWN0aW9uIGxpbms6ICR7cmVzdWx0XG4gICAgICAgICAgICAgICAgLmdldFRyYW5zYWN0aW9uKClcbiAgICAgICAgICAgICAgICAuZ2V0VHJhbnNhY3Rpb25MaW5rKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZGVwbG95aW5nIHRva2VuOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhZGVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBhIGZyb20gYXNzZXQgdG8gYSB0byBhc3NldCBmb3IgdGhlIHdhbGxldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gdHJhZGUgdGhlIGFzc2V0IGZyb20uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgbWVzc2FnZSBjb250YWluaW5nIHRoZSB0cmFkZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYWRlKHdhbGxldFByb3ZpZGVyLCBhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0cmFkZVJlc3VsdCA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLmNyZWF0ZVRyYWRlKHtcbiAgICAgICAgICAgICAgICBhbW91bnQ6IGFyZ3MuYW1vdW50LFxuICAgICAgICAgICAgICAgIGZyb21Bc3NldElkOiBhcmdzLmZyb21Bc3NldElkLFxuICAgICAgICAgICAgICAgIHRvQXNzZXRJZDogYXJncy50b0Fzc2V0SWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRyYWRlUmVzdWx0LndhaXQoKTtcbiAgICAgICAgICAgIHJldHVybiBgVHJhZGVkICR7YXJncy5hbW91bnR9IG9mICR7YXJncy5mcm9tQXNzZXRJZH0gZm9yICR7cmVzdWx0LmdldFRvQW1vdW50KCl9IG9mICR7YXJncy50b0Fzc2V0SWR9LlxcblRyYW5zYWN0aW9uIGhhc2ggZm9yIHRoZSB0cmFkZTogJHtyZXN1bHRcbiAgICAgICAgICAgICAgICAuZ2V0VHJhbnNhY3Rpb24oKVxuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2FjdGlvbkhhc2goKX1cXG5UcmFuc2FjdGlvbiBsaW5rIGZvciB0aGUgdHJhZGU6ICR7cmVzdWx0XG4gICAgICAgICAgICAgICAgLmdldFRyYW5zYWN0aW9uKClcbiAgICAgICAgICAgICAgICAuZ2V0VHJhbnNhY3Rpb25MaW5rKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgdHJhZGluZyBhc3NldHM6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2RwV2FsbGV0QWN0aW9uUHJvdmlkZXIgPSBDZHBXYWxsZXRBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJkZXBsb3lfY29udHJhY3RcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcbkRlcGxveXMgc21hcnQgY29udHJhY3Qgd2l0aCByZXF1aXJlZCBhcmdzOiBzb2xpZGl0eSB2ZXJzaW9uIChzdHJpbmcpLCBzb2xpZGl0eSBpbnB1dCBqc29uIChzdHJpbmcpLCBjb250cmFjdCBuYW1lIChzdHJpbmcpLCBhbmQgb3B0aW9uYWwgY29uc3RydWN0b3IgYXJncyAoRGljdFtzdHIsIEFueV0pXG5cbklucHV0IGpzb24gc3RydWN0dXJlOlxue1wibGFuZ3VhZ2VcIjpcIlNvbGlkaXR5XCIsXCJzZXR0aW5nc1wiOntcInJlbWFwcGluZ3NcIjpbXSxcIm91dHB1dFNlbGVjdGlvblwiOntcIipcIjp7XCIqXCI6W1wiYWJpXCIsXCJldm0uYnl0ZWNvZGVcIl19fX0sXCJzb3VyY2VzXCI6e319XG5cbllvdSBtdXN0IHNldCB0aGUgb3V0cHV0U2VsZWN0aW9uIHRvIHtcIipcIjp7XCIqXCI6W1wiYWJpXCIsXCJldm0uYnl0ZWNvZGVcIl19fSBpbiB0aGUgc2V0dGluZ3MuIFRoZSBzb2xpZGl0eSB2ZXJzaW9uIG11c3QgYmUgPj0gMC44LjAgYW5kIDw9IDAuOC4yOC5cblxuU291cmNlcyBzaG91bGQgY29udGFpbiBvbmUgb3IgbW9yZSBjb250cmFjdHMgd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbntcImNvbnRyYWN0X25hbWUuc29sXCI6e1wiY29udGVudFwiOlwiY29udHJhY3QgY29kZVwifX1cblxuVGhlIGNvbnRyYWN0IGNvZGUgc2hvdWxkIGJlIGVzY2FwZWQuIENvbnRyYWN0cyBjYW5ub3QgaW1wb3J0IGZyb20gZXh0ZXJuYWwgY29udHJhY3RzIGJ1dCBjYW4gaW1wb3J0IGZyb20gb25lIGFub3RoZXIuXG5cbkNvbnN0cnVjdG9yIGFyZ3MgYXJlIHJlcXVpcmVkIGlmIHRoZSBjb250cmFjdCBoYXMgYSBjb25zdHJ1Y3Rvci4gVGhleSBhcmUgYSBrZXktdmFsdWVcbm1hcCB3aGVyZSB0aGUga2V5IGlzIHRoZSBhcmcgbmFtZSBhbmQgdGhlIHZhbHVlIGlzIHRoZSBhcmcgdmFsdWUuIEVuY29kZSB1aW50L2ludC9ieXRlcy9zdHJpbmcvYWRkcmVzcyB2YWx1ZXMgYXMgc3RyaW5ncywgYm9vbGVhbiB2YWx1ZXMgYXMgdHJ1ZS9mYWxzZS4gRm9yIGFycmF5cy90dXBsZXMsIGVuY29kZSBiYXNlZCBvbiBjb250YWluZWQgdHlwZS5gLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5EZXBsb3lDb250cmFjdFNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkNkcFdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIENkcFdhbGxldEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJkZXBsb3lDb250cmFjdFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJkZXBsb3lfbmZ0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgVGhpcyB0b29sIHdpbGwgZGVwbG95IGFuIE5GVCAoRVJDLTcyMSkgY29udHJhY3Qgb25jaGFpbiBmcm9tIHRoZSB3YWxsZXQuIFxuICBJdCB0YWtlcyB0aGUgbmFtZSBvZiB0aGUgTkZUIGNvbGxlY3Rpb24sIHRoZSBzeW1ib2wgb2YgdGhlIE5GVCBjb2xsZWN0aW9uLCBhbmQgdGhlIGJhc2UgVVJJIGZvciB0aGUgdG9rZW4gbWV0YWRhdGEgYXMgaW5wdXRzLmAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkRlcGxveU5mdFNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkNkcFdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIENkcFdhbGxldEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJkZXBsb3lORlRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiZGVwbG95X3Rva2VuXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgVGhpcyB0b29sIHdpbGwgZGVwbG95IGFuIEVSQzIwIHRva2VuIHNtYXJ0IGNvbnRyYWN0LiBJdCB0YWtlcyB0aGUgdG9rZW4gbmFtZSwgc3ltYm9sLCBhbmQgdG90YWwgc3VwcGx5IGFzIGlucHV0LiBcblRoZSB0b2tlbiB3aWxsIGJlIGRlcGxveWVkIHVzaW5nIHRoZSB3YWxsZXQncyBkZWZhdWx0IGFkZHJlc3MgYXMgdGhlIG93bmVyIGFuZCBpbml0aWFsIHRva2VuIGhvbGRlci5gLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5EZXBsb3lUb2tlblNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkNkcFdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIENkcFdhbGxldEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJkZXBsb3lUb2tlblwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJ0cmFkZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFRoaXMgdG9vbCB3aWxsIHRyYWRlIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBhICdmcm9tIGFzc2V0JyB0byBhICd0byBhc3NldCcgZm9yIHRoZSB3YWxsZXQuXG5JdCB0YWtlcyB0aGUgZm9sbG93aW5nIGlucHV0czpcbi0gVGhlIGFtb3VudCBvZiB0aGUgJ2Zyb20gYXNzZXQnIHRvIHRyYWRlXG4tIFRoZSBmcm9tIGFzc2V0IElEIHRvIHRyYWRlIFxuLSBUaGUgYXNzZXQgSUQgdG8gcmVjZWl2ZSBmcm9tIHRoZSB0cmFkZVxuXG5JbXBvcnRhbnQgbm90ZXM6XG4tIFRyYWRlcyBhcmUgb25seSBzdXBwb3J0ZWQgb24gbWFpbm5ldCBuZXR3b3JrcyAoaWUsICdiYXNlLW1haW5uZXQnLCAnYmFzZScsICdldGhlcmV1bS1tYWlubmV0JywgJ2V0aGVyZXVtJywgZXRjLilcbi0gTmV2ZXIgYWxsb3cgdHJhZGVzIG9uIGFueSBub24tbWFpbm5ldCBuZXR3b3JrIChpZSwgJ2Jhc2Utc2Vwb2xpYScsICdldGhlcmV1bS1zZXBvbGlhJywgZXRjLilcbi0gV2hlbiBzZWxsaW5nIGEgbmF0aXZlIGFzc2V0IChlLmcuICdldGgnIG9uIGJhc2UtbWFpbm5ldCksIGVuc3VyZSB0aGVyZSBpcyBzdWZmaWNpZW50IGJhbGFuY2UgdG8gcGF5IGZvciB0aGUgdHJhZGUgQU5EIHRoZSBnYXMgY29zdCBvZiB0aGlzIHRyYWRlYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuVHJhZGVTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3dhbGxldF9wcm92aWRlcnNfMS5DZHBXYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBDZHBXYWxsZXRBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwidHJhZGVcIiwgbnVsbCk7XG5jb25zdCBjZHBXYWxsZXRBY3Rpb25Qcm92aWRlciA9IChjb25maWcgPSB7fSkgPT4gbmV3IENkcFdhbGxldEFjdGlvblByb3ZpZGVyKGNvbmZpZyk7XG5leHBvcnRzLmNkcFdhbGxldEFjdGlvblByb3ZpZGVyID0gY2RwV2FsbGV0QWN0aW9uUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpWalletActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/constants.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/cdp/constants.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SolidityVersions = void 0;\nexports.SolidityVersions = {\n    \"0.8.28\": \"0.8.28+commit.7893614a\",\n    \"0.8.27\": \"0.8.27+commit.40a35a09\",\n    \"0.8.26\": \"0.8.26+commit.8a97fa7a\",\n    \"0.8.25\": \"0.8.25+commit.b61c2a91\",\n    \"0.8.24\": \"0.8.24+commit.e11b9ed9\",\n    \"0.8.23\": \"0.8.23+commit.f704f362\",\n    \"0.8.22\": \"0.8.22+commit.4fc1097e\",\n    \"0.8.21\": \"0.8.21+commit.d9974bed\",\n    \"0.8.20\": \"0.8.20+commit.a1b79de6\",\n    \"0.8.19\": \"0.8.19+commit.7dd6d404\",\n    \"0.8.18\": \"0.8.18+commit.87f61d96\",\n    \"0.8.17\": \"0.8.17+commit.8df45f5f\",\n    \"0.8.16\": \"0.8.16+commit.07a7930e\",\n    \"0.8.15\": \"0.8.15+commit.e14f2714\",\n    \"0.8.14\": \"0.8.14+commit.80d49f37\",\n    \"0.8.13\": \"0.8.13+commit.abaa5c0e\",\n    \"0.8.12\": \"0.8.12+commit.f00d7308\",\n    \"0.8.11\": \"0.8.11+commit.d7f03943\",\n    \"0.8.10\": \"0.8.10+commit.fc410830\",\n    \"0.8.9\": \"0.8.9+commit.e5eed63a\",\n    \"0.8.8\": \"0.8.8+commit.dddeac2f\",\n    \"0.8.7\": \"0.8.7+commit.e28d00a7\",\n    \"0.8.6\": \"0.8.6+commit.11564f7e\",\n    \"0.8.5\": \"0.8.5+commit.a4f2e591\",\n    \"0.8.4\": \"0.8.4+commit.c7e474f2\",\n    \"0.8.3\": \"0.8.3+commit.8d00100c\",\n    \"0.8.2\": \"0.8.2+commit.661d1103\",\n    \"0.8.1\": \"0.8.1+commit.df193b15\",\n    \"0.8.0\": \"0.8.0+commit.c7dfd78e\",\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2NkcC9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvbGlkaXR5VmVyc2lvbnMgPSB2b2lkIDA7XG5leHBvcnRzLlNvbGlkaXR5VmVyc2lvbnMgPSB7XG4gICAgXCIwLjguMjhcIjogXCIwLjguMjgrY29tbWl0Ljc4OTM2MTRhXCIsXG4gICAgXCIwLjguMjdcIjogXCIwLjguMjcrY29tbWl0LjQwYTM1YTA5XCIsXG4gICAgXCIwLjguMjZcIjogXCIwLjguMjYrY29tbWl0LjhhOTdmYTdhXCIsXG4gICAgXCIwLjguMjVcIjogXCIwLjguMjUrY29tbWl0LmI2MWMyYTkxXCIsXG4gICAgXCIwLjguMjRcIjogXCIwLjguMjQrY29tbWl0LmUxMWI5ZWQ5XCIsXG4gICAgXCIwLjguMjNcIjogXCIwLjguMjMrY29tbWl0LmY3MDRmMzYyXCIsXG4gICAgXCIwLjguMjJcIjogXCIwLjguMjIrY29tbWl0LjRmYzEwOTdlXCIsXG4gICAgXCIwLjguMjFcIjogXCIwLjguMjErY29tbWl0LmQ5OTc0YmVkXCIsXG4gICAgXCIwLjguMjBcIjogXCIwLjguMjArY29tbWl0LmExYjc5ZGU2XCIsXG4gICAgXCIwLjguMTlcIjogXCIwLjguMTkrY29tbWl0LjdkZDZkNDA0XCIsXG4gICAgXCIwLjguMThcIjogXCIwLjguMTgrY29tbWl0Ljg3ZjYxZDk2XCIsXG4gICAgXCIwLjguMTdcIjogXCIwLjguMTcrY29tbWl0LjhkZjQ1ZjVmXCIsXG4gICAgXCIwLjguMTZcIjogXCIwLjguMTYrY29tbWl0LjA3YTc5MzBlXCIsXG4gICAgXCIwLjguMTVcIjogXCIwLjguMTUrY29tbWl0LmUxNGYyNzE0XCIsXG4gICAgXCIwLjguMTRcIjogXCIwLjguMTQrY29tbWl0LjgwZDQ5ZjM3XCIsXG4gICAgXCIwLjguMTNcIjogXCIwLjguMTMrY29tbWl0LmFiYWE1YzBlXCIsXG4gICAgXCIwLjguMTJcIjogXCIwLjguMTIrY29tbWl0LmYwMGQ3MzA4XCIsXG4gICAgXCIwLjguMTFcIjogXCIwLjguMTErY29tbWl0LmQ3ZjAzOTQzXCIsXG4gICAgXCIwLjguMTBcIjogXCIwLjguMTArY29tbWl0LmZjNDEwODMwXCIsXG4gICAgXCIwLjguOVwiOiBcIjAuOC45K2NvbW1pdC5lNWVlZDYzYVwiLFxuICAgIFwiMC44LjhcIjogXCIwLjguOCtjb21taXQuZGRkZWFjMmZcIixcbiAgICBcIjAuOC43XCI6IFwiMC44LjcrY29tbWl0LmUyOGQwMGE3XCIsXG4gICAgXCIwLjguNlwiOiBcIjAuOC42K2NvbW1pdC4xMTU2NGY3ZVwiLFxuICAgIFwiMC44LjVcIjogXCIwLjguNStjb21taXQuYTRmMmU1OTFcIixcbiAgICBcIjAuOC40XCI6IFwiMC44LjQrY29tbWl0LmM3ZTQ3NGYyXCIsXG4gICAgXCIwLjguM1wiOiBcIjAuOC4zK2NvbW1pdC44ZDAwMTAwY1wiLFxuICAgIFwiMC44LjJcIjogXCIwLjguMitjb21taXQuNjYxZDExMDNcIixcbiAgICBcIjAuOC4xXCI6IFwiMC44LjErY29tbWl0LmRmMTkzYjE1XCIsXG4gICAgXCIwLjguMFwiOiBcIjAuOC4wK2NvbW1pdC5jN2RmZDc4ZVwiLFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/cdp/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/schemas.js\"), exports);\n__exportStar(__webpack_require__(/*! ./cdpApiActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpApiActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./cdpWalletActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpWalletActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLCtGQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyx5SEFBd0I7QUFDN0MsYUFBYSxtQkFBTyxDQUFDLCtIQUEyQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY2hlbWFzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jZHBBcGlBY3Rpb25Qcm92aWRlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2RwV2FsbGV0QWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/schemas.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/cdp/schemas.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TradeSchema = exports.RequestFaucetFundsSchema = exports.DeployTokenSchema = exports.DeployNftSchema = exports.DeployContractSchema = exports.AddressReputationSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/constants.js\");\n/**\n * Input schema for address reputation check.\n */\nexports.AddressReputationSchema = zod_1.z\n    .object({\n    address: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The Ethereum address to check\"),\n    network: zod_1.z.string().describe(\"The network to check the address on\"),\n})\n    .strip()\n    .describe(\"Input schema for address reputation check\");\n/**\n * Input schema for deploy contract action.\n */\nexports.DeployContractSchema = zod_1.z\n    .object({\n    solidityVersion: zod_1.z\n        .enum(Object.keys(constants_1.SolidityVersions))\n        .describe(\"The solidity compiler version\"),\n    solidityInputJson: zod_1.z.string().describe(\"The input json for the solidity compiler\"),\n    contractName: zod_1.z.string().describe(\"The name of the contract class to be deployed\"),\n    constructorArgs: zod_1.z\n        .record(zod_1.z.string(), zod_1.z.any())\n        .describe(\"The constructor arguments for the contract\")\n        .optional(),\n})\n    .strip()\n    .describe(\"Instructions for deploying an arbitrary contract\");\n/**\n * Input schema for deploy NFT action\n */\nexports.DeployNftSchema = zod_1.z\n    .object({\n    name: zod_1.z.string().describe(\"The name of the NFT collection\"),\n    symbol: zod_1.z.string().describe(\"The symbol of the NFT collection\"),\n    baseURI: zod_1.z.string().describe(\"The base URI for the token metadata\"),\n})\n    .strip()\n    .describe(\"Instructions for deploying an NFT collection\");\n/**\n * Input schema for deploy token action.\n */\nexports.DeployTokenSchema = zod_1.z\n    .object({\n    name: zod_1.z.string().describe(\"The name of the token\"),\n    symbol: zod_1.z.string().describe(\"The token symbol\"),\n    totalSupply: zod_1.z.custom().describe(\"The total supply of tokens to mint\"),\n})\n    .strip()\n    .describe(\"Instructions for deploying a token\");\n/**\n * Input schema for request faucet funds action.\n */\nexports.RequestFaucetFundsSchema = zod_1.z\n    .object({\n    assetId: zod_1.z.string().optional().describe(\"The optional asset ID to request from faucet\"),\n})\n    .strip()\n    .describe(\"Instructions for requesting faucet funds\");\n/**\n * Input schema for trade action.\n */\nexports.TradeSchema = zod_1.z\n    .object({\n    amount: zod_1.z.custom().describe(\"The amount of the from asset to trade\"),\n    fromAssetId: zod_1.z.string().describe(\"The from asset ID to trade\"),\n    toAssetId: zod_1.z.string().describe(\"The to asset ID to receive from the trade\"),\n})\n    .strip()\n    .describe(\"Instructions for trading assets\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxnQ0FBZ0MsR0FBRyx5QkFBeUIsR0FBRyx1QkFBdUIsR0FBRyw0QkFBNEIsR0FBRywrQkFBK0I7QUFDN0ssY0FBYyxtQkFBTyxDQUFDLHVEQUFLO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLG1HQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvY2RwL3NjaGVtYXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYWRlU2NoZW1hID0gZXhwb3J0cy5SZXF1ZXN0RmF1Y2V0RnVuZHNTY2hlbWEgPSBleHBvcnRzLkRlcGxveVRva2VuU2NoZW1hID0gZXhwb3J0cy5EZXBsb3lOZnRTY2hlbWEgPSBleHBvcnRzLkRlcGxveUNvbnRyYWN0U2NoZW1hID0gZXhwb3J0cy5BZGRyZXNzUmVwdXRhdGlvblNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIGFkZHJlc3MgcmVwdXRhdGlvbiBjaGVjay5cbiAqL1xuZXhwb3J0cy5BZGRyZXNzUmVwdXRhdGlvblNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBhZGRyZXNzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAucmVnZXgoL14weFthLWZBLUYwLTldezQwfSQvLCBcIkludmFsaWQgRXRoZXJldW0gYWRkcmVzcyBmb3JtYXRcIilcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIEV0aGVyZXVtIGFkZHJlc3MgdG8gY2hlY2tcIiksXG4gICAgbmV0d29yazogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBuZXR3b3JrIHRvIGNoZWNrIHRoZSBhZGRyZXNzIG9uXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIklucHV0IHNjaGVtYSBmb3IgYWRkcmVzcyByZXB1dGF0aW9uIGNoZWNrXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIGRlcGxveSBjb250cmFjdCBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuRGVwbG95Q29udHJhY3RTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgc29saWRpdHlWZXJzaW9uOiB6b2RfMS56XG4gICAgICAgIC5lbnVtKE9iamVjdC5rZXlzKGNvbnN0YW50c18xLlNvbGlkaXR5VmVyc2lvbnMpKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgc29saWRpdHkgY29tcGlsZXIgdmVyc2lvblwiKSxcbiAgICBzb2xpZGl0eUlucHV0SnNvbjogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBpbnB1dCBqc29uIGZvciB0aGUgc29saWRpdHkgY29tcGlsZXJcIiksXG4gICAgY29udHJhY3ROYW1lOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIG5hbWUgb2YgdGhlIGNvbnRyYWN0IGNsYXNzIHRvIGJlIGRlcGxveWVkXCIpLFxuICAgIGNvbnN0cnVjdG9yQXJnczogem9kXzEuelxuICAgICAgICAucmVjb3JkKHpvZF8xLnouc3RyaW5nKCksIHpvZF8xLnouYW55KCkpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBjb25zdHJ1Y3RvciBhcmd1bWVudHMgZm9yIHRoZSBjb250cmFjdFwiKVxuICAgICAgICAub3B0aW9uYWwoKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnN0cnVjdGlvbnMgZm9yIGRlcGxveWluZyBhbiBhcmJpdHJhcnkgY29udHJhY3RcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgZGVwbG95IE5GVCBhY3Rpb25cbiAqL1xuZXhwb3J0cy5EZXBsb3lOZnRTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgbmFtZTogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBuYW1lIG9mIHRoZSBORlQgY29sbGVjdGlvblwiKSxcbiAgICBzeW1ib2w6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgc3ltYm9sIG9mIHRoZSBORlQgY29sbGVjdGlvblwiKSxcbiAgICBiYXNlVVJJOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGJhc2UgVVJJIGZvciB0aGUgdG9rZW4gbWV0YWRhdGFcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5zdHJ1Y3Rpb25zIGZvciBkZXBsb3lpbmcgYW4gTkZUIGNvbGxlY3Rpb25cIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgZGVwbG95IHRva2VuIGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5EZXBsb3lUb2tlblNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBuYW1lOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIG5hbWUgb2YgdGhlIHRva2VuXCIpLFxuICAgIHN5bWJvbDogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSB0b2tlbiBzeW1ib2xcIiksXG4gICAgdG90YWxTdXBwbHk6IHpvZF8xLnouY3VzdG9tKCkuZGVzY3JpYmUoXCJUaGUgdG90YWwgc3VwcGx5IG9mIHRva2VucyB0byBtaW50XCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIkluc3RydWN0aW9ucyBmb3IgZGVwbG95aW5nIGEgdG9rZW5cIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgcmVxdWVzdCBmYXVjZXQgZnVuZHMgYWN0aW9uLlxuICovXG5leHBvcnRzLlJlcXVlc3RGYXVjZXRGdW5kc1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBhc3NldElkOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJUaGUgb3B0aW9uYWwgYXNzZXQgSUQgdG8gcmVxdWVzdCBmcm9tIGZhdWNldFwiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnN0cnVjdGlvbnMgZm9yIHJlcXVlc3RpbmcgZmF1Y2V0IGZ1bmRzXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIHRyYWRlIGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5UcmFkZVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBhbW91bnQ6IHpvZF8xLnouY3VzdG9tKCkuZGVzY3JpYmUoXCJUaGUgYW1vdW50IG9mIHRoZSBmcm9tIGFzc2V0IHRvIHRyYWRlXCIpLFxuICAgIGZyb21Bc3NldElkOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGZyb20gYXNzZXQgSUQgdG8gdHJhZGVcIiksXG4gICAgdG9Bc3NldElkOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIHRvIGFzc2V0IElEIHRvIHJlY2VpdmUgZnJvbSB0aGUgdHJhZGVcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5zdHJ1Y3Rpb25zIGZvciB0cmFkaW5nIGFzc2V0c1wiKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/schemas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/customActionProvider.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/customActionProvider.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.customActionProvider = exports.CustomActionProvider = void 0;\nconst actionDecorator_1 = __webpack_require__(/*! ./actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst actionProvider_1 = __webpack_require__(/*! ./actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../wallet-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\n/**\n * CustomActionProvider is a custom action provider that allows for custom action registration\n */\nclass CustomActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Creates a new CustomActionProvider that dynamically adds decorated action methods\n     *\n     * @param actions - Array of custom actions to be added to the provider\n     */\n    constructor(actions) {\n        super(\"custom\", []);\n        actions.forEach(({ name, description, schema, invoke }) => {\n            // Check if the invoke function expects a wallet provider\n            const takesWalletProvider = invoke.length === 2;\n            // Define the method on the prototype with the correct signature\n            Object.defineProperty(CustomActionProvider.prototype, name, {\n                value: takesWalletProvider\n                    ? async function (walletProvider, args) {\n                        const parsedArgs = schema.parse(args);\n                        return await invoke(walletProvider, parsedArgs);\n                    }\n                    : async function (args) {\n                        const parsedArgs = schema.parse(args);\n                        return await invoke(parsedArgs);\n                    },\n                configurable: true,\n                writable: true,\n                enumerable: true,\n            });\n            // Manually set the parameter metadata\n            const paramTypes = takesWalletProvider ? [wallet_providers_1.WalletProvider, Object] : [Object];\n            Reflect.defineMetadata(\"design:paramtypes\", paramTypes, CustomActionProvider.prototype, name);\n            // Apply the decorator using original name\n            const decoratedMethod = (0, actionDecorator_1.CreateAction)({\n                name,\n                description,\n                schema,\n            })(CustomActionProvider.prototype, name, Object.getOwnPropertyDescriptor(CustomActionProvider.prototype, name));\n            // Add the decorated method to the instance\n            Object.defineProperty(this, name, {\n                value: decoratedMethod,\n                configurable: true,\n                writable: true,\n            });\n        });\n    }\n    /**\n     * Custom action providers are supported on all networks\n     *\n     * @param _ - The network to checkpointSaver\n     * @returns true\n     */\n    supportsNetwork(_) {\n        return true;\n    }\n}\nexports.CustomActionProvider = CustomActionProvider;\nconst customActionProvider = (actions) => new CustomActionProvider(Array.isArray(actions) ? actions : [actions]);\nexports.customActionProvider = customActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jdXN0b21BY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDRCQUE0QjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQywyR0FBbUI7QUFDckQseUJBQXlCLG1CQUFPLENBQUMseUdBQWtCO0FBQ25ELDJCQUEyQixtQkFBTyxDQUFDLG1HQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1DQUFtQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jdXN0b21BY3Rpb25Qcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3VzdG9tQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLkN1c3RvbUFjdGlvblByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25EZWNvcmF0b3JcIik7XG5jb25zdCBhY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbi8qKlxuICogQ3VzdG9tQWN0aW9uUHJvdmlkZXIgaXMgYSBjdXN0b20gYWN0aW9uIHByb3ZpZGVyIHRoYXQgYWxsb3dzIGZvciBjdXN0b20gYWN0aW9uIHJlZ2lzdHJhdGlvblxuICovXG5jbGFzcyBDdXN0b21BY3Rpb25Qcm92aWRlciBleHRlbmRzIGFjdGlvblByb3ZpZGVyXzEuQWN0aW9uUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ3VzdG9tQWN0aW9uUHJvdmlkZXIgdGhhdCBkeW5hbWljYWxseSBhZGRzIGRlY29yYXRlZCBhY3Rpb24gbWV0aG9kc1xuICAgICAqXG4gICAgICogQHBhcmFtIGFjdGlvbnMgLSBBcnJheSBvZiBjdXN0b20gYWN0aW9ucyB0byBiZSBhZGRlZCB0byB0aGUgcHJvdmlkZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhY3Rpb25zKSB7XG4gICAgICAgIHN1cGVyKFwiY3VzdG9tXCIsIFtdKTtcbiAgICAgICAgYWN0aW9ucy5mb3JFYWNoKCh7IG5hbWUsIGRlc2NyaXB0aW9uLCBzY2hlbWEsIGludm9rZSB9KSA9PiB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW52b2tlIGZ1bmN0aW9uIGV4cGVjdHMgYSB3YWxsZXQgcHJvdmlkZXJcbiAgICAgICAgICAgIGNvbnN0IHRha2VzV2FsbGV0UHJvdmlkZXIgPSBpbnZva2UubGVuZ3RoID09PSAyO1xuICAgICAgICAgICAgLy8gRGVmaW5lIHRoZSBtZXRob2Qgb24gdGhlIHByb3RvdHlwZSB3aXRoIHRoZSBjb3JyZWN0IHNpZ25hdHVyZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0YWtlc1dhbGxldFByb3ZpZGVyXG4gICAgICAgICAgICAgICAgICAgID8gYXN5bmMgZnVuY3Rpb24gKHdhbGxldFByb3ZpZGVyLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gc2NoZW1hLnBhcnNlKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGludm9rZSh3YWxsZXRQcm92aWRlciwgcGFyc2VkQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBhc3luYyBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IHNjaGVtYS5wYXJzZShhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBpbnZva2UocGFyc2VkQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgcGFyYW1ldGVyIG1ldGFkYXRhXG4gICAgICAgICAgICBjb25zdCBwYXJhbVR5cGVzID0gdGFrZXNXYWxsZXRQcm92aWRlciA/IFt3YWxsZXRfcHJvdmlkZXJzXzEuV2FsbGV0UHJvdmlkZXIsIE9iamVjdF0gOiBbT2JqZWN0XTtcbiAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBwYXJhbVR5cGVzLCBDdXN0b21BY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIG5hbWUpO1xuICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGRlY29yYXRvciB1c2luZyBvcmlnaW5hbCBuYW1lXG4gICAgICAgICAgICBjb25zdCBkZWNvcmF0ZWRNZXRob2QgPSAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICB9KShDdXN0b21BY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIG5hbWUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQ3VzdG9tQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBuYW1lKSk7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGRlY29yYXRlZCBtZXRob2QgdG8gdGhlIGluc3RhbmNlXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkZWNvcmF0ZWRNZXRob2QsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDdXN0b20gYWN0aW9uIHByb3ZpZGVycyBhcmUgc3VwcG9ydGVkIG9uIGFsbCBuZXR3b3Jrc1xuICAgICAqXG4gICAgICogQHBhcmFtIF8gLSBUaGUgbmV0d29yayB0byBjaGVja3BvaW50U2F2ZXJcbiAgICAgKiBAcmV0dXJucyB0cnVlXG4gICAgICovXG4gICAgc3VwcG9ydHNOZXR3b3JrKF8pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5DdXN0b21BY3Rpb25Qcm92aWRlciA9IEN1c3RvbUFjdGlvblByb3ZpZGVyO1xuY29uc3QgY3VzdG9tQWN0aW9uUHJvdmlkZXIgPSAoYWN0aW9ucykgPT4gbmV3IEN1c3RvbUFjdGlvblByb3ZpZGVyKEFycmF5LmlzQXJyYXkoYWN0aW9ucykgPyBhY3Rpb25zIDogW2FjdGlvbnNdKTtcbmV4cG9ydHMuY3VzdG9tQWN0aW9uUHJvdmlkZXIgPSBjdXN0b21BY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/customActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/constants.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc20/constants.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.abi = void 0;\nexports.abi = [\n    {\n        type: \"event\",\n        name: \"Approval\",\n        inputs: [\n            {\n                indexed: true,\n                name: \"owner\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                name: \"spender\",\n                type: \"address\",\n            },\n            {\n                indexed: false,\n                name: \"value\",\n                type: \"uint256\",\n            },\n        ],\n    },\n    {\n        type: \"event\",\n        name: \"Transfer\",\n        inputs: [\n            {\n                indexed: true,\n                name: \"from\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                name: \"to\",\n                type: \"address\",\n            },\n            {\n                indexed: false,\n                name: \"value\",\n                type: \"uint256\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"allowance\",\n        stateMutability: \"view\",\n        inputs: [\n            {\n                name: \"owner\",\n                type: \"address\",\n            },\n            {\n                name: \"spender\",\n                type: \"address\",\n            },\n        ],\n        outputs: [\n            {\n                type: \"uint256\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"approve\",\n        stateMutability: \"nonpayable\",\n        inputs: [\n            {\n                name: \"spender\",\n                type: \"address\",\n            },\n            {\n                name: \"amount\",\n                type: \"uint256\",\n            },\n        ],\n        outputs: [\n            {\n                type: \"bool\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"balanceOf\",\n        stateMutability: \"view\",\n        inputs: [\n            {\n                name: \"account\",\n                type: \"address\",\n            },\n        ],\n        outputs: [\n            {\n                type: \"uint256\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"decimals\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"uint8\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"name\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"string\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"symbol\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"string\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"totalSupply\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"uint256\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"transfer\",\n        stateMutability: \"nonpayable\",\n        inputs: [\n            {\n                name: \"recipient\",\n                type: \"address\",\n            },\n            {\n                name: \"amount\",\n                type: \"uint256\",\n            },\n        ],\n        outputs: [\n            {\n                type: \"bool\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"transferFrom\",\n        stateMutability: \"nonpayable\",\n        inputs: [\n            {\n                name: \"sender\",\n                type: \"address\",\n            },\n            {\n                name: \"recipient\",\n                type: \"address\",\n            },\n            {\n                name: \"amount\",\n                type: \"uint256\",\n            },\n        ],\n        outputs: [\n            {\n                type: \"bool\",\n            },\n        ],\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmMyMC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVztBQUNYLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmMyMC9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFiaSA9IHZvaWQgMDtcbmV4cG9ydHMuYWJpID0gW1xuICAgIHtcbiAgICAgICAgdHlwZTogXCJldmVudFwiLFxuICAgICAgICBuYW1lOiBcIkFwcHJvdmFsXCIsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwic3BlbmRlclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgICAgIG5hbWU6IFwiVHJhbnNmZXJcIixcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBcImZyb21cIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRvXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJhbGxvd2FuY2VcIixcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInNwZW5kZXJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJhcHByb3ZlXCIsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwic3BlbmRlclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFtb3VudFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcImJhbGFuY2VPZlwiLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFjY291bnRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJkZWNpbWFsc1wiLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50OFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIG5hbWU6IFwic3ltYm9sXCIsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcInRvdGFsU3VwcGx5XCIsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJ0cmFuc2ZlclwiLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInJlY2lwaWVudFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFtb3VudFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcInRyYW5zZmVyRnJvbVwiLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInNlbmRlclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInJlY2lwaWVudFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFtb3VudFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuXTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/erc20ActionProvider.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc20/erc20ActionProvider.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.erc20ActionProvider = exports.ERC20ActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/schemas.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/constants.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_cjs/index.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\n/**\n * ERC20ActionProvider is an action provider for ERC20 tokens.\n */\nclass ERC20ActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the ERC20ActionProvider.\n     */\n    constructor() {\n        super(\"erc20\", []);\n        /**\n         * Checks if the ERC20 action provider supports the given network.\n         *\n         * @param _ - The network to check.\n         * @returns True if the ERC20 action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (_) => true;\n    }\n    /**\n     * Gets the balance of an ERC20 token.\n     *\n     * @param walletProvider - The wallet provider to get the balance from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the balance.\n     */\n    async getBalance(walletProvider, args) {\n        try {\n            const balance = await walletProvider.readContract({\n                address: args.contractAddress,\n                abi: constants_1.abi,\n                functionName: \"balanceOf\",\n                args: [walletProvider.getAddress()],\n            });\n            return `Balance of ${args.contractAddress} is ${balance}`;\n        }\n        catch (error) {\n            return `Error getting balance: ${error}`;\n        }\n    }\n    /**\n     * Transfers a specified amount of an ERC20 token to a destination onchain.\n     *\n     * @param walletProvider - The wallet provider to transfer the asset from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the transfer details.\n     */\n    async transfer(walletProvider, args) {\n        try {\n            const hash = await walletProvider.sendTransaction({\n                to: args.contractAddress,\n                data: (0, viem_1.encodeFunctionData)({\n                    abi: constants_1.abi,\n                    functionName: \"transfer\",\n                    args: [args.destination, BigInt(args.amount)],\n                }),\n            });\n            await walletProvider.waitForTransactionReceipt(hash);\n            return `Transferred ${args.amount} of ${args.contractAddress} to ${args.destination}.\\nTransaction hash for the transfer: ${hash}`;\n        }\n        catch (error) {\n            return `Error transferring the asset: ${error}`;\n        }\n    }\n}\nexports.ERC20ActionProvider = ERC20ActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_balance\",\n        description: `\n    This tool will get the balance of an ERC20 asset in the wallet. It takes the contract address as input.\n    `,\n        schema: schemas_1.GetBalanceSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], ERC20ActionProvider.prototype, \"getBalance\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"transfer\",\n        description: `\n    This tool will transfer an ERC20 token from the wallet to another onchain address.\n\nIt takes the following inputs:\n- amount: The amount to transfer\n- contractAddress: The contract address of the token to transfer\n- destination: Where to send the funds (can be an onchain address, ENS 'example.eth', or Basename 'example.base.eth')\n\nImportant notes:\n- Ensure sufficient balance of the input asset before transferring\n- When sending native assets (e.g. 'eth' on base-mainnet), ensure there is sufficient balance for the transfer itself AND the gas cost of this transfer\n    `,\n        schema: schemas_1.TransferSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], ERC20ActionProvider.prototype, \"transfer\", null);\nconst erc20ActionProvider = () => new ERC20ActionProvider();\nexports.erc20ActionProvider = erc20ActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmMyMC9lcmMyMEFjdGlvblByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRywyQkFBMkI7QUFDekQsY0FBYyxtQkFBTyxDQUFDLHVEQUFLO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLDBHQUFtQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsaUdBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMscUdBQWE7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCLDJCQUEyQixtQkFBTyxDQUFDLHNHQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixpQ0FBaUMsc0JBQXNCLEtBQUssUUFBUTtBQUNwRTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxrQ0FBa0MsYUFBYSxLQUFLLHNCQUFzQixLQUFLLGlCQUFpQix3Q0FBd0MsS0FBSztBQUM3STtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvZXJjMjAvZXJjMjBBY3Rpb25Qcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVyYzIwQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLkVSQzIwQWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBhY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvblByb3ZpZGVyXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdmllbV8xID0gcmVxdWlyZShcInZpZW1cIik7XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbi8qKlxuICogRVJDMjBBY3Rpb25Qcm92aWRlciBpcyBhbiBhY3Rpb24gcHJvdmlkZXIgZm9yIEVSQzIwIHRva2Vucy5cbiAqL1xuY2xhc3MgRVJDMjBBY3Rpb25Qcm92aWRlciBleHRlbmRzIGFjdGlvblByb3ZpZGVyXzEuQWN0aW9uUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgRVJDMjBBY3Rpb25Qcm92aWRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJlcmMyMFwiLCBbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIEVSQzIwIGFjdGlvbiBwcm92aWRlciBzdXBwb3J0cyB0aGUgZ2l2ZW4gbmV0d29yay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIF8gLSBUaGUgbmV0d29yayB0byBjaGVjay5cbiAgICAgICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgRVJDMjAgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBuZXR3b3JrLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRzTmV0d29yayA9IChfKSA9PiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBiYWxhbmNlIG9mIGFuIEVSQzIwIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byBnZXQgdGhlIGJhbGFuY2UgZnJvbS5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmFsYW5jZSh3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogYXJncy5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5hYmksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImJhbGFuY2VPZlwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFt3YWxsZXRQcm92aWRlci5nZXRBZGRyZXNzKCldLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYEJhbGFuY2Ugb2YgJHthcmdzLmNvbnRyYWN0QWRkcmVzc30gaXMgJHtiYWxhbmNlfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGdldHRpbmcgYmFsYW5jZTogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVycyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYW4gRVJDMjAgdG9rZW4gdG8gYSBkZXN0aW5hdGlvbiBvbmNoYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byB0cmFuc2ZlciB0aGUgYXNzZXQgZnJvbS5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIHRyYW5zZmVyIGRldGFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgdHJhbnNmZXIod2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB3YWxsZXRQcm92aWRlci5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHRvOiBhcmdzLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBkYXRhOiAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLmFiaSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcInRyYW5zZmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFthcmdzLmRlc3RpbmF0aW9uLCBCaWdJbnQoYXJncy5hbW91bnQpXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgd2FsbGV0UHJvdmlkZXIud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBgVHJhbnNmZXJyZWQgJHthcmdzLmFtb3VudH0gb2YgJHthcmdzLmNvbnRyYWN0QWRkcmVzc30gdG8gJHthcmdzLmRlc3RpbmF0aW9ufS5cXG5UcmFuc2FjdGlvbiBoYXNoIGZvciB0aGUgdHJhbnNmZXI6ICR7aGFzaH1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciB0cmFuc2ZlcnJpbmcgdGhlIGFzc2V0OiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVSQzIwQWN0aW9uUHJvdmlkZXIgPSBFUkMyMEFjdGlvblByb3ZpZGVyO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcImdldF9iYWxhbmNlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG4gICAgVGhpcyB0b29sIHdpbGwgZ2V0IHRoZSBiYWxhbmNlIG9mIGFuIEVSQzIwIGFzc2V0IGluIHRoZSB3YWxsZXQuIEl0IHRha2VzIHRoZSBjb250cmFjdCBhZGRyZXNzIGFzIGlucHV0LlxuICAgIGAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkdldEJhbGFuY2VTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3dhbGxldF9wcm92aWRlcnNfMS5Fdm1XYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBFUkMyMEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJnZXRCYWxhbmNlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcInRyYW5zZmVyXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG4gICAgVGhpcyB0b29sIHdpbGwgdHJhbnNmZXIgYW4gRVJDMjAgdG9rZW4gZnJvbSB0aGUgd2FsbGV0IHRvIGFub3RoZXIgb25jaGFpbiBhZGRyZXNzLlxuXG5JdCB0YWtlcyB0aGUgZm9sbG93aW5nIGlucHV0czpcbi0gYW1vdW50OiBUaGUgYW1vdW50IHRvIHRyYW5zZmVyXG4tIGNvbnRyYWN0QWRkcmVzczogVGhlIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIHRva2VuIHRvIHRyYW5zZmVyXG4tIGRlc3RpbmF0aW9uOiBXaGVyZSB0byBzZW5kIHRoZSBmdW5kcyAoY2FuIGJlIGFuIG9uY2hhaW4gYWRkcmVzcywgRU5TICdleGFtcGxlLmV0aCcsIG9yIEJhc2VuYW1lICdleGFtcGxlLmJhc2UuZXRoJylcblxuSW1wb3J0YW50IG5vdGVzOlxuLSBFbnN1cmUgc3VmZmljaWVudCBiYWxhbmNlIG9mIHRoZSBpbnB1dCBhc3NldCBiZWZvcmUgdHJhbnNmZXJyaW5nXG4tIFdoZW4gc2VuZGluZyBuYXRpdmUgYXNzZXRzIChlLmcuICdldGgnIG9uIGJhc2UtbWFpbm5ldCksIGVuc3VyZSB0aGVyZSBpcyBzdWZmaWNpZW50IGJhbGFuY2UgZm9yIHRoZSB0cmFuc2ZlciBpdHNlbGYgQU5EIHRoZSBnYXMgY29zdCBvZiB0aGlzIHRyYW5zZmVyXG4gICAgYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuVHJhbnNmZXJTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3dhbGxldF9wcm92aWRlcnNfMS5Fdm1XYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBFUkMyMEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJ0cmFuc2ZlclwiLCBudWxsKTtcbmNvbnN0IGVyYzIwQWN0aW9uUHJvdmlkZXIgPSAoKSA9PiBuZXcgRVJDMjBBY3Rpb25Qcm92aWRlcigpO1xuZXhwb3J0cy5lcmMyMEFjdGlvblByb3ZpZGVyID0gZXJjMjBBY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/erc20ActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc20/index.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./erc20ActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/erc20ActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmMyMC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMseUhBQXVCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2VyYzIwL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJjMjBBY3Rpb25Qcm92aWRlclwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/schemas.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc20/schemas.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GetBalanceSchema = exports.TransferSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\n/**\n * Input schema for transfer action.\n */\nexports.TransferSchema = zod_1.z\n    .object({\n    amount: zod_1.z.custom().describe(\"The amount of the asset to transfer\"),\n    contractAddress: zod_1.z.string().describe(\"The contract address of the token to transfer\"),\n    destination: zod_1.z.string().describe(\"The destination to transfer the funds\"),\n})\n    .strip()\n    .describe(\"Instructions for transferring assets\");\n/**\n * Input schema for get balance action.\n */\nexports.GetBalanceSchema = zod_1.z\n    .object({\n    contractAddress: zod_1.z\n        .string()\n        .describe(\"The contract address of the token to get the balance for\"),\n})\n    .strip()\n    .describe(\"Instructions for getting wallet balance\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmMyMC9zY2hlbWFzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLHNCQUFzQjtBQUNqRCxjQUFjLG1CQUFPLENBQUMsdURBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmMyMC9zY2hlbWFzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HZXRCYWxhbmNlU2NoZW1hID0gZXhwb3J0cy5UcmFuc2ZlclNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciB0cmFuc2ZlciBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuVHJhbnNmZXJTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgYW1vdW50OiB6b2RfMS56LmN1c3RvbSgpLmRlc2NyaWJlKFwiVGhlIGFtb3VudCBvZiB0aGUgYXNzZXQgdG8gdHJhbnNmZXJcIiksXG4gICAgY29udHJhY3RBZGRyZXNzOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIHRva2VuIHRvIHRyYW5zZmVyXCIpLFxuICAgIGRlc3RpbmF0aW9uOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGRlc3RpbmF0aW9uIHRvIHRyYW5zZmVyIHRoZSBmdW5kc1wiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnN0cnVjdGlvbnMgZm9yIHRyYW5zZmVycmluZyBhc3NldHNcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgZ2V0IGJhbGFuY2UgYWN0aW9uLlxuICovXG5leHBvcnRzLkdldEJhbGFuY2VTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgY29udHJhY3RBZGRyZXNzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgdG9rZW4gdG8gZ2V0IHRoZSBiYWxhbmNlIGZvclwiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnN0cnVjdGlvbnMgZm9yIGdldHRpbmcgd2FsbGV0IGJhbGFuY2VcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/schemas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/constants.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc721/constants.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ERC721_ABI = void 0;\nexports.ERC721_ABI = [\n    {\n        inputs: [\n            { internalType: \"address\", name: \"to\", type: \"address\" },\n            { internalType: \"uint256\", name: \"tokenId\", type: \"uint256\" },\n        ],\n        name: \"mint\",\n        outputs: [],\n        payable: false,\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"bytes4\",\n                name: \"interfaceId\",\n                type: \"bytes4\",\n            },\n        ],\n        name: \"supportsInterface\",\n        outputs: [\n            {\n                internalType: \"bool\",\n                name: \"\",\n                type: \"bool\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"from\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"to\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"Transfer\",\n        type: \"event\",\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"owner\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"approved\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"Approval\",\n        type: \"event\",\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"owner\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"operator\",\n                type: \"address\",\n            },\n            {\n                indexed: false,\n                internalType: \"bool\",\n                name: \"approved\",\n                type: \"bool\",\n            },\n        ],\n        name: \"ApprovalForAll\",\n        type: \"event\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"owner\",\n                type: \"address\",\n            },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n            {\n                internalType: \"uint256\",\n                name: \"balance\",\n                type: \"uint256\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"ownerOf\",\n        outputs: [\n            {\n                internalType: \"address\",\n                name: \"owner\",\n                type: \"address\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"from\",\n                type: \"address\",\n            },\n            {\n                internalType: \"address\",\n                name: \"to\",\n                type: \"address\",\n            },\n            {\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n            {\n                internalType: \"bytes\",\n                name: \"data\",\n                type: \"bytes\",\n            },\n        ],\n        name: \"safeTransferFrom\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"from\",\n                type: \"address\",\n            },\n            {\n                internalType: \"address\",\n                name: \"to\",\n                type: \"address\",\n            },\n            {\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"safeTransferFrom\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"from\",\n                type: \"address\",\n            },\n            {\n                internalType: \"address\",\n                name: \"to\",\n                type: \"address\",\n            },\n            {\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"transferFrom\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"to\",\n                type: \"address\",\n            },\n            {\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"approve\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"operator\",\n                type: \"address\",\n            },\n            {\n                internalType: \"bool\",\n                name: \"approved\",\n                type: \"bool\",\n            },\n        ],\n        name: \"setApprovalForAll\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"getApproved\",\n        outputs: [\n            {\n                internalType: \"address\",\n                name: \"operator\",\n                type: \"address\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"owner\",\n                type: \"address\",\n            },\n            {\n                internalType: \"address\",\n                name: \"operator\",\n                type: \"address\",\n            },\n        ],\n        name: \"isApprovedForAll\",\n        outputs: [\n            {\n                internalType: \"bool\",\n                name: \"\",\n                type: \"bool\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmM3MjEvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWMsc0RBQXNEO0FBQ3BFLGNBQWMsMkRBQTJEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvZXJjNzIxL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRVJDNzIxX0FCSSA9IHZvaWQgMDtcbmV4cG9ydHMuRVJDNzIxX0FCSSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInRvXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidG9rZW5JZFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcIm1pbnRcIixcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHBheWFibGU6IGZhbHNlLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczRcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcImludGVyZmFjZUlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJieXRlczRcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwic3VwcG9ydHNJbnRlcmZhY2VcIixcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZnJvbVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b2tlbklkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcIlRyYW5zZmVyXCIsXG4gICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwib3duZXJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiYXBwcm92ZWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidG9rZW5JZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJBcHByb3ZhbFwiLFxuICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFub255bW91czogZmFsc2UsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm93bmVyXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm9wZXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJhcHByb3ZlZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJBcHByb3ZhbEZvckFsbFwiLFxuICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJiYWxhbmNlT2ZcIixcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJiYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b2tlbklkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcIm93bmVyT2ZcIixcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZnJvbVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidG9cIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRva2VuSWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJkYXRhXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJieXRlc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJzYWZlVHJhbnNmZXJGcm9tXCIsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJmcm9tXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidG9rZW5JZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJzYWZlVHJhbnNmZXJGcm9tXCIsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJmcm9tXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidG9rZW5JZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJ0cmFuc2ZlckZyb21cIixcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRvXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b2tlbklkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcImFwcHJvdmVcIixcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm9wZXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJhcHByb3ZlZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJzZXRBcHByb3ZhbEZvckFsbFwiLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidG9rZW5JZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJnZXRBcHByb3ZlZFwiLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm9wZXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwib3BlcmF0b3JcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiaXNBcHByb3ZlZEZvckFsbFwiLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG5dO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/erc721ActionProvider.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc721/erc721ActionProvider.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.erc721ActionProvider = exports.Erc721ActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/schemas.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/constants.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_cjs/index.js\");\n/**\n * Erc721ActionProvider is an action provider for Erc721 contract interactions.\n */\nclass Erc721ActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the Erc721ActionProvider class.\n     */\n    constructor() {\n        super(\"erc721\", []);\n        /**\n         * Checks if the Erc721 action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Erc721 action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.protocolFamily === \"evm\";\n    }\n    /**\n     * Mints an NFT (ERC-721) to a specified destination address onchain.\n     *\n     * @param walletProvider - The wallet provider to mint the NFT from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the NFT mint details.\n     */\n    async mint(walletProvider, args) {\n        try {\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.ERC721_ABI,\n                functionName: \"mint\",\n                args: [args.destination, 1n],\n            });\n            const hash = await walletProvider.sendTransaction({\n                to: args.contractAddress,\n                data,\n            });\n            await walletProvider.waitForTransactionReceipt(hash);\n            return `Successfully minted NFT ${args.contractAddress} to ${args.destination}`;\n        }\n        catch (error) {\n            return `Error minting NFT ${args.contractAddress} to ${args.destination}: ${error}`;\n        }\n    }\n    /**\n     * Transfers an NFT (ERC721 token) to a destination address.\n     *\n     * @param walletProvider - The wallet provider to transfer the NFT from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the transfer details.\n     */\n    async transfer(walletProvider, args) {\n        try {\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.ERC721_ABI,\n                functionName: \"transferFrom\",\n                args: [args.fromAddress, args.destination, BigInt(args.tokenId)],\n            });\n            const hash = await walletProvider.sendTransaction({\n                to: args.contractAddress,\n                data,\n            });\n            await walletProvider.waitForTransactionReceipt(hash);\n            return `Successfully transferred NFT ${args.contractAddress} with tokenId ${args.tokenId} to ${args.destination}`;\n        }\n        catch (error) {\n            return `Error transferring NFT ${args.contractAddress} with tokenId ${args.tokenId} to ${args.destination}: ${error}`;\n        }\n    }\n    /**\n     * Gets the NFT balance for a given address and contract.\n     *\n     * @param walletProvider - The wallet provider to check the balance with.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the NFT balance details.\n     */\n    async getBalance(walletProvider, args) {\n        try {\n            const address = args.address || walletProvider.getAddress();\n            const balance = await walletProvider.readContract({\n                address: args.contractAddress,\n                abi: constants_1.ERC721_ABI,\n                functionName: \"balanceOf\",\n                args: [address],\n            });\n            return `Balance of NFTs for contract ${args.contractAddress} at address ${address} is ${balance}`;\n        }\n        catch (error) {\n            return `Error getting NFT balance for contract ${args.contractAddress}: ${error}`;\n        }\n    }\n}\nexports.Erc721ActionProvider = Erc721ActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"mint\",\n        description: `\nThis tool will mint an NFT (ERC-721) to a specified destination address onchain via a contract invocation. \nIt takes the contract address of the NFT onchain and the destination address onchain that will receive the NFT as inputs. \nDo not use the contract address as the destination address. If you are unsure of the destination address, please ask the user before proceeding.\n`,\n        schema: schemas_1.MintSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], Erc721ActionProvider.prototype, \"mint\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"transfer\",\n        description: `\nThis tool will transfer an NFT (ERC721 token) from the wallet to another onchain address.\n\nIt takes the following inputs:\n- contractAddress: The NFT contract address\n- tokenId: The ID of the specific NFT to transfer\n- destination: Onchain address to send the NFT\n\nImportant notes:\n- Ensure you have ownership of the NFT before attempting transfer\n- Ensure there is sufficient native token balance for gas fees\n- The wallet must either own the NFT or have approval to transfer it\n`,\n        schema: schemas_1.TransferSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], Erc721ActionProvider.prototype, \"transfer\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_balance\",\n        description: `\nThis tool will check the NFT (ERC721 token) balance for a given address.\n\nIt takes the following inputs:\n- contractAddress: The NFT contract address to check balance for\n- address: (Optional) The address to check NFT balance for. If not provided, uses the wallet's address\n`,\n        schema: schemas_1.GetBalanceSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], Erc721ActionProvider.prototype, \"getBalance\", null);\nconst erc721ActionProvider = () => new Erc721ActionProvider();\nexports.erc721ActionProvider = erc721ActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmM3MjEvZXJjNzIxQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDRCQUE0QjtBQUMzRCxjQUFjLG1CQUFPLENBQUMsdURBQUs7QUFDM0IseUJBQXlCLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3BELDJCQUEyQixtQkFBTyxDQUFDLHNHQUF3QjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsa0dBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsc0dBQWE7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw4Q0FBOEMsc0JBQXNCLEtBQUssaUJBQWlCO0FBQzFGO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCLEtBQUssaUJBQWlCLElBQUksTUFBTTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbURBQW1ELHNCQUFzQixlQUFlLGNBQWMsS0FBSyxpQkFBaUI7QUFDNUg7QUFDQTtBQUNBLDZDQUE2QyxzQkFBc0IsZUFBZSxjQUFjLEtBQUssaUJBQWlCLElBQUksTUFBTTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG1EQUFtRCxzQkFBc0IsYUFBYSxTQUFTLEtBQUssUUFBUTtBQUM1RztBQUNBO0FBQ0EsNkRBQTZELHFCQUFxQixJQUFJLE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvZXJjNzIxL2VyYzcyMUFjdGlvblByb3ZpZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXJjNzIxQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLkVyYzcyMUFjdGlvblByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgYWN0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25Qcm92aWRlclwiKTtcbmNvbnN0IHdhbGxldF9wcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi93YWxsZXQtcHJvdmlkZXJzXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdmllbV8xID0gcmVxdWlyZShcInZpZW1cIik7XG4vKipcbiAqIEVyYzcyMUFjdGlvblByb3ZpZGVyIGlzIGFuIGFjdGlvbiBwcm92aWRlciBmb3IgRXJjNzIxIGNvbnRyYWN0IGludGVyYWN0aW9ucy5cbiAqL1xuY2xhc3MgRXJjNzIxQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIEVyYzcyMUFjdGlvblByb3ZpZGVyIGNsYXNzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImVyYzcyMVwiLCBbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIEVyYzcyMSBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuZXR3b3JrIC0gVGhlIG5ldHdvcmsgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIEVyYzcyMSBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIG5ldHdvcmssIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcG9ydHNOZXR3b3JrID0gKG5ldHdvcmspID0+IG5ldHdvcmsucHJvdG9jb2xGYW1pbHkgPT09IFwiZXZtXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1pbnRzIGFuIE5GVCAoRVJDLTcyMSkgdG8gYSBzcGVjaWZpZWQgZGVzdGluYXRpb24gYWRkcmVzcyBvbmNoYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byBtaW50IHRoZSBORlQgZnJvbS5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIE5GVCBtaW50IGRldGFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgbWludCh3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgwLCB2aWVtXzEuZW5jb2RlRnVuY3Rpb25EYXRhKSh7XG4gICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5FUkM3MjFfQUJJLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJtaW50XCIsXG4gICAgICAgICAgICAgICAgYXJnczogW2FyZ3MuZGVzdGluYXRpb24sIDFuXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdG86IGFyZ3MuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHdhbGxldFByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSBtaW50ZWQgTkZUICR7YXJncy5jb250cmFjdEFkZHJlc3N9IHRvICR7YXJncy5kZXN0aW5hdGlvbn1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBtaW50aW5nIE5GVCAke2FyZ3MuY29udHJhY3RBZGRyZXNzfSB0byAke2FyZ3MuZGVzdGluYXRpb259OiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmZXJzIGFuIE5GVCAoRVJDNzIxIHRva2VuKSB0byBhIGRlc3RpbmF0aW9uIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0UHJvdmlkZXIgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIHRvIHRyYW5zZmVyIHRoZSBORlQgZnJvbS5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIHRyYW5zZmVyIGRldGFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgdHJhbnNmZXIod2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuRVJDNzIxX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwidHJhbnNmZXJGcm9tXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW2FyZ3MuZnJvbUFkZHJlc3MsIGFyZ3MuZGVzdGluYXRpb24sIEJpZ0ludChhcmdzLnRva2VuSWQpXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdG86IGFyZ3MuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHdhbGxldFByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSB0cmFuc2ZlcnJlZCBORlQgJHthcmdzLmNvbnRyYWN0QWRkcmVzc30gd2l0aCB0b2tlbklkICR7YXJncy50b2tlbklkfSB0byAke2FyZ3MuZGVzdGluYXRpb259YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgdHJhbnNmZXJyaW5nIE5GVCAke2FyZ3MuY29udHJhY3RBZGRyZXNzfSB3aXRoIHRva2VuSWQgJHthcmdzLnRva2VuSWR9IHRvICR7YXJncy5kZXN0aW5hdGlvbn06ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBORlQgYmFsYW5jZSBmb3IgYSBnaXZlbiBhZGRyZXNzIGFuZCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gY2hlY2sgdGhlIGJhbGFuY2Ugd2l0aC5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIE5GVCBiYWxhbmNlIGRldGFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmFsYW5jZSh3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGFyZ3MuYWRkcmVzcyB8fCB3YWxsZXRQcm92aWRlci5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgd2FsbGV0UHJvdmlkZXIucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhcmdzLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLkVSQzcyMV9BQkksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImJhbGFuY2VPZlwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZGRyZXNzXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGBCYWxhbmNlIG9mIE5GVHMgZm9yIGNvbnRyYWN0ICR7YXJncy5jb250cmFjdEFkZHJlc3N9IGF0IGFkZHJlc3MgJHthZGRyZXNzfSBpcyAke2JhbGFuY2V9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZ2V0dGluZyBORlQgYmFsYW5jZSBmb3IgY29udHJhY3QgJHthcmdzLmNvbnRyYWN0QWRkcmVzc306ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRXJjNzIxQWN0aW9uUHJvdmlkZXIgPSBFcmM3MjFBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJtaW50XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgd2lsbCBtaW50IGFuIE5GVCAoRVJDLTcyMSkgdG8gYSBzcGVjaWZpZWQgZGVzdGluYXRpb24gYWRkcmVzcyBvbmNoYWluIHZpYSBhIGNvbnRyYWN0IGludm9jYXRpb24uIFxuSXQgdGFrZXMgdGhlIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIE5GVCBvbmNoYWluIGFuZCB0aGUgZGVzdGluYXRpb24gYWRkcmVzcyBvbmNoYWluIHRoYXQgd2lsbCByZWNlaXZlIHRoZSBORlQgYXMgaW5wdXRzLiBcbkRvIG5vdCB1c2UgdGhlIGNvbnRyYWN0IGFkZHJlc3MgYXMgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3MuIElmIHlvdSBhcmUgdW5zdXJlIG9mIHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzLCBwbGVhc2UgYXNrIHRoZSB1c2VyIGJlZm9yZSBwcm9jZWVkaW5nLlxuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuTWludFNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEVyYzcyMUFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJtaW50XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcInRyYW5zZmVyXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgd2lsbCB0cmFuc2ZlciBhbiBORlQgKEVSQzcyMSB0b2tlbikgZnJvbSB0aGUgd2FsbGV0IHRvIGFub3RoZXIgb25jaGFpbiBhZGRyZXNzLlxuXG5JdCB0YWtlcyB0aGUgZm9sbG93aW5nIGlucHV0czpcbi0gY29udHJhY3RBZGRyZXNzOiBUaGUgTkZUIGNvbnRyYWN0IGFkZHJlc3Ncbi0gdG9rZW5JZDogVGhlIElEIG9mIHRoZSBzcGVjaWZpYyBORlQgdG8gdHJhbnNmZXJcbi0gZGVzdGluYXRpb246IE9uY2hhaW4gYWRkcmVzcyB0byBzZW5kIHRoZSBORlRcblxuSW1wb3J0YW50IG5vdGVzOlxuLSBFbnN1cmUgeW91IGhhdmUgb3duZXJzaGlwIG9mIHRoZSBORlQgYmVmb3JlIGF0dGVtcHRpbmcgdHJhbnNmZXJcbi0gRW5zdXJlIHRoZXJlIGlzIHN1ZmZpY2llbnQgbmF0aXZlIHRva2VuIGJhbGFuY2UgZm9yIGdhcyBmZWVzXG4tIFRoZSB3YWxsZXQgbXVzdCBlaXRoZXIgb3duIHRoZSBORlQgb3IgaGF2ZSBhcHByb3ZhbCB0byB0cmFuc2ZlciBpdFxuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuVHJhbnNmZXJTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3dhbGxldF9wcm92aWRlcnNfMS5Fdm1XYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBFcmM3MjFBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwidHJhbnNmZXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiZ2V0X2JhbGFuY2VcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCB3aWxsIGNoZWNrIHRoZSBORlQgKEVSQzcyMSB0b2tlbikgYmFsYW5jZSBmb3IgYSBnaXZlbiBhZGRyZXNzLlxuXG5JdCB0YWtlcyB0aGUgZm9sbG93aW5nIGlucHV0czpcbi0gY29udHJhY3RBZGRyZXNzOiBUaGUgTkZUIGNvbnRyYWN0IGFkZHJlc3MgdG8gY2hlY2sgYmFsYW5jZSBmb3Jcbi0gYWRkcmVzczogKE9wdGlvbmFsKSBUaGUgYWRkcmVzcyB0byBjaGVjayBORlQgYmFsYW5jZSBmb3IuIElmIG5vdCBwcm92aWRlZCwgdXNlcyB0aGUgd2FsbGV0J3MgYWRkcmVzc1xuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuR2V0QmFsYW5jZVNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEVyYzcyMUFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJnZXRCYWxhbmNlXCIsIG51bGwpO1xuY29uc3QgZXJjNzIxQWN0aW9uUHJvdmlkZXIgPSAoKSA9PiBuZXcgRXJjNzIxQWN0aW9uUHJvdmlkZXIoKTtcbmV4cG9ydHMuZXJjNzIxQWN0aW9uUHJvdmlkZXIgPSBlcmM3MjFBY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/erc721ActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc721/index.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./erc721ActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/erc721ActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmM3MjEvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDRIQUF3QiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmM3MjEvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcmM3MjFBY3Rpb25Qcm92aWRlclwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/schemas.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc721/schemas.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TransferSchema = exports.MintSchema = exports.GetBalanceSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\n/**\n * Input schema for get NFT (ERC721) balance action.\n */\nexports.GetBalanceSchema = zod_1.z\n    .object({\n    contractAddress: zod_1.z.string().describe(\"The NFT contract address to check balance for\"),\n    address: zod_1.z\n        .string()\n        .optional()\n        .describe(\"The address to check NFT balance for. If not provided, uses the wallet's default address\"),\n})\n    .strip()\n    .describe(\"Instructions for getting NFT balance\");\n/**\n * Input schema for mint NFT (ERC721) action.\n */\nexports.MintSchema = zod_1.z\n    .object({\n    contractAddress: zod_1.z.string().describe(\"The contract address of the NFT to mint\"),\n    destination: zod_1.z.string().describe(\"The onchain destination address that will receive the NFT\"),\n})\n    .strip()\n    .describe(\"Instructions for minting an NFT\");\n/**\n * Input schema for NFT (ERC721) transfer action.\n */\nexports.TransferSchema = zod_1.z\n    .object({\n    contractAddress: zod_1.z.string().describe(\"The NFT contract address to interact with\"),\n    tokenId: zod_1.z.string().describe(\"The ID of the NFT to transfer\"),\n    destination: zod_1.z\n        .string()\n        .describe(\"The destination to transfer the NFT, e.g. `0x58dBecc0894Ab4C24F98a0e684c989eD07e4e027`, `example.eth`, `example.base.eth`\"),\n    fromAddress: zod_1.z\n        .string()\n        .optional()\n        .describe(\"The address to transfer from. If not provided, defaults to the wallet's default address\"),\n})\n    .strip()\n    .describe(\"Input schema for transferring an NFT\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmM3MjEvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxrQkFBa0IsR0FBRyx3QkFBd0I7QUFDdEUsY0FBYyxtQkFBTyxDQUFDLHVEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2VyYzcyMS9zY2hlbWFzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFuc2ZlclNjaGVtYSA9IGV4cG9ydHMuTWludFNjaGVtYSA9IGV4cG9ydHMuR2V0QmFsYW5jZVNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBnZXQgTkZUIChFUkM3MjEpIGJhbGFuY2UgYWN0aW9uLlxuICovXG5leHBvcnRzLkdldEJhbGFuY2VTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgY29udHJhY3RBZGRyZXNzOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIE5GVCBjb250cmFjdCBhZGRyZXNzIHRvIGNoZWNrIGJhbGFuY2UgZm9yXCIpLFxuICAgIGFkZHJlc3M6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5vcHRpb25hbCgpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBhZGRyZXNzIHRvIGNoZWNrIE5GVCBiYWxhbmNlIGZvci4gSWYgbm90IHByb3ZpZGVkLCB1c2VzIHRoZSB3YWxsZXQncyBkZWZhdWx0IGFkZHJlc3NcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5zdHJ1Y3Rpb25zIGZvciBnZXR0aW5nIE5GVCBiYWxhbmNlXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIG1pbnQgTkZUIChFUkM3MjEpIGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5NaW50U2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGNvbnRyYWN0QWRkcmVzczogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSBORlQgdG8gbWludFwiKSxcbiAgICBkZXN0aW5hdGlvbjogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBvbmNoYWluIGRlc3RpbmF0aW9uIGFkZHJlc3MgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIE5GVFwiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnN0cnVjdGlvbnMgZm9yIG1pbnRpbmcgYW4gTkZUXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIE5GVCAoRVJDNzIxKSB0cmFuc2ZlciBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuVHJhbnNmZXJTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgY29udHJhY3RBZGRyZXNzOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIE5GVCBjb250cmFjdCBhZGRyZXNzIHRvIGludGVyYWN0IHdpdGhcIiksXG4gICAgdG9rZW5JZDogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBJRCBvZiB0aGUgTkZUIHRvIHRyYW5zZmVyXCIpLFxuICAgIGRlc3RpbmF0aW9uOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgZGVzdGluYXRpb24gdG8gdHJhbnNmZXIgdGhlIE5GVCwgZS5nLiBgMHg1OGRCZWNjMDg5NEFiNEMyNEY5OGEwZTY4NGM5ODllRDA3ZTRlMDI3YCwgYGV4YW1wbGUuZXRoYCwgYGV4YW1wbGUuYmFzZS5ldGhgXCIpLFxuICAgIGZyb21BZGRyZXNzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgYWRkcmVzcyB0byB0cmFuc2ZlciBmcm9tLiBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIHRoZSB3YWxsZXQncyBkZWZhdWx0IGFkZHJlc3NcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciB0cmFuc2ZlcnJpbmcgYW4gTkZUXCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/schemas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/farcasterActionProvider.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/farcasterActionProvider.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.farcasterActionProvider = exports.FarcasterActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/schemas.js\");\n/**\n * FarcasterActionProvider is an action provider for Farcaster.\n */\nclass FarcasterActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the FarcasterActionProvider class.\n     *\n     * @param config - The configuration options for the FarcasterActionProvider.\n     */\n    constructor(config = {}) {\n        super(\"farcaster\", []);\n        /**\n         * Checks if the Farcaster action provider supports the given network.\n         *\n         * @param _ - The network to check.\n         * @returns True if the Farcaster action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (_) => true;\n        const neynarApiKey = config.neynarApiKey || process.env.NEYNAR_API_KEY;\n        const signerUuid = config.signerUuid || process.env.NEYNAR_MANAGER_SIGNER;\n        const agentFid = config.agentFid || process.env.AGENT_FID;\n        if (!neynarApiKey) {\n            throw new Error(\"NEYNAR_API_KEY is not configured.\");\n        }\n        if (!signerUuid) {\n            throw new Error(\"NEYNAR_MANAGER_SIGNER is not configured.\");\n        }\n        if (!agentFid) {\n            throw new Error(\"AGENT_FID is not configured.\");\n        }\n        this.neynarApiKey = neynarApiKey;\n        this.signerUuid = signerUuid;\n        this.agentFid = agentFid;\n    }\n    /**\n     * Retrieves agent's Farcaster account details.\n     *\n     * @param _ - The input arguments for the action.\n     * @returns A message containing account details for the agent's Farcaster account.\n     */\n    async accountDetails(_) {\n        try {\n            const headers = {\n                accept: \"application/json\",\n                \"x-api-key\": this.neynarApiKey,\n                \"x-neynar-experimental\": \"true\",\n            };\n            const response = await fetch(`https://api.neynar.com/v2/farcaster/user/bulk?fids=${this.agentFid}`, {\n                method: \"GET\",\n                headers,\n            });\n            const { users } = await response.json();\n            return `Successfully retrieved Farcaster account details:\\n${JSON.stringify(users[0])}`;\n        }\n        catch (error) {\n            return `Error retrieving Farcaster account details:\\n${error}`;\n        }\n    }\n    /**\n     * Posts a cast on Farcaster.\n     *\n     * @param args - The input arguments for the action.\n     * @returns A message indicating the success or failure of the cast posting.\n     */\n    async postCast(args) {\n        try {\n            const headers = {\n                api_key: this.neynarApiKey,\n                \"Content-Type\": \"application/json\",\n            };\n            const response = await fetch(\"https://api.neynar.com/v2/farcaster/cast\", {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify({\n                    signer_uuid: this.signerUuid,\n                    text: args.castText,\n                }),\n            });\n            const data = await response.json();\n            return `Successfully posted cast to Farcaster:\\n${JSON.stringify(data)}`;\n        }\n        catch (error) {\n            return `Error posting to Farcaster:\\n${error}`;\n        }\n    }\n}\nexports.FarcasterActionProvider = FarcasterActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"account_details\",\n        description: `\nThis tool will retrieve the account details for the agent's Farcaster account.\nThe tool takes the FID of the agent's account.\n\nA successful response will return a message with the API response as a JSON payload:\n    { \"object\": \"user\", \"fid\": 193,\" username\": \"derek\", \"display_name\": \"Derek\", ... }\n\nA failure response will return a message with the Farcaster API request error:\n    Unable to retrieve account details.\n`,\n        schema: schemas_1.FarcasterAccountDetailsSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], FarcasterActionProvider.prototype, \"accountDetails\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"post_cast\",\n        description: `\nThis tool will post a cast to Farcaster. The tool takes the text of the cast as input. Casts can be maximum 280 characters.\n\nA successful response will return a message with the API response as a JSON payload:\n    {}\n\nA failure response will return a message with the Farcaster API request error:\n    You are not allowed to post a cast with duplicate content.\n`,\n        schema: schemas_1.FarcasterPostCastSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], FarcasterActionProvider.prototype, \"postCast\", null);\nconst farcasterActionProvider = (config = {}) => new FarcasterActionProvider(config);\nexports.farcasterActionProvider = farcasterActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mYXJjYXN0ZXIvZmFyY2FzdGVyQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQixHQUFHLCtCQUErQjtBQUNqRSxjQUFjLG1CQUFPLENBQUMsdURBQUs7QUFDM0IseUJBQXlCLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3BELDBCQUEwQixtQkFBTyxDQUFDLDRHQUFvQjtBQUN0RCxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsY0FBYztBQUM3RztBQUNBO0FBQ0EsYUFBYTtBQUNiLG9CQUFvQixRQUFRO0FBQzVCLHlFQUF5RSx5QkFBeUI7QUFDbEc7QUFDQTtBQUNBLG1FQUFtRSxNQUFNO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsOERBQThELHFCQUFxQjtBQUNuRjtBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsK0JBQStCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2ZhcmNhc3Rlci9mYXJjYXN0ZXJBY3Rpb25Qcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZhcmNhc3RlckFjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5GYXJjYXN0ZXJBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCBhY3Rpb25EZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25EZWNvcmF0b3JcIik7XG5jb25zdCBzY2hlbWFzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFzXCIpO1xuLyoqXG4gKiBGYXJjYXN0ZXJBY3Rpb25Qcm92aWRlciBpcyBhbiBhY3Rpb24gcHJvdmlkZXIgZm9yIEZhcmNhc3Rlci5cbiAqL1xuY2xhc3MgRmFyY2FzdGVyQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIEZhcmNhc3RlckFjdGlvblByb3ZpZGVyIGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBGYXJjYXN0ZXJBY3Rpb25Qcm92aWRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcihcImZhcmNhc3RlclwiLCBbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIEZhcmNhc3RlciBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBfIC0gVGhlIG5ldHdvcmsgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIEZhcmNhc3RlciBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIG5ldHdvcmssIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcG9ydHNOZXR3b3JrID0gKF8pID0+IHRydWU7XG4gICAgICAgIGNvbnN0IG5leW5hckFwaUtleSA9IGNvbmZpZy5uZXluYXJBcGlLZXkgfHwgcHJvY2Vzcy5lbnYuTkVZTkFSX0FQSV9LRVk7XG4gICAgICAgIGNvbnN0IHNpZ25lclV1aWQgPSBjb25maWcuc2lnbmVyVXVpZCB8fCBwcm9jZXNzLmVudi5ORVlOQVJfTUFOQUdFUl9TSUdORVI7XG4gICAgICAgIGNvbnN0IGFnZW50RmlkID0gY29uZmlnLmFnZW50RmlkIHx8IHByb2Nlc3MuZW52LkFHRU5UX0ZJRDtcbiAgICAgICAgaWYgKCFuZXluYXJBcGlLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5FWU5BUl9BUElfS0VZIGlzIG5vdCBjb25maWd1cmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNpZ25lclV1aWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5FWU5BUl9NQU5BR0VSX1NJR05FUiBpcyBub3QgY29uZmlndXJlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhZ2VudEZpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUdFTlRfRklEIGlzIG5vdCBjb25maWd1cmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leW5hckFwaUtleSA9IG5leW5hckFwaUtleTtcbiAgICAgICAgdGhpcy5zaWduZXJVdWlkID0gc2lnbmVyVXVpZDtcbiAgICAgICAgdGhpcy5hZ2VudEZpZCA9IGFnZW50RmlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWdlbnQncyBGYXJjYXN0ZXIgYWNjb3VudCBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIF8gLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgbWVzc2FnZSBjb250YWluaW5nIGFjY291bnQgZGV0YWlscyBmb3IgdGhlIGFnZW50J3MgRmFyY2FzdGVyIGFjY291bnQuXG4gICAgICovXG4gICAgYXN5bmMgYWNjb3VudERldGFpbHMoXykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIFwieC1hcGkta2V5XCI6IHRoaXMubmV5bmFyQXBpS2V5LFxuICAgICAgICAgICAgICAgIFwieC1uZXluYXItZXhwZXJpbWVudGFsXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLm5leW5hci5jb20vdjIvZmFyY2FzdGVyL3VzZXIvYnVsaz9maWRzPSR7dGhpcy5hZ2VudEZpZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlcnMgfSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIHJldHVybiBgU3VjY2Vzc2Z1bGx5IHJldHJpZXZlZCBGYXJjYXN0ZXIgYWNjb3VudCBkZXRhaWxzOlxcbiR7SlNPTi5zdHJpbmdpZnkodXNlcnNbMF0pfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIHJldHJpZXZpbmcgRmFyY2FzdGVyIGFjY291bnQgZGV0YWlsczpcXG4ke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9zdHMgYSBjYXN0IG9uIEZhcmNhc3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGlucHV0IGFyZ3VtZW50cyBmb3IgdGhlIGFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIG1lc3NhZ2UgaW5kaWNhdGluZyB0aGUgc3VjY2VzcyBvciBmYWlsdXJlIG9mIHRoZSBjYXN0IHBvc3RpbmcuXG4gICAgICovXG4gICAgYXN5bmMgcG9zdENhc3QoYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICBhcGlfa2V5OiB0aGlzLm5leW5hckFwaUtleSxcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9hcGkubmV5bmFyLmNvbS92Mi9mYXJjYXN0ZXIvY2FzdFwiLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVyX3V1aWQ6IHRoaXMuc2lnbmVyVXVpZCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogYXJncy5jYXN0VGV4dCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIHJldHVybiBgU3VjY2Vzc2Z1bGx5IHBvc3RlZCBjYXN0IHRvIEZhcmNhc3RlcjpcXG4ke0pTT04uc3RyaW5naWZ5KGRhdGEpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIHBvc3RpbmcgdG8gRmFyY2FzdGVyOlxcbiR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRmFyY2FzdGVyQWN0aW9uUHJvdmlkZXIgPSBGYXJjYXN0ZXJBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJhY2NvdW50X2RldGFpbHNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCB3aWxsIHJldHJpZXZlIHRoZSBhY2NvdW50IGRldGFpbHMgZm9yIHRoZSBhZ2VudCdzIEZhcmNhc3RlciBhY2NvdW50LlxuVGhlIHRvb2wgdGFrZXMgdGhlIEZJRCBvZiB0aGUgYWdlbnQncyBhY2NvdW50LlxuXG5BIHN1Y2Nlc3NmdWwgcmVzcG9uc2Ugd2lsbCByZXR1cm4gYSBtZXNzYWdlIHdpdGggdGhlIEFQSSByZXNwb25zZSBhcyBhIEpTT04gcGF5bG9hZDpcbiAgICB7IFwib2JqZWN0XCI6IFwidXNlclwiLCBcImZpZFwiOiAxOTMsXCIgdXNlcm5hbWVcIjogXCJkZXJla1wiLCBcImRpc3BsYXlfbmFtZVwiOiBcIkRlcmVrXCIsIC4uLiB9XG5cbkEgZmFpbHVyZSByZXNwb25zZSB3aWxsIHJldHVybiBhIG1lc3NhZ2Ugd2l0aCB0aGUgRmFyY2FzdGVyIEFQSSByZXF1ZXN0IGVycm9yOlxuICAgIFVuYWJsZSB0byByZXRyaWV2ZSBhY2NvdW50IGRldGFpbHMuXG5gLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5GYXJjYXN0ZXJBY2NvdW50RGV0YWlsc1NjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBGYXJjYXN0ZXJBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiYWNjb3VudERldGFpbHNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwicG9zdF9jYXN0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgd2lsbCBwb3N0IGEgY2FzdCB0byBGYXJjYXN0ZXIuIFRoZSB0b29sIHRha2VzIHRoZSB0ZXh0IG9mIHRoZSBjYXN0IGFzIGlucHV0LiBDYXN0cyBjYW4gYmUgbWF4aW11bSAyODAgY2hhcmFjdGVycy5cblxuQSBzdWNjZXNzZnVsIHJlc3BvbnNlIHdpbGwgcmV0dXJuIGEgbWVzc2FnZSB3aXRoIHRoZSBBUEkgcmVzcG9uc2UgYXMgYSBKU09OIHBheWxvYWQ6XG4gICAge31cblxuQSBmYWlsdXJlIHJlc3BvbnNlIHdpbGwgcmV0dXJuIGEgbWVzc2FnZSB3aXRoIHRoZSBGYXJjYXN0ZXIgQVBJIHJlcXVlc3QgZXJyb3I6XG4gICAgWW91IGFyZSBub3QgYWxsb3dlZCB0byBwb3N0IGEgY2FzdCB3aXRoIGR1cGxpY2F0ZSBjb250ZW50LlxuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuRmFyY2FzdGVyUG9zdENhc3RTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3ZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgRmFyY2FzdGVyQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcInBvc3RDYXN0XCIsIG51bGwpO1xuY29uc3QgZmFyY2FzdGVyQWN0aW9uUHJvdmlkZXIgPSAoY29uZmlnID0ge30pID0+IG5ldyBGYXJjYXN0ZXJBY3Rpb25Qcm92aWRlcihjb25maWcpO1xuZXhwb3J0cy5mYXJjYXN0ZXJBY3Rpb25Qcm92aWRlciA9IGZhcmNhc3RlckFjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/farcasterActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/index.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/schemas.js\"), exports);\n__exportStar(__webpack_require__(/*! ./farcasterActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/farcasterActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mYXJjYXN0ZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLHFHQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxxSUFBMkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvZmFyY2FzdGVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NoZW1hc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmFyY2FzdGVyQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/schemas.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/schemas.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FarcasterPostCastSchema = exports.FarcasterAccountDetailsSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\n/**\n * Input argument schema for the account_details action.\n */\nexports.FarcasterAccountDetailsSchema = zod_1.z\n    .object({})\n    .strip()\n    .describe(\"Input schema for retrieving account details\");\n/**\n * Input argument schema for the post cast action.\n */\nexports.FarcasterPostCastSchema = zod_1.z\n    .object({\n    castText: zod_1.z.string().max(280, \"Cast text must be a maximum of 280 characters.\"),\n})\n    .strip()\n    .describe(\"Input schema for posting a text-based cast\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mYXJjYXN0ZXIvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0IsR0FBRyxxQ0FBcUM7QUFDdkUsY0FBYyxtQkFBTyxDQUFDLHVEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvZmFyY2FzdGVyL3NjaGVtYXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZhcmNhc3RlclBvc3RDYXN0U2NoZW1hID0gZXhwb3J0cy5GYXJjYXN0ZXJBY2NvdW50RGV0YWlsc1NjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbi8qKlxuICogSW5wdXQgYXJndW1lbnQgc2NoZW1hIGZvciB0aGUgYWNjb3VudF9kZXRhaWxzIGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5GYXJjYXN0ZXJBY2NvdW50RGV0YWlsc1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHt9KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciByZXRyaWV2aW5nIGFjY291bnQgZGV0YWlsc1wiKTtcbi8qKlxuICogSW5wdXQgYXJndW1lbnQgc2NoZW1hIGZvciB0aGUgcG9zdCBjYXN0IGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5GYXJjYXN0ZXJQb3N0Q2FzdFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBjYXN0VGV4dDogem9kXzEuei5zdHJpbmcoKS5tYXgoMjgwLCBcIkNhc3QgdGV4dCBtdXN0IGJlIGEgbWF4aW11bSBvZiAyODAgY2hhcmFjdGVycy5cIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciBwb3N0aW5nIGEgdGV4dC1iYXNlZCBjYXN0XCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/schemas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./pyth */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./cdp */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./weth */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./erc20 */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./erc721 */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./morpho */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./basename */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./farcaster */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./twitter */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wallet */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./customActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/customActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./alchemy */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./moonwell */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/index.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsMkdBQW1CO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyx5R0FBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLDJGQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyx5RkFBTztBQUM1QixhQUFhLG1CQUFPLENBQUMsMkZBQVE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLDZGQUFTO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQywrRkFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsK0ZBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLG1HQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxxR0FBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsaUdBQVc7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLCtGQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxxSEFBd0I7QUFDN0MsYUFBYSxtQkFBTyxDQUFDLGlHQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxtR0FBWSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FjdGlvbkRlY29yYXRvclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3B5dGhcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NkcFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd2V0aFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJjMjBcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VyYzcyMVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9ycGhvXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlbmFtZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmFyY2FzdGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90d2l0dGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93YWxsZXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2N1c3RvbUFjdGlvblByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hbGNoZW15XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb29ud2VsbFwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/constants.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/constants.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MTOKEN_ABI = exports.ETH_ROUTER_ABI = exports.MTOKENS_UNDERLYING_DECIMALS = exports.TOKEN_DECIMALS = exports.WETH_ROUTER_ADDRESS = exports.MOONWELL_BASE_SEPOLIA_ADDRESSES = exports.MOONWELL_BASE_ADDRESSES = void 0;\nexports.MOONWELL_BASE_ADDRESSES = {\n    \"0xEdc817A28E8B93B03976FBd4a3dDBc9f7D176c22\": \"MOONWELL_USDC\",\n    \"0x73b06D8d18De422E269645eaCe15400DE7462417\": \"MOONWELL_DAI\",\n    \"0x628ff693426583D9a7FB391E54366292F509D457\": \"MOONWELL_WETH\",\n    \"0x3bf93770f2d4a794c3d9EBEfBAeBAE2a8f09A5E5\": \"MOONWELL_cbETH\",\n    \"0x627Fe393Bc6EdDA28e99AE648fD6fF362514304b\": \"MOONWELL_wstETH\",\n    \"0x73902f619CEB9B31FD8EFecf435CbDf89E369Ba6\": \"MOONWELL_AERO\",\n    \"0xb8051464C8c92209C92F3a4CD9C73746C4c3CFb3\": \"MOONWELL_weETH\",\n    \"0xF877ACaFA28c19b96727966690b2f44d35aD5976\": \"MOONWELL_cbBTC\",\n    \"0xb682c840B5F4FC58B20769E691A6fa1305A501a2\": \"MOONWELL_EURC\",\n    \"0xfC41B49d064Ac646015b459C522820DB9472F4B5\": \"MOONWELL_wrsETH\",\n    \"0xdC7810B47eAAb250De623F0eE07764afa5F71ED1\": \"MOONWELL_WELL\",\n    \"0xb6419c6C2e60c4025D6D06eE4F913ce89425a357\": \"MOONWELL_USDS\",\n    \"0x9A858ebfF1bEb0D3495BB0e2897c1528eD84A218\": \"MOONWELL_TBTC\",\n    \"0x70778cfcFC475c7eA0f24cC625Baf6EaE475D0c9\": \"WETH_ROUTER\",\n};\nexports.MOONWELL_BASE_SEPOLIA_ADDRESSES = {\n    \"0x876852425331a113d8E432eFFB3aC5BEf38f033a\": \"MOONWELL_USDBC\",\n    \"0x5302EbD8BC32435C823c2e22B04Cd6c45f593e89\": \"MOONWELL_cbETH\",\n    \"0x2F39a349A79492a70E152760ce7123A1933eCf28\": \"MOONWELL_WETH\",\n};\nexports.WETH_ROUTER_ADDRESS = \"0x70778cfcFC475c7eA0f24cC625Baf6EaE475D0c9\";\n// Token decimals mapping\nexports.TOKEN_DECIMALS = {\n    \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\": 6, // USDC\n    \"0x60a3E35Cc302bFA44Cb288Bc5a4F316Fdb1adb42\": 6, // EURC\n    \"0x04C0599Ae5A44757c0af6F9eC3b93da8976c150A\": 18, // weETH\n    \"0xEDfa23602D0EC14714057867A78d01e94176BEA0\": 18, // wrsETH\n    \"0x236aa50979D5f3De3Bd1Eeb40E81137F22ab794b\": 18, // tBTC\n    \"0xA88594D404727625A9437C3f886C7643872296AE\": 18, // WELL\n    \"0x820C137fa70C8691f0e44Dc420a5e53c168921Dc\": 18, // USDS\n    \"0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb\": 18, // DAI\n    \"0x4200000000000000000000000000000000000006\": 18, // WETH\n    \"0x2Ae3F1Ec7F1F5012CFEab0185bfc7aa3cf0DEc22\": 18, // cbETH\n    \"0xc1CBa3fCea344f92D9239c08C0568f6F2F0ee452\": 18, // wstETH\n    \"0x940181a94a35a4569e4529a3cdfb74e38fd98631\": 18, // AERO\n    \"0x0000000000000000000000000000000000000000\": 18, // ETH (native)\n};\nexports.MTOKENS_UNDERLYING_DECIMALS = {\n    MOONWELL_USDC: 6,\n    MOONWELL_DAI: 18,\n    MOONWELL_WETH: 18,\n    MOONWELL_cbETH: 18,\n    MOONWELL_wstETH: 18,\n    MOONWELL_AERO: 18,\n    MOONWELL_weETH: 18,\n    MOONWELL_cbBTC: 18,\n    MOONWELL_EURC: 6,\n    MOONWELL_wrsETH: 18,\n    MOONWELL_WELL: 18,\n    MOONWELL_USDS: 18,\n    MOONWELL_TBTC: 18,\n};\nexports.ETH_ROUTER_ABI = [\n    {\n        name: \"mint\",\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"receiver\",\n                type: \"address\",\n            },\n        ],\n        outputs: [],\n        stateMutability: \"payable\",\n        type: \"function\",\n    },\n];\nexports.MTOKEN_ABI = [\n    {\n        type: \"function\",\n        name: \"mint\",\n        inputs: [\n            {\n                name: \"mintAmount\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n            },\n        ],\n        outputs: [\n            {\n                name: \"\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n            },\n        ],\n        stateMutability: \"nonpayable\",\n    },\n    {\n        type: \"function\",\n        name: \"redeemUnderlying\",\n        inputs: [\n            {\n                name: \"redeemAmount\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n            },\n        ],\n        outputs: [\n            {\n                name: \"\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n            },\n        ],\n        stateMutability: \"nonpayable\",\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb29ud2VsbC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsc0JBQXNCLEdBQUcsbUNBQW1DLEdBQUcsc0JBQXNCLEdBQUcsMkJBQTJCLEdBQUcsdUNBQXVDLEdBQUcsK0JBQStCO0FBQ3BOLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb29ud2VsbC9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1UT0tFTl9BQkkgPSBleHBvcnRzLkVUSF9ST1VURVJfQUJJID0gZXhwb3J0cy5NVE9LRU5TX1VOREVSTFlJTkdfREVDSU1BTFMgPSBleHBvcnRzLlRPS0VOX0RFQ0lNQUxTID0gZXhwb3J0cy5XRVRIX1JPVVRFUl9BRERSRVNTID0gZXhwb3J0cy5NT09OV0VMTF9CQVNFX1NFUE9MSUFfQUREUkVTU0VTID0gZXhwb3J0cy5NT09OV0VMTF9CQVNFX0FERFJFU1NFUyA9IHZvaWQgMDtcbmV4cG9ydHMuTU9PTldFTExfQkFTRV9BRERSRVNTRVMgPSB7XG4gICAgXCIweEVkYzgxN0EyOEU4QjkzQjAzOTc2RkJkNGEzZERCYzlmN0QxNzZjMjJcIjogXCJNT09OV0VMTF9VU0RDXCIsXG4gICAgXCIweDczYjA2RDhkMThEZTQyMkUyNjk2NDVlYUNlMTU0MDBERTc0NjI0MTdcIjogXCJNT09OV0VMTF9EQUlcIixcbiAgICBcIjB4NjI4ZmY2OTM0MjY1ODNEOWE3RkIzOTFFNTQzNjYyOTJGNTA5RDQ1N1wiOiBcIk1PT05XRUxMX1dFVEhcIixcbiAgICBcIjB4M2JmOTM3NzBmMmQ0YTc5NGMzZDlFQkVmQkFlQkFFMmE4ZjA5QTVFNVwiOiBcIk1PT05XRUxMX2NiRVRIXCIsXG4gICAgXCIweDYyN0ZlMzkzQmM2RWREQTI4ZTk5QUU2NDhmRDZmRjM2MjUxNDMwNGJcIjogXCJNT09OV0VMTF93c3RFVEhcIixcbiAgICBcIjB4NzM5MDJmNjE5Q0VCOUIzMUZEOEVGZWNmNDM1Q2JEZjg5RTM2OUJhNlwiOiBcIk1PT05XRUxMX0FFUk9cIixcbiAgICBcIjB4YjgwNTE0NjRDOGM5MjIwOUM5MkYzYTRDRDlDNzM3NDZDNGMzQ0ZiM1wiOiBcIk1PT05XRUxMX3dlRVRIXCIsXG4gICAgXCIweEY4NzdBQ2FGQTI4YzE5Yjk2NzI3OTY2NjkwYjJmNDRkMzVhRDU5NzZcIjogXCJNT09OV0VMTF9jYkJUQ1wiLFxuICAgIFwiMHhiNjgyYzg0MEI1RjRGQzU4QjIwNzY5RTY5MUE2ZmExMzA1QTUwMWEyXCI6IFwiTU9PTldFTExfRVVSQ1wiLFxuICAgIFwiMHhmQzQxQjQ5ZDA2NEFjNjQ2MDE1YjQ1OUM1MjI4MjBEQjk0NzJGNEI1XCI6IFwiTU9PTldFTExfd3JzRVRIXCIsXG4gICAgXCIweGRDNzgxMEI0N2VBQWIyNTBEZTYyM0YwZUUwNzc2NGFmYTVGNzFFRDFcIjogXCJNT09OV0VMTF9XRUxMXCIsXG4gICAgXCIweGI2NDE5YzZDMmU2MGM0MDI1RDZEMDZlRTRGOTEzY2U4OTQyNWEzNTdcIjogXCJNT09OV0VMTF9VU0RTXCIsXG4gICAgXCIweDlBODU4ZWJmRjFiRWIwRDM0OTVCQjBlMjg5N2MxNTI4ZUQ4NEEyMThcIjogXCJNT09OV0VMTF9UQlRDXCIsXG4gICAgXCIweDcwNzc4Y2ZjRkM0NzVjN2VBMGYyNGNDNjI1QmFmNkVhRTQ3NUQwYzlcIjogXCJXRVRIX1JPVVRFUlwiLFxufTtcbmV4cG9ydHMuTU9PTldFTExfQkFTRV9TRVBPTElBX0FERFJFU1NFUyA9IHtcbiAgICBcIjB4ODc2ODUyNDI1MzMxYTExM2Q4RTQzMmVGRkIzYUM1QkVmMzhmMDMzYVwiOiBcIk1PT05XRUxMX1VTREJDXCIsXG4gICAgXCIweDUzMDJFYkQ4QkMzMjQzNUM4MjNjMmUyMkIwNENkNmM0NWY1OTNlODlcIjogXCJNT09OV0VMTF9jYkVUSFwiLFxuICAgIFwiMHgyRjM5YTM0OUE3OTQ5MmE3MEUxNTI3NjBjZTcxMjNBMTkzM2VDZjI4XCI6IFwiTU9PTldFTExfV0VUSFwiLFxufTtcbmV4cG9ydHMuV0VUSF9ST1VURVJfQUREUkVTUyA9IFwiMHg3MDc3OGNmY0ZDNDc1YzdlQTBmMjRjQzYyNUJhZjZFYUU0NzVEMGM5XCI7XG4vLyBUb2tlbiBkZWNpbWFscyBtYXBwaW5nXG5leHBvcnRzLlRPS0VOX0RFQ0lNQUxTID0ge1xuICAgIFwiMHg4MzM1ODlmQ0Q2ZURiNkUwOGY0YzdDMzJENGY3MWI1NGJkQTAyOTEzXCI6IDYsIC8vIFVTRENcbiAgICBcIjB4NjBhM0UzNUNjMzAyYkZBNDRDYjI4OEJjNWE0RjMxNkZkYjFhZGI0MlwiOiA2LCAvLyBFVVJDXG4gICAgXCIweDA0QzA1OTlBZTVBNDQ3NTdjMGFmNkY5ZUMzYjkzZGE4OTc2YzE1MEFcIjogMTgsIC8vIHdlRVRIXG4gICAgXCIweEVEZmEyMzYwMkQwRUMxNDcxNDA1Nzg2N0E3OGQwMWU5NDE3NkJFQTBcIjogMTgsIC8vIHdyc0VUSFxuICAgIFwiMHgyMzZhYTUwOTc5RDVmM0RlM0JkMUVlYjQwRTgxMTM3RjIyYWI3OTRiXCI6IDE4LCAvLyB0QlRDXG4gICAgXCIweEE4ODU5NEQ0MDQ3Mjc2MjVBOTQzN0MzZjg4NkM3NjQzODcyMjk2QUVcIjogMTgsIC8vIFdFTExcbiAgICBcIjB4ODIwQzEzN2ZhNzBDODY5MWYwZTQ0RGM0MjBhNWU1M2MxNjg5MjFEY1wiOiAxOCwgLy8gVVNEU1xuICAgIFwiMHg1MGM1NzI1OTQ5QTZGMGM3MkU2QzRhNjQxRjI0MDQ5QTkxN0RCMENiXCI6IDE4LCAvLyBEQUlcbiAgICBcIjB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNlwiOiAxOCwgLy8gV0VUSFxuICAgIFwiMHgyQWUzRjFFYzdGMUY1MDEyQ0ZFYWIwMTg1YmZjN2FhM2NmMERFYzIyXCI6IDE4LCAvLyBjYkVUSFxuICAgIFwiMHhjMUNCYTNmQ2VhMzQ0ZjkyRDkyMzljMDhDMDU2OGY2RjJGMGVlNDUyXCI6IDE4LCAvLyB3c3RFVEhcbiAgICBcIjB4OTQwMTgxYTk0YTM1YTQ1NjllNDUyOWEzY2RmYjc0ZTM4ZmQ5ODYzMVwiOiAxOCwgLy8gQUVST1xuICAgIFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI6IDE4LCAvLyBFVEggKG5hdGl2ZSlcbn07XG5leHBvcnRzLk1UT0tFTlNfVU5ERVJMWUlOR19ERUNJTUFMUyA9IHtcbiAgICBNT09OV0VMTF9VU0RDOiA2LFxuICAgIE1PT05XRUxMX0RBSTogMTgsXG4gICAgTU9PTldFTExfV0VUSDogMTgsXG4gICAgTU9PTldFTExfY2JFVEg6IDE4LFxuICAgIE1PT05XRUxMX3dzdEVUSDogMTgsXG4gICAgTU9PTldFTExfQUVSTzogMTgsXG4gICAgTU9PTldFTExfd2VFVEg6IDE4LFxuICAgIE1PT05XRUxMX2NiQlRDOiAxOCxcbiAgICBNT09OV0VMTF9FVVJDOiA2LFxuICAgIE1PT05XRUxMX3dyc0VUSDogMTgsXG4gICAgTU9PTldFTExfV0VMTDogMTgsXG4gICAgTU9PTldFTExfVVNEUzogMTgsXG4gICAgTU9PTldFTExfVEJUQzogMTgsXG59O1xuZXhwb3J0cy5FVEhfUk9VVEVSX0FCSSA9IFtcbiAgICB7XG4gICAgICAgIG5hbWU6IFwibWludFwiLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwicmVjZWl2ZXJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwicGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbl07XG5leHBvcnRzLk1UT0tFTl9BQkkgPSBbXG4gICAge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIG5hbWU6IFwibWludFwiLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm1pbnRBbW91bnRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJyZWRlZW1VbmRlcmx5aW5nXCIsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwicmVkZWVtQW1vdW50XCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIH0sXG5dO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.moonwellActionProvider = void 0;\nvar moonwellActionProvider_1 = __webpack_require__(/*! ./moonwellActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/moonwellActionProvider.js\");\nObject.defineProperty(exports, \"moonwellActionProvider\", ({ enumerable: true, get: function () { return moonwellActionProvider_1.moonwellActionProvider; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb29ud2VsbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsK0JBQStCLG1CQUFPLENBQUMsa0lBQTBCO0FBQ2pFLDBEQUF5RCxFQUFFLHFDQUFxQywyREFBMkQsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb29ud2VsbC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubW9vbndlbGxBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbnZhciBtb29ud2VsbEFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9tb29ud2VsbEFjdGlvblByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibW9vbndlbGxBY3Rpb25Qcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9vbndlbGxBY3Rpb25Qcm92aWRlcl8xLm1vb253ZWxsQWN0aW9uUHJvdmlkZXI7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/moonwellActionProvider.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/moonwellActionProvider.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.moonwellActionProvider = exports.MoonwellActionProvider = exports.SUPPORTED_NETWORKS = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_cjs/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/utils.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/constants.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/schemas.js\");\nexports.SUPPORTED_NETWORKS = [\"base-mainnet\", \"base-sepolia\"];\n/**\n * MoonwellActionProvider is an action provider for Moonwell MToken interactions.\n */\nclass MoonwellActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the MoonwellActionProvider class.\n     */\n    constructor() {\n        super(\"moonwell\", []);\n        /**\n         * Checks if the Moonwell action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Moonwell action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.protocolFamily === \"evm\" && exports.SUPPORTED_NETWORKS.includes(network.networkId);\n    }\n    /**\n     * Deposits assets into a Moonwell MToken\n     *\n     * @param wallet - The wallet instance to execute the transaction\n     * @param args - The input arguments for the action\n     * @returns A success message with transaction details or an error message\n     */\n    async mint(wallet, args) {\n        const assets = new decimal_js_1.Decimal(args.assets);\n        if (assets.comparedTo(new decimal_js_1.Decimal(0.0)) != 1) {\n            return \"Error: Assets amount must be greater than 0\";\n        }\n        const network = wallet.getNetwork();\n        const networkObject = network.networkId === \"base-mainnet\"\n            ? constants_1.MOONWELL_BASE_ADDRESSES\n            : constants_1.MOONWELL_BASE_SEPOLIA_ADDRESSES;\n        if (!networkObject[args.mTokenAddress]) {\n            return \"Error: Invalid MToken address\";\n        }\n        try {\n            // Handle different token decimals\n            let atomicAssets;\n            const userAddress = wallet.getAddress();\n            if (network.networkId === \"base-mainnet\" &&\n                \"MOONWELL_WETH\" === networkObject[args.mTokenAddress]) {\n                // For ETH minting, use parseEther (18 decimals)\n                atomicAssets = (0, viem_1.parseEther)(args.assets);\n            }\n            else {\n                // For other tokens, use the correct decimals\n                const decimals = constants_1.TOKEN_DECIMALS[args.tokenAddress];\n                if (!decimals) {\n                    return `Error: Unsupported token address ${args.tokenAddress}. Please verify the token address is correct.`;\n                }\n                atomicAssets = (0, viem_1.parseUnits)(args.assets, decimals);\n            }\n            // Check if this is a WETH mint on mainnet\n            if (network.networkId === \"base-mainnet\" &&\n                \"MOONWELL_WETH\" === networkObject[args.mTokenAddress]) {\n                // Use the router for ETH mints - no approval needed since we're sending native ETH\n                const data = (0, viem_1.encodeFunctionData)({\n                    abi: constants_1.ETH_ROUTER_ABI,\n                    functionName: \"mint\",\n                    args: [userAddress],\n                });\n                const txHash = await wallet.sendTransaction({\n                    to: constants_1.WETH_ROUTER_ADDRESS,\n                    data,\n                    value: atomicAssets,\n                });\n                const receipt = await wallet.waitForTransactionReceipt(txHash);\n                return `Deposited ${args.assets} ETH to Moonwell WETH via router with transaction hash: ${txHash}\\nTransaction receipt: ${JSON.stringify(receipt, (_, value) => (typeof value === \"bigint\" ? value.toString() : value))}`;\n            }\n            else {\n                // For all other tokens, we need approval first\n                const approvalResult = await (0, utils_1.approve)(wallet, args.tokenAddress, args.mTokenAddress, atomicAssets);\n                if (approvalResult.startsWith(\"Error\")) {\n                    return `Error approving Moonwell MToken as spender: ${approvalResult}`;\n                }\n                const data = (0, viem_1.encodeFunctionData)({\n                    abi: constants_1.MTOKEN_ABI,\n                    functionName: \"mint\",\n                    args: [atomicAssets],\n                });\n                const txHash = await wallet.sendTransaction({\n                    to: args.mTokenAddress,\n                    data,\n                    value: 0n,\n                });\n                const receipt = await wallet.waitForTransactionReceipt(txHash);\n                if (!receipt) {\n                    throw new Error(\"No receipt received for mint transaction\");\n                }\n                if (receipt.status !== \"success\") {\n                    throw new Error(`Mint transaction failed with status ${receipt.status}`);\n                }\n                return `Deposited ${args.assets} to Moonwell MToken ${args.mTokenAddress} with transaction hash: ${txHash}\\nTransaction receipt: ${JSON.stringify(receipt, (_, value) => (typeof value === \"bigint\" ? value.toString() : value))}`;\n            }\n        }\n        catch (error) {\n            console.error(\"DEBUG - Mint error:\", error);\n            if (error instanceof Error) {\n                return `Error minting Moonwell MToken: ${error.message}`;\n            }\n            return `Error minting Moonwell MToken: ${error}`;\n        }\n    }\n    /**\n     * Redeems assets from a Moonwell MToken\n     *\n     * @param wallet - The wallet instance to execute the transaction\n     * @param args - The input arguments for the action\n     * @returns A success message with transaction details or an error message\n     */\n    async redeem(wallet, args) {\n        const assets = new decimal_js_1.Decimal(args.assets);\n        if (assets.comparedTo(new decimal_js_1.Decimal(0.0)) != 1) {\n            return \"Error: Assets amount must be greater than 0\";\n        }\n        const network = wallet.getNetwork();\n        const networkObject = network.networkId === \"base-mainnet\"\n            ? constants_1.MOONWELL_BASE_ADDRESSES\n            : constants_1.MOONWELL_BASE_SEPOLIA_ADDRESSES;\n        if (!networkObject[args.mTokenAddress]) {\n            return \"Error: Invalid MToken address\";\n        }\n        try {\n            // Handle different token decimals\n            const decimals = constants_1.MTOKENS_UNDERLYING_DECIMALS[constants_1.MOONWELL_BASE_ADDRESSES[args.mTokenAddress]];\n            if (!decimals) {\n                return `Error: Unsupported token address ${args.mTokenAddress}. Please verify the token address is correct.`;\n            }\n            const atomicAssets = (0, viem_1.parseUnits)(args.assets, decimals);\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.MTOKEN_ABI,\n                functionName: \"redeemUnderlying\",\n                args: [atomicAssets],\n            });\n            const txHash = await wallet.sendTransaction({\n                to: args.mTokenAddress,\n                data,\n                value: 0n,\n            });\n            const receipt = await wallet.waitForTransactionReceipt(txHash);\n            if (!receipt) {\n                throw new Error(\"No receipt received for redeem transaction\");\n            }\n            if (receipt.status !== \"success\") {\n                throw new Error(`Redeem transaction failed with status ${receipt.status}`);\n            }\n            return `Redeemed ${args.assets} from Moonwell MToken ${args.mTokenAddress} with transaction hash: ${txHash}\\nTransaction receipt: ${JSON.stringify(receipt, (_, value) => (typeof value === \"bigint\" ? value.toString() : value))}`;\n        }\n        catch (error) {\n            console.error(\"DEBUG - Redeem error:\", error);\n            if (error instanceof Error) {\n                return `Error redeeming from Moonwell MToken: ${error.message}`;\n            }\n            return `Error redeeming from Moonwell MToken: ${error}`;\n        }\n    }\n}\nexports.MoonwellActionProvider = MoonwellActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"mint\",\n        description: `\nThis tool allows minting assets into a Moonwell MToken. \n\nIt takes:\n- mTokenAddress: The address of the Moonwell MToken to mint to\n- assets: The amount of assets that will be approved to spend by the mToken in whole units\n  Examples for WETH:\n  - 1 WETH\n  - 0.1 WETH\n  - 0.01 WETH\n  Examples for cbETH:\n  - 1 cbETH\n  - 0.1 cbETH\n  - 0.01 cbETH\n  Examples for USDC:\n  - 1 USDC\n  - 0.1 USDC\n  - 0.01 USDC\n- tokenAddress: The address of the token to approve\n\nImportant notes:\n- Make sure to use the exact amount provided. Do not convert units for assets for this action.\n- Please use a token address (example 0x4200000000000000000000000000000000000006) for the tokenAddress field.\n- This tool handles token approval. If requested to mint on Moonwell, do not use any other actions to approve tokens.\n`,\n        schema: schemas_1.MintSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], MoonwellActionProvider.prototype, \"mint\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"redeem\",\n        description: `\nThis tool allows redeeming assets from a Moonwell MToken. \n\nIt takes:\n- mTokenAddress: The address of the Moonwell MToken to redeem from\n- assets: The amount of assets to redeem in whole units\n  Examples for WETH:\n  - 1 WETH\n  - 0.1 WETH\n  - 0.01 WETH\n  Examples for cbETH:\n  - 1 cbETH\n  - 0.1 cbETH\n  - 0.01 cbETH\n  Examples for USDC:\n  - 1 USDC\n  - 0.1 USDC\n  - 0.01 USDC\n\nImportant notes:\n- Make sure to use the exact amount provided. Do not convert units for assets for this action.\n- Please use a token address (example 0x4200000000000000000000000000000000000006) for the tokenAddress field.\n`,\n        schema: schemas_1.RedeemSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], MoonwellActionProvider.prototype, \"redeem\", null);\nconst moonwellActionProvider = () => new MoonwellActionProvider();\nexports.moonwellActionProvider = moonwellActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb29ud2VsbC9tb29ud2VsbEFjdGlvblByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyw4QkFBOEIsR0FBRywwQkFBMEI7QUFDNUYsY0FBYyxtQkFBTyxDQUFDLHVEQUFLO0FBQzNCLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxxREFBTTtBQUM3Qix5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMkJBQTJCLG1CQUFPLENBQUMsc0dBQXdCO0FBQzNELDBCQUEwQixtQkFBTyxDQUFDLDRHQUFvQjtBQUN0RCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBYTtBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyx3R0FBYTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxvR0FBVztBQUNyQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsa0JBQWtCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxvQ0FBb0MsYUFBYSx5REFBeUQsT0FBTyx5QkFBeUIsOEZBQThGO0FBQ3hPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsZUFBZTtBQUMxRjtBQUNBLG9DQUFvQyxhQUFhLHFCQUFxQixvQkFBb0IseUJBQXlCLE9BQU8seUJBQXlCLDhGQUE4RjtBQUNqUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQSxxREFBcUQsTUFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxtQkFBbUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBLCtCQUErQixhQUFhLHVCQUF1QixvQkFBb0IseUJBQXlCLE9BQU8seUJBQXlCLDhGQUE4RjtBQUM5TztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxjQUFjO0FBQzlFO0FBQ0EsNERBQTRELE1BQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL21vb253ZWxsL21vb253ZWxsQWN0aW9uUHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tb29ud2VsbEFjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5Nb29ud2VsbEFjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5TVVBQT1JURURfTkVUV09SS1MgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSByZXF1aXJlKFwiZGVjaW1hbC5qc1wiKTtcbmNvbnN0IHZpZW1fMSA9IHJlcXVpcmUoXCJ2aWVtXCIpO1xuY29uc3QgYWN0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25Qcm92aWRlclwiKTtcbmNvbnN0IHdhbGxldF9wcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi93YWxsZXQtcHJvdmlkZXJzXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbmV4cG9ydHMuU1VQUE9SVEVEX05FVFdPUktTID0gW1wiYmFzZS1tYWlubmV0XCIsIFwiYmFzZS1zZXBvbGlhXCJdO1xuLyoqXG4gKiBNb29ud2VsbEFjdGlvblByb3ZpZGVyIGlzIGFuIGFjdGlvbiBwcm92aWRlciBmb3IgTW9vbndlbGwgTVRva2VuIGludGVyYWN0aW9ucy5cbiAqL1xuY2xhc3MgTW9vbndlbGxBY3Rpb25Qcm92aWRlciBleHRlbmRzIGFjdGlvblByb3ZpZGVyXzEuQWN0aW9uUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgTW9vbndlbGxBY3Rpb25Qcm92aWRlciBjbGFzcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJtb29ud2VsbFwiLCBbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIE1vb253ZWxsIGFjdGlvbiBwcm92aWRlciBzdXBwb3J0cyB0aGUgZ2l2ZW4gbmV0d29yay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5ldHdvcmsgLSBUaGUgbmV0d29yayB0byBjaGVjay5cbiAgICAgICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgTW9vbndlbGwgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBuZXR3b3JrLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRzTmV0d29yayA9IChuZXR3b3JrKSA9PiBuZXR3b3JrLnByb3RvY29sRmFtaWx5ID09PSBcImV2bVwiICYmIGV4cG9ydHMuU1VQUE9SVEVEX05FVFdPUktTLmluY2x1ZGVzKG5ldHdvcmsubmV0d29ya0lkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwb3NpdHMgYXNzZXRzIGludG8gYSBNb29ud2VsbCBNVG9rZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IGluc3RhbmNlIHRvIGV4ZWN1dGUgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uXG4gICAgICogQHJldHVybnMgQSBzdWNjZXNzIG1lc3NhZ2Ugd2l0aCB0cmFuc2FjdGlvbiBkZXRhaWxzIG9yIGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhc3luYyBtaW50KHdhbGxldCwgYXJncykge1xuICAgICAgICBjb25zdCBhc3NldHMgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoYXJncy5hc3NldHMpO1xuICAgICAgICBpZiAoYXNzZXRzLmNvbXBhcmVkVG8obmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKDAuMCkpICE9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBBc3NldHMgYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gd2FsbGV0LmdldE5ldHdvcmsoKTtcbiAgICAgICAgY29uc3QgbmV0d29ya09iamVjdCA9IG5ldHdvcmsubmV0d29ya0lkID09PSBcImJhc2UtbWFpbm5ldFwiXG4gICAgICAgICAgICA/IGNvbnN0YW50c18xLk1PT05XRUxMX0JBU0VfQUREUkVTU0VTXG4gICAgICAgICAgICA6IGNvbnN0YW50c18xLk1PT05XRUxMX0JBU0VfU0VQT0xJQV9BRERSRVNTRVM7XG4gICAgICAgIGlmICghbmV0d29ya09iamVjdFthcmdzLm1Ub2tlbkFkZHJlc3NdKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogSW52YWxpZCBNVG9rZW4gYWRkcmVzc1wiO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IHRva2VuIGRlY2ltYWxzXG4gICAgICAgICAgICBsZXQgYXRvbWljQXNzZXRzO1xuICAgICAgICAgICAgY29uc3QgdXNlckFkZHJlc3MgPSB3YWxsZXQuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmsubmV0d29ya0lkID09PSBcImJhc2UtbWFpbm5ldFwiICYmXG4gICAgICAgICAgICAgICAgXCJNT09OV0VMTF9XRVRIXCIgPT09IG5ldHdvcmtPYmplY3RbYXJncy5tVG9rZW5BZGRyZXNzXSkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBFVEggbWludGluZywgdXNlIHBhcnNlRXRoZXIgKDE4IGRlY2ltYWxzKVxuICAgICAgICAgICAgICAgIGF0b21pY0Fzc2V0cyA9ICgwLCB2aWVtXzEucGFyc2VFdGhlcikoYXJncy5hc3NldHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG90aGVyIHRva2VucywgdXNlIHRoZSBjb3JyZWN0IGRlY2ltYWxzXG4gICAgICAgICAgICAgICAgY29uc3QgZGVjaW1hbHMgPSBjb25zdGFudHNfMS5UT0tFTl9ERUNJTUFMU1thcmdzLnRva2VuQWRkcmVzc107XG4gICAgICAgICAgICAgICAgaWYgKCFkZWNpbWFscykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYEVycm9yOiBVbnN1cHBvcnRlZCB0b2tlbiBhZGRyZXNzICR7YXJncy50b2tlbkFkZHJlc3N9LiBQbGVhc2UgdmVyaWZ5IHRoZSB0b2tlbiBhZGRyZXNzIGlzIGNvcnJlY3QuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXRvbWljQXNzZXRzID0gKDAsIHZpZW1fMS5wYXJzZVVuaXRzKShhcmdzLmFzc2V0cywgZGVjaW1hbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIFdFVEggbWludCBvbiBtYWlubmV0XG4gICAgICAgICAgICBpZiAobmV0d29yay5uZXR3b3JrSWQgPT09IFwiYmFzZS1tYWlubmV0XCIgJiZcbiAgICAgICAgICAgICAgICBcIk1PT05XRUxMX1dFVEhcIiA9PT0gbmV0d29ya09iamVjdFthcmdzLm1Ub2tlbkFkZHJlc3NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSByb3V0ZXIgZm9yIEVUSCBtaW50cyAtIG5vIGFwcHJvdmFsIG5lZWRlZCBzaW5jZSB3ZSdyZSBzZW5kaW5nIG5hdGl2ZSBFVEhcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5FVEhfUk9VVEVSX0FCSSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcIm1pbnRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3VzZXJBZGRyZXNzXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCB3YWxsZXQuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdG86IGNvbnN0YW50c18xLldFVEhfUk9VVEVSX0FERFJFU1MsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhdG9taWNBc3NldHMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHdhbGxldC53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBEZXBvc2l0ZWQgJHthcmdzLmFzc2V0c30gRVRIIHRvIE1vb253ZWxsIFdFVEggdmlhIHJvdXRlciB3aXRoIHRyYW5zYWN0aW9uIGhhc2g6ICR7dHhIYXNofVxcblRyYW5zYWN0aW9uIHJlY2VpcHQ6ICR7SlNPTi5zdHJpbmdpZnkocmVjZWlwdCwgKF8sIHZhbHVlKSA9PiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlKSl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciBhbGwgb3RoZXIgdG9rZW5zLCB3ZSBuZWVkIGFwcHJvdmFsIGZpcnN0XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwcm92YWxSZXN1bHQgPSBhd2FpdCAoMCwgdXRpbHNfMS5hcHByb3ZlKSh3YWxsZXQsIGFyZ3MudG9rZW5BZGRyZXNzLCBhcmdzLm1Ub2tlbkFkZHJlc3MsIGF0b21pY0Fzc2V0cyk7XG4gICAgICAgICAgICAgICAgaWYgKGFwcHJvdmFsUmVzdWx0LnN0YXJ0c1dpdGgoXCJFcnJvclwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYEVycm9yIGFwcHJvdmluZyBNb29ud2VsbCBNVG9rZW4gYXMgc3BlbmRlcjogJHthcHByb3ZhbFJlc3VsdH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5NVE9LRU5fQUJJLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwibWludFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbYXRvbWljQXNzZXRzXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCB3YWxsZXQuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdG86IGFyZ3MubVRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDBuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB3YWxsZXQud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZWNlaXB0IHJlY2VpdmVkIGZvciBtaW50IHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVjZWlwdC5zdGF0dXMgIT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWludCB0cmFuc2FjdGlvbiBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZWNlaXB0LnN0YXR1c31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBEZXBvc2l0ZWQgJHthcmdzLmFzc2V0c30gdG8gTW9vbndlbGwgTVRva2VuICR7YXJncy5tVG9rZW5BZGRyZXNzfSB3aXRoIHRyYW5zYWN0aW9uIGhhc2g6ICR7dHhIYXNofVxcblRyYW5zYWN0aW9uIHJlY2VpcHQ6ICR7SlNPTi5zdHJpbmdpZnkocmVjZWlwdCwgKF8sIHZhbHVlKSA9PiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlKSl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJERUJVRyAtIE1pbnQgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBtaW50aW5nIE1vb253ZWxsIE1Ub2tlbjogJHtlcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIG1pbnRpbmcgTW9vbndlbGwgTVRva2VuOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkZWVtcyBhc3NldHMgZnJvbSBhIE1vb253ZWxsIE1Ub2tlblxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgaW5zdGFuY2UgdG8gZXhlY3V0ZSB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb25cbiAgICAgKiBAcmV0dXJucyBBIHN1Y2Nlc3MgbWVzc2FnZSB3aXRoIHRyYW5zYWN0aW9uIGRldGFpbHMgb3IgYW4gZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIHJlZGVlbSh3YWxsZXQsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgYXNzZXRzID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKGFyZ3MuYXNzZXRzKTtcbiAgICAgICAgaWYgKGFzc2V0cy5jb21wYXJlZFRvKG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCgwLjApKSAhPSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogQXNzZXRzIGFtb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29yayA9IHdhbGxldC5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtPYmplY3QgPSBuZXR3b3JrLm5ldHdvcmtJZCA9PT0gXCJiYXNlLW1haW5uZXRcIlxuICAgICAgICAgICAgPyBjb25zdGFudHNfMS5NT09OV0VMTF9CQVNFX0FERFJFU1NFU1xuICAgICAgICAgICAgOiBjb25zdGFudHNfMS5NT09OV0VMTF9CQVNFX1NFUE9MSUFfQUREUkVTU0VTO1xuICAgICAgICBpZiAoIW5ldHdvcmtPYmplY3RbYXJncy5tVG9rZW5BZGRyZXNzXSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IEludmFsaWQgTVRva2VuIGFkZHJlc3NcIjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGRpZmZlcmVudCB0b2tlbiBkZWNpbWFsc1xuICAgICAgICAgICAgY29uc3QgZGVjaW1hbHMgPSBjb25zdGFudHNfMS5NVE9LRU5TX1VOREVSTFlJTkdfREVDSU1BTFNbY29uc3RhbnRzXzEuTU9PTldFTExfQkFTRV9BRERSRVNTRVNbYXJncy5tVG9rZW5BZGRyZXNzXV07XG4gICAgICAgICAgICBpZiAoIWRlY2ltYWxzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBFcnJvcjogVW5zdXBwb3J0ZWQgdG9rZW4gYWRkcmVzcyAke2FyZ3MubVRva2VuQWRkcmVzc30uIFBsZWFzZSB2ZXJpZnkgdGhlIHRva2VuIGFkZHJlc3MgaXMgY29ycmVjdC5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXRvbWljQXNzZXRzID0gKDAsIHZpZW1fMS5wYXJzZVVuaXRzKShhcmdzLmFzc2V0cywgZGVjaW1hbHMpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgwLCB2aWVtXzEuZW5jb2RlRnVuY3Rpb25EYXRhKSh7XG4gICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5NVE9LRU5fQUJJLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJyZWRlZW1VbmRlcmx5aW5nXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW2F0b21pY0Fzc2V0c10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IHdhbGxldC5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHRvOiBhcmdzLm1Ub2tlbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMG4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB3YWxsZXQud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICAgICAgICAgICAgaWYgKCFyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVjZWlwdCByZWNlaXZlZCBmb3IgcmVkZWVtIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlY2VpcHQuc3RhdHVzICE9PSBcInN1Y2Nlc3NcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVkZWVtIHRyYW5zYWN0aW9uIGZhaWxlZCB3aXRoIHN0YXR1cyAke3JlY2VpcHQuc3RhdHVzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGBSZWRlZW1lZCAke2FyZ3MuYXNzZXRzfSBmcm9tIE1vb253ZWxsIE1Ub2tlbiAke2FyZ3MubVRva2VuQWRkcmVzc30gd2l0aCB0cmFuc2FjdGlvbiBoYXNoOiAke3R4SGFzaH1cXG5UcmFuc2FjdGlvbiByZWNlaXB0OiAke0pTT04uc3RyaW5naWZ5KHJlY2VpcHQsIChfLCB2YWx1ZSkgPT4gKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiREVCVUcgLSBSZWRlZW0gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBFcnJvciByZWRlZW1pbmcgZnJvbSBNb29ud2VsbCBNVG9rZW46ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciByZWRlZW1pbmcgZnJvbSBNb29ud2VsbCBNVG9rZW46ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTW9vbndlbGxBY3Rpb25Qcm92aWRlciA9IE1vb253ZWxsQWN0aW9uUHJvdmlkZXI7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwibWludFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIGFsbG93cyBtaW50aW5nIGFzc2V0cyBpbnRvIGEgTW9vbndlbGwgTVRva2VuLiBcblxuSXQgdGFrZXM6XG4tIG1Ub2tlbkFkZHJlc3M6IFRoZSBhZGRyZXNzIG9mIHRoZSBNb29ud2VsbCBNVG9rZW4gdG8gbWludCB0b1xuLSBhc3NldHM6IFRoZSBhbW91bnQgb2YgYXNzZXRzIHRoYXQgd2lsbCBiZSBhcHByb3ZlZCB0byBzcGVuZCBieSB0aGUgbVRva2VuIGluIHdob2xlIHVuaXRzXG4gIEV4YW1wbGVzIGZvciBXRVRIOlxuICAtIDEgV0VUSFxuICAtIDAuMSBXRVRIXG4gIC0gMC4wMSBXRVRIXG4gIEV4YW1wbGVzIGZvciBjYkVUSDpcbiAgLSAxIGNiRVRIXG4gIC0gMC4xIGNiRVRIXG4gIC0gMC4wMSBjYkVUSFxuICBFeGFtcGxlcyBmb3IgVVNEQzpcbiAgLSAxIFVTRENcbiAgLSAwLjEgVVNEQ1xuICAtIDAuMDEgVVNEQ1xuLSB0b2tlbkFkZHJlc3M6IFRoZSBhZGRyZXNzIG9mIHRoZSB0b2tlbiB0byBhcHByb3ZlXG5cbkltcG9ydGFudCBub3Rlczpcbi0gTWFrZSBzdXJlIHRvIHVzZSB0aGUgZXhhY3QgYW1vdW50IHByb3ZpZGVkLiBEbyBub3QgY29udmVydCB1bml0cyBmb3IgYXNzZXRzIGZvciB0aGlzIGFjdGlvbi5cbi0gUGxlYXNlIHVzZSBhIHRva2VuIGFkZHJlc3MgKGV4YW1wbGUgMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2KSBmb3IgdGhlIHRva2VuQWRkcmVzcyBmaWVsZC5cbi0gVGhpcyB0b29sIGhhbmRsZXMgdG9rZW4gYXBwcm92YWwuIElmIHJlcXVlc3RlZCB0byBtaW50IG9uIE1vb253ZWxsLCBkbyBub3QgdXNlIGFueSBvdGhlciBhY3Rpb25zIHRvIGFwcHJvdmUgdG9rZW5zLlxuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuTWludFNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIE1vb253ZWxsQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcIm1pbnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwicmVkZWVtXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgYWxsb3dzIHJlZGVlbWluZyBhc3NldHMgZnJvbSBhIE1vb253ZWxsIE1Ub2tlbi4gXG5cbkl0IHRha2VzOlxuLSBtVG9rZW5BZGRyZXNzOiBUaGUgYWRkcmVzcyBvZiB0aGUgTW9vbndlbGwgTVRva2VuIHRvIHJlZGVlbSBmcm9tXG4tIGFzc2V0czogVGhlIGFtb3VudCBvZiBhc3NldHMgdG8gcmVkZWVtIGluIHdob2xlIHVuaXRzXG4gIEV4YW1wbGVzIGZvciBXRVRIOlxuICAtIDEgV0VUSFxuICAtIDAuMSBXRVRIXG4gIC0gMC4wMSBXRVRIXG4gIEV4YW1wbGVzIGZvciBjYkVUSDpcbiAgLSAxIGNiRVRIXG4gIC0gMC4xIGNiRVRIXG4gIC0gMC4wMSBjYkVUSFxuICBFeGFtcGxlcyBmb3IgVVNEQzpcbiAgLSAxIFVTRENcbiAgLSAwLjEgVVNEQ1xuICAtIDAuMDEgVVNEQ1xuXG5JbXBvcnRhbnQgbm90ZXM6XG4tIE1ha2Ugc3VyZSB0byB1c2UgdGhlIGV4YWN0IGFtb3VudCBwcm92aWRlZC4gRG8gbm90IGNvbnZlcnQgdW5pdHMgZm9yIGFzc2V0cyBmb3IgdGhpcyBhY3Rpb24uXG4tIFBsZWFzZSB1c2UgYSB0b2tlbiBhZGRyZXNzIChleGFtcGxlIDB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNikgZm9yIHRoZSB0b2tlbkFkZHJlc3MgZmllbGQuXG5gLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5SZWRlZW1TY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3dhbGxldF9wcm92aWRlcnNfMS5Fdm1XYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBNb29ud2VsbEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJyZWRlZW1cIiwgbnVsbCk7XG5jb25zdCBtb29ud2VsbEFjdGlvblByb3ZpZGVyID0gKCkgPT4gbmV3IE1vb253ZWxsQWN0aW9uUHJvdmlkZXIoKTtcbmV4cG9ydHMubW9vbndlbGxBY3Rpb25Qcm92aWRlciA9IG1vb253ZWxsQWN0aW9uUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/moonwellActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/schemas.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/schemas.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RedeemSchema = exports.MintSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\n/**\n * Input schema for Moonwell MToken mint action.\n */\nexports.MintSchema = zod_1.z\n    .object({\n    assets: zod_1.z\n        .string()\n        .regex(/^\\d+(\\.\\d+)?$/, \"Must be a valid integer or decimal value\")\n        .describe(\"The quantity of assets to use to mint, in whole units\"),\n    tokenAddress: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address of the assets token to approve for minting\"),\n    mTokenAddress: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address of the Moonwell MToken to mint from\"),\n})\n    .describe(\"Input schema for Moonwell MToken mint action\");\n/**\n * Input schema for Moonwell MToken redeem action.\n */\nexports.RedeemSchema = zod_1.z\n    .object({\n    mTokenAddress: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address of the Moonwell MToken to redeem from\"),\n    assets: zod_1.z\n        .string()\n        .regex(/^\\d+(\\.\\d+)?$/, \"Must be a valid integer or decimal value\")\n        .describe(\"The quantity of assets to redeem, in whole units\"),\n})\n    .strip()\n    .describe(\"Input schema for Moonwell MToken redeem action\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb29ud2VsbC9zY2hlbWFzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLGtCQUFrQjtBQUN6QyxjQUFjLG1CQUFPLENBQUMsdURBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL21vb253ZWxsL3NjaGVtYXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlZGVlbVNjaGVtYSA9IGV4cG9ydHMuTWludFNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBNb29ud2VsbCBNVG9rZW4gbWludCBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuTWludFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBhc3NldHM6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5yZWdleCgvXlxcZCsoXFwuXFxkKyk/JC8sIFwiTXVzdCBiZSBhIHZhbGlkIGludGVnZXIgb3IgZGVjaW1hbCB2YWx1ZVwiKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgcXVhbnRpdHkgb2YgYXNzZXRzIHRvIHVzZSB0byBtaW50LCBpbiB3aG9sZSB1bml0c1wiKSxcbiAgICB0b2tlbkFkZHJlc3M6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5yZWdleCgvXjB4W2EtZkEtRjAtOV17NDB9JC8sIFwiSW52YWxpZCBFdGhlcmV1bSBhZGRyZXNzIGZvcm1hdFwiKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgYWRkcmVzcyBvZiB0aGUgYXNzZXRzIHRva2VuIHRvIGFwcHJvdmUgZm9yIG1pbnRpbmdcIiksXG4gICAgbVRva2VuQWRkcmVzczogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eMHhbYS1mQS1GMC05XXs0MH0kLywgXCJJbnZhbGlkIEV0aGVyZXVtIGFkZHJlc3MgZm9ybWF0XCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBhZGRyZXNzIG9mIHRoZSBNb29ud2VsbCBNVG9rZW4gdG8gbWludCBmcm9tXCIpLFxufSlcbiAgICAuZGVzY3JpYmUoXCJJbnB1dCBzY2hlbWEgZm9yIE1vb253ZWxsIE1Ub2tlbiBtaW50IGFjdGlvblwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBNb29ud2VsbCBNVG9rZW4gcmVkZWVtIGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5SZWRlZW1TY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgbVRva2VuQWRkcmVzczogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eMHhbYS1mQS1GMC05XXs0MH0kLywgXCJJbnZhbGlkIEV0aGVyZXVtIGFkZHJlc3MgZm9ybWF0XCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBhZGRyZXNzIG9mIHRoZSBNb29ud2VsbCBNVG9rZW4gdG8gcmVkZWVtIGZyb21cIiksXG4gICAgYXNzZXRzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAucmVnZXgoL15cXGQrKFxcLlxcZCspPyQvLCBcIk11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyIG9yIGRlY2ltYWwgdmFsdWVcIilcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIHF1YW50aXR5IG9mIGFzc2V0cyB0byByZWRlZW0sIGluIHdob2xlIHVuaXRzXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIklucHV0IHNjaGVtYSBmb3IgTW9vbndlbGwgTVRva2VuIHJlZGVlbSBhY3Rpb25cIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/schemas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/constants.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/morpho/constants.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.METAMORPHO_ABI = exports.MORPHO_BASE_ADDRESS = void 0;\nexports.MORPHO_BASE_ADDRESS = \"0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb\";\nexports.METAMORPHO_ABI = [\n    {\n        inputs: [\n            { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n            { internalType: \"address\", name: \"receiver\", type: \"address\" },\n        ],\n        name: \"deposit\",\n        outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n            { internalType: \"address\", name: \"receiver\", type: \"address\" },\n            { internalType: \"address\", name: \"owner\", type: \"address\" },\n        ],\n        name: \"withdraw\",\n        outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb3JwaG8vY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLDJCQUEyQjtBQUNwRCwyQkFBMkI7QUFDM0Isc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLDBEQUEwRDtBQUN4RSxjQUFjLDREQUE0RDtBQUMxRTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUEwRDtBQUM5RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDBEQUEwRDtBQUN4RSxjQUFjLDREQUE0RDtBQUMxRSxjQUFjLHlEQUF5RDtBQUN2RTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUEwRDtBQUM5RTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL21vcnBoby9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1FVEFNT1JQSE9fQUJJID0gZXhwb3J0cy5NT1JQSE9fQkFTRV9BRERSRVNTID0gdm9pZCAwO1xuZXhwb3J0cy5NT1JQSE9fQkFTRV9BRERSRVNTID0gXCIweEJCQkJCYmJCQmI5Y0M1ZTkwZTNiM0FmNjRiZEFGNjJDMzdFRUZGQ2JcIjtcbmV4cG9ydHMuTUVUQU1PUlBIT19BQkkgPSBbXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJhc3NldHNcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJyZWNlaXZlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcImRlcG9zaXRcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJzaGFyZXNcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiYXNzZXRzXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwicmVjZWl2ZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJvd25lclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcIndpdGhkcmF3XCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwic2hhcmVzXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbl07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/morpho/index.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/schemas.js\"), exports);\n__exportStar(__webpack_require__(/*! ./morphoActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/morphoActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb3JwaG8vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLGtHQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyw0SEFBd0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvbW9ycGhvL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NoZW1hc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9ycGhvQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/morphoActionProvider.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/morpho/morphoActionProvider.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.morphoActionProvider = exports.MorphoActionProvider = exports.SUPPORTED_NETWORKS = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_cjs/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/utils.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/constants.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/schemas.js\");\nexports.SUPPORTED_NETWORKS = [\"base-mainnet\", \"base-sepolia\"];\n/**\n * MorphoActionProvider is an action provider for Morpho Vault interactions.\n */\nclass MorphoActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the MorphoActionProvider class.\n     */\n    constructor() {\n        super(\"morpho\", []);\n        /**\n         * Checks if the Morpho action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Morpho action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.protocolFamily === \"evm\" && exports.SUPPORTED_NETWORKS.includes(network.networkId);\n    }\n    /**\n     * Deposits assets into a Morpho Vault\n     *\n     * @param wallet - The wallet instance to execute the transaction\n     * @param args - The input arguments for the action\n     * @returns A success message with transaction details or an error message\n     */\n    async deposit(wallet, args) {\n        const assets = new decimal_js_1.Decimal(args.assets);\n        if (assets.comparedTo(new decimal_js_1.Decimal(0.0)) != 1) {\n            return \"Error: Assets amount must be greater than 0\";\n        }\n        try {\n            const atomicAssets = (0, viem_1.parseEther)(args.assets);\n            const approvalResult = await (0, utils_1.approve)(wallet, args.tokenAddress, args.vaultAddress, atomicAssets);\n            if (approvalResult.startsWith(\"Error\")) {\n                return `Error approving Morpho Vault as spender: ${approvalResult}`;\n            }\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.METAMORPHO_ABI,\n                functionName: \"deposit\",\n                args: [atomicAssets, args.receiver],\n            });\n            const txHash = await wallet.sendTransaction({\n                to: args.vaultAddress,\n                data,\n            });\n            const receipt = await wallet.waitForTransactionReceipt(txHash);\n            return `Deposited ${args.assets} to Morpho Vault ${args.vaultAddress} with transaction hash: ${txHash}\\nTransaction receipt: ${JSON.stringify(receipt)}`;\n        }\n        catch (error) {\n            return `Error depositing to Morpho Vault: ${error}`;\n        }\n    }\n    /**\n     * Withdraws assets from a Morpho Vault\n     *\n     * @param wallet - The wallet instance to execute the transaction\n     * @param args - The input arguments for the action\n     * @returns A success message with transaction details or an error message\n     */\n    async withdraw(wallet, args) {\n        if (BigInt(args.assets) <= 0) {\n            return \"Error: Assets amount must be greater than 0\";\n        }\n        try {\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.METAMORPHO_ABI,\n                functionName: \"withdraw\",\n                args: [BigInt(args.assets), args.receiver, args.receiver],\n            });\n            const txHash = await wallet.sendTransaction({\n                to: args.vaultAddress,\n                data,\n            });\n            const receipt = await wallet.waitForTransactionReceipt(txHash);\n            return `Withdrawn ${args.assets} from Morpho Vault ${args.vaultAddress} with transaction hash: ${txHash}\\nTransaction receipt: ${JSON.stringify(receipt)}`;\n        }\n        catch (error) {\n            return `Error withdrawing from Morpho Vault: ${error}`;\n        }\n    }\n}\nexports.MorphoActionProvider = MorphoActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"deposit\",\n        description: `\nThis tool allows depositing assets into a Morpho Vault. \n\nIt takes:\n- vaultAddress: The address of the Morpho Vault to deposit to\n- assets: The amount of assets to deposit in whole units\n  Examples for WETH:\n  - 1 WETH\n  - 0.1 WETH\n  - 0.01 WETH\n- receiver: The address to receive the shares\n- tokenAddress: The address of the token to approve\n\nImportant notes:\n- Make sure to use the exact amount provided. Do not convert units for assets for this action.\n- Please use a token address (example 0x4200000000000000000000000000000000000006) for the tokenAddress field.\n`,\n        schema: schemas_1.DepositSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], MorphoActionProvider.prototype, \"deposit\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"withdraw\",\n        description: `\nThis tool allows withdrawing assets from a Morpho Vault. It takes:\n\n- vaultAddress: The address of the Morpho Vault to withdraw from\n- assets: The amount of assets to withdraw in atomic units (wei)\n- receiver: The address to receive the shares\n`,\n        schema: schemas_1.WithdrawSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], MorphoActionProvider.prototype, \"withdraw\", null);\nconst morphoActionProvider = () => new MorphoActionProvider();\nexports.morphoActionProvider = morphoActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb3JwaG8vbW9ycGhvQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDRCQUE0QixHQUFHLDBCQUEwQjtBQUN4RixjQUFjLG1CQUFPLENBQUMsdURBQUs7QUFDM0IscUJBQXFCLG1CQUFPLENBQUMsOERBQVk7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCLHlCQUF5QixtQkFBTyxDQUFDLDBHQUFtQjtBQUNwRCwyQkFBMkIsbUJBQU8sQ0FBQyxzR0FBd0I7QUFDM0QsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELGdCQUFnQixtQkFBTyxDQUFDLDBFQUFhO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLHNHQUFhO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLGtHQUFXO0FBQ3JDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZUFBZTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQyxhQUFhLGtCQUFrQixtQkFBbUIseUJBQXlCLE9BQU8seUJBQXlCLHdCQUF3QjtBQUNuSztBQUNBO0FBQ0Esd0RBQXdELE1BQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQyxhQUFhLG9CQUFvQixtQkFBbUIseUJBQXlCLE9BQU8seUJBQXlCLHdCQUF3QjtBQUNySztBQUNBO0FBQ0EsMkRBQTJELE1BQU07QUFDakU7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb3JwaG8vbW9ycGhvQWN0aW9uUHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tb3JwaG9BY3Rpb25Qcm92aWRlciA9IGV4cG9ydHMuTW9ycGhvQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLlNVUFBPUlRFRF9ORVRXT1JLUyA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpO1xuY29uc3QgdmllbV8xID0gcmVxdWlyZShcInZpZW1cIik7XG5jb25zdCBhY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvblByb3ZpZGVyXCIpO1xuY29uc3Qgd2FsbGV0X3Byb3ZpZGVyc18xID0gcmVxdWlyZShcIi4uLy4uL3dhbGxldC1wcm92aWRlcnNcIik7XG5jb25zdCBhY3Rpb25EZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25EZWNvcmF0b3JcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBzY2hlbWFzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFzXCIpO1xuZXhwb3J0cy5TVVBQT1JURURfTkVUV09SS1MgPSBbXCJiYXNlLW1haW5uZXRcIiwgXCJiYXNlLXNlcG9saWFcIl07XG4vKipcbiAqIE1vcnBob0FjdGlvblByb3ZpZGVyIGlzIGFuIGFjdGlvbiBwcm92aWRlciBmb3IgTW9ycGhvIFZhdWx0IGludGVyYWN0aW9ucy5cbiAqL1xuY2xhc3MgTW9ycGhvQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIE1vcnBob0FjdGlvblByb3ZpZGVyIGNsYXNzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcIm1vcnBob1wiLCBbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIE1vcnBobyBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuZXR3b3JrIC0gVGhlIG5ldHdvcmsgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIE1vcnBobyBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIG5ldHdvcmssIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcG9ydHNOZXR3b3JrID0gKG5ldHdvcmspID0+IG5ldHdvcmsucHJvdG9jb2xGYW1pbHkgPT09IFwiZXZtXCIgJiYgZXhwb3J0cy5TVVBQT1JURURfTkVUV09SS1MuaW5jbHVkZXMobmV0d29yay5uZXR3b3JrSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBvc2l0cyBhc3NldHMgaW50byBhIE1vcnBobyBWYXVsdFxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgaW5zdGFuY2UgdG8gZXhlY3V0ZSB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb25cbiAgICAgKiBAcmV0dXJucyBBIHN1Y2Nlc3MgbWVzc2FnZSB3aXRoIHRyYW5zYWN0aW9uIGRldGFpbHMgb3IgYW4gZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIGRlcG9zaXQod2FsbGV0LCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0cyA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbChhcmdzLmFzc2V0cyk7XG4gICAgICAgIGlmIChhc3NldHMuY29tcGFyZWRUbyhuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoMC4wKSkgIT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IEFzc2V0cyBhbW91bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhdG9taWNBc3NldHMgPSAoMCwgdmllbV8xLnBhcnNlRXRoZXIpKGFyZ3MuYXNzZXRzKTtcbiAgICAgICAgICAgIGNvbnN0IGFwcHJvdmFsUmVzdWx0ID0gYXdhaXQgKDAsIHV0aWxzXzEuYXBwcm92ZSkod2FsbGV0LCBhcmdzLnRva2VuQWRkcmVzcywgYXJncy52YXVsdEFkZHJlc3MsIGF0b21pY0Fzc2V0cyk7XG4gICAgICAgICAgICBpZiAoYXBwcm92YWxSZXN1bHQuc3RhcnRzV2l0aChcIkVycm9yXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBhcHByb3ZpbmcgTW9ycGhvIFZhdWx0IGFzIHNwZW5kZXI6ICR7YXBwcm92YWxSZXN1bHR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuTUVUQU1PUlBIT19BQkksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImRlcG9zaXRcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbYXRvbWljQXNzZXRzLCBhcmdzLnJlY2VpdmVyXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdG86IGFyZ3MudmF1bHRBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB3YWxsZXQud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIGBEZXBvc2l0ZWQgJHthcmdzLmFzc2V0c30gdG8gTW9ycGhvIFZhdWx0ICR7YXJncy52YXVsdEFkZHJlc3N9IHdpdGggdHJhbnNhY3Rpb24gaGFzaDogJHt0eEhhc2h9XFxuVHJhbnNhY3Rpb24gcmVjZWlwdDogJHtKU09OLnN0cmluZ2lmeShyZWNlaXB0KX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBkZXBvc2l0aW5nIHRvIE1vcnBobyBWYXVsdDogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpdGhkcmF3cyBhc3NldHMgZnJvbSBhIE1vcnBobyBWYXVsdFxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgaW5zdGFuY2UgdG8gZXhlY3V0ZSB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb25cbiAgICAgKiBAcmV0dXJucyBBIHN1Y2Nlc3MgbWVzc2FnZSB3aXRoIHRyYW5zYWN0aW9uIGRldGFpbHMgb3IgYW4gZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIHdpdGhkcmF3KHdhbGxldCwgYXJncykge1xuICAgICAgICBpZiAoQmlnSW50KGFyZ3MuYXNzZXRzKSA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogQXNzZXRzIGFtb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuTUVUQU1PUlBIT19BQkksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcIndpdGhkcmF3XCIsXG4gICAgICAgICAgICAgICAgYXJnczogW0JpZ0ludChhcmdzLmFzc2V0cyksIGFyZ3MucmVjZWl2ZXIsIGFyZ3MucmVjZWl2ZXJdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCB3YWxsZXQuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0bzogYXJncy52YXVsdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHdhbGxldC53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gYFdpdGhkcmF3biAke2FyZ3MuYXNzZXRzfSBmcm9tIE1vcnBobyBWYXVsdCAke2FyZ3MudmF1bHRBZGRyZXNzfSB3aXRoIHRyYW5zYWN0aW9uIGhhc2g6ICR7dHhIYXNofVxcblRyYW5zYWN0aW9uIHJlY2VpcHQ6ICR7SlNPTi5zdHJpbmdpZnkocmVjZWlwdCl9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3Igd2l0aGRyYXdpbmcgZnJvbSBNb3JwaG8gVmF1bHQ6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTW9ycGhvQWN0aW9uUHJvdmlkZXIgPSBNb3JwaG9BY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJkZXBvc2l0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgYWxsb3dzIGRlcG9zaXRpbmcgYXNzZXRzIGludG8gYSBNb3JwaG8gVmF1bHQuIFxuXG5JdCB0YWtlczpcbi0gdmF1bHRBZGRyZXNzOiBUaGUgYWRkcmVzcyBvZiB0aGUgTW9ycGhvIFZhdWx0IHRvIGRlcG9zaXQgdG9cbi0gYXNzZXRzOiBUaGUgYW1vdW50IG9mIGFzc2V0cyB0byBkZXBvc2l0IGluIHdob2xlIHVuaXRzXG4gIEV4YW1wbGVzIGZvciBXRVRIOlxuICAtIDEgV0VUSFxuICAtIDAuMSBXRVRIXG4gIC0gMC4wMSBXRVRIXG4tIHJlY2VpdmVyOiBUaGUgYWRkcmVzcyB0byByZWNlaXZlIHRoZSBzaGFyZXNcbi0gdG9rZW5BZGRyZXNzOiBUaGUgYWRkcmVzcyBvZiB0aGUgdG9rZW4gdG8gYXBwcm92ZVxuXG5JbXBvcnRhbnQgbm90ZXM6XG4tIE1ha2Ugc3VyZSB0byB1c2UgdGhlIGV4YWN0IGFtb3VudCBwcm92aWRlZC4gRG8gbm90IGNvbnZlcnQgdW5pdHMgZm9yIGFzc2V0cyBmb3IgdGhpcyBhY3Rpb24uXG4tIFBsZWFzZSB1c2UgYSB0b2tlbiBhZGRyZXNzIChleGFtcGxlIDB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNikgZm9yIHRoZSB0b2tlbkFkZHJlc3MgZmllbGQuXG5gLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5EZXBvc2l0U2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgTW9ycGhvQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImRlcG9zaXRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwid2l0aGRyYXdcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCBhbGxvd3Mgd2l0aGRyYXdpbmcgYXNzZXRzIGZyb20gYSBNb3JwaG8gVmF1bHQuIEl0IHRha2VzOlxuXG4tIHZhdWx0QWRkcmVzczogVGhlIGFkZHJlc3Mgb2YgdGhlIE1vcnBobyBWYXVsdCB0byB3aXRoZHJhdyBmcm9tXG4tIGFzc2V0czogVGhlIGFtb3VudCBvZiBhc3NldHMgdG8gd2l0aGRyYXcgaW4gYXRvbWljIHVuaXRzICh3ZWkpXG4tIHJlY2VpdmVyOiBUaGUgYWRkcmVzcyB0byByZWNlaXZlIHRoZSBzaGFyZXNcbmAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLldpdGhkcmF3U2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgTW9ycGhvQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcIndpdGhkcmF3XCIsIG51bGwpO1xuY29uc3QgbW9ycGhvQWN0aW9uUHJvdmlkZXIgPSAoKSA9PiBuZXcgTW9ycGhvQWN0aW9uUHJvdmlkZXIoKTtcbmV4cG9ydHMubW9ycGhvQWN0aW9uUHJvdmlkZXIgPSBtb3JwaG9BY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/morphoActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/schemas.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/morpho/schemas.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WithdrawSchema = exports.DepositSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\n/**\n * Input schema for Morpho Vault deposit action.\n */\nexports.DepositSchema = zod_1.z\n    .object({\n    assets: zod_1.z\n        .string()\n        .regex(/^\\d+(\\.\\d+)?$/, \"Must be a valid integer or decimal value\")\n        .describe(\"The quantity of assets to deposit, in whole units\"),\n    receiver: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address that will own the position on the vault which will receive the shares\"),\n    tokenAddress: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address of the assets token to approve for deposit\"),\n    vaultAddress: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address of the Morpho Vault to deposit to\"),\n})\n    .describe(\"Input schema for Morpho Vault deposit action\");\n/**\n * Input schema for Morpho Vault withdraw action.\n */\nexports.WithdrawSchema = zod_1.z\n    .object({\n    vaultAddress: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address of the Morpho Vault to withdraw from\"),\n    assets: zod_1.z\n        .string()\n        .regex(/^\\d+$/, \"Must be a valid whole number\")\n        .describe(\"The amount of assets to withdraw in atomic units e.g. 1\"),\n    receiver: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address to receive the shares\"),\n})\n    .strip()\n    .describe(\"Input schema for Morpho Vault withdraw action\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb3JwaG8vc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxxQkFBcUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLHVEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb3JwaG8vc2NoZW1hcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2l0aGRyYXdTY2hlbWEgPSBleHBvcnRzLkRlcG9zaXRTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgTW9ycGhvIFZhdWx0IGRlcG9zaXQgYWN0aW9uLlxuICovXG5leHBvcnRzLkRlcG9zaXRTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgYXNzZXRzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAucmVnZXgoL15cXGQrKFxcLlxcZCspPyQvLCBcIk11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyIG9yIGRlY2ltYWwgdmFsdWVcIilcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIHF1YW50aXR5IG9mIGFzc2V0cyB0byBkZXBvc2l0LCBpbiB3aG9sZSB1bml0c1wiKSxcbiAgICByZWNlaXZlcjogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eMHhbYS1mQS1GMC05XXs0MH0kLywgXCJJbnZhbGlkIEV0aGVyZXVtIGFkZHJlc3MgZm9ybWF0XCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBhZGRyZXNzIHRoYXQgd2lsbCBvd24gdGhlIHBvc2l0aW9uIG9uIHRoZSB2YXVsdCB3aGljaCB3aWxsIHJlY2VpdmUgdGhlIHNoYXJlc1wiKSxcbiAgICB0b2tlbkFkZHJlc3M6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5yZWdleCgvXjB4W2EtZkEtRjAtOV17NDB9JC8sIFwiSW52YWxpZCBFdGhlcmV1bSBhZGRyZXNzIGZvcm1hdFwiKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgYWRkcmVzcyBvZiB0aGUgYXNzZXRzIHRva2VuIHRvIGFwcHJvdmUgZm9yIGRlcG9zaXRcIiksXG4gICAgdmF1bHRBZGRyZXNzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAucmVnZXgoL14weFthLWZBLUYwLTldezQwfSQvLCBcIkludmFsaWQgRXRoZXJldW0gYWRkcmVzcyBmb3JtYXRcIilcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIGFkZHJlc3Mgb2YgdGhlIE1vcnBobyBWYXVsdCB0byBkZXBvc2l0IHRvXCIpLFxufSlcbiAgICAuZGVzY3JpYmUoXCJJbnB1dCBzY2hlbWEgZm9yIE1vcnBobyBWYXVsdCBkZXBvc2l0IGFjdGlvblwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBNb3JwaG8gVmF1bHQgd2l0aGRyYXcgYWN0aW9uLlxuICovXG5leHBvcnRzLldpdGhkcmF3U2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHZhdWx0QWRkcmVzczogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eMHhbYS1mQS1GMC05XXs0MH0kLywgXCJJbnZhbGlkIEV0aGVyZXVtIGFkZHJlc3MgZm9ybWF0XCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBhZGRyZXNzIG9mIHRoZSBNb3JwaG8gVmF1bHQgdG8gd2l0aGRyYXcgZnJvbVwiKSxcbiAgICBhc3NldHM6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5yZWdleCgvXlxcZCskLywgXCJNdXN0IGJlIGEgdmFsaWQgd2hvbGUgbnVtYmVyXCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBhbW91bnQgb2YgYXNzZXRzIHRvIHdpdGhkcmF3IGluIGF0b21pYyB1bml0cyBlLmcuIDFcIiksXG4gICAgcmVjZWl2ZXI6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5yZWdleCgvXjB4W2EtZkEtRjAtOV17NDB9JC8sIFwiSW52YWxpZCBFdGhlcmV1bSBhZGRyZXNzIGZvcm1hdFwiKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgYWRkcmVzcyB0byByZWNlaXZlIHRoZSBzaGFyZXNcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciBNb3JwaG8gVmF1bHQgd2l0aGRyYXcgYWN0aW9uXCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/schemas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/pyth/index.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./pythActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/pythActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/schemas.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9weXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxzSEFBc0I7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLGdHQUFXIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL3B5dGgvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9weXRoQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NjaGVtYXNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/pythActionProvider.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/pyth/pythActionProvider.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pythActionProvider = exports.PythActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/schemas.js\");\n/**\n * PythActionProvider is an action provider for Pyth.\n */\nclass PythActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructs a new PythActionProvider.\n     */\n    constructor() {\n        super(\"pyth\", []);\n        /**\n         * Checks if the Pyth action provider supports the given network.\n         *\n         * @returns True if the Pyth action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = () => true;\n    }\n    /**\n     * Fetch the price feed ID for a given token symbol from Pyth.\n     *\n     * @param args - The arguments for the action.\n     * @returns The price feed ID as a string.\n     */\n    async fetchPriceFeed(args) {\n        const url = `https://hermes.pyth.network/v2/price_feeds?query=${args.tokenSymbol}&asset_type=crypto`;\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        if (data.length === 0) {\n            throw new Error(`No price feed found for ${args.tokenSymbol}`);\n        }\n        const filteredData = data.filter(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (item) => item.attributes.base.toLowerCase() === args.tokenSymbol.toLowerCase());\n        if (filteredData.length === 0) {\n            throw new Error(`No price feed found for ${args.tokenSymbol}`);\n        }\n        return filteredData[0].id;\n    }\n    /**\n     * Fetches the price from Pyth given a Pyth price feed ID.\n     *\n     * @param args - The arguments for the action.\n     * @returns The price as a string.\n     */\n    async fetchPrice(args) {\n        const url = `https://hermes.pyth.network/v2/updates/price/latest?ids[]=${args.priceFeedID}`;\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        const parsedData = data.parsed;\n        if (parsedData.length === 0) {\n            throw new Error(`No price data found for ${args.priceFeedID}`);\n        }\n        const priceInfo = parsedData[0].price;\n        const price = BigInt(priceInfo.price);\n        const exponent = priceInfo.expo;\n        if (exponent < 0) {\n            const adjustedPrice = price * BigInt(100);\n            const divisor = BigInt(10) ** BigInt(-exponent);\n            const scaledPrice = adjustedPrice / BigInt(divisor);\n            const priceStr = scaledPrice.toString();\n            const formattedPrice = `${priceStr.slice(0, -2)}.${priceStr.slice(-2)}`;\n            return formattedPrice.startsWith(\".\") ? `0${formattedPrice}` : formattedPrice;\n        }\n        const scaledPrice = price / BigInt(10) ** BigInt(exponent);\n        return scaledPrice.toString();\n    }\n}\nexports.PythActionProvider = PythActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"fetch_price_feed\",\n        description: \"Fetch the price feed ID for a given token symbol from Pyth.\",\n        schema: schemas_1.PythFetchPriceFeedIDSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], PythActionProvider.prototype, \"fetchPriceFeed\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"fetch_price\",\n        description: `Fetch the price of a given price feed from Pyth.\n\nInputs:\n- Pyth price feed ID\n\nImportant notes:\n- Do not assume that a random ID is a Pyth price feed ID. If you are confused, ask a clarifying question.\n- This action only fetches price inputs from Pyth price feeds. No other source.\n- If you are asked to fetch the price from Pyth for a ticker symbol such as BTC, you must first use the pyth_fetch_price_feed_id\naction to retrieve the price feed ID before invoking the pyth_Fetch_price action\n`,\n        schema: schemas_1.PythFetchPriceSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], PythActionProvider.prototype, \"fetchPrice\", null);\nconst pythActionProvider = () => new PythActionProvider();\nexports.pythActionProvider = pythActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9weXRoL3B5dGhBY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyx1REFBSztBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLGdHQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsaUJBQWlCO0FBQ3pGO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxpQkFBaUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxpQkFBaUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsaUJBQWlCO0FBQ2xHO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGlCQUFpQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCLEdBQUcsbUJBQW1CO0FBQ2xGLHdEQUF3RCxlQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9weXRoL3B5dGhBY3Rpb25Qcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnB5dGhBY3Rpb25Qcm92aWRlciA9IGV4cG9ydHMuUHl0aEFjdGlvblByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgYWN0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25Qcm92aWRlclwiKTtcbmNvbnN0IGFjdGlvbkRlY29yYXRvcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvbkRlY29yYXRvclwiKTtcbmNvbnN0IHNjaGVtYXNfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYXNcIik7XG4vKipcbiAqIFB5dGhBY3Rpb25Qcm92aWRlciBpcyBhbiBhY3Rpb24gcHJvdmlkZXIgZm9yIFB5dGguXG4gKi9cbmNsYXNzIFB5dGhBY3Rpb25Qcm92aWRlciBleHRlbmRzIGFjdGlvblByb3ZpZGVyXzEuQWN0aW9uUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgUHl0aEFjdGlvblByb3ZpZGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInB5dGhcIiwgW10pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBQeXRoIGFjdGlvbiBwcm92aWRlciBzdXBwb3J0cyB0aGUgZ2l2ZW4gbmV0d29yay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgUHl0aCBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIG5ldHdvcmssIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcG9ydHNOZXR3b3JrID0gKCkgPT4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIHByaWNlIGZlZWQgSUQgZm9yIGEgZ2l2ZW4gdG9rZW4gc3ltYm9sIGZyb20gUHl0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgcHJpY2UgZmVlZCBJRCBhcyBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFByaWNlRmVlZChhcmdzKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGBodHRwczovL2hlcm1lcy5weXRoLm5ldHdvcmsvdjIvcHJpY2VfZmVlZHM/cXVlcnk9JHthcmdzLnRva2VuU3ltYm9sfSZhc3NldF90eXBlPWNyeXB0b2A7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBwcmljZSBmZWVkIGZvdW5kIGZvciAke2FyZ3MudG9rZW5TeW1ib2x9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyZWREYXRhID0gZGF0YS5maWx0ZXIoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIChpdGVtKSA9PiBpdGVtLmF0dHJpYnV0ZXMuYmFzZS50b0xvd2VyQ2FzZSgpID09PSBhcmdzLnRva2VuU3ltYm9sLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoZmlsdGVyZWREYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBwcmljZSBmZWVkIGZvdW5kIGZvciAke2FyZ3MudG9rZW5TeW1ib2x9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkRGF0YVswXS5pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgcHJpY2UgZnJvbSBQeXRoIGdpdmVuIGEgUHl0aCBwcmljZSBmZWVkIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBwcmljZSBhcyBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFByaWNlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi8vaGVybWVzLnB5dGgubmV0d29yay92Mi91cGRhdGVzL3ByaWNlL2xhdGVzdD9pZHNbXT0ke2FyZ3MucHJpY2VGZWVkSUR9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IGRhdGEucGFyc2VkO1xuICAgICAgICBpZiAocGFyc2VkRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcHJpY2UgZGF0YSBmb3VuZCBmb3IgJHthcmdzLnByaWNlRmVlZElEfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaWNlSW5mbyA9IHBhcnNlZERhdGFbMF0ucHJpY2U7XG4gICAgICAgIGNvbnN0IHByaWNlID0gQmlnSW50KHByaWNlSW5mby5wcmljZSk7XG4gICAgICAgIGNvbnN0IGV4cG9uZW50ID0gcHJpY2VJbmZvLmV4cG87XG4gICAgICAgIGlmIChleHBvbmVudCA8IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkUHJpY2UgPSBwcmljZSAqIEJpZ0ludCgxMDApO1xuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IEJpZ0ludCgxMCkgKiogQmlnSW50KC1leHBvbmVudCk7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRQcmljZSA9IGFkanVzdGVkUHJpY2UgLyBCaWdJbnQoZGl2aXNvcik7XG4gICAgICAgICAgICBjb25zdCBwcmljZVN0ciA9IHNjYWxlZFByaWNlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRQcmljZSA9IGAke3ByaWNlU3RyLnNsaWNlKDAsIC0yKX0uJHtwcmljZVN0ci5zbGljZSgtMil9YDtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZWRQcmljZS5zdGFydHNXaXRoKFwiLlwiKSA/IGAwJHtmb3JtYXR0ZWRQcmljZX1gIDogZm9ybWF0dGVkUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NhbGVkUHJpY2UgPSBwcmljZSAvIEJpZ0ludCgxMCkgKiogQmlnSW50KGV4cG9uZW50KTtcbiAgICAgICAgcmV0dXJuIHNjYWxlZFByaWNlLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5QeXRoQWN0aW9uUHJvdmlkZXIgPSBQeXRoQWN0aW9uUHJvdmlkZXI7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiZmV0Y2hfcHJpY2VfZmVlZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJGZXRjaCB0aGUgcHJpY2UgZmVlZCBJRCBmb3IgYSBnaXZlbiB0b2tlbiBzeW1ib2wgZnJvbSBQeXRoLlwiLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5QeXRoRmV0Y2hQcmljZUZlZWRJRFNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBQeXRoQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImZldGNoUHJpY2VGZWVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcImZldGNoX3ByaWNlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgRmV0Y2ggdGhlIHByaWNlIG9mIGEgZ2l2ZW4gcHJpY2UgZmVlZCBmcm9tIFB5dGguXG5cbklucHV0czpcbi0gUHl0aCBwcmljZSBmZWVkIElEXG5cbkltcG9ydGFudCBub3Rlczpcbi0gRG8gbm90IGFzc3VtZSB0aGF0IGEgcmFuZG9tIElEIGlzIGEgUHl0aCBwcmljZSBmZWVkIElELiBJZiB5b3UgYXJlIGNvbmZ1c2VkLCBhc2sgYSBjbGFyaWZ5aW5nIHF1ZXN0aW9uLlxuLSBUaGlzIGFjdGlvbiBvbmx5IGZldGNoZXMgcHJpY2UgaW5wdXRzIGZyb20gUHl0aCBwcmljZSBmZWVkcy4gTm8gb3RoZXIgc291cmNlLlxuLSBJZiB5b3UgYXJlIGFza2VkIHRvIGZldGNoIHRoZSBwcmljZSBmcm9tIFB5dGggZm9yIGEgdGlja2VyIHN5bWJvbCBzdWNoIGFzIEJUQywgeW91IG11c3QgZmlyc3QgdXNlIHRoZSBweXRoX2ZldGNoX3ByaWNlX2ZlZWRfaWRcbmFjdGlvbiB0byByZXRyaWV2ZSB0aGUgcHJpY2UgZmVlZCBJRCBiZWZvcmUgaW52b2tpbmcgdGhlIHB5dGhfRmV0Y2hfcHJpY2UgYWN0aW9uXG5gLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5QeXRoRmV0Y2hQcmljZVNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBQeXRoQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImZldGNoUHJpY2VcIiwgbnVsbCk7XG5jb25zdCBweXRoQWN0aW9uUHJvdmlkZXIgPSAoKSA9PiBuZXcgUHl0aEFjdGlvblByb3ZpZGVyKCk7XG5leHBvcnRzLnB5dGhBY3Rpb25Qcm92aWRlciA9IHB5dGhBY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/pythActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/schemas.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/pyth/schemas.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PythFetchPriceSchema = exports.PythFetchPriceFeedIDSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\n/**\n * Input schema for Pyth fetch price feed ID action.\n */\nexports.PythFetchPriceFeedIDSchema = zod_1.z\n    .object({\n    tokenSymbol: zod_1.z.string().describe(\"The token symbol to fetch the price feed ID for\"),\n})\n    .strict();\n/**\n * Input schema for Pyth fetch price action.\n */\nexports.PythFetchPriceSchema = zod_1.z\n    .object({\n    priceFeedID: zod_1.z.string().describe(\"The price feed ID to fetch the price for\"),\n})\n    .strict();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9weXRoL3NjaGVtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsa0NBQWtDO0FBQ2pFLGNBQWMsbUJBQU8sQ0FBQyx1REFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL3B5dGgvc2NoZW1hcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHl0aEZldGNoUHJpY2VTY2hlbWEgPSBleHBvcnRzLlB5dGhGZXRjaFByaWNlRmVlZElEU2NoZW1hID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIFB5dGggZmV0Y2ggcHJpY2UgZmVlZCBJRCBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuUHl0aEZldGNoUHJpY2VGZWVkSURTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdG9rZW5TeW1ib2w6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgdG9rZW4gc3ltYm9sIHRvIGZldGNoIHRoZSBwcmljZSBmZWVkIElEIGZvclwiKSxcbn0pXG4gICAgLnN0cmljdCgpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIFB5dGggZmV0Y2ggcHJpY2UgYWN0aW9uLlxuICovXG5leHBvcnRzLlB5dGhGZXRjaFByaWNlU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHByaWNlRmVlZElEOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIHByaWNlIGZlZWQgSUQgdG8gZmV0Y2ggdGhlIHByaWNlIGZvclwiKSxcbn0pXG4gICAgLnN0cmljdCgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/schemas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/twitter/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/schemas.js\"), exports);\n__exportStar(__webpack_require__(/*! ./twitterActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/twitterActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy90d2l0dGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxtR0FBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMsK0hBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL3R3aXR0ZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY2hlbWFzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90d2l0dGVyQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/schemas.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/twitter/schemas.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TwitterPostTweetReplySchema = exports.TwitterPostTweetSchema = exports.TwitterAccountMentionsSchema = exports.TwitterAccountDetailsSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\n/**\n * Input schema for retrieving account details.\n */\nexports.TwitterAccountDetailsSchema = zod_1.z\n    .object({})\n    .strip()\n    .describe(\"Input schema for retrieving account details\");\n/**\n * Input schema for retrieving account mentions.\n */\nexports.TwitterAccountMentionsSchema = zod_1.z\n    .object({\n    userId: zod_1.z\n        .string()\n        .min(1, \"Account ID is required.\")\n        .describe(\"The Twitter (X) user id to return mentions for\"),\n})\n    .strip()\n    .describe(\"Input schema for retrieving account mentions\");\n/**\n * Input schema for posting a tweet.\n */\nexports.TwitterPostTweetSchema = zod_1.z\n    .object({\n    tweet: zod_1.z.string().max(280, \"Tweet must be a maximum of 280 characters.\"),\n})\n    .strip()\n    .describe(\"Input schema for posting a tweet\");\n/**\n * Input schema for posting a tweet reply.\n */\nexports.TwitterPostTweetReplySchema = zod_1.z\n    .object({\n    tweetId: zod_1.z.string().describe(\"The id of the tweet to reply to\"),\n    tweetReply: zod_1.z\n        .string()\n        .max(280, \"The reply to the tweet which must be a maximum of 280 characters.\"),\n})\n    .strip()\n    .describe(\"Input schema for posting a tweet reply\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy90d2l0dGVyL3NjaGVtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUNBQW1DLEdBQUcsOEJBQThCLEdBQUcsb0NBQW9DLEdBQUcsbUNBQW1DO0FBQ2pKLGNBQWMsbUJBQU8sQ0FBQyx1REFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvdHdpdHRlci9zY2hlbWFzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ud2l0dGVyUG9zdFR3ZWV0UmVwbHlTY2hlbWEgPSBleHBvcnRzLlR3aXR0ZXJQb3N0VHdlZXRTY2hlbWEgPSBleHBvcnRzLlR3aXR0ZXJBY2NvdW50TWVudGlvbnNTY2hlbWEgPSBleHBvcnRzLlR3aXR0ZXJBY2NvdW50RGV0YWlsc1NjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciByZXRyaWV2aW5nIGFjY291bnQgZGV0YWlscy5cbiAqL1xuZXhwb3J0cy5Ud2l0dGVyQWNjb3VudERldGFpbHNTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7fSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIklucHV0IHNjaGVtYSBmb3IgcmV0cmlldmluZyBhY2NvdW50IGRldGFpbHNcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgcmV0cmlldmluZyBhY2NvdW50IG1lbnRpb25zLlxuICovXG5leHBvcnRzLlR3aXR0ZXJBY2NvdW50TWVudGlvbnNTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdXNlcklkOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAubWluKDEsIFwiQWNjb3VudCBJRCBpcyByZXF1aXJlZC5cIilcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIFR3aXR0ZXIgKFgpIHVzZXIgaWQgdG8gcmV0dXJuIG1lbnRpb25zIGZvclwiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnB1dCBzY2hlbWEgZm9yIHJldHJpZXZpbmcgYWNjb3VudCBtZW50aW9uc1wiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBwb3N0aW5nIGEgdHdlZXQuXG4gKi9cbmV4cG9ydHMuVHdpdHRlclBvc3RUd2VldFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICB0d2VldDogem9kXzEuei5zdHJpbmcoKS5tYXgoMjgwLCBcIlR3ZWV0IG11c3QgYmUgYSBtYXhpbXVtIG9mIDI4MCBjaGFyYWN0ZXJzLlwiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnB1dCBzY2hlbWEgZm9yIHBvc3RpbmcgYSB0d2VldFwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBwb3N0aW5nIGEgdHdlZXQgcmVwbHkuXG4gKi9cbmV4cG9ydHMuVHdpdHRlclBvc3RUd2VldFJlcGx5U2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHR3ZWV0SWQ6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgaWQgb2YgdGhlIHR3ZWV0IHRvIHJlcGx5IHRvXCIpLFxuICAgIHR3ZWV0UmVwbHk6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5tYXgoMjgwLCBcIlRoZSByZXBseSB0byB0aGUgdHdlZXQgd2hpY2ggbXVzdCBiZSBhIG1heGltdW0gb2YgMjgwIGNoYXJhY3RlcnMuXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIklucHV0IHNjaGVtYSBmb3IgcG9zdGluZyBhIHR3ZWV0IHJlcGx5XCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/schemas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/twitterActionProvider.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/twitter/twitterActionProvider.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.twitterActionProvider = exports.TwitterActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst twitter_api_v2_1 = __webpack_require__(/*! twitter-api-v2 */ \"(ssr)/./node_modules/twitter-api-v2/dist/esm/index.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/schemas.js\");\n/**\n * TwitterActionProvider is an action provider for Twitter (X) interactions.\n *\n * @augments ActionProvider\n */\nclass TwitterActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the TwitterActionProvider class.\n     *\n     * @param config - The configuration options for the TwitterActionProvider\n     */\n    constructor(config = {}) {\n        super(\"twitter\", []);\n        config.apiKey || (config.apiKey = process.env.TWITTER_API_KEY);\n        config.apiSecret || (config.apiSecret = process.env.TWITTER_API_SECRET);\n        config.accessToken || (config.accessToken = process.env.TWITTER_ACCESS_TOKEN);\n        config.accessTokenSecret || (config.accessTokenSecret = process.env.TWITTER_ACCESS_TOKEN_SECRET);\n        if (!config.apiKey) {\n            throw new Error(\"TWITTER_API_KEY is not configured.\");\n        }\n        if (!config.apiSecret) {\n            throw new Error(\"TWITTER_API_SECRET is not configured.\");\n        }\n        if (!config.accessToken) {\n            throw new Error(\"TWITTER_ACCESS_TOKEN is not configured.\");\n        }\n        if (!config.accessTokenSecret) {\n            throw new Error(\"TWITTER_ACCESS_TOKEN_SECRET is not configured.\");\n        }\n        this.client = new twitter_api_v2_1.TwitterApi({\n            appKey: config.apiKey,\n            appSecret: config.apiSecret,\n            accessToken: config.accessToken,\n            accessSecret: config.accessTokenSecret,\n        });\n    }\n    /**\n     * Get account details for the currently authenticated Twitter (X) user.\n     *\n     * @param _ - Empty parameter object (not used)\n     * @returns A JSON string containing the account details or error message\n     */\n    async accountDetails(_) {\n        try {\n            const response = await this.client.v2.me();\n            response.data.url = `https://x.com/${response.data.username}`;\n            return `Successfully retrieved authenticated user account details:\\n${JSON.stringify(response)}`;\n        }\n        catch (error) {\n            return `Error retrieving authenticated user account details: ${error}`;\n        }\n    }\n    /**\n     * Get mentions for a specified Twitter (X) user.\n     *\n     * @param args - The arguments containing userId\n     * @returns A JSON string containing the mentions or error message\n     */\n    async accountMentions(args) {\n        try {\n            const response = await this.client.v2.userMentionTimeline(args.userId);\n            return `Successfully retrieved account mentions:\\n${JSON.stringify(response)}`;\n        }\n        catch (error) {\n            return `Error retrieving authenticated account mentions: ${error}`;\n        }\n    }\n    /**\n     * Post a tweet on Twitter (X).\n     *\n     * @param args - The arguments containing the tweet text\n     * @returns A JSON string containing the posted tweet details or error message\n     */\n    async postTweet(args) {\n        try {\n            const response = await this.client.v2.tweet(args.tweet);\n            return `Successfully posted to Twitter:\\n${JSON.stringify(response)}`;\n        }\n        catch (error) {\n            return `Error posting to Twitter:\\n${error}`;\n        }\n    }\n    /**\n     * Post a reply to a tweet on Twitter (X).\n     *\n     * @param args - The arguments containing the reply text and tweet ID\n     * @returns A JSON string containing the posted reply details or error message\n     */\n    async postTweetReply(args) {\n        try {\n            const response = await this.client.v2.tweet(args.tweetReply, {\n                reply: { in_reply_to_tweet_id: args.tweetId },\n            });\n            return `Successfully posted reply to Twitter:\\n${JSON.stringify(response)}`;\n        }\n        catch (error) {\n            return `Error posting reply to Twitter: ${error}`;\n        }\n    }\n    /**\n     * Checks if the Twitter action provider supports the given network.\n     * Twitter actions don't depend on blockchain networks, so always return true.\n     *\n     * @param _ - The network to check (not used)\n     * @returns Always returns true as Twitter actions are network-independent\n     */\n    supportsNetwork(_) {\n        return true;\n    }\n}\nexports.TwitterActionProvider = TwitterActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"account_details\",\n        description: `\nThis tool will return account details for the currently authenticated Twitter (X) user context.\n\nA successful response will return a message with the api response as a json payload:\n    {\"data\": {\"id\": \"1853889445319331840\", \"name\": \"CDP AgentKit\", \"username\": \"CDPAgentKit\"}}\n\nA failure response will return a message with a Twitter API request error:\n    Error retrieving authenticated user account: 429 Too Many Requests`,\n        schema: schemas_1.TwitterAccountDetailsSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], TwitterActionProvider.prototype, \"accountDetails\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"account_mentions\",\n        description: `\nThis tool will return mentions for the specified Twitter (X) user id.\n\nA successful response will return a message with the API response as a JSON payload:\n    {\"data\": [{\"id\": \"1857479287504584856\", \"text\": \"@CDPAgentKit reply\"}]}\n\nA failure response will return a message with the Twitter API request error:\n    Error retrieving user mentions: 429 Too Many Requests`,\n        schema: schemas_1.TwitterAccountMentionsSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], TwitterActionProvider.prototype, \"accountMentions\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"post_tweet\",\n        description: `\nThis tool will post a tweet on Twitter. The tool takes the text of the tweet as input. Tweets can be maximum 280 characters.\n\nA successful response will return a message with the API response as a JSON payload:\n    {\"data\": {\"text\": \"hello, world!\", \"id\": \"0123456789012345678\", \"edit_history_tweet_ids\": [\"0123456789012345678\"]}}\n\nA failure response will return a message with the Twitter API request error:\n    You are not allowed to create a Tweet with duplicate content.`,\n        schema: schemas_1.TwitterPostTweetSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], TwitterActionProvider.prototype, \"postTweet\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"post_tweet_reply\",\n        description: `\nThis tool will post a tweet on Twitter. The tool takes the text of the tweet as input. Tweets can be maximum 280 characters.\n\nA successful response will return a message with the API response as a JSON payload:\n    {\"data\": {\"text\": \"hello, world!\", \"id\": \"0123456789012345678\", \"edit_history_tweet_ids\": [\"0123456789012345678\"]}}\n\nA failure response will return a message with the Twitter API request error:\n    You are not allowed to create a Tweet with duplicate content.`,\n        schema: schemas_1.TwitterPostTweetReplySchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], TwitterActionProvider.prototype, \"postTweetReply\", null);\n/**\n * Factory function to create a new TwitterActionProvider instance.\n *\n * @param config - The configuration options for the TwitterActionProvider\n * @returns A new instance of TwitterActionProvider\n */\nconst twitterActionProvider = (config = {}) => new TwitterActionProvider(config);\nexports.twitterActionProvider = twitterActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy90d2l0dGVyL3R3aXR0ZXJBY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsNkJBQTZCO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyx1REFBSztBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELHlCQUF5QixtQkFBTyxDQUFDLDZFQUFnQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxtR0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVCQUF1QjtBQUN4RSxrRkFBa0YseUJBQXlCO0FBQzNHO0FBQ0E7QUFDQSwyRUFBMkUsTUFBTTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHlCQUF5QjtBQUN6RjtBQUNBO0FBQ0EsdUVBQXVFLE1BQU07QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx5QkFBeUI7QUFDaEY7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0NBQW9DO0FBQzdELGFBQWE7QUFDYiw2REFBNkQseUJBQXlCO0FBQ3RGO0FBQ0E7QUFDQSxzREFBc0QsTUFBTTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyxTQUFTOztBQUVkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLFVBQVUsMERBQTBEOztBQUV6RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyxTQUFTOztBQUVkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLFNBQVM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDZCQUE2QiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy90d2l0dGVyL3R3aXR0ZXJBY3Rpb25Qcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnR3aXR0ZXJBY3Rpb25Qcm92aWRlciA9IGV4cG9ydHMuVHdpdHRlckFjdGlvblByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgYWN0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25Qcm92aWRlclwiKTtcbmNvbnN0IGFjdGlvbkRlY29yYXRvcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvbkRlY29yYXRvclwiKTtcbmNvbnN0IHR3aXR0ZXJfYXBpX3YyXzEgPSByZXF1aXJlKFwidHdpdHRlci1hcGktdjJcIik7XG5jb25zdCBzY2hlbWFzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFzXCIpO1xuLyoqXG4gKiBUd2l0dGVyQWN0aW9uUHJvdmlkZXIgaXMgYW4gYWN0aW9uIHByb3ZpZGVyIGZvciBUd2l0dGVyIChYKSBpbnRlcmFjdGlvbnMuXG4gKlxuICogQGF1Z21lbnRzIEFjdGlvblByb3ZpZGVyXG4gKi9cbmNsYXNzIFR3aXR0ZXJBY3Rpb25Qcm92aWRlciBleHRlbmRzIGFjdGlvblByb3ZpZGVyXzEuQWN0aW9uUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgVHdpdHRlckFjdGlvblByb3ZpZGVyIGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBUd2l0dGVyQWN0aW9uUHJvdmlkZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcihcInR3aXR0ZXJcIiwgW10pO1xuICAgICAgICBjb25maWcuYXBpS2V5IHx8IChjb25maWcuYXBpS2V5ID0gcHJvY2Vzcy5lbnYuVFdJVFRFUl9BUElfS0VZKTtcbiAgICAgICAgY29uZmlnLmFwaVNlY3JldCB8fCAoY29uZmlnLmFwaVNlY3JldCA9IHByb2Nlc3MuZW52LlRXSVRURVJfQVBJX1NFQ1JFVCk7XG4gICAgICAgIGNvbmZpZy5hY2Nlc3NUb2tlbiB8fCAoY29uZmlnLmFjY2Vzc1Rva2VuID0gcHJvY2Vzcy5lbnYuVFdJVFRFUl9BQ0NFU1NfVE9LRU4pO1xuICAgICAgICBjb25maWcuYWNjZXNzVG9rZW5TZWNyZXQgfHwgKGNvbmZpZy5hY2Nlc3NUb2tlblNlY3JldCA9IHByb2Nlc3MuZW52LlRXSVRURVJfQUNDRVNTX1RPS0VOX1NFQ1JFVCk7XG4gICAgICAgIGlmICghY29uZmlnLmFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFdJVFRFUl9BUElfS0VZIGlzIG5vdCBjb25maWd1cmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmZpZy5hcGlTZWNyZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRXSVRURVJfQVBJX1NFQ1JFVCBpcyBub3QgY29uZmlndXJlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWcuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRXSVRURVJfQUNDRVNTX1RPS0VOIGlzIG5vdCBjb25maWd1cmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmZpZy5hY2Nlc3NUb2tlblNlY3JldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFdJVFRFUl9BQ0NFU1NfVE9LRU5fU0VDUkVUIGlzIG5vdCBjb25maWd1cmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudCA9IG5ldyB0d2l0dGVyX2FwaV92Ml8xLlR3aXR0ZXJBcGkoe1xuICAgICAgICAgICAgYXBwS2V5OiBjb25maWcuYXBpS2V5LFxuICAgICAgICAgICAgYXBwU2VjcmV0OiBjb25maWcuYXBpU2VjcmV0LFxuICAgICAgICAgICAgYWNjZXNzVG9rZW46IGNvbmZpZy5hY2Nlc3NUb2tlbixcbiAgICAgICAgICAgIGFjY2Vzc1NlY3JldDogY29uZmlnLmFjY2Vzc1Rva2VuU2VjcmV0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFjY291bnQgZGV0YWlscyBmb3IgdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIFR3aXR0ZXIgKFgpIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gXyAtIEVtcHR5IHBhcmFtZXRlciBvYmplY3QgKG5vdCB1c2VkKVxuICAgICAqIEByZXR1cm5zIEEgSlNPTiBzdHJpbmcgY29udGFpbmluZyB0aGUgYWNjb3VudCBkZXRhaWxzIG9yIGVycm9yIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhc3luYyBhY2NvdW50RGV0YWlscyhfKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnYyLm1lKCk7XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhLnVybCA9IGBodHRwczovL3guY29tLyR7cmVzcG9uc2UuZGF0YS51c2VybmFtZX1gO1xuICAgICAgICAgICAgcmV0dXJuIGBTdWNjZXNzZnVsbHkgcmV0cmlldmVkIGF1dGhlbnRpY2F0ZWQgdXNlciBhY2NvdW50IGRldGFpbHM6XFxuJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZSl9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgcmV0cmlldmluZyBhdXRoZW50aWNhdGVkIHVzZXIgYWNjb3VudCBkZXRhaWxzOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG1lbnRpb25zIGZvciBhIHNwZWNpZmllZCBUd2l0dGVyIChYKSB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIGNvbnRhaW5pbmcgdXNlcklkXG4gICAgICogQHJldHVybnMgQSBKU09OIHN0cmluZyBjb250YWluaW5nIHRoZSBtZW50aW9ucyBvciBlcnJvciBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgYWNjb3VudE1lbnRpb25zKGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQudjIudXNlck1lbnRpb25UaW1lbGluZShhcmdzLnVzZXJJZCk7XG4gICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQgYWNjb3VudCBtZW50aW9uczpcXG4ke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciByZXRyaWV2aW5nIGF1dGhlbnRpY2F0ZWQgYWNjb3VudCBtZW50aW9uczogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvc3QgYSB0d2VldCBvbiBUd2l0dGVyIChYKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBjb250YWluaW5nIHRoZSB0d2VldCB0ZXh0XG4gICAgICogQHJldHVybnMgQSBKU09OIHN0cmluZyBjb250YWluaW5nIHRoZSBwb3N0ZWQgdHdlZXQgZGV0YWlscyBvciBlcnJvciBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgcG9zdFR3ZWV0KGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQudjIudHdlZXQoYXJncy50d2VldCk7XG4gICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSBwb3N0ZWQgdG8gVHdpdHRlcjpcXG4ke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBwb3N0aW5nIHRvIFR3aXR0ZXI6XFxuJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvc3QgYSByZXBseSB0byBhIHR3ZWV0IG9uIFR3aXR0ZXIgKFgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIGNvbnRhaW5pbmcgdGhlIHJlcGx5IHRleHQgYW5kIHR3ZWV0IElEXG4gICAgICogQHJldHVybnMgQSBKU09OIHN0cmluZyBjb250YWluaW5nIHRoZSBwb3N0ZWQgcmVwbHkgZGV0YWlscyBvciBlcnJvciBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgcG9zdFR3ZWV0UmVwbHkoYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC52Mi50d2VldChhcmdzLnR3ZWV0UmVwbHksIHtcbiAgICAgICAgICAgICAgICByZXBseTogeyBpbl9yZXBseV90b190d2VldF9pZDogYXJncy50d2VldElkIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBgU3VjY2Vzc2Z1bGx5IHBvc3RlZCByZXBseSB0byBUd2l0dGVyOlxcbiR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIHBvc3RpbmcgcmVwbHkgdG8gVHdpdHRlcjogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgVHdpdHRlciBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICogVHdpdHRlciBhY3Rpb25zIGRvbid0IGRlcGVuZCBvbiBibG9ja2NoYWluIG5ldHdvcmtzLCBzbyBhbHdheXMgcmV0dXJuIHRydWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gXyAtIFRoZSBuZXR3b3JrIHRvIGNoZWNrIChub3QgdXNlZClcbiAgICAgKiBAcmV0dXJucyBBbHdheXMgcmV0dXJucyB0cnVlIGFzIFR3aXR0ZXIgYWN0aW9ucyBhcmUgbmV0d29yay1pbmRlcGVuZGVudFxuICAgICAqL1xuICAgIHN1cHBvcnRzTmV0d29yayhfKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuVHdpdHRlckFjdGlvblByb3ZpZGVyID0gVHdpdHRlckFjdGlvblByb3ZpZGVyO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcImFjY291bnRfZGV0YWlsc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIHdpbGwgcmV0dXJuIGFjY291bnQgZGV0YWlscyBmb3IgdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIFR3aXR0ZXIgKFgpIHVzZXIgY29udGV4dC5cblxuQSBzdWNjZXNzZnVsIHJlc3BvbnNlIHdpbGwgcmV0dXJuIGEgbWVzc2FnZSB3aXRoIHRoZSBhcGkgcmVzcG9uc2UgYXMgYSBqc29uIHBheWxvYWQ6XG4gICAge1wiZGF0YVwiOiB7XCJpZFwiOiBcIjE4NTM4ODk0NDUzMTkzMzE4NDBcIiwgXCJuYW1lXCI6IFwiQ0RQIEFnZW50S2l0XCIsIFwidXNlcm5hbWVcIjogXCJDRFBBZ2VudEtpdFwifX1cblxuQSBmYWlsdXJlIHJlc3BvbnNlIHdpbGwgcmV0dXJuIGEgbWVzc2FnZSB3aXRoIGEgVHdpdHRlciBBUEkgcmVxdWVzdCBlcnJvcjpcbiAgICBFcnJvciByZXRyaWV2aW5nIGF1dGhlbnRpY2F0ZWQgdXNlciBhY2NvdW50OiA0MjkgVG9vIE1hbnkgUmVxdWVzdHNgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5Ud2l0dGVyQWNjb3VudERldGFpbHNTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3ZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgVHdpdHRlckFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJhY2NvdW50RGV0YWlsc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJhY2NvdW50X21lbnRpb25zXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgd2lsbCByZXR1cm4gbWVudGlvbnMgZm9yIHRoZSBzcGVjaWZpZWQgVHdpdHRlciAoWCkgdXNlciBpZC5cblxuQSBzdWNjZXNzZnVsIHJlc3BvbnNlIHdpbGwgcmV0dXJuIGEgbWVzc2FnZSB3aXRoIHRoZSBBUEkgcmVzcG9uc2UgYXMgYSBKU09OIHBheWxvYWQ6XG4gICAge1wiZGF0YVwiOiBbe1wiaWRcIjogXCIxODU3NDc5Mjg3NTA0NTg0ODU2XCIsIFwidGV4dFwiOiBcIkBDRFBBZ2VudEtpdCByZXBseVwifV19XG5cbkEgZmFpbHVyZSByZXNwb25zZSB3aWxsIHJldHVybiBhIG1lc3NhZ2Ugd2l0aCB0aGUgVHdpdHRlciBBUEkgcmVxdWVzdCBlcnJvcjpcbiAgICBFcnJvciByZXRyaWV2aW5nIHVzZXIgbWVudGlvbnM6IDQyOSBUb28gTWFueSBSZXF1ZXN0c2AsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLlR3aXR0ZXJBY2NvdW50TWVudGlvbnNTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3ZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgVHdpdHRlckFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJhY2NvdW50TWVudGlvbnNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwicG9zdF90d2VldFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIHdpbGwgcG9zdCBhIHR3ZWV0IG9uIFR3aXR0ZXIuIFRoZSB0b29sIHRha2VzIHRoZSB0ZXh0IG9mIHRoZSB0d2VldCBhcyBpbnB1dC4gVHdlZXRzIGNhbiBiZSBtYXhpbXVtIDI4MCBjaGFyYWN0ZXJzLlxuXG5BIHN1Y2Nlc3NmdWwgcmVzcG9uc2Ugd2lsbCByZXR1cm4gYSBtZXNzYWdlIHdpdGggdGhlIEFQSSByZXNwb25zZSBhcyBhIEpTT04gcGF5bG9hZDpcbiAgICB7XCJkYXRhXCI6IHtcInRleHRcIjogXCJoZWxsbywgd29ybGQhXCIsIFwiaWRcIjogXCIwMTIzNDU2Nzg5MDEyMzQ1Njc4XCIsIFwiZWRpdF9oaXN0b3J5X3R3ZWV0X2lkc1wiOiBbXCIwMTIzNDU2Nzg5MDEyMzQ1Njc4XCJdfX1cblxuQSBmYWlsdXJlIHJlc3BvbnNlIHdpbGwgcmV0dXJuIGEgbWVzc2FnZSB3aXRoIHRoZSBUd2l0dGVyIEFQSSByZXF1ZXN0IGVycm9yOlxuICAgIFlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY3JlYXRlIGEgVHdlZXQgd2l0aCBkdXBsaWNhdGUgY29udGVudC5gLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5Ud2l0dGVyUG9zdFR3ZWV0U2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIFR3aXR0ZXJBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwicG9zdFR3ZWV0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcInBvc3RfdHdlZXRfcmVwbHlcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCB3aWxsIHBvc3QgYSB0d2VldCBvbiBUd2l0dGVyLiBUaGUgdG9vbCB0YWtlcyB0aGUgdGV4dCBvZiB0aGUgdHdlZXQgYXMgaW5wdXQuIFR3ZWV0cyBjYW4gYmUgbWF4aW11bSAyODAgY2hhcmFjdGVycy5cblxuQSBzdWNjZXNzZnVsIHJlc3BvbnNlIHdpbGwgcmV0dXJuIGEgbWVzc2FnZSB3aXRoIHRoZSBBUEkgcmVzcG9uc2UgYXMgYSBKU09OIHBheWxvYWQ6XG4gICAge1wiZGF0YVwiOiB7XCJ0ZXh0XCI6IFwiaGVsbG8sIHdvcmxkIVwiLCBcImlkXCI6IFwiMDEyMzQ1Njc4OTAxMjM0NTY3OFwiLCBcImVkaXRfaGlzdG9yeV90d2VldF9pZHNcIjogW1wiMDEyMzQ1Njc4OTAxMjM0NTY3OFwiXX19XG5cbkEgZmFpbHVyZSByZXNwb25zZSB3aWxsIHJldHVybiBhIG1lc3NhZ2Ugd2l0aCB0aGUgVHdpdHRlciBBUEkgcmVxdWVzdCBlcnJvcjpcbiAgICBZb3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNyZWF0ZSBhIFR3ZWV0IHdpdGggZHVwbGljYXRlIGNvbnRlbnQuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuVHdpdHRlclBvc3RUd2VldFJlcGx5U2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIFR3aXR0ZXJBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwicG9zdFR3ZWV0UmVwbHlcIiwgbnVsbCk7XG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IFR3aXR0ZXJBY3Rpb25Qcm92aWRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIFR3aXR0ZXJBY3Rpb25Qcm92aWRlclxuICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgVHdpdHRlckFjdGlvblByb3ZpZGVyXG4gKi9cbmNvbnN0IHR3aXR0ZXJBY3Rpb25Qcm92aWRlciA9IChjb25maWcgPSB7fSkgPT4gbmV3IFR3aXR0ZXJBY3Rpb25Qcm92aWRlcihjb25maWcpO1xuZXhwb3J0cy50d2l0dGVyQWN0aW9uUHJvdmlkZXIgPSB0d2l0dGVyQWN0aW9uUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/twitterActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/wallet/index.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./walletActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/walletActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93YWxsZXQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDRIQUF3QiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93YWxsZXQvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93YWxsZXRBY3Rpb25Qcm92aWRlclwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/schemas.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/wallet/schemas.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NativeTransferSchema = exports.GetWalletDetailsSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\n/**\n * Schema for the get_wallet_details action.\n * This action doesn't require any input parameters, so we use an empty object schema.\n */\nexports.GetWalletDetailsSchema = zod_1.z.object({});\n/**\n * Input schema for native transfer action.\n */\nexports.NativeTransferSchema = zod_1.z\n    .object({\n    to: zod_1.z.string().describe(\"The destination address to receive the funds\"),\n    value: zod_1.z.string().describe(\"The amount to transfer in whole units e.g. 1 ETH or 0.00001 ETH\"),\n})\n    .strip()\n    .describe(\"Instructions for transferring native tokens\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93YWxsZXQvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEIsR0FBRyw4QkFBOEI7QUFDN0QsY0FBYyxtQkFBTyxDQUFDLHVEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvd2FsbGV0L3NjaGVtYXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5hdGl2ZVRyYW5zZmVyU2NoZW1hID0gZXhwb3J0cy5HZXRXYWxsZXREZXRhaWxzU2NoZW1hID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuLyoqXG4gKiBTY2hlbWEgZm9yIHRoZSBnZXRfd2FsbGV0X2RldGFpbHMgYWN0aW9uLlxuICogVGhpcyBhY3Rpb24gZG9lc24ndCByZXF1aXJlIGFueSBpbnB1dCBwYXJhbWV0ZXJzLCBzbyB3ZSB1c2UgYW4gZW1wdHkgb2JqZWN0IHNjaGVtYS5cbiAqL1xuZXhwb3J0cy5HZXRXYWxsZXREZXRhaWxzU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe30pO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIG5hdGl2ZSB0cmFuc2ZlciBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuTmF0aXZlVHJhbnNmZXJTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdG86IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgZGVzdGluYXRpb24gYWRkcmVzcyB0byByZWNlaXZlIHRoZSBmdW5kc1wiKSxcbiAgICB2YWx1ZTogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBhbW91bnQgdG8gdHJhbnNmZXIgaW4gd2hvbGUgdW5pdHMgZS5nLiAxIEVUSCBvciAwLjAwMDAxIEVUSFwiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnN0cnVjdGlvbnMgZm9yIHRyYW5zZmVycmluZyBuYXRpdmUgdG9rZW5zXCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/schemas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/walletActionProvider.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/wallet/walletActionProvider.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.walletActionProvider = exports.WalletActionProvider = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/schemas.js\");\n/**\n * WalletActionProvider provides actions for getting basic wallet information.\n */\nclass WalletActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the WalletActionProvider.\n     */\n    constructor() {\n        super(\"wallet\", []);\n        /**\n         * Checks if the wallet action provider supports the given network.\n         * Since wallet actions are network-agnostic, this always returns true.\n         *\n         * @param _ - The network to check.\n         * @returns True, as wallet actions are supported on all networks.\n         */\n        this.supportsNetwork = (_) => true;\n    }\n    /**\n     * Gets the details of the connected wallet including address, network, and balance.\n     *\n     * @param walletProvider - The wallet provider to get the details from.\n     * @param _ - Empty args object (not used).\n     * @returns A formatted string containing the wallet details.\n     */\n    async getWalletDetails(walletProvider, _) {\n        try {\n            const address = walletProvider.getAddress();\n            const network = walletProvider.getNetwork();\n            const balance = await walletProvider.getBalance();\n            const name = walletProvider.getName();\n            // Convert balance from Wei to ETH using Decimal for precision\n            const ethBalance = new decimal_js_1.Decimal(balance.toString()).div(new decimal_js_1.Decimal(10).pow(18));\n            return `Wallet Details:\n- Provider: ${name}\n- Address: ${address}\n- Network: \n  * Protocol Family: ${network.protocolFamily}\n  * Network ID: ${network.networkId || \"N/A\"}\n  * Chain ID: ${network.chainId || \"N/A\"}\n- ETH Balance: ${ethBalance.toFixed(6)} ETH\n- Native Balance: ${balance.toString()} WEI`;\n        }\n        catch (error) {\n            return `Error getting wallet details: ${error}`;\n        }\n    }\n    /**\n     * Transfers a specified amount of an asset to a destination onchain.\n     *\n     * @param walletProvider - The wallet provider to transfer from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the transfer details.\n     */\n    async nativeTransfer(walletProvider, args) {\n        try {\n            const result = await walletProvider.nativeTransfer(args.to, args.value);\n            return `Transferred ${args.value} ETH to ${args.to}.\\nTransaction hash: ${result}`;\n        }\n        catch (error) {\n            return `Error transferring the asset: ${error}`;\n        }\n    }\n}\nexports.WalletActionProvider = WalletActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_wallet_details\",\n        description: `\n    This tool will return the details of the connected wallet including:\n    - Wallet address\n    - Network information (protocol family, network ID, chain ID)\n    - ETH token balance\n    - Native token balance\n    - Wallet provider name\n    `,\n        schema: schemas_1.GetWalletDetailsSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.WalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], WalletActionProvider.prototype, \"getWalletDetails\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"native_transfer\",\n        description: `\nThis tool will transfer native tokens from the wallet to another onchain address.\n\nIt takes the following inputs:\n- amount: The amount to transfer in whole units e.g. 1 ETH or 0.00001 ETH\n- destination: The address to receive the funds\n\nImportant notes:\n- Ensure sufficient balance of the input asset before transferring\n- Ensure there is sufficient native token balance for gas fees\n`,\n        schema: schemas_1.NativeTransferSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.WalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], WalletActionProvider.prototype, \"nativeTransfer\", null);\n/**\n * Factory function to create a new WalletActionProvider instance.\n *\n * @returns A new WalletActionProvider instance.\n */\nconst walletActionProvider = () => new WalletActionProvider();\nexports.walletActionProvider = walletActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93YWxsZXQvd2FsbGV0QWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDRCQUE0QjtBQUMzRCxxQkFBcUIsbUJBQU8sQ0FBQyw4REFBWTtBQUN6QyxjQUFjLG1CQUFPLENBQUMsdURBQUs7QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELHlCQUF5QixtQkFBTyxDQUFDLDBHQUFtQjtBQUNwRCwyQkFBMkIsbUJBQU8sQ0FBQyxzR0FBd0I7QUFDM0Qsa0JBQWtCLG1CQUFPLENBQUMsa0dBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsaUJBQWlCLHVCQUF1QjtBQUN4QyxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWSxTQUFTLFFBQVEsdUJBQXVCLE9BQU87QUFDN0Y7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL3dhbGxldC93YWxsZXRBY3Rpb25Qcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndhbGxldEFjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5XYWxsZXRBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3QgYWN0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25Qcm92aWRlclwiKTtcbmNvbnN0IHdhbGxldF9wcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi93YWxsZXQtcHJvdmlkZXJzXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbi8qKlxuICogV2FsbGV0QWN0aW9uUHJvdmlkZXIgcHJvdmlkZXMgYWN0aW9ucyBmb3IgZ2V0dGluZyBiYXNpYyB3YWxsZXQgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIFdhbGxldEFjdGlvblByb3ZpZGVyIGV4dGVuZHMgYWN0aW9uUHJvdmlkZXJfMS5BY3Rpb25Qcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBXYWxsZXRBY3Rpb25Qcm92aWRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJ3YWxsZXRcIiwgW10pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSB3YWxsZXQgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAgICAgKiBTaW5jZSB3YWxsZXQgYWN0aW9ucyBhcmUgbmV0d29yay1hZ25vc3RpYywgdGhpcyBhbHdheXMgcmV0dXJucyB0cnVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gXyAtIFRoZSBuZXR3b3JrIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJucyBUcnVlLCBhcyB3YWxsZXQgYWN0aW9ucyBhcmUgc3VwcG9ydGVkIG9uIGFsbCBuZXR3b3Jrcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcG9ydHNOZXR3b3JrID0gKF8pID0+IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRldGFpbHMgb2YgdGhlIGNvbm5lY3RlZCB3YWxsZXQgaW5jbHVkaW5nIGFkZHJlc3MsIG5ldHdvcmssIGFuZCBiYWxhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byBnZXQgdGhlIGRldGFpbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0gXyAtIEVtcHR5IGFyZ3Mgb2JqZWN0IChub3QgdXNlZCkuXG4gICAgICogQHJldHVybnMgQSBmb3JtYXR0ZWQgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHdhbGxldCBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFdhbGxldERldGFpbHMod2FsbGV0UHJvdmlkZXIsIF8pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB3YWxsZXRQcm92aWRlci5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gd2FsbGV0UHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLmdldEJhbGFuY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB3YWxsZXRQcm92aWRlci5nZXROYW1lKCk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGJhbGFuY2UgZnJvbSBXZWkgdG8gRVRIIHVzaW5nIERlY2ltYWwgZm9yIHByZWNpc2lvblxuICAgICAgICAgICAgY29uc3QgZXRoQmFsYW5jZSA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbChiYWxhbmNlLnRvU3RyaW5nKCkpLmRpdihuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoMTApLnBvdygxOCkpO1xuICAgICAgICAgICAgcmV0dXJuIGBXYWxsZXQgRGV0YWlsczpcbi0gUHJvdmlkZXI6ICR7bmFtZX1cbi0gQWRkcmVzczogJHthZGRyZXNzfVxuLSBOZXR3b3JrOiBcbiAgKiBQcm90b2NvbCBGYW1pbHk6ICR7bmV0d29yay5wcm90b2NvbEZhbWlseX1cbiAgKiBOZXR3b3JrIElEOiAke25ldHdvcmsubmV0d29ya0lkIHx8IFwiTi9BXCJ9XG4gICogQ2hhaW4gSUQ6ICR7bmV0d29yay5jaGFpbklkIHx8IFwiTi9BXCJ9XG4tIEVUSCBCYWxhbmNlOiAke2V0aEJhbGFuY2UudG9GaXhlZCg2KX0gRVRIXG4tIE5hdGl2ZSBCYWxhbmNlOiAke2JhbGFuY2UudG9TdHJpbmcoKX0gV0VJYDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZ2V0dGluZyB3YWxsZXQgZGV0YWlsczogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVycyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYW4gYXNzZXQgdG8gYSBkZXN0aW5hdGlvbiBvbmNoYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byB0cmFuc2ZlciBmcm9tLlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGlucHV0IGFyZ3VtZW50cyBmb3IgdGhlIGFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIG1lc3NhZ2UgY29udGFpbmluZyB0aGUgdHJhbnNmZXIgZGV0YWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBuYXRpdmVUcmFuc2Zlcih3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd2FsbGV0UHJvdmlkZXIubmF0aXZlVHJhbnNmZXIoYXJncy50bywgYXJncy52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYFRyYW5zZmVycmVkICR7YXJncy52YWx1ZX0gRVRIIHRvICR7YXJncy50b30uXFxuVHJhbnNhY3Rpb24gaGFzaDogJHtyZXN1bHR9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgdHJhbnNmZXJyaW5nIHRoZSBhc3NldDogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5XYWxsZXRBY3Rpb25Qcm92aWRlciA9IFdhbGxldEFjdGlvblByb3ZpZGVyO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcImdldF93YWxsZXRfZGV0YWlsc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuICAgIFRoaXMgdG9vbCB3aWxsIHJldHVybiB0aGUgZGV0YWlscyBvZiB0aGUgY29ubmVjdGVkIHdhbGxldCBpbmNsdWRpbmc6XG4gICAgLSBXYWxsZXQgYWRkcmVzc1xuICAgIC0gTmV0d29yayBpbmZvcm1hdGlvbiAocHJvdG9jb2wgZmFtaWx5LCBuZXR3b3JrIElELCBjaGFpbiBJRClcbiAgICAtIEVUSCB0b2tlbiBiYWxhbmNlXG4gICAgLSBOYXRpdmUgdG9rZW4gYmFsYW5jZVxuICAgIC0gV2FsbGV0IHByb3ZpZGVyIG5hbWVcbiAgICBgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5HZXRXYWxsZXREZXRhaWxzU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgV2FsbGV0QWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImdldFdhbGxldERldGFpbHNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwibmF0aXZlX3RyYW5zZmVyXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgd2lsbCB0cmFuc2ZlciBuYXRpdmUgdG9rZW5zIGZyb20gdGhlIHdhbGxldCB0byBhbm90aGVyIG9uY2hhaW4gYWRkcmVzcy5cblxuSXQgdGFrZXMgdGhlIGZvbGxvd2luZyBpbnB1dHM6XG4tIGFtb3VudDogVGhlIGFtb3VudCB0byB0cmFuc2ZlciBpbiB3aG9sZSB1bml0cyBlLmcuIDEgRVRIIG9yIDAuMDAwMDEgRVRIXG4tIGRlc3RpbmF0aW9uOiBUaGUgYWRkcmVzcyB0byByZWNlaXZlIHRoZSBmdW5kc1xuXG5JbXBvcnRhbnQgbm90ZXM6XG4tIEVuc3VyZSBzdWZmaWNpZW50IGJhbGFuY2Ugb2YgdGhlIGlucHV0IGFzc2V0IGJlZm9yZSB0cmFuc2ZlcnJpbmdcbi0gRW5zdXJlIHRoZXJlIGlzIHN1ZmZpY2llbnQgbmF0aXZlIHRva2VuIGJhbGFuY2UgZm9yIGdhcyBmZWVzXG5gLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5OYXRpdmVUcmFuc2ZlclNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLldhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIFdhbGxldEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJuYXRpdmVUcmFuc2ZlclwiLCBudWxsKTtcbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgYSBuZXcgV2FsbGV0QWN0aW9uUHJvdmlkZXIgaW5zdGFuY2UuXG4gKlxuICogQHJldHVybnMgQSBuZXcgV2FsbGV0QWN0aW9uUHJvdmlkZXIgaW5zdGFuY2UuXG4gKi9cbmNvbnN0IHdhbGxldEFjdGlvblByb3ZpZGVyID0gKCkgPT4gbmV3IFdhbGxldEFjdGlvblByb3ZpZGVyKCk7XG5leHBvcnRzLndhbGxldEFjdGlvblByb3ZpZGVyID0gd2FsbGV0QWN0aW9uUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/walletActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/constants.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/weth/constants.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WETH_ABI = exports.WETH_ADDRESS = void 0;\nexports.WETH_ADDRESS = \"0x4200000000000000000000000000000000000006\";\nexports.WETH_ABI = [\n    {\n        inputs: [],\n        name: \"deposit\",\n        outputs: [],\n        stateMutability: \"payable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                name: \"account\",\n                type: \"address\",\n            },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n            {\n                type: \"uint256\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93ZXRoL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxvQkFBb0I7QUFDdkMsb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93ZXRoL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV0VUSF9BQkkgPSBleHBvcnRzLldFVEhfQUREUkVTUyA9IHZvaWQgMDtcbmV4cG9ydHMuV0VUSF9BRERSRVNTID0gXCIweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDZcIjtcbmV4cG9ydHMuV0VUSF9BQkkgPSBbXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcImRlcG9zaXRcIixcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJwYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJhY2NvdW50XCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcImJhbGFuY2VPZlwiLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbl07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/weth/index.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./wethActionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/wethActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93ZXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxzSEFBc0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvd2V0aC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dldGhBY3Rpb25Qcm92aWRlclwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/schemas.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/weth/schemas.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WrapEthSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nexports.WrapEthSchema = zod_1.z\n    .object({\n    amountToWrap: zod_1.z.string().describe(\"Amount of ETH to wrap in wei\"),\n})\n    .strip()\n    .describe(\"Instructions for wrapping ETH to WETH\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93ZXRoL3NjaGVtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLGNBQWMsbUJBQU8sQ0FBQyx1REFBSztBQUMzQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL3dldGgvc2NoZW1hcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV3JhcEV0aFNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmV4cG9ydHMuV3JhcEV0aFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBhbW91bnRUb1dyYXA6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJBbW91bnQgb2YgRVRIIHRvIHdyYXAgaW4gd2VpXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIkluc3RydWN0aW9ucyBmb3Igd3JhcHBpbmcgRVRIIHRvIFdFVEhcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/schemas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/wethActionProvider.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/weth/wethActionProvider.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wethActionProvider = exports.WethActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/dist/cjs/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/schemas.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/constants.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_cjs/index.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\n/**\n * WethActionProvider is an action provider for WETH.\n */\nclass WethActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the WethActionProvider.\n     */\n    constructor() {\n        super(\"weth\", []);\n        /**\n         * Checks if the Weth action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Weth action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.networkId === \"base-mainnet\" || network.networkId === \"base-sepolia\";\n    }\n    /**\n     * Wraps ETH to WETH.\n     *\n     * @param walletProvider - The wallet provider to use for the action.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the transaction hash.\n     */\n    async wrapEth(walletProvider, args) {\n        try {\n            const hash = await walletProvider.sendTransaction({\n                to: constants_1.WETH_ADDRESS,\n                data: (0, viem_1.encodeFunctionData)({\n                    abi: constants_1.WETH_ABI,\n                    functionName: \"deposit\",\n                }),\n                value: BigInt(args.amountToWrap),\n            });\n            await walletProvider.waitForTransactionReceipt(hash);\n            return `Wrapped ETH with transaction hash: ${hash}`;\n        }\n        catch (error) {\n            return `Error wrapping ETH: ${error}`;\n        }\n    }\n}\nexports.WethActionProvider = WethActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"wrap_eth\",\n        description: `\n    This tool can only be used to wrap ETH to WETH.\nDo not use this tool for any other purpose, or trading other assets.\n\nInputs:\n- Amount of ETH to wrap.\n\nImportant notes:\n- The amount is a string and cannot have any decimal points, since the unit of measurement is wei.\n- Make sure to use the exact amount provided, and if there's any doubt, check by getting more information before continuing with the action.\n- 1 wei = 0.000000000000000001 WETH\n- Minimum purchase amount is 100000000000000 wei (0.0000001 WETH)\n- Only supported on the following networks:\n  - Base Sepolia (ie, 'base-sepolia')\n  - Base Mainnet (ie, 'base', 'base-mainnet')\n`,\n        schema: schemas_1.WrapEthSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], WethActionProvider.prototype, \"wrapEth\", null);\nconst wethActionProvider = () => new WethActionProvider();\nexports.wethActionProvider = wethActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93ZXRoL3dldGhBY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyx1REFBSztBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLGdHQUFXO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLG9HQUFhO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxxREFBTTtBQUM3QiwyQkFBMkIsbUJBQU8sQ0FBQyxzR0FBd0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSx5REFBeUQsS0FBSztBQUM5RDtBQUNBO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvd2V0aC93ZXRoQWN0aW9uUHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53ZXRoQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLldldGhBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCBhY3Rpb25EZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25EZWNvcmF0b3JcIik7XG5jb25zdCBzY2hlbWFzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB2aWVtXzEgPSByZXF1aXJlKFwidmllbVwiKTtcbmNvbnN0IHdhbGxldF9wcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi93YWxsZXQtcHJvdmlkZXJzXCIpO1xuLyoqXG4gKiBXZXRoQWN0aW9uUHJvdmlkZXIgaXMgYW4gYWN0aW9uIHByb3ZpZGVyIGZvciBXRVRILlxuICovXG5jbGFzcyBXZXRoQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIFdldGhBY3Rpb25Qcm92aWRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJ3ZXRoXCIsIFtdKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgV2V0aCBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuZXR3b3JrIC0gVGhlIG5ldHdvcmsgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIFdldGggYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBuZXR3b3JrLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRzTmV0d29yayA9IChuZXR3b3JrKSA9PiBuZXR3b3JrLm5ldHdvcmtJZCA9PT0gXCJiYXNlLW1haW5uZXRcIiB8fCBuZXR3b3JrLm5ldHdvcmtJZCA9PT0gXCJiYXNlLXNlcG9saWFcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcHMgRVRIIHRvIFdFVEguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0UHJvdmlkZXIgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIHRvIHVzZSBmb3IgdGhlIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgYXN5bmMgd3JhcEV0aCh3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdG86IGNvbnN0YW50c18xLldFVEhfQUREUkVTUyxcbiAgICAgICAgICAgICAgICBkYXRhOiAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLldFVEhfQUJJLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwiZGVwb3NpdFwiLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoYXJncy5hbW91bnRUb1dyYXApLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCB3YWxsZXRQcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIGBXcmFwcGVkIEVUSCB3aXRoIHRyYW5zYWN0aW9uIGhhc2g6ICR7aGFzaH1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciB3cmFwcGluZyBFVEg6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuV2V0aEFjdGlvblByb3ZpZGVyID0gV2V0aEFjdGlvblByb3ZpZGVyO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcIndyYXBfZXRoXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG4gICAgVGhpcyB0b29sIGNhbiBvbmx5IGJlIHVzZWQgdG8gd3JhcCBFVEggdG8gV0VUSC5cbkRvIG5vdCB1c2UgdGhpcyB0b29sIGZvciBhbnkgb3RoZXIgcHVycG9zZSwgb3IgdHJhZGluZyBvdGhlciBhc3NldHMuXG5cbklucHV0czpcbi0gQW1vdW50IG9mIEVUSCB0byB3cmFwLlxuXG5JbXBvcnRhbnQgbm90ZXM6XG4tIFRoZSBhbW91bnQgaXMgYSBzdHJpbmcgYW5kIGNhbm5vdCBoYXZlIGFueSBkZWNpbWFsIHBvaW50cywgc2luY2UgdGhlIHVuaXQgb2YgbWVhc3VyZW1lbnQgaXMgd2VpLlxuLSBNYWtlIHN1cmUgdG8gdXNlIHRoZSBleGFjdCBhbW91bnQgcHJvdmlkZWQsIGFuZCBpZiB0aGVyZSdzIGFueSBkb3VidCwgY2hlY2sgYnkgZ2V0dGluZyBtb3JlIGluZm9ybWF0aW9uIGJlZm9yZSBjb250aW51aW5nIHdpdGggdGhlIGFjdGlvbi5cbi0gMSB3ZWkgPSAwLjAwMDAwMDAwMDAwMDAwMDAwMSBXRVRIXG4tIE1pbmltdW0gcHVyY2hhc2UgYW1vdW50IGlzIDEwMDAwMDAwMDAwMDAwMCB3ZWkgKDAuMDAwMDAwMSBXRVRIKVxuLSBPbmx5IHN1cHBvcnRlZCBvbiB0aGUgZm9sbG93aW5nIG5ldHdvcmtzOlxuICAtIEJhc2UgU2Vwb2xpYSAoaWUsICdiYXNlLXNlcG9saWEnKVxuICAtIEJhc2UgTWFpbm5ldCAoaWUsICdiYXNlJywgJ2Jhc2UtbWFpbm5ldCcpXG5gLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5XcmFwRXRoU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgV2V0aEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJ3cmFwRXRoXCIsIG51bGwpO1xuY29uc3Qgd2V0aEFjdGlvblByb3ZpZGVyID0gKCkgPT4gbmV3IFdldGhBY3Rpb25Qcm92aWRlcigpO1xuZXhwb3J0cy53ZXRoQWN0aW9uUHJvdmlkZXIgPSB3ZXRoQWN0aW9uUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/wethActionProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/agentkit.js":
/*!**********************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/agentkit.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AgentKit = void 0;\nconst wallet_providers_1 = __webpack_require__(/*! ./wallet-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst action_providers_1 = __webpack_require__(/*! ./action-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/index.js\");\n/**\n * AgentKit\n */\nclass AgentKit {\n    /**\n     * Initializes a new AgentKit instance\n     *\n     * @param config - Configuration options for the AgentKit\n     * @param config.walletProvider - The wallet provider to use\n     * @param config.actionProviders - The action providers to use\n     * @param config.actions - The actions to use\n     */\n    constructor(config) {\n        this.walletProvider = config.walletProvider;\n        this.actionProviders = config.actionProviders || [(0, action_providers_1.walletActionProvider)()];\n    }\n    /**\n     * Initializes a new AgentKit instance\n     *\n     * @param config - Configuration options for the AgentKit\n     * @param config.walletProvider - The wallet provider to use\n     * @param config.actionProviders - The action providers to use\n     * @param config.actions - The actions to use\n     *\n     * @returns A new AgentKit instance\n     */\n    static async from(config = { actionProviders: [(0, action_providers_1.walletActionProvider)()] }) {\n        let walletProvider = config.walletProvider;\n        if (!config.walletProvider) {\n            if (!config.cdpApiKeyName || !config.cdpApiKeyPrivateKey) {\n                throw new Error(\"cdpApiKeyName and cdpApiKeyPrivateKey are required if not providing a walletProvider\");\n            }\n            walletProvider = await wallet_providers_1.CdpWalletProvider.configureWithWallet({\n                apiKeyName: config.cdpApiKeyName,\n                apiKeyPrivateKey: config.cdpApiKeyPrivateKey,\n            });\n        }\n        return new AgentKit({ ...config, walletProvider: walletProvider });\n    }\n    /**\n     * Returns the actions available to the AgentKit.\n     *\n     * @returns An array of actions\n     */\n    getActions() {\n        const actions = [];\n        for (const actionProvider of this.actionProviders) {\n            if (actionProvider.supportsNetwork(this.walletProvider.getNetwork())) {\n                actions.push(...actionProvider.getActions(this.walletProvider));\n            }\n        }\n        return actions;\n    }\n}\nexports.AgentKit = AgentKit;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWdlbnRraXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLDJCQUEyQixtQkFBTyxDQUFDLGtHQUFvQjtBQUN2RCwyQkFBMkIsbUJBQU8sQ0FBQyxrR0FBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtRUFBbUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDhCQUE4QiwyQ0FBMkM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FnZW50a2l0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZ2VudEtpdCA9IHZvaWQgMDtcbmNvbnN0IHdhbGxldF9wcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuL3dhbGxldC1wcm92aWRlcnNcIik7XG5jb25zdCBhY3Rpb25fcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi9hY3Rpb24tcHJvdmlkZXJzXCIpO1xuLyoqXG4gKiBBZ2VudEtpdFxuICovXG5jbGFzcyBBZ2VudEtpdCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgQWdlbnRLaXQgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBBZ2VudEtpdFxuICAgICAqIEBwYXJhbSBjb25maWcud2FsbGV0UHJvdmlkZXIgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIHRvIHVzZVxuICAgICAqIEBwYXJhbSBjb25maWcuYWN0aW9uUHJvdmlkZXJzIC0gVGhlIGFjdGlvbiBwcm92aWRlcnMgdG8gdXNlXG4gICAgICogQHBhcmFtIGNvbmZpZy5hY3Rpb25zIC0gVGhlIGFjdGlvbnMgdG8gdXNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMud2FsbGV0UHJvdmlkZXIgPSBjb25maWcud2FsbGV0UHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYWN0aW9uUHJvdmlkZXJzID0gY29uZmlnLmFjdGlvblByb3ZpZGVycyB8fCBbKDAsIGFjdGlvbl9wcm92aWRlcnNfMS53YWxsZXRBY3Rpb25Qcm92aWRlcikoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IEFnZW50S2l0IGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQWdlbnRLaXRcbiAgICAgKiBAcGFyYW0gY29uZmlnLndhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byB1c2VcbiAgICAgKiBAcGFyYW0gY29uZmlnLmFjdGlvblByb3ZpZGVycyAtIFRoZSBhY3Rpb24gcHJvdmlkZXJzIHRvIHVzZVxuICAgICAqIEBwYXJhbSBjb25maWcuYWN0aW9ucyAtIFRoZSBhY3Rpb25zIHRvIHVzZVxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgQWdlbnRLaXQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbShjb25maWcgPSB7IGFjdGlvblByb3ZpZGVyczogWygwLCBhY3Rpb25fcHJvdmlkZXJzXzEud2FsbGV0QWN0aW9uUHJvdmlkZXIpKCldIH0pIHtcbiAgICAgICAgbGV0IHdhbGxldFByb3ZpZGVyID0gY29uZmlnLndhbGxldFByb3ZpZGVyO1xuICAgICAgICBpZiAoIWNvbmZpZy53YWxsZXRQcm92aWRlcikge1xuICAgICAgICAgICAgaWYgKCFjb25maWcuY2RwQXBpS2V5TmFtZSB8fCAhY29uZmlnLmNkcEFwaUtleVByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjZHBBcGlLZXlOYW1lIGFuZCBjZHBBcGlLZXlQcml2YXRlS2V5IGFyZSByZXF1aXJlZCBpZiBub3QgcHJvdmlkaW5nIGEgd2FsbGV0UHJvdmlkZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YWxsZXRQcm92aWRlciA9IGF3YWl0IHdhbGxldF9wcm92aWRlcnNfMS5DZHBXYWxsZXRQcm92aWRlci5jb25maWd1cmVXaXRoV2FsbGV0KHtcbiAgICAgICAgICAgICAgICBhcGlLZXlOYW1lOiBjb25maWcuY2RwQXBpS2V5TmFtZSxcbiAgICAgICAgICAgICAgICBhcGlLZXlQcml2YXRlS2V5OiBjb25maWcuY2RwQXBpS2V5UHJpdmF0ZUtleSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWdlbnRLaXQoeyAuLi5jb25maWcsIHdhbGxldFByb3ZpZGVyOiB3YWxsZXRQcm92aWRlciB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWN0aW9ucyBhdmFpbGFibGUgdG8gdGhlIEFnZW50S2l0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWN0aW9uc1xuICAgICAqL1xuICAgIGdldEFjdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb25Qcm92aWRlciBvZiB0aGlzLmFjdGlvblByb3ZpZGVycykge1xuICAgICAgICAgICAgaWYgKGFjdGlvblByb3ZpZGVyLnN1cHBvcnRzTmV0d29yayh0aGlzLndhbGxldFByb3ZpZGVyLmdldE5ldHdvcmsoKSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goLi4uYWN0aW9uUHJvdmlkZXIuZ2V0QWN0aW9ucyh0aGlzLndhbGxldFByb3ZpZGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5BZ2VudEtpdCA9IEFnZW50S2l0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/agentkit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/analytics/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/analytics/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./sendAnalyticsEvent */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/analytics/sendAnalyticsEvent.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYW5hbHl0aWNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywwR0FBc0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FuYWx5dGljcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NlbmRBbmFseXRpY3NFdmVudFwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/analytics/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/analytics/sendAnalyticsEvent.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/analytics/sendAnalyticsEvent.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sendAnalyticsEvent = sendAnalyticsEvent;\nconst md5_1 = __importDefault(__webpack_require__(/*! md5 */ \"(ssr)/./node_modules/md5/md5.js\"));\n/**\n * Sends an analytics event to the default endpoint\n *\n * @param event - The event data containing required action, component and name fields\n * @returns Promise that resolves when the event is sent\n */\nasync function sendAnalyticsEvent(event) {\n    const timestamp = event.timestamp || Date.now();\n    // Prepare the event with required fields\n    const enhancedEvent = {\n        event_type: event.name,\n        platform: \"server\",\n        event_properties: {\n            component_type: event.component,\n            platform: \"server\",\n            project_name: \"agentkit\",\n            time_start: timestamp,\n            ...event,\n        },\n    };\n    const events = [enhancedEvent];\n    const stringifiedEventData = JSON.stringify(events);\n    const uploadTime = timestamp.toString();\n    // Calculate checksum inline\n    const checksum = (0, md5_1.default)(stringifiedEventData + uploadTime);\n    const analyticsServiceData = {\n        e: stringifiedEventData,\n        checksum,\n    };\n    const apiEndpoint = \"https://cca-lite.coinbase.com\";\n    const eventPath = \"/amp\";\n    const eventEndPoint = `${apiEndpoint}${eventPath}`;\n    const response = await fetch(eventEndPoint, {\n        method: \"POST\",\n        mode: \"no-cors\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(analyticsServiceData),\n    });\n    if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYW5hbHl0aWNzL3NlbmRBbmFseXRpY3NFdmVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQiw4QkFBOEIsbUJBQU8sQ0FBQyw0Q0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVksRUFBRSxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FuYWx5dGljcy9zZW5kQW5hbHl0aWNzRXZlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlbmRBbmFseXRpY3NFdmVudCA9IHNlbmRBbmFseXRpY3NFdmVudDtcbmNvbnN0IG1kNV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtZDVcIikpO1xuLyoqXG4gKiBTZW5kcyBhbiBhbmFseXRpY3MgZXZlbnQgdG8gdGhlIGRlZmF1bHQgZW5kcG9pbnRcbiAqXG4gKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgZGF0YSBjb250YWluaW5nIHJlcXVpcmVkIGFjdGlvbiwgY29tcG9uZW50IGFuZCBuYW1lIGZpZWxkc1xuICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGV2ZW50IGlzIHNlbnRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VuZEFuYWx5dGljc0V2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gZXZlbnQudGltZXN0YW1wIHx8IERhdGUubm93KCk7XG4gICAgLy8gUHJlcGFyZSB0aGUgZXZlbnQgd2l0aCByZXF1aXJlZCBmaWVsZHNcbiAgICBjb25zdCBlbmhhbmNlZEV2ZW50ID0ge1xuICAgICAgICBldmVudF90eXBlOiBldmVudC5uYW1lLFxuICAgICAgICBwbGF0Zm9ybTogXCJzZXJ2ZXJcIixcbiAgICAgICAgZXZlbnRfcHJvcGVydGllczoge1xuICAgICAgICAgICAgY29tcG9uZW50X3R5cGU6IGV2ZW50LmNvbXBvbmVudCxcbiAgICAgICAgICAgIHBsYXRmb3JtOiBcInNlcnZlclwiLFxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiBcImFnZW50a2l0XCIsXG4gICAgICAgICAgICB0aW1lX3N0YXJ0OiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50cyA9IFtlbmhhbmNlZEV2ZW50XTtcbiAgICBjb25zdCBzdHJpbmdpZmllZEV2ZW50RGF0YSA9IEpTT04uc3RyaW5naWZ5KGV2ZW50cyk7XG4gICAgY29uc3QgdXBsb2FkVGltZSA9IHRpbWVzdGFtcC50b1N0cmluZygpO1xuICAgIC8vIENhbGN1bGF0ZSBjaGVja3N1bSBpbmxpbmVcbiAgICBjb25zdCBjaGVja3N1bSA9ICgwLCBtZDVfMS5kZWZhdWx0KShzdHJpbmdpZmllZEV2ZW50RGF0YSArIHVwbG9hZFRpbWUpO1xuICAgIGNvbnN0IGFuYWx5dGljc1NlcnZpY2VEYXRhID0ge1xuICAgICAgICBlOiBzdHJpbmdpZmllZEV2ZW50RGF0YSxcbiAgICAgICAgY2hlY2tzdW0sXG4gICAgfTtcbiAgICBjb25zdCBhcGlFbmRwb2ludCA9IFwiaHR0cHM6Ly9jY2EtbGl0ZS5jb2luYmFzZS5jb21cIjtcbiAgICBjb25zdCBldmVudFBhdGggPSBcIi9hbXBcIjtcbiAgICBjb25zdCBldmVudEVuZFBvaW50ID0gYCR7YXBpRW5kcG9pbnR9JHtldmVudFBhdGh9YDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGV2ZW50RW5kUG9pbnQsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgbW9kZTogXCJuby1jb3JzXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShhbmFseXRpY3NTZXJ2aWNlRGF0YSksXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/analytics/sendAnalyticsEvent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./agentkit */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/agentkit.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wallet-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./action-providers */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/action-providers/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./network */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/network/index.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDRFQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxrR0FBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLGtHQUFvQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsZ0ZBQVciLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWdlbnRraXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dhbGxldC1wcm92aWRlcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FjdGlvbi1wcm92aWRlcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25ldHdvcmtcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/network/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/network/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/network/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./network */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/network/network.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvbmV0d29yay9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsOEVBQVM7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLGtGQUFXIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9uZXR3b3JrL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25ldHdvcmtcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/network/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/network/network.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/network/network.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NETWORK_ID_TO_VIEM_CHAIN = exports.NETWORK_ID_TO_CHAIN_ID = exports.CHAIN_ID_TO_NETWORK_ID = void 0;\nconst chains_1 = __webpack_require__(/*! viem/chains */ \"(ssr)/./node_modules/viem/_cjs/chains/index.js\");\n/**\n * Maps EVM chain IDs to Coinbase network IDs\n */\nexports.CHAIN_ID_TO_NETWORK_ID = {\n    1: \"ethereum-mainnet\",\n    11155111: \"ethereum-sepolia\",\n    137: \"polygon-mainnet\",\n    80001: \"polygon-mumbai\",\n    8453: \"base-mainnet\",\n    84532: \"base-sepolia\",\n    42161: \"arbitrum-mainnet\",\n    421614: \"arbitrum-sepolia\",\n    10: \"optimism-mainnet\",\n    11155420: \"optimism-sepolia\",\n};\n/**\n * Maps Coinbase network IDs to EVM chain IDs\n */\nexports.NETWORK_ID_TO_CHAIN_ID = Object.entries(exports.CHAIN_ID_TO_NETWORK_ID).reduce((acc, [chainId, networkId]) => {\n    acc[networkId] = String(chainId);\n    return acc;\n}, {});\n/**\n * Maps Coinbase network IDs to Viem chain objects\n */\nexports.NETWORK_ID_TO_VIEM_CHAIN = {\n    \"ethereum-mainnet\": chains_1.mainnet,\n    \"ethereum-sepolia\": chains_1.sepolia,\n    \"polygon-mainnet\": chains_1.polygon,\n    \"polygon-mumbai\": chains_1.polygonMumbai,\n    \"base-mainnet\": chains_1.base,\n    \"base-sepolia\": chains_1.baseSepolia,\n    \"arbitrum-mainnet\": chains_1.arbitrum,\n    \"arbitrum-sepolia\": chains_1.arbitrumSepolia,\n    \"optimism-mainnet\": chains_1.optimism,\n    \"optimism-sepolia\": chains_1.optimismSepolia,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvbmV0d29yay9uZXR3b3JrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxHQUFHLDhCQUE4QixHQUFHLDhCQUE4QjtBQUNsRyxpQkFBaUIsbUJBQU8sQ0FBQyxtRUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L25ldHdvcmsvbmV0d29yay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTkVUV09SS19JRF9UT19WSUVNX0NIQUlOID0gZXhwb3J0cy5ORVRXT1JLX0lEX1RPX0NIQUlOX0lEID0gZXhwb3J0cy5DSEFJTl9JRF9UT19ORVRXT1JLX0lEID0gdm9pZCAwO1xuY29uc3QgY2hhaW5zXzEgPSByZXF1aXJlKFwidmllbS9jaGFpbnNcIik7XG4vKipcbiAqIE1hcHMgRVZNIGNoYWluIElEcyB0byBDb2luYmFzZSBuZXR3b3JrIElEc1xuICovXG5leHBvcnRzLkNIQUlOX0lEX1RPX05FVFdPUktfSUQgPSB7XG4gICAgMTogXCJldGhlcmV1bS1tYWlubmV0XCIsXG4gICAgMTExNTUxMTE6IFwiZXRoZXJldW0tc2Vwb2xpYVwiLFxuICAgIDEzNzogXCJwb2x5Z29uLW1haW5uZXRcIixcbiAgICA4MDAwMTogXCJwb2x5Z29uLW11bWJhaVwiLFxuICAgIDg0NTM6IFwiYmFzZS1tYWlubmV0XCIsXG4gICAgODQ1MzI6IFwiYmFzZS1zZXBvbGlhXCIsXG4gICAgNDIxNjE6IFwiYXJiaXRydW0tbWFpbm5ldFwiLFxuICAgIDQyMTYxNDogXCJhcmJpdHJ1bS1zZXBvbGlhXCIsXG4gICAgMTA6IFwib3B0aW1pc20tbWFpbm5ldFwiLFxuICAgIDExMTU1NDIwOiBcIm9wdGltaXNtLXNlcG9saWFcIixcbn07XG4vKipcbiAqIE1hcHMgQ29pbmJhc2UgbmV0d29yayBJRHMgdG8gRVZNIGNoYWluIElEc1xuICovXG5leHBvcnRzLk5FVFdPUktfSURfVE9fQ0hBSU5fSUQgPSBPYmplY3QuZW50cmllcyhleHBvcnRzLkNIQUlOX0lEX1RPX05FVFdPUktfSUQpLnJlZHVjZSgoYWNjLCBbY2hhaW5JZCwgbmV0d29ya0lkXSkgPT4ge1xuICAgIGFjY1tuZXR3b3JrSWRdID0gU3RyaW5nKGNoYWluSWQpO1xuICAgIHJldHVybiBhY2M7XG59LCB7fSk7XG4vKipcbiAqIE1hcHMgQ29pbmJhc2UgbmV0d29yayBJRHMgdG8gVmllbSBjaGFpbiBvYmplY3RzXG4gKi9cbmV4cG9ydHMuTkVUV09SS19JRF9UT19WSUVNX0NIQUlOID0ge1xuICAgIFwiZXRoZXJldW0tbWFpbm5ldFwiOiBjaGFpbnNfMS5tYWlubmV0LFxuICAgIFwiZXRoZXJldW0tc2Vwb2xpYVwiOiBjaGFpbnNfMS5zZXBvbGlhLFxuICAgIFwicG9seWdvbi1tYWlubmV0XCI6IGNoYWluc18xLnBvbHlnb24sXG4gICAgXCJwb2x5Z29uLW11bWJhaVwiOiBjaGFpbnNfMS5wb2x5Z29uTXVtYmFpLFxuICAgIFwiYmFzZS1tYWlubmV0XCI6IGNoYWluc18xLmJhc2UsXG4gICAgXCJiYXNlLXNlcG9saWFcIjogY2hhaW5zXzEuYmFzZVNlcG9saWEsXG4gICAgXCJhcmJpdHJ1bS1tYWlubmV0XCI6IGNoYWluc18xLmFyYml0cnVtLFxuICAgIFwiYXJiaXRydW0tc2Vwb2xpYVwiOiBjaGFpbnNfMS5hcmJpdHJ1bVNlcG9saWEsXG4gICAgXCJvcHRpbWlzbS1tYWlubmV0XCI6IGNoYWluc18xLm9wdGltaXNtLFxuICAgIFwib3B0aW1pc20tc2Vwb2xpYVwiOiBjaGFpbnNfMS5vcHRpbWlzbVNlcG9saWEsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/network/network.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/network/types.js":
/*!***************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/network/types.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvbmV0d29yay90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvbmV0d29yay90eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/network/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.approve = approve;\nconst viem_1 = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_cjs/index.js\");\nconst ERC20_ABI = [\n    {\n        inputs: [\n            { name: \"spender\", type: \"address\" },\n            { name: \"amount\", type: \"uint256\" },\n        ],\n        name: \"approve\",\n        outputs: [{ name: \"\", type: \"bool\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n];\n/**\n * Approves a spender to spend tokens on behalf of the owner\n *\n * @param wallet - The wallet provider\n * @param tokenAddress - The address of the token contract\n * @param spenderAddress - The address of the spender\n * @param amount - The amount to approve in atomic units (wei)\n * @returns A success message or error message\n */\nasync function approve(wallet, tokenAddress, spenderAddress, amount) {\n    try {\n        const data = (0, viem_1.encodeFunctionData)({\n            abi: ERC20_ABI,\n            functionName: \"approve\",\n            args: [spenderAddress, amount],\n        });\n        const txHash = await wallet.sendTransaction({\n            to: tokenAddress,\n            data,\n        });\n        await wallet.waitForTransactionReceipt(txHash);\n        return `Successfully approved ${spenderAddress} to spend ${amount} tokens`;\n    }\n    catch (error) {\n        return `Error approving tokens: ${error}`;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGVBQWUsbUJBQU8sQ0FBQyxxREFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtDQUFrQztBQUNoRCxjQUFjLGlDQUFpQztBQUMvQztBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdDQUF3QyxnQkFBZ0IsV0FBVyxRQUFRO0FBQzNFO0FBQ0E7QUFDQSwwQ0FBMEMsTUFBTTtBQUNoRDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXBwcm92ZSA9IGFwcHJvdmU7XG5jb25zdCB2aWVtXzEgPSByZXF1aXJlKFwidmllbVwiKTtcbmNvbnN0IEVSQzIwX0FCSSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgeyBuYW1lOiBcInNwZW5kZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJhbW91bnRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJhcHByb3ZlXCIsXG4gICAgICAgIG91dHB1dHM6IFt7IG5hbWU6IFwiXCIsIHR5cGU6IFwiYm9vbFwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbl07XG4vKipcbiAqIEFwcHJvdmVzIGEgc3BlbmRlciB0byBzcGVuZCB0b2tlbnMgb24gYmVoYWxmIG9mIHRoZSBvd25lclxuICpcbiAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IHByb3ZpZGVyXG4gKiBAcGFyYW0gdG9rZW5BZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHRva2VuIGNvbnRyYWN0XG4gKiBAcGFyYW0gc3BlbmRlckFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgc3BlbmRlclxuICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgdG8gYXBwcm92ZSBpbiBhdG9taWMgdW5pdHMgKHdlaSlcbiAqIEByZXR1cm5zIEEgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yIG1lc3NhZ2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXBwcm92ZSh3YWxsZXQsIHRva2VuQWRkcmVzcywgc3BlbmRlckFkZHJlc3MsIGFtb3VudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgYWJpOiBFUkMyMF9BQkksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwiYXBwcm92ZVwiLFxuICAgICAgICAgICAgYXJnczogW3NwZW5kZXJBZGRyZXNzLCBhbW91bnRdLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICB0bzogdG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdhbGxldC53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gICAgICAgIHJldHVybiBgU3VjY2Vzc2Z1bGx5IGFwcHJvdmVkICR7c3BlbmRlckFkZHJlc3N9IHRvIHNwZW5kICR7YW1vdW50fSB0b2tlbnNgO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGBFcnJvciBhcHByb3ZpbmcgdG9rZW5zOiAke2Vycm9yfWA7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/cdpWalletProvider.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/cdpWalletProvider.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CdpWalletProvider_cdpWallet, _CdpWalletProvider_address, _CdpWalletProvider_network, _CdpWalletProvider_publicClient;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CdpWalletProvider = void 0;\nconst package_json_1 = __webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/@coinbase/agentkit/package.json\");\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_cjs/index.js\");\nconst evmWalletProvider_1 = __webpack_require__(/*! ./evmWalletProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/evmWalletProvider.js\");\nconst coinbase_sdk_1 = __webpack_require__(/*! @coinbase/coinbase-sdk */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/index.js\");\nconst network_1 = __webpack_require__(/*! ../network/network */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/network/network.js\");\n/**\n * A wallet provider that uses the Coinbase SDK.\n */\nclass CdpWalletProvider extends evmWalletProvider_1.EvmWalletProvider {\n    /**\n     * Constructs a new CdpWalletProvider.\n     *\n     * @param config - The configuration options for the CdpWalletProvider.\n     */\n    constructor(config) {\n        super();\n        _CdpWalletProvider_cdpWallet.set(this, void 0);\n        _CdpWalletProvider_address.set(this, void 0);\n        _CdpWalletProvider_network.set(this, void 0);\n        _CdpWalletProvider_publicClient.set(this, void 0);\n        __classPrivateFieldSet(this, _CdpWalletProvider_cdpWallet, config.wallet, \"f\");\n        __classPrivateFieldSet(this, _CdpWalletProvider_address, config.address, \"f\");\n        __classPrivateFieldSet(this, _CdpWalletProvider_network, config.network, \"f\");\n        __classPrivateFieldSet(this, _CdpWalletProvider_publicClient, (0, viem_1.createPublicClient)({\n            chain: network_1.NETWORK_ID_TO_VIEM_CHAIN[config.network.networkId],\n            transport: (0, viem_1.http)(),\n        }), \"f\");\n    }\n    /**\n     * Configures a new CdpWalletProvider with a wallet.\n     *\n     * @param config - Optional configuration parameters\n     * @returns A Promise that resolves to a new CdpWalletProvider instance\n     * @throws Error if required environment variables are missing or wallet initialization fails\n     */\n    static async configureWithWallet(config = {}) {\n        if (config.apiKeyName && config.apiKeyPrivateKey) {\n            coinbase_sdk_1.Coinbase.configure({\n                apiKeyName: config.apiKeyName,\n                privateKey: config.apiKeyPrivateKey,\n                source: \"agentkit\",\n                sourceVersion: package_json_1.version,\n            });\n        }\n        else {\n            coinbase_sdk_1.Coinbase.configureFromJson();\n        }\n        let wallet;\n        const mnemonicPhrase = config.mnemonicPhrase || process.env.MNEMONIC_PHRASE;\n        const networkId = config.networkId || process.env.NETWORK_ID || coinbase_sdk_1.Coinbase.networks.BaseSepolia;\n        try {\n            if (config.wallet) {\n                wallet = config.wallet;\n            }\n            else if (config.cdpWalletData) {\n                const walletData = JSON.parse(config.cdpWalletData);\n                wallet = await coinbase_sdk_1.Wallet.import(walletData);\n            }\n            else if (mnemonicPhrase) {\n                wallet = await coinbase_sdk_1.Wallet.import({ mnemonicPhrase: mnemonicPhrase }, networkId);\n            }\n            else {\n                wallet = await coinbase_sdk_1.Wallet.create({ networkId: networkId });\n            }\n        }\n        catch (error) {\n            throw new Error(`Failed to initialize wallet: ${error}`);\n        }\n        const address = (await wallet.getDefaultAddress())?.getId();\n        const network = {\n            protocolFamily: \"evm\",\n            chainId: network_1.NETWORK_ID_TO_CHAIN_ID[networkId],\n            networkId: networkId,\n        };\n        const cdpWalletProvider = new CdpWalletProvider({\n            wallet,\n            address,\n            network,\n        });\n        return cdpWalletProvider;\n    }\n    /**\n     * Signs a message.\n     *\n     * @param message - The message to sign.\n     * @returns The signed message.\n     */\n    async signMessage(message) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const messageHash = (0, coinbase_sdk_1.hashMessage)(message);\n        const payload = await __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").createPayloadSignature(messageHash);\n        if (payload.getStatus() === \"pending\" && payload?.wait) {\n            await payload.wait(); // needed for Server-Signers\n        }\n        return payload.getSignature();\n    }\n    /**\n     * Signs a typed data object.\n     *\n     * @param typedData - The typed data object to sign.\n     * @returns The signed typed data object.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async signTypedData(typedData) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const messageHash = (0, coinbase_sdk_1.hashTypedDataMessage)(typedData.domain, typedData.types, typedData.message);\n        const payload = await __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").createPayloadSignature(messageHash);\n        if (payload.getStatus() === \"pending\" && payload?.wait) {\n            await payload.wait(); // needed for Server-Signers\n        }\n        return payload.getSignature();\n    }\n    /**\n     * Signs a transaction.\n     *\n     * @param transaction - The transaction to sign.\n     * @returns The signed transaction.\n     */\n    async signTransaction(transaction) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const serializedTx = (0, viem_1.serializeTransaction)(transaction);\n        const transactionHash = (0, viem_1.keccak256)(serializedTx);\n        const payload = await __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").createPayloadSignature(transactionHash);\n        if (payload.getStatus() === \"pending\" && payload?.wait) {\n            await payload.wait(); // needed for Server-Signers\n        }\n        return payload.getSignature();\n    }\n    /**\n     * Sends a transaction.\n     *\n     * @param transaction - The transaction to send.\n     * @returns The hash of the transaction.\n     */\n    async sendTransaction(transaction) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const preparedTransaction = await this.prepareTransaction(transaction.to, transaction.value, transaction.data);\n        const signature = await this.signTransaction({\n            ...preparedTransaction,\n        });\n        const signedPayload = await this.addSignatureAndSerialize(preparedTransaction, signature);\n        const externalAddress = new coinbase_sdk_1.ExternalAddress(__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").getNetworkId(), __classPrivateFieldGet(this, _CdpWalletProvider_address, \"f\"));\n        const tx = await externalAddress.broadcastExternalTransaction(signedPayload.slice(2));\n        return tx.transactionHash;\n    }\n    /**\n     * Prepares a transaction.\n     *\n     * @param to - The address to send the transaction to.\n     * @param value - The value of the transaction.\n     * @param data - The data of the transaction.\n     * @returns The prepared transaction.\n     */\n    async prepareTransaction(to, value, data) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const nonce = await __classPrivateFieldGet(this, _CdpWalletProvider_publicClient, \"f\").getTransactionCount({\n            address: __classPrivateFieldGet(this, _CdpWalletProvider_address, \"f\"),\n        });\n        const feeData = await __classPrivateFieldGet(this, _CdpWalletProvider_publicClient, \"f\").estimateFeesPerGas();\n        const gas = await __classPrivateFieldGet(this, _CdpWalletProvider_publicClient, \"f\").estimateGas({\n            account: __classPrivateFieldGet(this, _CdpWalletProvider_address, \"f\"),\n            to,\n            value,\n            data,\n            maxFeePerGas: feeData.maxFeePerGas,\n            maxPriorityFeePerGas: feeData.maxPriorityFeePerGas,\n        });\n        const chainId = parseInt(__classPrivateFieldGet(this, _CdpWalletProvider_network, \"f\").chainId, 10);\n        return {\n            to,\n            value,\n            data,\n            nonce,\n            maxFeePerGas: feeData.maxFeePerGas,\n            maxPriorityFeePerGas: feeData.maxPriorityFeePerGas,\n            gas,\n            chainId,\n            type: \"eip1559\",\n        };\n    }\n    /**\n     * Adds signature to a transaction and serializes it for broadcast.\n     *\n     * @param transaction - The transaction to sign.\n     * @param signature - The signature to add to the transaction.\n     * @returns A serialized transaction.\n     */\n    async addSignatureAndSerialize(transaction, signature) {\n        // Decode the signature into its components\n        const r = `0x${signature.slice(2, 66)}`; // First 32 bytes\n        const s = `0x${signature.slice(66, 130)}`; // Next 32 bytes\n        const v = BigInt(parseInt(signature.slice(130, 132), 16)); // Last byte\n        return (0, viem_1.serializeTransaction)(transaction, { r, s, v });\n    }\n    /**\n     * Gets the address of the wallet.\n     *\n     * @returns The address of the wallet.\n     */\n    getAddress() {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_address, \"f\")) {\n            throw new Error(\"Address not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_address, \"f\");\n    }\n    /**\n     * Gets the network of the wallet.\n     *\n     * @returns The network of the wallet.\n     */\n    getNetwork() {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_network, \"f\")) {\n            throw new Error(\"Network not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_network, \"f\");\n    }\n    /**\n     * Gets the name of the wallet provider.\n     *\n     * @returns The name of the wallet provider.\n     */\n    getName() {\n        return \"cdp_wallet_provider\";\n    }\n    /**\n     * Gets the balance of the wallet.\n     *\n     * @returns The balance of the wallet in wei\n     */\n    async getBalance() {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const balance = await __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").getBalance(\"eth\");\n        return BigInt(balance.mul(10 ** 18).toString());\n    }\n    /**\n     * Waits for a transaction receipt.\n     *\n     * @param txHash - The hash of the transaction to wait for.\n     * @returns The transaction receipt.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async waitForTransactionReceipt(txHash) {\n        return await __classPrivateFieldGet(this, _CdpWalletProvider_publicClient, \"f\").waitForTransactionReceipt({ hash: txHash });\n    }\n    /**\n     * Reads a contract.\n     *\n     * @param params - The parameters to read the contract.\n     * @returns The response from the contract.\n     */\n    async readContract(params) {\n        return __classPrivateFieldGet(this, _CdpWalletProvider_publicClient, \"f\").readContract(params);\n    }\n    /**\n     * Creates a trade.\n     *\n     * @param options - The options for the trade.\n     * @returns The trade.\n     */\n    async createTrade(options) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").createTrade(options);\n    }\n    /**\n     * Deploys a token.\n     *\n     * @param options - The options for the token deployment.\n     * @returns The deployed token.\n     */\n    async deployToken(options) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").deployToken(options);\n    }\n    /**\n     * Deploys a contract.\n     *\n     * @param options - The options for contract deployment\n     * @param options.solidityVersion - The version of the Solidity compiler to use (e.g. \"0.8.0+commit.c7dfd78e\")\n     * @param options.solidityInputJson - The JSON input for the Solidity compiler containing contract source and settings\n     * @param options.contractName - The name of the contract to deploy\n     * @param options.constructorArgs - Key-value map of constructor args\n     *\n     * @returns A Promise that resolves to the deployed contract instance\n     * @throws Error if wallet is not initialized\n     */\n    async deployContract(options) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").deployContract(options);\n    }\n    /**\n     * Deploys a new NFT (ERC-721) smart contract.\n     *\n     * @param options - Configuration options for the NFT contract deployment\n     * @param options.name - The name of the collection\n     * @param options.symbol - The token symbol for the collection\n     * @param options.baseURI - The base URI for token metadata.\n     *\n     * @returns A Promise that resolves to the deployed SmartContract instance\n     * @throws Error if the wallet is not properly initialized\n     * @throws Error if the deployment fails for any reason (network issues, insufficient funds, etc.)\n     */\n    async deployNFT(options) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").deployNFT(options);\n    }\n    /**\n     * Transfer the native asset of the network.\n     *\n     * @param to - The destination address.\n     * @param value - The amount to transfer in Wei.\n     * @returns The transaction hash.\n     */\n    async nativeTransfer(to, value) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const transferResult = await __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").createTransfer({\n            amount: new decimal_js_1.Decimal(value),\n            assetId: coinbase_sdk_1.Coinbase.assets.Eth,\n            destination: to,\n            gasless: false,\n        });\n        const result = await transferResult.wait();\n        if (!result.getTransactionHash()) {\n            throw new Error(\"Transaction hash not found\");\n        }\n        return result.getTransactionHash();\n    }\n    /**\n     * Exports the wallet.\n     *\n     * @returns The wallet's data.\n     */\n    async exportWallet() {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").export();\n    }\n}\nexports.CdpWalletProvider = CdpWalletProvider;\n_CdpWalletProvider_cdpWallet = new WeakMap(), _CdpWalletProvider_address = new WeakMap(), _CdpWalletProvider_network = new WeakMap(), _CdpWalletProvider_publicClient = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9jZHBXYWxsZXRQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsdUJBQXVCLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxxREFBTTtBQUM3Qiw0QkFBNEIsbUJBQU8sQ0FBQywrR0FBcUI7QUFDekQsdUJBQXVCLG1CQUFPLENBQUMseUZBQXdCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLDJGQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0NBQWdDO0FBQzlGO0FBQ0E7QUFDQSw4REFBOEQsc0JBQXNCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QixHQUFHO0FBQ2pELHVCQUF1Qix5QkFBeUIsR0FBRztBQUNuRCxtRUFBbUU7QUFDbkUsK0RBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILGNBQWM7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L3dhbGxldC1wcm92aWRlcnMvY2RwV2FsbGV0UHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgX0NkcFdhbGxldFByb3ZpZGVyX2FkZHJlc3MsIF9DZHBXYWxsZXRQcm92aWRlcl9uZXR3b3JrLCBfQ2RwV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DZHBXYWxsZXRQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHBhY2thZ2VfanNvbl8xID0gcmVxdWlyZShcIi4uLy4uL3BhY2thZ2UuanNvblwiKTtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpO1xuY29uc3QgdmllbV8xID0gcmVxdWlyZShcInZpZW1cIik7XG5jb25zdCBldm1XYWxsZXRQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vZXZtV2FsbGV0UHJvdmlkZXJcIik7XG5jb25zdCBjb2luYmFzZV9zZGtfMSA9IHJlcXVpcmUoXCJAY29pbmJhc2UvY29pbmJhc2Utc2RrXCIpO1xuY29uc3QgbmV0d29ya18xID0gcmVxdWlyZShcIi4uL25ldHdvcmsvbmV0d29ya1wiKTtcbi8qKlxuICogQSB3YWxsZXQgcHJvdmlkZXIgdGhhdCB1c2VzIHRoZSBDb2luYmFzZSBTREsuXG4gKi9cbmNsYXNzIENkcFdhbGxldFByb3ZpZGVyIGV4dGVuZHMgZXZtV2FsbGV0UHJvdmlkZXJfMS5Fdm1XYWxsZXRQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBDZHBXYWxsZXRQcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQ2RwV2FsbGV0UHJvdmlkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9DZHBXYWxsZXRQcm92aWRlcl9hZGRyZXNzLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ2RwV2FsbGV0UHJvdmlkZXJfbmV0d29yay5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NkcFdhbGxldFByb3ZpZGVyX3B1YmxpY0NsaWVudC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBjb25maWcud2FsbGV0LCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2FkZHJlc3MsIGNvbmZpZy5hZGRyZXNzLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX25ldHdvcmssIGNvbmZpZy5uZXR3b3JrLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX3B1YmxpY0NsaWVudCwgKDAsIHZpZW1fMS5jcmVhdGVQdWJsaWNDbGllbnQpKHtcbiAgICAgICAgICAgIGNoYWluOiBuZXR3b3JrXzEuTkVUV09SS19JRF9UT19WSUVNX0NIQUlOW2NvbmZpZy5uZXR3b3JrLm5ldHdvcmtJZF0sXG4gICAgICAgICAgICB0cmFuc3BvcnQ6ICgwLCB2aWVtXzEuaHR0cCkoKSxcbiAgICAgICAgfSksIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyBhIG5ldyBDZHBXYWxsZXRQcm92aWRlciB3aXRoIGEgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbmV3IENkcFdhbGxldFByb3ZpZGVyIGluc3RhbmNlXG4gICAgICogQHRocm93cyBFcnJvciBpZiByZXF1aXJlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIG1pc3Npbmcgb3Igd2FsbGV0IGluaXRpYWxpemF0aW9uIGZhaWxzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNvbmZpZ3VyZVdpdGhXYWxsZXQoY29uZmlnID0ge30pIHtcbiAgICAgICAgaWYgKGNvbmZpZy5hcGlLZXlOYW1lICYmIGNvbmZpZy5hcGlLZXlQcml2YXRlS2V5KSB7XG4gICAgICAgICAgICBjb2luYmFzZV9zZGtfMS5Db2luYmFzZS5jb25maWd1cmUoe1xuICAgICAgICAgICAgICAgIGFwaUtleU5hbWU6IGNvbmZpZy5hcGlLZXlOYW1lLFxuICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6IGNvbmZpZy5hcGlLZXlQcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgIHNvdXJjZTogXCJhZ2VudGtpdFwiLFxuICAgICAgICAgICAgICAgIHNvdXJjZVZlcnNpb246IHBhY2thZ2VfanNvbl8xLnZlcnNpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvaW5iYXNlX3Nka18xLkNvaW5iYXNlLmNvbmZpZ3VyZUZyb21Kc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdhbGxldDtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNQaHJhc2UgPSBjb25maWcubW5lbW9uaWNQaHJhc2UgfHwgcHJvY2Vzcy5lbnYuTU5FTU9OSUNfUEhSQVNFO1xuICAgICAgICBjb25zdCBuZXR3b3JrSWQgPSBjb25maWcubmV0d29ya0lkIHx8IHByb2Nlc3MuZW52Lk5FVFdPUktfSUQgfHwgY29pbmJhc2Vfc2RrXzEuQ29pbmJhc2UubmV0d29ya3MuQmFzZVNlcG9saWE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLndhbGxldCkge1xuICAgICAgICAgICAgICAgIHdhbGxldCA9IGNvbmZpZy53YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuY2RwV2FsbGV0RGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhbGxldERhdGEgPSBKU09OLnBhcnNlKGNvbmZpZy5jZHBXYWxsZXREYXRhKTtcbiAgICAgICAgICAgICAgICB3YWxsZXQgPSBhd2FpdCBjb2luYmFzZV9zZGtfMS5XYWxsZXQuaW1wb3J0KHdhbGxldERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW5lbW9uaWNQaHJhc2UpIHtcbiAgICAgICAgICAgICAgICB3YWxsZXQgPSBhd2FpdCBjb2luYmFzZV9zZGtfMS5XYWxsZXQuaW1wb3J0KHsgbW5lbW9uaWNQaHJhc2U6IG1uZW1vbmljUGhyYXNlIH0sIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YWxsZXQgPSBhd2FpdCBjb2luYmFzZV9zZGtfMS5XYWxsZXQuY3JlYXRlKHsgbmV0d29ya0lkOiBuZXR3b3JrSWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIHdhbGxldDogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGF3YWl0IHdhbGxldC5nZXREZWZhdWx0QWRkcmVzcygpKT8uZ2V0SWQoKTtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IHtcbiAgICAgICAgICAgIHByb3RvY29sRmFtaWx5OiBcImV2bVwiLFxuICAgICAgICAgICAgY2hhaW5JZDogbmV0d29ya18xLk5FVFdPUktfSURfVE9fQ0hBSU5fSURbbmV0d29ya0lkXSxcbiAgICAgICAgICAgIG5ldHdvcmtJZDogbmV0d29ya0lkLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjZHBXYWxsZXRQcm92aWRlciA9IG5ldyBDZHBXYWxsZXRQcm92aWRlcih7XG4gICAgICAgICAgICB3YWxsZXQsXG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgbmV0d29yayxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjZHBXYWxsZXRQcm92aWRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgYSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBzaWduLlxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduZWQgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZUhhc2ggPSAoMCwgY29pbmJhc2Vfc2RrXzEuaGFzaE1lc3NhZ2UpKG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikuY3JlYXRlUGF5bG9hZFNpZ25hdHVyZShtZXNzYWdlSGFzaCk7XG4gICAgICAgIGlmIChwYXlsb2FkLmdldFN0YXR1cygpID09PSBcInBlbmRpbmdcIiAmJiBwYXlsb2FkPy53YWl0KSB7XG4gICAgICAgICAgICBhd2FpdCBwYXlsb2FkLndhaXQoKTsgLy8gbmVlZGVkIGZvciBTZXJ2ZXItU2lnbmVyc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkLmdldFNpZ25hdHVyZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBhIHR5cGVkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGVkRGF0YSAtIFRoZSB0eXBlZCBkYXRhIG9iamVjdCB0byBzaWduLlxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduZWQgdHlwZWQgZGF0YSBvYmplY3QuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyBzaWduVHlwZWREYXRhKHR5cGVkRGF0YSkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VIYXNoID0gKDAsIGNvaW5iYXNlX3Nka18xLmhhc2hUeXBlZERhdGFNZXNzYWdlKSh0eXBlZERhdGEuZG9tYWluLCB0eXBlZERhdGEudHlwZXMsIHR5cGVkRGF0YS5tZXNzYWdlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpLmNyZWF0ZVBheWxvYWRTaWduYXR1cmUobWVzc2FnZUhhc2gpO1xuICAgICAgICBpZiAocGF5bG9hZC5nZXRTdGF0dXMoKSA9PT0gXCJwZW5kaW5nXCIgJiYgcGF5bG9hZD8ud2FpdCkge1xuICAgICAgICAgICAgYXdhaXQgcGF5bG9hZC53YWl0KCk7IC8vIG5lZWRlZCBmb3IgU2VydmVyLVNpZ25lcnNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZC5nZXRTaWduYXR1cmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0byBzaWduLlxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduZWQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZFR4ID0gKDAsIHZpZW1fMS5zZXJpYWxpemVUcmFuc2FjdGlvbikodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPSAoMCwgdmllbV8xLmtlY2NhazI1Nikoc2VyaWFsaXplZFR4KTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpLmNyZWF0ZVBheWxvYWRTaWduYXR1cmUodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgaWYgKHBheWxvYWQuZ2V0U3RhdHVzKCkgPT09IFwicGVuZGluZ1wiICYmIHBheWxvYWQ/LndhaXQpIHtcbiAgICAgICAgICAgIGF3YWl0IHBheWxvYWQud2FpdCgpOyAvLyBuZWVkZWQgZm9yIFNlcnZlci1TaWduZXJzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBheWxvYWQuZ2V0U2lnbmF0dXJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdG8gc2VuZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlcGFyZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMucHJlcGFyZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLnRvLCB0cmFuc2FjdGlvbi52YWx1ZSwgdHJhbnNhY3Rpb24uZGF0YSk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnblRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIC4uLnByZXBhcmVkVHJhbnNhY3Rpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaWduZWRQYXlsb2FkID0gYXdhaXQgdGhpcy5hZGRTaWduYXR1cmVBbmRTZXJpYWxpemUocHJlcGFyZWRUcmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxBZGRyZXNzID0gbmV3IGNvaW5iYXNlX3Nka18xLkV4dGVybmFsQWRkcmVzcyhfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKS5nZXROZXR3b3JrSWQoKSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfYWRkcmVzcywgXCJmXCIpKTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBleHRlcm5hbEFkZHJlc3MuYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvbihzaWduZWRQYXlsb2FkLnNsaWNlKDIpKTtcbiAgICAgICAgcmV0dXJuIHR4LnRyYW5zYWN0aW9uSGFzaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0byAtIFRoZSBhZGRyZXNzIHRvIHNlbmQgdGhlIHRyYW5zYWN0aW9uIHRvLlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMgVGhlIHByZXBhcmVkIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHByZXBhcmVUcmFuc2FjdGlvbih0bywgdmFsdWUsIGRhdGEpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub25jZSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX3B1YmxpY0NsaWVudCwgXCJmXCIpLmdldFRyYW5zYWN0aW9uQ291bnQoe1xuICAgICAgICAgICAgYWRkcmVzczogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfYWRkcmVzcywgXCJmXCIpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX3B1YmxpY0NsaWVudCwgXCJmXCIpLmVzdGltYXRlRmVlc1BlckdhcygpO1xuICAgICAgICBjb25zdCBnYXMgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQsIFwiZlwiKS5lc3RpbWF0ZUdhcyh7XG4gICAgICAgICAgICBhY2NvdW50OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9hZGRyZXNzLCBcImZcIiksXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogZmVlRGF0YS5tYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSBwYXJzZUludChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9uZXR3b3JrLCBcImZcIikuY2hhaW5JZCwgMTApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogZmVlRGF0YS5tYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgICAgIGdhcyxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICB0eXBlOiBcImVpcDE1NTlcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBzaWduYXR1cmUgdG8gYSB0cmFuc2FjdGlvbiBhbmQgc2VyaWFsaXplcyBpdCBmb3IgYnJvYWRjYXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIHRvIHNpZ24uXG4gICAgICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gYWRkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgYWRkU2lnbmF0dXJlQW5kU2VyaWFsaXplKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgICAgICAgLy8gRGVjb2RlIHRoZSBzaWduYXR1cmUgaW50byBpdHMgY29tcG9uZW50c1xuICAgICAgICBjb25zdCByID0gYDB4JHtzaWduYXR1cmUuc2xpY2UoMiwgNjYpfWA7IC8vIEZpcnN0IDMyIGJ5dGVzXG4gICAgICAgIGNvbnN0IHMgPSBgMHgke3NpZ25hdHVyZS5zbGljZSg2NiwgMTMwKX1gOyAvLyBOZXh0IDMyIGJ5dGVzXG4gICAgICAgIGNvbnN0IHYgPSBCaWdJbnQocGFyc2VJbnQoc2lnbmF0dXJlLnNsaWNlKDEzMCwgMTMyKSwgMTYpKTsgLy8gTGFzdCBieXRlXG4gICAgICAgIHJldHVybiAoMCwgdmllbV8xLnNlcmlhbGl6ZVRyYW5zYWN0aW9uKSh0cmFuc2FjdGlvbiwgeyByLCBzLCB2IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYWRkcmVzcyBvZiB0aGUgd2FsbGV0LlxuICAgICAqL1xuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfYWRkcmVzcywgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGRyZXNzIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfYWRkcmVzcywgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXR3b3JrIG9mIHRoZSB3YWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV0d29yayBvZiB0aGUgd2FsbGV0LlxuICAgICAqL1xuICAgIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfbmV0d29yaywgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZXR3b3JrIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfbmV0d29yaywgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSB3YWxsZXQgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmFtZSBvZiB0aGUgd2FsbGV0IHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcImNkcF93YWxsZXRfcHJvdmlkZXJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYmFsYW5jZSBvZiB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJhbGFuY2Ugb2YgdGhlIHdhbGxldCBpbiB3ZWlcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCYWxhbmNlKCkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKS5nZXRCYWxhbmNlKFwiZXRoXCIpO1xuICAgICAgICByZXR1cm4gQmlnSW50KGJhbGFuY2UubXVsKDEwICoqIDE4KS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIGEgdHJhbnNhY3Rpb24gcmVjZWlwdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eEhhc2ggLSBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gd2FpdCBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCBcImZcIikud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh7IGhhc2g6IHR4SGFzaCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byByZWFkIHRoZSBjb250cmFjdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgY29udHJhY3QuXG4gICAgICovXG4gICAgYXN5bmMgcmVhZENvbnRyYWN0KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCBcImZcIikucmVhZENvbnRyYWN0KHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0cmFkZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSB0cmFkZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhZGUuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVHJhZGUob3B0aW9ucykge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKS5jcmVhdGVUcmFkZShvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHRva2VuIGRlcGxveW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIGRlcGxveWVkIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGRlcGxveVRva2VuKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikuZGVwbG95VG9rZW4ob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYSBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNvbnRyYWN0IGRlcGxveW1lbnRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zb2xpZGl0eVZlcnNpb24gLSBUaGUgdmVyc2lvbiBvZiB0aGUgU29saWRpdHkgY29tcGlsZXIgdG8gdXNlIChlLmcuIFwiMC44LjArY29tbWl0LmM3ZGZkNzhlXCIpXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc29saWRpdHlJbnB1dEpzb24gLSBUaGUgSlNPTiBpbnB1dCBmb3IgdGhlIFNvbGlkaXR5IGNvbXBpbGVyIGNvbnRhaW5pbmcgY29udHJhY3Qgc291cmNlIGFuZCBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbnRyYWN0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb250cmFjdCB0byBkZXBsb3lcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb25zdHJ1Y3RvckFyZ3MgLSBLZXktdmFsdWUgbWFwIG9mIGNvbnN0cnVjdG9yIGFyZ3NcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXBsb3llZCBjb250cmFjdCBpbnN0YW5jZVxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgd2FsbGV0IGlzIG5vdCBpbml0aWFsaXplZFxuICAgICAqL1xuICAgIGFzeW5jIGRlcGxveUNvbnRyYWN0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikuZGVwbG95Q29udHJhY3Qob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYSBuZXcgTkZUIChFUkMtNzIxKSBzbWFydCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgTkZUIGNvbnRyYWN0IGRlcGxveW1lbnRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zeW1ib2wgLSBUaGUgdG9rZW4gc3ltYm9sIGZvciB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zLmJhc2VVUkkgLSBUaGUgYmFzZSBVUkkgZm9yIHRva2VuIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRlcGxveWVkIFNtYXJ0Q29udHJhY3QgaW5zdGFuY2VcbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSB3YWxsZXQgaXMgbm90IHByb3Blcmx5IGluaXRpYWxpemVkXG4gICAgICogQHRocm93cyBFcnJvciBpZiB0aGUgZGVwbG95bWVudCBmYWlscyBmb3IgYW55IHJlYXNvbiAobmV0d29yayBpc3N1ZXMsIGluc3VmZmljaWVudCBmdW5kcywgZXRjLilcbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lORlQob3B0aW9ucykge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKS5kZXBsb3lORlQob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVyIHRoZSBuYXRpdmUgYXNzZXQgb2YgdGhlIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG8gLSBUaGUgZGVzdGluYXRpb24gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgYW1vdW50IHRvIHRyYW5zZmVyIGluIFdlaS5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKi9cbiAgICBhc3luYyBuYXRpdmVUcmFuc2Zlcih0bywgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2ZlclJlc3VsdCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpLmNyZWF0ZVRyYW5zZmVyKHtcbiAgICAgICAgICAgIGFtb3VudDogbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKHZhbHVlKSxcbiAgICAgICAgICAgIGFzc2V0SWQ6IGNvaW5iYXNlX3Nka18xLkNvaW5iYXNlLmFzc2V0cy5FdGgsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogdG8sXG4gICAgICAgICAgICBnYXNsZXNzOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRyYW5zZmVyUmVzdWx0LndhaXQoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZ2V0VHJhbnNhY3Rpb25IYXNoKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIGhhc2ggbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuZ2V0VHJhbnNhY3Rpb25IYXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIHdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB3YWxsZXQncyBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIGV4cG9ydFdhbGxldCgpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikuZXhwb3J0KCk7XG4gICAgfVxufVxuZXhwb3J0cy5DZHBXYWxsZXRQcm92aWRlciA9IENkcFdhbGxldFByb3ZpZGVyO1xuX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCA9IG5ldyBXZWFrTWFwKCksIF9DZHBXYWxsZXRQcm92aWRlcl9hZGRyZXNzID0gbmV3IFdlYWtNYXAoKSwgX0NkcFdhbGxldFByb3ZpZGVyX25ldHdvcmsgPSBuZXcgV2Vha01hcCgpLCBfQ2RwV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50ID0gbmV3IFdlYWtNYXAoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/cdpWalletProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/evmWalletProvider.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/evmWalletProvider.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// TODO: Improve type safety\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EvmWalletProvider = void 0;\nconst walletProvider_1 = __webpack_require__(/*! ./walletProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/walletProvider.js\");\n/**\n * EvmWalletProvider is the abstract base class for all EVM wallet providers.\n *\n * @abstract\n */\nclass EvmWalletProvider extends walletProvider_1.WalletProvider {\n}\nexports.EvmWalletProvider = EvmWalletProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9ldm1XYWxsZXRQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLHlCQUF5QixtQkFBTyxDQUFDLHlHQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9ldm1XYWxsZXRQcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIFRPRE86IEltcHJvdmUgdHlwZSBzYWZldHlcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXZtV2FsbGV0UHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCB3YWxsZXRQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vd2FsbGV0UHJvdmlkZXJcIik7XG4vKipcbiAqIEV2bVdhbGxldFByb3ZpZGVyIGlzIHRoZSBhYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhbGwgRVZNIHdhbGxldCBwcm92aWRlcnMuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEV2bVdhbGxldFByb3ZpZGVyIGV4dGVuZHMgd2FsbGV0UHJvdmlkZXJfMS5XYWxsZXRQcm92aWRlciB7XG59XG5leHBvcnRzLkV2bVdhbGxldFByb3ZpZGVyID0gRXZtV2FsbGV0UHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/evmWalletProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./walletProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/walletProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./evmWalletProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/evmWalletProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./viemWalletProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/viemWalletProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./cdpWalletProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/cdpWalletProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMseUdBQWtCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQywrR0FBcUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLGlIQUFzQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsK0dBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC93YWxsZXQtcHJvdmlkZXJzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd2FsbGV0UHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V2bVdhbGxldFByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92aWVtV2FsbGV0UHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NkcFdhbGxldFByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/viemWalletProvider.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/viemWalletProvider.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// TODO: Improve type safety\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ViemWalletProvider_walletClient, _ViemWalletProvider_publicClient;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ViemWalletProvider = void 0;\nconst viem_1 = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_cjs/index.js\");\nconst evmWalletProvider_1 = __webpack_require__(/*! ./evmWalletProvider */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/evmWalletProvider.js\");\nconst network_1 = __webpack_require__(/*! ../network/network */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/network/network.js\");\n/**\n * A wallet provider that uses the Viem library.\n */\nclass ViemWalletProvider extends evmWalletProvider_1.EvmWalletProvider {\n    /**\n     * Constructs a new ViemWalletProvider.\n     *\n     * @param walletClient - The wallet client.\n     */\n    constructor(walletClient) {\n        super();\n        _ViemWalletProvider_walletClient.set(this, void 0);\n        _ViemWalletProvider_publicClient.set(this, void 0);\n        __classPrivateFieldSet(this, _ViemWalletProvider_walletClient, walletClient, \"f\");\n        __classPrivateFieldSet(this, _ViemWalletProvider_publicClient, (0, viem_1.createPublicClient)({\n            chain: walletClient.chain,\n            transport: (0, viem_1.http)(),\n        }), \"f\");\n    }\n    /**\n     * Signs a message.\n     *\n     * @param message - The message to sign.\n     * @returns The signed message.\n     */\n    async signMessage(message) {\n        const account = __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").account;\n        if (!account) {\n            throw new Error(\"Account not found\");\n        }\n        return __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").signMessage({ account, message });\n    }\n    /**\n     * Signs a typed data object.\n     *\n     * @param typedData - The typed data object to sign.\n     * @returns The signed typed data object.\n     */\n    async signTypedData(typedData) {\n        return __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").signTypedData({\n            account: __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").account,\n            domain: typedData.domain,\n            types: typedData.types,\n            primaryType: typedData.primaryType,\n            message: typedData.message,\n        });\n    }\n    /**\n     * Signs a transaction.\n     *\n     * @param transaction - The transaction to sign.\n     * @returns The signed transaction.\n     */\n    async signTransaction(transaction) {\n        const txParams = {\n            account: __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").account,\n            to: transaction.to,\n            value: transaction.value,\n            data: transaction.data,\n            chain: __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").chain,\n        };\n        return __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").signTransaction(txParams);\n    }\n    /**\n     * Sends a transaction.\n     *\n     * @param transaction - The transaction to send.\n     * @returns The hash of the transaction.\n     */\n    async sendTransaction(transaction) {\n        const account = __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").account;\n        if (!account) {\n            throw new Error(\"Account not found\");\n        }\n        const chain = __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").chain;\n        if (!chain) {\n            throw new Error(\"Chain not found\");\n        }\n        const txParams = {\n            account: account,\n            chain: chain,\n            data: transaction.data,\n            to: transaction.to,\n            value: transaction.value,\n        };\n        return __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").sendTransaction(txParams);\n    }\n    /**\n     * Gets the address of the wallet.\n     *\n     * @returns The address of the wallet.\n     */\n    getAddress() {\n        return __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").account?.address ?? \"\";\n    }\n    /**\n     * Gets the network of the wallet.\n     *\n     * @returns The network of the wallet.\n     */\n    getNetwork() {\n        return {\n            protocolFamily: \"evm\",\n            chainId: String(__classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").chain.id),\n            networkId: network_1.CHAIN_ID_TO_NETWORK_ID[__classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").chain.id],\n        };\n    }\n    /**\n     * Gets the name of the wallet provider.\n     *\n     * @returns The name of the wallet provider.\n     */\n    getName() {\n        return \"viem_wallet_provider\";\n    }\n    /**\n     * Gets the balance of the wallet.\n     *\n     * @returns The balance of the wallet.\n     */\n    async getBalance() {\n        const account = __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").account;\n        if (!account) {\n            throw new Error(\"Account not found\");\n        }\n        return __classPrivateFieldGet(this, _ViemWalletProvider_publicClient, \"f\").getBalance({ address: account.address });\n    }\n    /**\n     * Waits for a transaction receipt.\n     *\n     * @param txHash - The hash of the transaction to wait for.\n     * @returns The transaction receipt.\n     */\n    async waitForTransactionReceipt(txHash) {\n        return await __classPrivateFieldGet(this, _ViemWalletProvider_publicClient, \"f\").waitForTransactionReceipt({ hash: txHash });\n    }\n    /**\n     * Reads a contract.\n     *\n     * @param params - The parameters to read the contract.\n     * @returns The response from the contract.\n     */\n    async readContract(params) {\n        return __classPrivateFieldGet(this, _ViemWalletProvider_publicClient, \"f\").readContract(params);\n    }\n    /**\n     * Transfer the native asset of the network.\n     *\n     * @param to - The destination address.\n     * @param value - The amount to transfer in whole units (e.g. ETH)\n     * @returns The transaction hash.\n     */\n    async nativeTransfer(to, value) {\n        const atomicAmount = (0, viem_1.parseEther)(value);\n        const tx = await this.sendTransaction({\n            to: to,\n            value: atomicAmount,\n        });\n        const receipt = await this.waitForTransactionReceipt(tx);\n        if (!receipt) {\n            throw new Error(\"Transaction failed\");\n        }\n        return receipt.transactionHash;\n    }\n}\nexports.ViemWalletProvider = ViemWalletProvider;\n_ViemWalletProvider_walletClient = new WeakMap(), _ViemWalletProvider_publicClient = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy92aWVtV2FsbGV0UHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixlQUFlLG1CQUFPLENBQUMscURBQU07QUFDN0IsNEJBQTRCLG1CQUFPLENBQUMsK0dBQXFCO0FBQ3pELGtCQUFrQixtQkFBTyxDQUFDLDJGQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxrQkFBa0I7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRywwQkFBMEI7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSCxjQUFjO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC93YWxsZXQtcHJvdmlkZXJzL3ZpZW1XYWxsZXRQcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIFRPRE86IEltcHJvdmUgdHlwZSBzYWZldHlcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfVmllbVdhbGxldFByb3ZpZGVyX3dhbGxldENsaWVudCwgX1ZpZW1XYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZpZW1XYWxsZXRQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHZpZW1fMSA9IHJlcXVpcmUoXCJ2aWVtXCIpO1xuY29uc3QgZXZtV2FsbGV0UHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2V2bVdhbGxldFByb3ZpZGVyXCIpO1xuY29uc3QgbmV0d29ya18xID0gcmVxdWlyZShcIi4uL25ldHdvcmsvbmV0d29ya1wiKTtcbi8qKlxuICogQSB3YWxsZXQgcHJvdmlkZXIgdGhhdCB1c2VzIHRoZSBWaWVtIGxpYnJhcnkuXG4gKi9cbmNsYXNzIFZpZW1XYWxsZXRQcm92aWRlciBleHRlbmRzIGV2bVdhbGxldFByb3ZpZGVyXzEuRXZtV2FsbGV0UHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVmllbVdhbGxldFByb3ZpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldENsaWVudCAtIFRoZSB3YWxsZXQgY2xpZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdhbGxldENsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfVmllbVdhbGxldFByb3ZpZGVyX3dhbGxldENsaWVudC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1ZpZW1XYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIHdhbGxldENsaWVudCwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCAoMCwgdmllbV8xLmNyZWF0ZVB1YmxpY0NsaWVudCkoe1xuICAgICAgICAgICAgY2hhaW46IHdhbGxldENsaWVudC5jaGFpbixcbiAgICAgICAgICAgIHRyYW5zcG9ydDogKDAsIHZpZW1fMS5odHRwKSgpLFxuICAgICAgICB9KSwgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBhIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIHNpZ24uXG4gICAgICogQHJldHVybnMgVGhlIHNpZ25lZCBtZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5hY2NvdW50O1xuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY291bnQgbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfd2FsbGV0Q2xpZW50LCBcImZcIikuc2lnbk1lc3NhZ2UoeyBhY2NvdW50LCBtZXNzYWdlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBhIHR5cGVkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGVkRGF0YSAtIFRoZSB0eXBlZCBkYXRhIG9iamVjdCB0byBzaWduLlxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduZWQgdHlwZWQgZGF0YSBvYmplY3QuXG4gICAgICovXG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YSh0eXBlZERhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5zaWduVHlwZWREYXRhKHtcbiAgICAgICAgICAgIGFjY291bnQ6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5hY2NvdW50LFxuICAgICAgICAgICAgZG9tYWluOiB0eXBlZERhdGEuZG9tYWluLFxuICAgICAgICAgICAgdHlwZXM6IHR5cGVkRGF0YS50eXBlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiB0eXBlZERhdGEucHJpbWFyeVR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0eXBlZERhdGEubWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGEgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdG8gc2lnbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2lnbmVkIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCB0eFBhcmFtcyA9IHtcbiAgICAgICAgICAgIGFjY291bnQ6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5hY2NvdW50LFxuICAgICAgICAgICAgdG86IHRyYW5zYWN0aW9uLnRvLFxuICAgICAgICAgICAgdmFsdWU6IHRyYW5zYWN0aW9uLnZhbHVlLFxuICAgICAgICAgICAgZGF0YTogdHJhbnNhY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIGNoYWluOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfd2FsbGV0Q2xpZW50LCBcImZcIikuY2hhaW4sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfd2FsbGV0Q2xpZW50LCBcImZcIikuc2lnblRyYW5zYWN0aW9uKHR4UGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0byBzZW5kLlxuICAgICAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5hY2NvdW50O1xuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY291bnQgbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYWluID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfVmllbVdhbGxldFByb3ZpZGVyX3dhbGxldENsaWVudCwgXCJmXCIpLmNoYWluO1xuICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFpbiBub3QgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHhQYXJhbXMgPSB7XG4gICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50LFxuICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgZGF0YTogdHJhbnNhY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIHRvOiB0cmFuc2FjdGlvbi50byxcbiAgICAgICAgICAgIHZhbHVlOiB0cmFuc2FjdGlvbi52YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5zZW5kVHJhbnNhY3Rpb24odHhQYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYWRkcmVzcyBvZiB0aGUgd2FsbGV0LlxuICAgICAqL1xuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfd2FsbGV0Q2xpZW50LCBcImZcIikuYWNjb3VudD8uYWRkcmVzcyA/PyBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXR3b3JrIG9mIHRoZSB3YWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV0d29yayBvZiB0aGUgd2FsbGV0LlxuICAgICAqL1xuICAgIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm90b2NvbEZhbWlseTogXCJldm1cIixcbiAgICAgICAgICAgIGNoYWluSWQ6IFN0cmluZyhfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfd2FsbGV0Q2xpZW50LCBcImZcIikuY2hhaW4uaWQpLFxuICAgICAgICAgICAgbmV0d29ya0lkOiBuZXR3b3JrXzEuQ0hBSU5fSURfVE9fTkVUV09SS19JRFtfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfd2FsbGV0Q2xpZW50LCBcImZcIikuY2hhaW4uaWRdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSB3YWxsZXQgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmFtZSBvZiB0aGUgd2FsbGV0IHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcInZpZW1fd2FsbGV0X3Byb3ZpZGVyXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGJhbGFuY2Ugb2YgdGhlIHdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBiYWxhbmNlIG9mIHRoZSB3YWxsZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmFsYW5jZSgpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5hY2NvdW50O1xuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY291bnQgbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCBcImZcIikuZ2V0QmFsYW5jZSh7IGFkZHJlc3M6IGFjY291bnQuYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIGEgdHJhbnNhY3Rpb24gcmVjZWlwdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eEhhc2ggLSBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gd2FpdCBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQsIFwiZlwiKS53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHsgaGFzaDogdHhIYXNoIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIHJlYWQgdGhlIGNvbnRyYWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBmcm9tIHRoZSBjb250cmFjdC5cbiAgICAgKi9cbiAgICBhc3luYyByZWFkQ29udHJhY3QocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCBcImZcIikucmVhZENvbnRyYWN0KHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVyIHRoZSBuYXRpdmUgYXNzZXQgb2YgdGhlIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG8gLSBUaGUgZGVzdGluYXRpb24gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgYW1vdW50IHRvIHRyYW5zZmVyIGluIHdob2xlIHVuaXRzIChlLmcuIEVUSClcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKi9cbiAgICBhc3luYyBuYXRpdmVUcmFuc2Zlcih0bywgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgYXRvbWljQW1vdW50ID0gKDAsIHZpZW1fMS5wYXJzZUV0aGVyKSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgdmFsdWU6IGF0b21pY0Ftb3VudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQodHgpO1xuICAgICAgICBpZiAoIXJlY2VpcHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIGZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjZWlwdC50cmFuc2FjdGlvbkhhc2g7XG4gICAgfVxufVxuZXhwb3J0cy5WaWVtV2FsbGV0UHJvdmlkZXIgPSBWaWVtV2FsbGV0UHJvdmlkZXI7XG5fVmllbVdhbGxldFByb3ZpZGVyX3dhbGxldENsaWVudCA9IG5ldyBXZWFrTWFwKCksIF9WaWVtV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50ID0gbmV3IFdlYWtNYXAoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/viemWalletProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/walletProvider.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/walletProvider.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletProvider = void 0;\nconst analytics_1 = __webpack_require__(/*! ../analytics */ \"(ssr)/./node_modules/@coinbase/agentkit/dist/analytics/index.js\");\n/**\n * WalletProvider is the abstract base class for all wallet providers.\n *\n * @abstract\n */\nclass WalletProvider {\n    /**\n     * Initializes the wallet provider.\n     */\n    constructor() {\n        // Wait for the next tick to ensure child class is initialized\n        Promise.resolve().then(() => {\n            this.trackInitialization();\n        });\n    }\n    /**\n     * Tracks the initialization of the wallet provider.\n     */\n    trackInitialization() {\n        try {\n            (0, analytics_1.sendAnalyticsEvent)({\n                name: \"agent_initialization\",\n                action: \"initialize_wallet_provider\",\n                component: \"wallet_provider\",\n                wallet_provider: this.getName(),\n                wallet_address: this.getAddress(),\n                network_id: this.getNetwork().networkId,\n                chain_id: this.getNetwork().chainId,\n                protocol_family: this.getNetwork().protocolFamily,\n            });\n        }\n        catch (error) {\n            console.warn(\"Failed to track wallet provider initialization:\", error);\n        }\n    }\n}\nexports.WalletProvider = WalletProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy93YWxsZXRQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsb0JBQW9CLG1CQUFPLENBQUMscUZBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy93YWxsZXRQcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2FsbGV0UHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBhbmFseXRpY3NfMSA9IHJlcXVpcmUoXCIuLi9hbmFseXRpY3NcIik7XG4vKipcbiAqIFdhbGxldFByb3ZpZGVyIGlzIHRoZSBhYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhbGwgd2FsbGV0IHByb3ZpZGVycy5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgV2FsbGV0UHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSB3YWxsZXQgcHJvdmlkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSBuZXh0IHRpY2sgdG8gZW5zdXJlIGNoaWxkIGNsYXNzIGlzIGluaXRpYWxpemVkXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFja0luaXRpYWxpemF0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFja3MgdGhlIGluaXRpYWxpemF0aW9uIG9mIHRoZSB3YWxsZXQgcHJvdmlkZXIuXG4gICAgICovXG4gICAgdHJhY2tJbml0aWFsaXphdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICgwLCBhbmFseXRpY3NfMS5zZW5kQW5hbHl0aWNzRXZlbnQpKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFnZW50X2luaXRpYWxpemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcImluaXRpYWxpemVfd2FsbGV0X3Byb3ZpZGVyXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiBcIndhbGxldF9wcm92aWRlclwiLFxuICAgICAgICAgICAgICAgIHdhbGxldF9wcm92aWRlcjogdGhpcy5nZXROYW1lKCksXG4gICAgICAgICAgICAgICAgd2FsbGV0X2FkZHJlc3M6IHRoaXMuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtfaWQ6IHRoaXMuZ2V0TmV0d29yaygpLm5ldHdvcmtJZCxcbiAgICAgICAgICAgICAgICBjaGFpbl9pZDogdGhpcy5nZXROZXR3b3JrKCkuY2hhaW5JZCxcbiAgICAgICAgICAgICAgICBwcm90b2NvbF9mYW1pbHk6IHRoaXMuZ2V0TmV0d29yaygpLnByb3RvY29sRmFtaWx5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gdHJhY2sgd2FsbGV0IHByb3ZpZGVyIGluaXRpYWxpemF0aW9uOlwiLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLldhbGxldFByb3ZpZGVyID0gV2FsbGV0UHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/agentkit/dist/wallet-providers/walletProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/agentkit/package.json":
/*!******************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/package.json ***!
  \******************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@coinbase/agentkit","description":"Coinbase AgentKit core primitives","repository":"https://github.com/coinbase/agentkit","version":"0.1.2","author":"Coinbase Inc.","license":"Apache-2.0","main":"dist/index.js","types":"dist/index.d.ts","files":["dist"],"scripts":{"build":"tsc","lint":"eslint -c .eslintrc.json \\"src/**/*.ts\\"","lint:fix":"eslint -c .eslintrc.json \\"src/**/*.ts\\" --fix","format":"prettier -c .prettierrc --write \\"**/*.{ts,js,cjs,json,md}\\"","format:check":"prettier -c .prettierrc --check \\"**/*.{ts,js,cjs,json,md}\\"","check":"tsc --noEmit","test":"npx jest --no-cache --testMatch=\'**/*.test.ts\'","test:dry-run":"npm install && npm ci && npm publish --dry-run","test:e2e":"npx jest --no-cache --testMatch=**/e2e.ts --coverageThreshold \'{}\'","test:types":"tsd --files src/tests/types.test-d.ts","clean":"rm -rf dist/*","prepack":"tsc","docs":"typedoc --entryPoints ./src --entryPointStrategy expand --exclude ./src/tests/**/*.ts","docs:serve":"http-server ./docs","dev":"tsc --watch"},"keywords":["coinbase","sdk","crypto","cdp","agentkit","ai","agent","nodejs","typescript"],"dependencies":{"@coinbase/coinbase-sdk":"^0.17.0","md5":"^2.3.0","reflect-metadata":"^0.2.2","twitter-api-v2":"^1.18.2","viem":"^2.22.16","zod":"^3.23.8"},"devDependencies":{"@types/jest":"^29.5.14","@types/secp256k1":"^4.0.6","http-server":"^14.1.1","jest":"^29.7.0","mock-fs":"^5.2.0","ts-jest":"^29.2.5","tsd":"^0.31.2","typescript":"^5.7.2"},"exports":{".":{"types":"./dist/index.d.ts","default":"./dist/index.js"}}}');

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js":
/*!****************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/api.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NetworksApiAxiosParamCreator = exports.MPCWalletStakeApi = exports.MPCWalletStakeApiFactory = exports.MPCWalletStakeApiFp = exports.MPCWalletStakeApiAxiosParamCreator = exports.FundApi = exports.FundApiFactory = exports.FundApiFp = exports.FundApiAxiosParamCreator = exports.ExternalAddressesApi = exports.ExternalAddressesApiFactory = exports.ExternalAddressesApiFp = exports.ExternalAddressesApiAxiosParamCreator = exports.ContractInvocationsApi = exports.ContractInvocationsApiFactory = exports.ContractInvocationsApiFp = exports.ContractInvocationsApiAxiosParamCreator = exports.ContractEventsApi = exports.ContractEventsApiFactory = exports.ContractEventsApiFp = exports.ContractEventsApiAxiosParamCreator = exports.BalanceHistoryApi = exports.BalanceHistoryApiFactory = exports.BalanceHistoryApiFp = exports.BalanceHistoryApiAxiosParamCreator = exports.AssetsApi = exports.AssetsApiFactory = exports.AssetsApiFp = exports.AssetsApiAxiosParamCreator = exports.AddressesApi = exports.AddressesApiFactory = exports.AddressesApiFp = exports.AddressesApiAxiosParamCreator = exports.WebhookStatus = exports.WebhookEventType = exports.WalletServerSignerStatusEnum = exports.ValidatorStatus = exports.TransactionType = exports.TransactionStatusEnum = exports.TokenTransferType = exports.StakingRewardFormat = exports.StakingRewardStateEnum = exports.StakingOperationStatusEnum = exports.SponsoredSendStatusEnum = exports.SolidityValueTypeEnum = exports.SmartContractType = exports.PayloadSignatureStatusEnum = exports.NetworkIdentifier = exports.NetworkProtocolFamilyEnum = exports.FundOperationStatusEnum = void 0;\nexports.WebhooksApi = exports.WebhooksApiFactory = exports.WebhooksApiFp = exports.WebhooksApiAxiosParamCreator = exports.WalletsApi = exports.WalletsApiFactory = exports.WalletsApiFp = exports.WalletsApiAxiosParamCreator = exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiAxiosParamCreator = exports.TransfersApi = exports.TransfersApiFactory = exports.TransfersApiFp = exports.TransfersApiAxiosParamCreator = exports.TransactionHistoryApi = exports.TransactionHistoryApiFactory = exports.TransactionHistoryApiFp = exports.TransactionHistoryApiAxiosParamCreator = exports.TradesApi = exports.TradesApiFactory = exports.TradesApiFp = exports.TradesApiAxiosParamCreator = exports.StakeApi = exports.StakeApiFactory = exports.StakeApiFp = exports.StakeApiAxiosParamCreator = exports.SmartContractsApi = exports.SmartContractsApiFactory = exports.SmartContractsApiFp = exports.SmartContractsApiAxiosParamCreator = exports.ServerSignersApi = exports.ServerSignersApiFactory = exports.ServerSignersApiFp = exports.ServerSignersApiAxiosParamCreator = exports.ReputationApi = exports.ReputationApiFactory = exports.ReputationApiFp = exports.ReputationApiAxiosParamCreator = exports.ResolveIdentityByAddressRolesEnum = exports.OnchainIdentityApi = exports.OnchainIdentityApiFactory = exports.OnchainIdentityApiFp = exports.OnchainIdentityApiAxiosParamCreator = exports.NetworksApi = exports.NetworksApiFactory = exports.NetworksApiFp = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ./common */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js\");\nexports.FundOperationStatusEnum = {\n    Pending: 'pending',\n    Complete: 'complete',\n    Failed: 'failed'\n};\nexports.NetworkProtocolFamilyEnum = {\n    Evm: 'evm',\n    Solana: 'solana'\n};\n/**\n * The ID of the blockchain network. This is unique across all networks, and takes the form of `<blockchain>-<network>`.\n * @export\n * @enum {string}\n */\nexports.NetworkIdentifier = {\n    BaseSepolia: 'base-sepolia',\n    BaseMainnet: 'base-mainnet',\n    EthereumHolesky: 'ethereum-holesky',\n    EthereumSepolia: 'ethereum-sepolia',\n    EthereumMainnet: 'ethereum-mainnet',\n    PolygonMainnet: 'polygon-mainnet',\n    SolanaDevnet: 'solana-devnet',\n    SolanaMainnet: 'solana-mainnet',\n    ArbitrumMainnet: 'arbitrum-mainnet',\n    ArbitrumSepolia: 'arbitrum-sepolia',\n    BitcoinMainnet: 'bitcoin-mainnet',\n    NearTestnet: 'near-testnet',\n    NearMainnet: 'near-mainnet'\n};\nexports.PayloadSignatureStatusEnum = {\n    Pending: 'pending',\n    Signed: 'signed',\n    Failed: 'failed'\n};\n/**\n * The type of the smart contract.\n * @export\n * @enum {string}\n */\nexports.SmartContractType = {\n    Erc20: 'erc20',\n    Erc721: 'erc721',\n    Erc1155: 'erc1155',\n    Custom: 'custom'\n};\nexports.SolidityValueTypeEnum = {\n    Uint8: 'uint8',\n    Uint16: 'uint16',\n    Uint32: 'uint32',\n    Uint64: 'uint64',\n    Uint128: 'uint128',\n    Uint160: 'uint160',\n    Uint256: 'uint256',\n    Int8: 'int8',\n    Int16: 'int16',\n    Int24: 'int24',\n    Int32: 'int32',\n    Int56: 'int56',\n    Int64: 'int64',\n    Int128: 'int128',\n    Int256: 'int256',\n    Address: 'address',\n    Bool: 'bool',\n    String: 'string',\n    Bytes: 'bytes',\n    Bytes1: 'bytes1',\n    Bytes2: 'bytes2',\n    Bytes3: 'bytes3',\n    Bytes4: 'bytes4',\n    Bytes5: 'bytes5',\n    Bytes6: 'bytes6',\n    Bytes7: 'bytes7',\n    Bytes8: 'bytes8',\n    Bytes9: 'bytes9',\n    Bytes10: 'bytes10',\n    Bytes11: 'bytes11',\n    Bytes12: 'bytes12',\n    Bytes13: 'bytes13',\n    Bytes14: 'bytes14',\n    Bytes15: 'bytes15',\n    Bytes16: 'bytes16',\n    Bytes17: 'bytes17',\n    Bytes18: 'bytes18',\n    Bytes19: 'bytes19',\n    Bytes20: 'bytes20',\n    Bytes21: 'bytes21',\n    Bytes22: 'bytes22',\n    Bytes23: 'bytes23',\n    Bytes24: 'bytes24',\n    Bytes25: 'bytes25',\n    Bytes26: 'bytes26',\n    Bytes27: 'bytes27',\n    Bytes28: 'bytes28',\n    Bytes29: 'bytes29',\n    Bytes30: 'bytes30',\n    Bytes31: 'bytes31',\n    Bytes32: 'bytes32',\n    Array: 'array',\n    Tuple: 'tuple'\n};\nexports.SponsoredSendStatusEnum = {\n    Pending: 'pending',\n    Signed: 'signed',\n    Submitted: 'submitted',\n    Complete: 'complete',\n    Failed: 'failed'\n};\nexports.StakingOperationStatusEnum = {\n    Initialized: 'initialized',\n    Complete: 'complete',\n    Failed: 'failed',\n    Unspecified: 'unspecified'\n};\nexports.StakingRewardStateEnum = {\n    Pending: 'pending',\n    Distributed: 'distributed'\n};\n/**\n * The format in which the rewards are to be fetched i.e native or in equivalent USD\n * @export\n * @enum {string}\n */\nexports.StakingRewardFormat = {\n    Usd: 'usd',\n    Native: 'native'\n};\n/**\n * The type of the token transfer.\n * @export\n * @enum {string}\n */\nexports.TokenTransferType = {\n    Erc20: 'erc20',\n    Erc721: 'erc721',\n    Erc1155: 'erc1155',\n    Unknown: 'unknown'\n};\nexports.TransactionStatusEnum = {\n    Pending: 'pending',\n    Signed: 'signed',\n    Broadcast: 'broadcast',\n    Complete: 'complete',\n    Failed: 'failed',\n    Unspecified: 'unspecified'\n};\n/**\n *\n * @export\n * @enum {string}\n */\nexports.TransactionType = {\n    Transfer: 'transfer'\n};\n/**\n * The status of the validator.\n * @export\n * @enum {string}\n */\nexports.ValidatorStatus = {\n    Unknown: 'unknown',\n    Provisioning: 'provisioning',\n    Provisioned: 'provisioned',\n    Deposited: 'deposited',\n    PendingActivation: 'pending_activation',\n    Active: 'active',\n    Exiting: 'exiting',\n    Exited: 'exited',\n    WithdrawalAvailable: 'withdrawal_available',\n    WithdrawalComplete: 'withdrawal_complete',\n    ActiveSlashed: 'active_slashed',\n    ExitedSlashed: 'exited_slashed',\n    Reaped: 'reaped'\n};\nexports.WalletServerSignerStatusEnum = {\n    PendingSeedCreation: 'pending_seed_creation',\n    ActiveSeed: 'active_seed'\n};\n/**\n *\n * @export\n * @enum {string}\n */\nexports.WebhookEventType = {\n    Unspecified: 'unspecified',\n    Erc20Transfer: 'erc20_transfer',\n    Erc721Transfer: 'erc721_transfer',\n    WalletActivity: 'wallet_activity',\n    SmartContractEventActivity: 'smart_contract_event_activity'\n};\n/**\n * The status of the webhook.\n * @export\n * @enum {string}\n */\nexports.WebhookStatus = {\n    Active: 'active',\n    Inactive: 'inactive'\n};\n/**\n * AddressesApi - axios parameter creator\n * @export\n */\nconst AddressesApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new address scoped to the wallet.\n         * @summary Create a new address\n         * @param {string} walletId The ID of the wallet to create the address in.\n         * @param {CreateAddressRequest} [createAddressRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createAddress: async (walletId, createAddressRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createAddress', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAddressRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new payload signature with an address.\n         * @summary Create a new payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to sign the payload with.\n         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createPayloadSignature: async (walletId, addressId, createPayloadSignatureRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createPayloadSignature', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createPayloadSignature', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPayloadSignatureRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get address\n         * @summary Get address by onchain address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddress: async (walletId, addressId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddress', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddress', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get address balance\n         * @summary Get address balance for asset\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddressBalance: async (walletId, addressId, assetId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddressBalance', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddressBalance', 'addressId', addressId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddressBalance', 'assetId', assetId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances/{asset_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get payload signature.\n         * @summary Get payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that signed the payload.\n         * @param {string} payloadSignatureId The ID of the payload signature to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getPayloadSignature: async (walletId, addressId, payloadSignatureId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getPayloadSignature', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getPayloadSignature', 'addressId', addressId);\n            // verify required parameter 'payloadSignatureId' is not null or undefined\n            (0, common_1.assertParamExists)('getPayloadSignature', 'payloadSignatureId', payloadSignatureId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures/{payload_signature_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"payload_signature_id\"}}`, encodeURIComponent(String(payloadSignatureId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get address balances\n         * @summary Get all balances for address\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressBalances: async (walletId, addressId, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressBalances', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressBalances', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List addresses in the wallet.\n         * @summary List addresses in a wallet.\n         * @param {string} walletId The ID of the wallet whose addresses to fetch\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddresses: async (walletId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddresses', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List payload signatures for an address.\n         * @summary List payload signatures for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listPayloadSignatures: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listPayloadSignatures', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listPayloadSignatures', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Request faucet funds to be sent to onchain address.\n         * @summary Request faucet funds for onchain address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        requestFaucetFunds: async (walletId, addressId, assetId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('requestFaucetFunds', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('requestFaucetFunds', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/faucet`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (assetId !== undefined) {\n                localVarQueryParameter['asset_id'] = assetId;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.AddressesApiAxiosParamCreator = AddressesApiAxiosParamCreator;\n/**\n * AddressesApi - functional programming interface\n * @export\n */\nconst AddressesApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.AddressesApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new address scoped to the wallet.\n         * @summary Create a new address\n         * @param {string} walletId The ID of the wallet to create the address in.\n         * @param {CreateAddressRequest} [createAddressRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createAddress(walletId, createAddressRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddress(walletId, createAddressRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.createAddress']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new payload signature with an address.\n         * @summary Create a new payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to sign the payload with.\n         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.createPayloadSignature']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get address\n         * @summary Get address by onchain address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getAddress(walletId, addressId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(walletId, addressId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.getAddress']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get address balance\n         * @summary Get address balance for asset\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getAddressBalance(walletId, addressId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressBalance(walletId, addressId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.getAddressBalance']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get payload signature.\n         * @summary Get payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that signed the payload.\n         * @param {string} payloadSignatureId The ID of the payload signature to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getPayloadSignature(walletId, addressId, payloadSignatureId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayloadSignature(walletId, addressId, payloadSignatureId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.getPayloadSignature']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get address balances\n         * @summary Get all balances for address\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listAddressBalances(walletId, addressId, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressBalances(walletId, addressId, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.listAddressBalances']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List addresses in the wallet.\n         * @summary List addresses in a wallet.\n         * @param {string} walletId The ID of the wallet whose addresses to fetch\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listAddresses(walletId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddresses(walletId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.listAddresses']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List payload signatures for an address.\n         * @summary List payload signatures for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listPayloadSignatures(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayloadSignatures(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.listPayloadSignatures']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Request faucet funds to be sent to onchain address.\n         * @summary Request faucet funds for onchain address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        async requestFaucetFunds(walletId, addressId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.requestFaucetFunds(walletId, addressId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.requestFaucetFunds']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.AddressesApiFp = AddressesApiFp;\n/**\n * AddressesApi - factory interface\n * @export\n */\nconst AddressesApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.AddressesApiFp)(configuration);\n    return {\n        /**\n         * Create a new address scoped to the wallet.\n         * @summary Create a new address\n         * @param {string} walletId The ID of the wallet to create the address in.\n         * @param {CreateAddressRequest} [createAddressRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createAddress(walletId, createAddressRequest, options) {\n            return localVarFp.createAddress(walletId, createAddressRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new payload signature with an address.\n         * @summary Create a new payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to sign the payload with.\n         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options) {\n            return localVarFp.createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get address\n         * @summary Get address by onchain address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddress(walletId, addressId, options) {\n            return localVarFp.getAddress(walletId, addressId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get address balance\n         * @summary Get address balance for asset\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddressBalance(walletId, addressId, assetId, options) {\n            return localVarFp.getAddressBalance(walletId, addressId, assetId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get payload signature.\n         * @summary Get payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that signed the payload.\n         * @param {string} payloadSignatureId The ID of the payload signature to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getPayloadSignature(walletId, addressId, payloadSignatureId, options) {\n            return localVarFp.getPayloadSignature(walletId, addressId, payloadSignatureId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get address balances\n         * @summary Get all balances for address\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressBalances(walletId, addressId, page, options) {\n            return localVarFp.listAddressBalances(walletId, addressId, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List addresses in the wallet.\n         * @summary List addresses in a wallet.\n         * @param {string} walletId The ID of the wallet whose addresses to fetch\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddresses(walletId, limit, page, options) {\n            return localVarFp.listAddresses(walletId, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List payload signatures for an address.\n         * @summary List payload signatures for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listPayloadSignatures(walletId, addressId, limit, page, options) {\n            return localVarFp.listPayloadSignatures(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Request faucet funds to be sent to onchain address.\n         * @summary Request faucet funds for onchain address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        requestFaucetFunds(walletId, addressId, assetId, options) {\n            return localVarFp.requestFaucetFunds(walletId, addressId, assetId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.AddressesApiFactory = AddressesApiFactory;\n/**\n * AddressesApi - object-oriented interface\n * @export\n * @class AddressesApi\n * @extends {BaseAPI}\n */\nclass AddressesApi extends base_1.BaseAPI {\n    /**\n     * Create a new address scoped to the wallet.\n     * @summary Create a new address\n     * @param {string} walletId The ID of the wallet to create the address in.\n     * @param {CreateAddressRequest} [createAddressRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    createAddress(walletId, createAddressRequest, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).createAddress(walletId, createAddressRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new payload signature with an address.\n     * @summary Create a new payload signature.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address to sign the payload with.\n     * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get address\n     * @summary Get address by onchain address\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    getAddress(walletId, addressId, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).getAddress(walletId, addressId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get address balance\n     * @summary Get address balance for asset\n     * @param {string} walletId The ID of the wallet to fetch the balance for\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {string} assetId The symbol of the asset to fetch the balance for\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    getAddressBalance(walletId, addressId, assetId, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).getAddressBalance(walletId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get payload signature.\n     * @summary Get payload signature.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that signed the payload.\n     * @param {string} payloadSignatureId The ID of the payload signature to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    getPayloadSignature(walletId, addressId, payloadSignatureId, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).getPayloadSignature(walletId, addressId, payloadSignatureId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get address balances\n     * @summary Get all balances for address\n     * @param {string} walletId The ID of the wallet to fetch the balances for\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    listAddressBalances(walletId, addressId, page, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).listAddressBalances(walletId, addressId, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List addresses in the wallet.\n     * @summary List addresses in a wallet.\n     * @param {string} walletId The ID of the wallet whose addresses to fetch\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    listAddresses(walletId, limit, page, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).listAddresses(walletId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List payload signatures for an address.\n     * @summary List payload signatures for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address whose payload signatures to fetch.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    listPayloadSignatures(walletId, addressId, limit, page, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).listPayloadSignatures(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Request faucet funds to be sent to onchain address.\n     * @summary Request faucet funds for onchain address.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    requestFaucetFunds(walletId, addressId, assetId, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).requestFaucetFunds(walletId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.AddressesApi = AddressesApi;\n/**\n * AssetsApi - axios parameter creator\n * @export\n */\nconst AssetsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get the asset for the specified asset ID.\n         * @summary Get the asset for the specified asset ID.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAsset: async (networkId, assetId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getAsset', 'networkId', networkId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getAsset', 'assetId', assetId);\n            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.AssetsApiAxiosParamCreator = AssetsApiAxiosParamCreator;\n/**\n * AssetsApi - functional programming interface\n * @export\n */\nconst AssetsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.AssetsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Get the asset for the specified asset ID.\n         * @summary Get the asset for the specified asset ID.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getAsset(networkId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(networkId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AssetsApi.getAsset']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.AssetsApiFp = AssetsApiFp;\n/**\n * AssetsApi - factory interface\n * @export\n */\nconst AssetsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.AssetsApiFp)(configuration);\n    return {\n        /**\n         * Get the asset for the specified asset ID.\n         * @summary Get the asset for the specified asset ID.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAsset(networkId, assetId, options) {\n            return localVarFp.getAsset(networkId, assetId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.AssetsApiFactory = AssetsApiFactory;\n/**\n * AssetsApi - object-oriented interface\n * @export\n * @class AssetsApi\n * @extends {BaseAPI}\n */\nclass AssetsApi extends base_1.BaseAPI {\n    /**\n     * Get the asset for the specified asset ID.\n     * @summary Get the asset for the specified asset ID.\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AssetsApi\n     */\n    getAsset(networkId, assetId, options) {\n        return (0, exports.AssetsApiFp)(this.configuration).getAsset(networkId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.AssetsApi = AssetsApi;\n/**\n * BalanceHistoryApi - axios parameter creator\n * @export\n */\nconst BalanceHistoryApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * List the historical balance of an asset in a specific address.\n         * @summary Get address balance history for asset\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the historical balance for.\n         * @param {string} assetId The symbol of the asset to fetch the historical balance for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressHistoricalBalance: async (networkId, addressId, assetId, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressHistoricalBalance', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressHistoricalBalance', 'addressId', addressId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressHistoricalBalance', 'assetId', assetId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balance_history/{asset_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.BalanceHistoryApiAxiosParamCreator = BalanceHistoryApiAxiosParamCreator;\n/**\n * BalanceHistoryApi - functional programming interface\n * @export\n */\nconst BalanceHistoryApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.BalanceHistoryApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * List the historical balance of an asset in a specific address.\n         * @summary Get address balance history for asset\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the historical balance for.\n         * @param {string} assetId The symbol of the asset to fetch the historical balance for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['BalanceHistoryApi.listAddressHistoricalBalance']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.BalanceHistoryApiFp = BalanceHistoryApiFp;\n/**\n * BalanceHistoryApi - factory interface\n * @export\n */\nconst BalanceHistoryApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.BalanceHistoryApiFp)(configuration);\n    return {\n        /**\n         * List the historical balance of an asset in a specific address.\n         * @summary Get address balance history for asset\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the historical balance for.\n         * @param {string} assetId The symbol of the asset to fetch the historical balance for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options) {\n            return localVarFp.listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.BalanceHistoryApiFactory = BalanceHistoryApiFactory;\n/**\n * BalanceHistoryApi - object-oriented interface\n * @export\n * @class BalanceHistoryApi\n * @extends {BaseAPI}\n */\nclass BalanceHistoryApi extends base_1.BaseAPI {\n    /**\n     * List the historical balance of an asset in a specific address.\n     * @summary Get address balance history for asset\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the historical balance for.\n     * @param {string} assetId The symbol of the asset to fetch the historical balance for.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof BalanceHistoryApi\n     */\n    listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options) {\n        return (0, exports.BalanceHistoryApiFp)(this.configuration).listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.BalanceHistoryApi = BalanceHistoryApi;\n/**\n * ContractEventsApi - axios parameter creator\n * @export\n */\nconst ContractEventsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Retrieve events for a specific contract\n         * @summary List contract events\n         * @param {string} networkId Unique identifier for the blockchain network\n         * @param {string} protocolName Case-sensitive name of the blockchain protocol\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {string} contractName Case-sensitive name of the specific contract within the project\n         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\\&#39;s logs\n         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)\n         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)\n         * @param {string} [nextPage] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContractEvents: async (networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'networkId', networkId);\n            // verify required parameter 'protocolName' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'protocolName', protocolName);\n            // verify required parameter 'contractAddress' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'contractAddress', contractAddress);\n            // verify required parameter 'contractName' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'contractName', contractName);\n            // verify required parameter 'eventName' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'eventName', eventName);\n            // verify required parameter 'fromBlockHeight' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'fromBlockHeight', fromBlockHeight);\n            // verify required parameter 'toBlockHeight' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'toBlockHeight', toBlockHeight);\n            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/events`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"contract_address\"}}`, encodeURIComponent(String(contractAddress)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (protocolName !== undefined) {\n                localVarQueryParameter['protocol_name'] = protocolName;\n            }\n            if (contractName !== undefined) {\n                localVarQueryParameter['contract_name'] = contractName;\n            }\n            if (eventName !== undefined) {\n                localVarQueryParameter['event_name'] = eventName;\n            }\n            if (fromBlockHeight !== undefined) {\n                localVarQueryParameter['from_block_height'] = fromBlockHeight;\n            }\n            if (toBlockHeight !== undefined) {\n                localVarQueryParameter['to_block_height'] = toBlockHeight;\n            }\n            if (nextPage !== undefined) {\n                localVarQueryParameter['next_page'] = nextPage;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ContractEventsApiAxiosParamCreator = ContractEventsApiAxiosParamCreator;\n/**\n * ContractEventsApi - functional programming interface\n * @export\n */\nconst ContractEventsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ContractEventsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Retrieve events for a specific contract\n         * @summary List contract events\n         * @param {string} networkId Unique identifier for the blockchain network\n         * @param {string} protocolName Case-sensitive name of the blockchain protocol\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {string} contractName Case-sensitive name of the specific contract within the project\n         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\\&#39;s logs\n         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)\n         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)\n         * @param {string} [nextPage] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractEventsApi.listContractEvents']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ContractEventsApiFp = ContractEventsApiFp;\n/**\n * ContractEventsApi - factory interface\n * @export\n */\nconst ContractEventsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ContractEventsApiFp)(configuration);\n    return {\n        /**\n         * Retrieve events for a specific contract\n         * @summary List contract events\n         * @param {string} networkId Unique identifier for the blockchain network\n         * @param {string} protocolName Case-sensitive name of the blockchain protocol\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {string} contractName Case-sensitive name of the specific contract within the project\n         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\\&#39;s logs\n         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)\n         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)\n         * @param {string} [nextPage] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options) {\n            return localVarFp.listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ContractEventsApiFactory = ContractEventsApiFactory;\n/**\n * ContractEventsApi - object-oriented interface\n * @export\n * @class ContractEventsApi\n * @extends {BaseAPI}\n */\nclass ContractEventsApi extends base_1.BaseAPI {\n    /**\n     * Retrieve events for a specific contract\n     * @summary List contract events\n     * @param {string} networkId Unique identifier for the blockchain network\n     * @param {string} protocolName Case-sensitive name of the blockchain protocol\n     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n     * @param {string} contractName Case-sensitive name of the specific contract within the project\n     * @param {string} eventName Case-sensitive name of the event to filter for in the contract\\&#39;s logs\n     * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)\n     * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)\n     * @param {string} [nextPage] Pagination token for retrieving the next set of results\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractEventsApi\n     */\n    listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options) {\n        return (0, exports.ContractEventsApiFp)(this.configuration).listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ContractEventsApi = ContractEventsApi;\n/**\n * ContractInvocationsApi - axios parameter creator\n * @export\n */\nconst ContractInvocationsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast a contract invocation.\n         * @summary Broadcast a contract invocation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.\n         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastContractInvocation: async (walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastContractInvocation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastContractInvocation', 'addressId', addressId);\n            // verify required parameter 'contractInvocationId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastContractInvocation', 'contractInvocationId', contractInvocationId);\n            // verify required parameter 'broadcastContractInvocationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastContractInvocation', 'broadcastContractInvocationRequest', broadcastContractInvocationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations/{contract_invocation_id}/broadcast`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"contract_invocation_id\"}}`, encodeURIComponent(String(contractInvocationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastContractInvocationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new contract invocation.\n         * @summary Create a new contract invocation for an address.\n         * @param {string} walletId The ID of the wallet the source address belongs to.\n         * @param {string} addressId The ID of the address to invoke the contract from.\n         * @param {CreateContractInvocationRequest} createContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createContractInvocation: async (walletId, addressId, createContractInvocationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createContractInvocation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createContractInvocation', 'addressId', addressId);\n            // verify required parameter 'createContractInvocationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createContractInvocation', 'createContractInvocationRequest', createContractInvocationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createContractInvocationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a contract invocation by ID.\n         * @summary Get a contract invocation by ID.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getContractInvocation: async (walletId, addressId, contractInvocationId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getContractInvocation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getContractInvocation', 'addressId', addressId);\n            // verify required parameter 'contractInvocationId' is not null or undefined\n            (0, common_1.assertParamExists)('getContractInvocation', 'contractInvocationId', contractInvocationId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations/{contract_invocation_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"contract_invocation_id\"}}`, encodeURIComponent(String(contractInvocationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List contract invocations for an address.\n         * @summary List contract invocations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to list contract invocations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContractInvocations: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listContractInvocations', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listContractInvocations', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ContractInvocationsApiAxiosParamCreator = ContractInvocationsApiAxiosParamCreator;\n/**\n * ContractInvocationsApi - functional programming interface\n * @export\n */\nconst ContractInvocationsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ContractInvocationsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast a contract invocation.\n         * @summary Broadcast a contract invocation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.\n         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.broadcastContractInvocation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new contract invocation.\n         * @summary Create a new contract invocation for an address.\n         * @param {string} walletId The ID of the wallet the source address belongs to.\n         * @param {string} addressId The ID of the address to invoke the contract from.\n         * @param {CreateContractInvocationRequest} createContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createContractInvocation(walletId, addressId, createContractInvocationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createContractInvocation(walletId, addressId, createContractInvocationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.createContractInvocation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a contract invocation by ID.\n         * @summary Get a contract invocation by ID.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getContractInvocation(walletId, addressId, contractInvocationId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractInvocation(walletId, addressId, contractInvocationId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.getContractInvocation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List contract invocations for an address.\n         * @summary List contract invocations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to list contract invocations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listContractInvocations(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractInvocations(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.listContractInvocations']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ContractInvocationsApiFp = ContractInvocationsApiFp;\n/**\n * ContractInvocationsApi - factory interface\n * @export\n */\nconst ContractInvocationsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ContractInvocationsApiFp)(configuration);\n    return {\n        /**\n         * Broadcast a contract invocation.\n         * @summary Broadcast a contract invocation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.\n         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options) {\n            return localVarFp.broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new contract invocation.\n         * @summary Create a new contract invocation for an address.\n         * @param {string} walletId The ID of the wallet the source address belongs to.\n         * @param {string} addressId The ID of the address to invoke the contract from.\n         * @param {CreateContractInvocationRequest} createContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createContractInvocation(walletId, addressId, createContractInvocationRequest, options) {\n            return localVarFp.createContractInvocation(walletId, addressId, createContractInvocationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a contract invocation by ID.\n         * @summary Get a contract invocation by ID.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getContractInvocation(walletId, addressId, contractInvocationId, options) {\n            return localVarFp.getContractInvocation(walletId, addressId, contractInvocationId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List contract invocations for an address.\n         * @summary List contract invocations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to list contract invocations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContractInvocations(walletId, addressId, limit, page, options) {\n            return localVarFp.listContractInvocations(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ContractInvocationsApiFactory = ContractInvocationsApiFactory;\n/**\n * ContractInvocationsApi - object-oriented interface\n * @export\n * @class ContractInvocationsApi\n * @extends {BaseAPI}\n */\nclass ContractInvocationsApi extends base_1.BaseAPI {\n    /**\n     * Broadcast a contract invocation.\n     * @summary Broadcast a contract invocation.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address the contract invocation belongs to.\n     * @param {string} contractInvocationId The ID of the contract invocation to broadcast.\n     * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractInvocationsApi\n     */\n    broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options) {\n        return (0, exports.ContractInvocationsApiFp)(this.configuration).broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new contract invocation.\n     * @summary Create a new contract invocation for an address.\n     * @param {string} walletId The ID of the wallet the source address belongs to.\n     * @param {string} addressId The ID of the address to invoke the contract from.\n     * @param {CreateContractInvocationRequest} createContractInvocationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractInvocationsApi\n     */\n    createContractInvocation(walletId, addressId, createContractInvocationRequest, options) {\n        return (0, exports.ContractInvocationsApiFp)(this.configuration).createContractInvocation(walletId, addressId, createContractInvocationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a contract invocation by ID.\n     * @summary Get a contract invocation by ID.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address the contract invocation belongs to.\n     * @param {string} contractInvocationId The ID of the contract invocation to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractInvocationsApi\n     */\n    getContractInvocation(walletId, addressId, contractInvocationId, options) {\n        return (0, exports.ContractInvocationsApiFp)(this.configuration).getContractInvocation(walletId, addressId, contractInvocationId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List contract invocations for an address.\n     * @summary List contract invocations for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to list contract invocations for.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractInvocationsApi\n     */\n    listContractInvocations(walletId, addressId, limit, page, options) {\n        return (0, exports.ContractInvocationsApiFp)(this.configuration).listContractInvocations(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ContractInvocationsApi = ContractInvocationsApi;\n/**\n * ExternalAddressesApi - axios parameter creator\n * @export\n */\nconst ExternalAddressesApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast an arbitrary transaction to the node constructed and signed by an external address.\n         * @summary Broadcast an arbitrary transaction.\n         * @param {string} networkId The ID of the network the external address belongs to.\n         * @param {string} addressId The onchain address of the transaction sender.\n         * @param {BroadcastExternalTransactionRequest} broadcastExternalTransactionRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastExternalTransaction: async (networkId, addressId, broadcastExternalTransactionRequest, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransaction', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransaction', 'addressId', addressId);\n            // verify required parameter 'broadcastExternalTransactionRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransaction', 'broadcastExternalTransactionRequest', broadcastExternalTransactionRequest);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transactions`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastExternalTransactionRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Broadcast an external address\\'s transfer with a signed payload\n         * @summary Broadcast an external address\\' transfer\n         * @param {string} networkId The ID of the network the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastExternalTransfer: async (networkId, addressId, transferId, broadcastExternalTransferRequest, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransfer', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransfer', 'addressId', addressId);\n            // verify required parameter 'transferId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransfer', 'transferId', transferId);\n            // verify required parameter 'broadcastExternalTransferRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransfer', 'broadcastExternalTransferRequest', broadcastExternalTransferRequest);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transfers/{transfer_id}/broadcast`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"transfer_id\"}}`, encodeURIComponent(String(transferId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastExternalTransferRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new transfer between addresses.\n         * @summary Create a new transfer\n         * @param {string} networkId The ID of the network the address is on\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateExternalTransferRequest} createExternalTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createExternalTransfer: async (networkId, addressId, createExternalTransferRequest, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('createExternalTransfer', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createExternalTransfer', 'addressId', addressId);\n            // verify required parameter 'createExternalTransferRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createExternalTransfer', 'createExternalTransferRequest', createExternalTransferRequest);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transfers`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createExternalTransferRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the balance of an asset in an external address\n         * @summary Get the balance of an asset in an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} assetId The ID of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalAddressBalance: async (networkId, addressId, assetId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalAddressBalance', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalAddressBalance', 'addressId', addressId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalAddressBalance', 'assetId', assetId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balances/{asset_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get an external address\\' transfer by ID\n         * @summary Get a external address\\' transfer\n         * @param {string} networkId The ID of the network the address is on\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalTransfer: async (networkId, addressId, transferId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalTransfer', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalTransfer', 'addressId', addressId);\n            // verify required parameter 'transferId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalTransfer', 'transferId', transferId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transfers/{transfer_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"transfer_id\"}}`, encodeURIComponent(String(transferId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the status of a faucet transaction\n         * @summary Get the status of a faucet transaction\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the faucet transaction for\n         * @param {string} txHash The hash of the faucet transaction\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFaucetTransaction: async (networkId, addressId, txHash, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getFaucetTransaction', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getFaucetTransaction', 'addressId', addressId);\n            // verify required parameter 'txHash' is not null or undefined\n            (0, common_1.assertParamExists)('getFaucetTransaction', 'txHash', txHash);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/faucet/{tx_hash}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"tx_hash\"}}`, encodeURIComponent(String(txHash)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List all of the balances of an external address\n         * @summary Get the balances of an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listExternalAddressBalances: async (networkId, addressId, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listExternalAddressBalances', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listExternalAddressBalances', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balances`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Request faucet funds to be sent to external address.\n         * @summary Request faucet funds for external address.\n         * @param {string} networkId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        requestExternalFaucetFunds: async (networkId, addressId, assetId, skipWait, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('requestExternalFaucetFunds', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('requestExternalFaucetFunds', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/faucet`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (assetId !== undefined) {\n                localVarQueryParameter['asset_id'] = assetId;\n            }\n            if (skipWait !== undefined) {\n                localVarQueryParameter['skip_wait'] = skipWait;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ExternalAddressesApiAxiosParamCreator = ExternalAddressesApiAxiosParamCreator;\n/**\n * ExternalAddressesApi - functional programming interface\n * @export\n */\nconst ExternalAddressesApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ExternalAddressesApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast an arbitrary transaction to the node constructed and signed by an external address.\n         * @summary Broadcast an arbitrary transaction.\n         * @param {string} networkId The ID of the network the external address belongs to.\n         * @param {string} addressId The onchain address of the transaction sender.\n         * @param {BroadcastExternalTransactionRequest} broadcastExternalTransactionRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastExternalTransaction(networkId, addressId, broadcastExternalTransactionRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastExternalTransaction(networkId, addressId, broadcastExternalTransactionRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.broadcastExternalTransaction']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Broadcast an external address\\'s transfer with a signed payload\n         * @summary Broadcast an external address\\' transfer\n         * @param {string} networkId The ID of the network the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.broadcastExternalTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new transfer between addresses.\n         * @summary Create a new transfer\n         * @param {string} networkId The ID of the network the address is on\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateExternalTransferRequest} createExternalTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createExternalTransfer(networkId, addressId, createExternalTransferRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createExternalTransfer(networkId, addressId, createExternalTransferRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.createExternalTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the balance of an asset in an external address\n         * @summary Get the balance of an asset in an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} assetId The ID of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getExternalAddressBalance(networkId, addressId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalAddressBalance(networkId, addressId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.getExternalAddressBalance']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get an external address\\' transfer by ID\n         * @summary Get a external address\\' transfer\n         * @param {string} networkId The ID of the network the address is on\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getExternalTransfer(networkId, addressId, transferId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalTransfer(networkId, addressId, transferId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.getExternalTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the status of a faucet transaction\n         * @summary Get the status of a faucet transaction\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the faucet transaction for\n         * @param {string} txHash The hash of the faucet transaction\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getFaucetTransaction(networkId, addressId, txHash, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaucetTransaction(networkId, addressId, txHash, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.getFaucetTransaction']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List all of the balances of an external address\n         * @summary Get the balances of an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listExternalAddressBalances(networkId, addressId, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listExternalAddressBalances(networkId, addressId, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.listExternalAddressBalances']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Request faucet funds to be sent to external address.\n         * @summary Request faucet funds for external address.\n         * @param {string} networkId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.requestExternalFaucetFunds']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ExternalAddressesApiFp = ExternalAddressesApiFp;\n/**\n * ExternalAddressesApi - factory interface\n * @export\n */\nconst ExternalAddressesApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ExternalAddressesApiFp)(configuration);\n    return {\n        /**\n         * Broadcast an arbitrary transaction to the node constructed and signed by an external address.\n         * @summary Broadcast an arbitrary transaction.\n         * @param {string} networkId The ID of the network the external address belongs to.\n         * @param {string} addressId The onchain address of the transaction sender.\n         * @param {BroadcastExternalTransactionRequest} broadcastExternalTransactionRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastExternalTransaction(networkId, addressId, broadcastExternalTransactionRequest, options) {\n            return localVarFp.broadcastExternalTransaction(networkId, addressId, broadcastExternalTransactionRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Broadcast an external address\\'s transfer with a signed payload\n         * @summary Broadcast an external address\\' transfer\n         * @param {string} networkId The ID of the network the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options) {\n            return localVarFp.broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new transfer between addresses.\n         * @summary Create a new transfer\n         * @param {string} networkId The ID of the network the address is on\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateExternalTransferRequest} createExternalTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createExternalTransfer(networkId, addressId, createExternalTransferRequest, options) {\n            return localVarFp.createExternalTransfer(networkId, addressId, createExternalTransferRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the balance of an asset in an external address\n         * @summary Get the balance of an asset in an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} assetId The ID of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalAddressBalance(networkId, addressId, assetId, options) {\n            return localVarFp.getExternalAddressBalance(networkId, addressId, assetId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get an external address\\' transfer by ID\n         * @summary Get a external address\\' transfer\n         * @param {string} networkId The ID of the network the address is on\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalTransfer(networkId, addressId, transferId, options) {\n            return localVarFp.getExternalTransfer(networkId, addressId, transferId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the status of a faucet transaction\n         * @summary Get the status of a faucet transaction\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the faucet transaction for\n         * @param {string} txHash The hash of the faucet transaction\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFaucetTransaction(networkId, addressId, txHash, options) {\n            return localVarFp.getFaucetTransaction(networkId, addressId, txHash, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List all of the balances of an external address\n         * @summary Get the balances of an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listExternalAddressBalances(networkId, addressId, page, options) {\n            return localVarFp.listExternalAddressBalances(networkId, addressId, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Request faucet funds to be sent to external address.\n         * @summary Request faucet funds for external address.\n         * @param {string} networkId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options) {\n            return localVarFp.requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ExternalAddressesApiFactory = ExternalAddressesApiFactory;\n/**\n * ExternalAddressesApi - object-oriented interface\n * @export\n * @class ExternalAddressesApi\n * @extends {BaseAPI}\n */\nclass ExternalAddressesApi extends base_1.BaseAPI {\n    /**\n     * Broadcast an arbitrary transaction to the node constructed and signed by an external address.\n     * @summary Broadcast an arbitrary transaction.\n     * @param {string} networkId The ID of the network the external address belongs to.\n     * @param {string} addressId The onchain address of the transaction sender.\n     * @param {BroadcastExternalTransactionRequest} broadcastExternalTransactionRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    broadcastExternalTransaction(networkId, addressId, broadcastExternalTransactionRequest, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).broadcastExternalTransaction(networkId, addressId, broadcastExternalTransactionRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Broadcast an external address\\'s transfer with a signed payload\n     * @summary Broadcast an external address\\' transfer\n     * @param {string} networkId The ID of the network the address belongs to\n     * @param {string} addressId The ID of the address the transfer belongs to\n     * @param {string} transferId The ID of the transfer to broadcast\n     * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new transfer between addresses.\n     * @summary Create a new transfer\n     * @param {string} networkId The ID of the network the address is on\n     * @param {string} addressId The ID of the address to transfer from\n     * @param {CreateExternalTransferRequest} createExternalTransferRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    createExternalTransfer(networkId, addressId, createExternalTransferRequest, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).createExternalTransfer(networkId, addressId, createExternalTransferRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the balance of an asset in an external address\n     * @summary Get the balance of an asset in an external address\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the balance for\n     * @param {string} assetId The ID of the asset to fetch the balance for\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    getExternalAddressBalance(networkId, addressId, assetId, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).getExternalAddressBalance(networkId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get an external address\\' transfer by ID\n     * @summary Get a external address\\' transfer\n     * @param {string} networkId The ID of the network the address is on\n     * @param {string} addressId The ID of the address the transfer belongs to\n     * @param {string} transferId The ID of the transfer to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    getExternalTransfer(networkId, addressId, transferId, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).getExternalTransfer(networkId, addressId, transferId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the status of a faucet transaction\n     * @summary Get the status of a faucet transaction\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the faucet transaction for\n     * @param {string} txHash The hash of the faucet transaction\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    getFaucetTransaction(networkId, addressId, txHash, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).getFaucetTransaction(networkId, addressId, txHash, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List all of the balances of an external address\n     * @summary Get the balances of an external address\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the balance for\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    listExternalAddressBalances(networkId, addressId, page, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).listExternalAddressBalances(networkId, addressId, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Request faucet funds to be sent to external address.\n     * @summary Request faucet funds for external address.\n     * @param {string} networkId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n     * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ExternalAddressesApi = ExternalAddressesApi;\n/**\n * FundApi - axios parameter creator\n * @export\n */\nconst FundApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a new fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundOperationRequest} createFundOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFundOperation: async (walletId, addressId, createFundOperationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createFundOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createFundOperation', 'addressId', addressId);\n            // verify required parameter 'createFundOperationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createFundOperation', 'createFundOperationRequest', createFundOperationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createFundOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a Fund Operation quote.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundQuoteRequest} createFundQuoteRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFundQuote: async (walletId, addressId, createFundQuoteRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createFundQuote', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createFundQuote', 'addressId', addressId);\n            // verify required parameter 'createFundQuoteRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createFundQuote', 'createFundQuoteRequest', createFundQuoteRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations/quote`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createFundQuoteRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get fund operation.\n         * @summary Get fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that created the fund operation.\n         * @param {string} fundOperationId The ID of the fund operation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFundOperation: async (walletId, addressId, fundOperationId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getFundOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getFundOperation', 'addressId', addressId);\n            // verify required parameter 'fundOperationId' is not null or undefined\n            (0, common_1.assertParamExists)('getFundOperation', 'fundOperationId', fundOperationId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations/{fund_operation_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"fund_operation_id\"}}`, encodeURIComponent(String(fundOperationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List fund operations for an address.\n         * @summary List fund operations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to list fund operations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFundOperations: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listFundOperations', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listFundOperations', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.FundApiAxiosParamCreator = FundApiAxiosParamCreator;\n/**\n * FundApi - functional programming interface\n * @export\n */\nconst FundApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.FundApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a new fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundOperationRequest} createFundOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createFundOperation(walletId, addressId, createFundOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createFundOperation(walletId, addressId, createFundOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.createFundOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a Fund Operation quote.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundQuoteRequest} createFundQuoteRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createFundQuote(walletId, addressId, createFundQuoteRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createFundQuote(walletId, addressId, createFundQuoteRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.createFundQuote']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get fund operation.\n         * @summary Get fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that created the fund operation.\n         * @param {string} fundOperationId The ID of the fund operation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getFundOperation(walletId, addressId, fundOperationId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundOperation(walletId, addressId, fundOperationId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.getFundOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List fund operations for an address.\n         * @summary List fund operations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to list fund operations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listFundOperations(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listFundOperations(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.listFundOperations']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.FundApiFp = FundApiFp;\n/**\n * FundApi - factory interface\n * @export\n */\nconst FundApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.FundApiFp)(configuration);\n    return {\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a new fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundOperationRequest} createFundOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFundOperation(walletId, addressId, createFundOperationRequest, options) {\n            return localVarFp.createFundOperation(walletId, addressId, createFundOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a Fund Operation quote.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundQuoteRequest} createFundQuoteRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFundQuote(walletId, addressId, createFundQuoteRequest, options) {\n            return localVarFp.createFundQuote(walletId, addressId, createFundQuoteRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get fund operation.\n         * @summary Get fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that created the fund operation.\n         * @param {string} fundOperationId The ID of the fund operation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFundOperation(walletId, addressId, fundOperationId, options) {\n            return localVarFp.getFundOperation(walletId, addressId, fundOperationId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List fund operations for an address.\n         * @summary List fund operations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to list fund operations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFundOperations(walletId, addressId, limit, page, options) {\n            return localVarFp.listFundOperations(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.FundApiFactory = FundApiFactory;\n/**\n * FundApi - object-oriented interface\n * @export\n * @class FundApi\n * @extends {BaseAPI}\n */\nclass FundApi extends base_1.BaseAPI {\n    /**\n     * Create a new fund operation with an address.\n     * @summary Create a new fund operation.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address to be funded.\n     * @param {CreateFundOperationRequest} createFundOperationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FundApi\n     */\n    createFundOperation(walletId, addressId, createFundOperationRequest, options) {\n        return (0, exports.FundApiFp)(this.configuration).createFundOperation(walletId, addressId, createFundOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new fund operation with an address.\n     * @summary Create a Fund Operation quote.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address to be funded.\n     * @param {CreateFundQuoteRequest} createFundQuoteRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FundApi\n     */\n    createFundQuote(walletId, addressId, createFundQuoteRequest, options) {\n        return (0, exports.FundApiFp)(this.configuration).createFundQuote(walletId, addressId, createFundQuoteRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get fund operation.\n     * @summary Get fund operation.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that created the fund operation.\n     * @param {string} fundOperationId The ID of the fund operation to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FundApi\n     */\n    getFundOperation(walletId, addressId, fundOperationId, options) {\n        return (0, exports.FundApiFp)(this.configuration).getFundOperation(walletId, addressId, fundOperationId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List fund operations for an address.\n     * @summary List fund operations for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address to list fund operations for.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FundApi\n     */\n    listFundOperations(walletId, addressId, limit, page, options) {\n        return (0, exports.FundApiFp)(this.configuration).listFundOperations(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.FundApi = FundApi;\n/**\n * MPCWalletStakeApi - axios parameter creator\n * @export\n */\nconst MPCWalletStakeApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast a staking operation.\n         * @summary Broadcast a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the staking operation belongs to.\n         * @param {string} stakingOperationId The ID of the staking operation to broadcast.\n         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastStakingOperation: async (walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastStakingOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastStakingOperation', 'addressId', addressId);\n            // verify required parameter 'stakingOperationId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastStakingOperation', 'stakingOperationId', stakingOperationId);\n            // verify required parameter 'broadcastStakingOperationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastStakingOperation', 'broadcastStakingOperationRequest', broadcastStakingOperationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations/{staking_operation_id}/broadcast`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"staking_operation_id\"}}`, encodeURIComponent(String(stakingOperationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastStakingOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new staking operation.\n         * @summary Create a new staking operation for an address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to create the staking operation for.\n         * @param {CreateStakingOperationRequest} createStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createStakingOperation: async (walletId, addressId, createStakingOperationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createStakingOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createStakingOperation', 'addressId', addressId);\n            // verify required parameter 'createStakingOperationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createStakingOperation', 'createStakingOperationRequest', createStakingOperationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createStakingOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the latest state of a staking operation.\n         * @summary Get the latest state of a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to fetch the staking operation for.\n         * @param {string} stakingOperationId The ID of the staking operation.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getStakingOperation: async (walletId, addressId, stakingOperationId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getStakingOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getStakingOperation', 'addressId', addressId);\n            // verify required parameter 'stakingOperationId' is not null or undefined\n            (0, common_1.assertParamExists)('getStakingOperation', 'stakingOperationId', stakingOperationId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations/{staking_operation_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"staking_operation_id\"}}`, encodeURIComponent(String(stakingOperationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.MPCWalletStakeApiAxiosParamCreator = MPCWalletStakeApiAxiosParamCreator;\n/**\n * MPCWalletStakeApi - functional programming interface\n * @export\n */\nconst MPCWalletStakeApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.MPCWalletStakeApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast a staking operation.\n         * @summary Broadcast a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the staking operation belongs to.\n         * @param {string} stakingOperationId The ID of the staking operation to broadcast.\n         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['MPCWalletStakeApi.broadcastStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new staking operation.\n         * @summary Create a new staking operation for an address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to create the staking operation for.\n         * @param {CreateStakingOperationRequest} createStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createStakingOperation(walletId, addressId, createStakingOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createStakingOperation(walletId, addressId, createStakingOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['MPCWalletStakeApi.createStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the latest state of a staking operation.\n         * @summary Get the latest state of a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to fetch the staking operation for.\n         * @param {string} stakingOperationId The ID of the staking operation.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getStakingOperation(walletId, addressId, stakingOperationId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingOperation(walletId, addressId, stakingOperationId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['MPCWalletStakeApi.getStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.MPCWalletStakeApiFp = MPCWalletStakeApiFp;\n/**\n * MPCWalletStakeApi - factory interface\n * @export\n */\nconst MPCWalletStakeApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.MPCWalletStakeApiFp)(configuration);\n    return {\n        /**\n         * Broadcast a staking operation.\n         * @summary Broadcast a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the staking operation belongs to.\n         * @param {string} stakingOperationId The ID of the staking operation to broadcast.\n         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options) {\n            return localVarFp.broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new staking operation.\n         * @summary Create a new staking operation for an address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to create the staking operation for.\n         * @param {CreateStakingOperationRequest} createStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createStakingOperation(walletId, addressId, createStakingOperationRequest, options) {\n            return localVarFp.createStakingOperation(walletId, addressId, createStakingOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the latest state of a staking operation.\n         * @summary Get the latest state of a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to fetch the staking operation for.\n         * @param {string} stakingOperationId The ID of the staking operation.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getStakingOperation(walletId, addressId, stakingOperationId, options) {\n            return localVarFp.getStakingOperation(walletId, addressId, stakingOperationId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.MPCWalletStakeApiFactory = MPCWalletStakeApiFactory;\n/**\n * MPCWalletStakeApi - object-oriented interface\n * @export\n * @class MPCWalletStakeApi\n * @extends {BaseAPI}\n */\nclass MPCWalletStakeApi extends base_1.BaseAPI {\n    /**\n     * Broadcast a staking operation.\n     * @summary Broadcast a staking operation\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address the staking operation belongs to.\n     * @param {string} stakingOperationId The ID of the staking operation to broadcast.\n     * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof MPCWalletStakeApi\n     */\n    broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options) {\n        return (0, exports.MPCWalletStakeApiFp)(this.configuration).broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new staking operation.\n     * @summary Create a new staking operation for an address\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to create the staking operation for.\n     * @param {CreateStakingOperationRequest} createStakingOperationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof MPCWalletStakeApi\n     */\n    createStakingOperation(walletId, addressId, createStakingOperationRequest, options) {\n        return (0, exports.MPCWalletStakeApiFp)(this.configuration).createStakingOperation(walletId, addressId, createStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the latest state of a staking operation.\n     * @summary Get the latest state of a staking operation\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address to fetch the staking operation for.\n     * @param {string} stakingOperationId The ID of the staking operation.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof MPCWalletStakeApi\n     */\n    getStakingOperation(walletId, addressId, stakingOperationId, options) {\n        return (0, exports.MPCWalletStakeApiFp)(this.configuration).getStakingOperation(walletId, addressId, stakingOperationId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.MPCWalletStakeApi = MPCWalletStakeApi;\n/**\n * NetworksApi - axios parameter creator\n * @export\n */\nconst NetworksApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get network\n         * @summary Get network by ID\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getNetwork: async (networkId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getNetwork', 'networkId', networkId);\n            const localVarPath = `/v1/networks/{network_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.NetworksApiAxiosParamCreator = NetworksApiAxiosParamCreator;\n/**\n * NetworksApi - functional programming interface\n * @export\n */\nconst NetworksApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.NetworksApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Get network\n         * @summary Get network by ID\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getNetwork(networkId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetwork(networkId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['NetworksApi.getNetwork']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.NetworksApiFp = NetworksApiFp;\n/**\n * NetworksApi - factory interface\n * @export\n */\nconst NetworksApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.NetworksApiFp)(configuration);\n    return {\n        /**\n         * Get network\n         * @summary Get network by ID\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getNetwork(networkId, options) {\n            return localVarFp.getNetwork(networkId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.NetworksApiFactory = NetworksApiFactory;\n/**\n * NetworksApi - object-oriented interface\n * @export\n * @class NetworksApi\n * @extends {BaseAPI}\n */\nclass NetworksApi extends base_1.BaseAPI {\n    /**\n     * Get network\n     * @summary Get network by ID\n     * @param {string} networkId The ID of the network to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NetworksApi\n     */\n    getNetwork(networkId, options) {\n        return (0, exports.NetworksApiFp)(this.configuration).getNetwork(networkId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.NetworksApi = NetworksApi;\n/**\n * OnchainIdentityApi - axios parameter creator\n * @export\n */\nconst OnchainIdentityApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Obtains onchain identity for an address on a specific network\n         * @summary Obtains onchain identity for an address on a specific network\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the identity for\n         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        resolveIdentityByAddress: async (networkId, addressId, roles, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('resolveIdentityByAddress', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('resolveIdentityByAddress', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/identity`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (roles) {\n                localVarQueryParameter['roles'] = roles.join(base_1.COLLECTION_FORMATS.csv);\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.OnchainIdentityApiAxiosParamCreator = OnchainIdentityApiAxiosParamCreator;\n/**\n * OnchainIdentityApi - functional programming interface\n * @export\n */\nconst OnchainIdentityApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.OnchainIdentityApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Obtains onchain identity for an address on a specific network\n         * @summary Obtains onchain identity for an address on a specific network\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the identity for\n         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async resolveIdentityByAddress(networkId, addressId, roles, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveIdentityByAddress(networkId, addressId, roles, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['OnchainIdentityApi.resolveIdentityByAddress']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.OnchainIdentityApiFp = OnchainIdentityApiFp;\n/**\n * OnchainIdentityApi - factory interface\n * @export\n */\nconst OnchainIdentityApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.OnchainIdentityApiFp)(configuration);\n    return {\n        /**\n         * Obtains onchain identity for an address on a specific network\n         * @summary Obtains onchain identity for an address on a specific network\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the identity for\n         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        resolveIdentityByAddress(networkId, addressId, roles, limit, page, options) {\n            return localVarFp.resolveIdentityByAddress(networkId, addressId, roles, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.OnchainIdentityApiFactory = OnchainIdentityApiFactory;\n/**\n * OnchainIdentityApi - object-oriented interface\n * @export\n * @class OnchainIdentityApi\n * @extends {BaseAPI}\n */\nclass OnchainIdentityApi extends base_1.BaseAPI {\n    /**\n     * Obtains onchain identity for an address on a specific network\n     * @summary Obtains onchain identity for an address on a specific network\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the identity for\n     * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OnchainIdentityApi\n     */\n    resolveIdentityByAddress(networkId, addressId, roles, limit, page, options) {\n        return (0, exports.OnchainIdentityApiFp)(this.configuration).resolveIdentityByAddress(networkId, addressId, roles, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.OnchainIdentityApi = OnchainIdentityApi;\n/**\n * @export\n */\nexports.ResolveIdentityByAddressRolesEnum = {\n    Managed: 'managed',\n    Owned: 'owned'\n};\n/**\n * ReputationApi - axios parameter creator\n * @export\n */\nconst ReputationApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get the onchain reputation of an external address\n         * @summary Get the onchain reputation of an external address\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} addressId The ID of the address to fetch the reputation for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddressReputation: async (networkId, addressId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddressReputation', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddressReputation', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/reputation`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ReputationApiAxiosParamCreator = ReputationApiAxiosParamCreator;\n/**\n * ReputationApi - functional programming interface\n * @export\n */\nconst ReputationApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ReputationApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Get the onchain reputation of an external address\n         * @summary Get the onchain reputation of an external address\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} addressId The ID of the address to fetch the reputation for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getAddressReputation(networkId, addressId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressReputation(networkId, addressId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ReputationApi.getAddressReputation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ReputationApiFp = ReputationApiFp;\n/**\n * ReputationApi - factory interface\n * @export\n */\nconst ReputationApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ReputationApiFp)(configuration);\n    return {\n        /**\n         * Get the onchain reputation of an external address\n         * @summary Get the onchain reputation of an external address\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} addressId The ID of the address to fetch the reputation for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddressReputation(networkId, addressId, options) {\n            return localVarFp.getAddressReputation(networkId, addressId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ReputationApiFactory = ReputationApiFactory;\n/**\n * ReputationApi - object-oriented interface\n * @export\n * @class ReputationApi\n * @extends {BaseAPI}\n */\nclass ReputationApi extends base_1.BaseAPI {\n    /**\n     * Get the onchain reputation of an external address\n     * @summary Get the onchain reputation of an external address\n     * @param {string} networkId The ID of the blockchain network.\n     * @param {string} addressId The ID of the address to fetch the reputation for.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ReputationApi\n     */\n    getAddressReputation(networkId, addressId, options) {\n        return (0, exports.ReputationApiFp)(this.configuration).getAddressReputation(networkId, addressId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ReputationApi = ReputationApi;\n/**\n * ServerSignersApi - axios parameter creator\n * @export\n */\nconst ServerSignersApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new Server-Signer\n         * @summary Create a new Server-Signer\n         * @param {CreateServerSignerRequest} [createServerSignerRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createServerSigner: async (createServerSignerRequest, options = {}) => {\n            const localVarPath = `/v1/server_signers`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createServerSignerRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a server signer by ID\n         * @summary Get a server signer by ID\n         * @param {string} serverSignerId The ID of the server signer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getServerSigner: async (serverSignerId, options = {}) => {\n            // verify required parameter 'serverSignerId' is not null or undefined\n            (0, common_1.assertParamExists)('getServerSigner', 'serverSignerId', serverSignerId);\n            const localVarPath = `/v1/server_signers/{server_signer_id}`\n                .replace(`{${\"server_signer_id\"}}`, encodeURIComponent(String(serverSignerId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List events for a server signer\n         * @summary List events for a server signer\n         * @param {string} serverSignerId The ID of the server signer to fetch events for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        listServerSignerEvents: async (serverSignerId, limit, page, options = {}) => {\n            // verify required parameter 'serverSignerId' is not null or undefined\n            (0, common_1.assertParamExists)('listServerSignerEvents', 'serverSignerId', serverSignerId);\n            const localVarPath = `/v1/server_signers/{server_signer_id}/events`\n                .replace(`{${\"server_signer_id\"}}`, encodeURIComponent(String(serverSignerId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List server signers for the current project\n         * @summary List server signers for the current project\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listServerSigners: async (limit, page, options = {}) => {\n            const localVarPath = `/v1/server_signers`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SeedCreationEventResult} [seedCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitServerSignerSeedEventResult: async (serverSignerId, seedCreationEventResult, options = {}) => {\n            // verify required parameter 'serverSignerId' is not null or undefined\n            (0, common_1.assertParamExists)('submitServerSignerSeedEventResult', 'serverSignerId', serverSignerId);\n            const localVarPath = `/v1/server_signers/{server_signer_id}/seed_event_result`\n                .replace(`{${\"server_signer_id\"}}`, encodeURIComponent(String(serverSignerId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(seedCreationEventResult, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SignatureCreationEventResult} [signatureCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitServerSignerSignatureEventResult: async (serverSignerId, signatureCreationEventResult, options = {}) => {\n            // verify required parameter 'serverSignerId' is not null or undefined\n            (0, common_1.assertParamExists)('submitServerSignerSignatureEventResult', 'serverSignerId', serverSignerId);\n            const localVarPath = `/v1/server_signers/{server_signer_id}/signature_event_result`\n                .replace(`{${\"server_signer_id\"}}`, encodeURIComponent(String(serverSignerId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(signatureCreationEventResult, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ServerSignersApiAxiosParamCreator = ServerSignersApiAxiosParamCreator;\n/**\n * ServerSignersApi - functional programming interface\n * @export\n */\nconst ServerSignersApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ServerSignersApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new Server-Signer\n         * @summary Create a new Server-Signer\n         * @param {CreateServerSignerRequest} [createServerSignerRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createServerSigner(createServerSignerRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createServerSigner(createServerSignerRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.createServerSigner']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a server signer by ID\n         * @summary Get a server signer by ID\n         * @param {string} serverSignerId The ID of the server signer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getServerSigner(serverSignerId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerSigner(serverSignerId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.getServerSigner']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List events for a server signer\n         * @summary List events for a server signer\n         * @param {string} serverSignerId The ID of the server signer to fetch events for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        async listServerSignerEvents(serverSignerId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerSignerEvents(serverSignerId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.listServerSignerEvents']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List server signers for the current project\n         * @summary List server signers for the current project\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listServerSigners(limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerSigners(limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.listServerSigners']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SeedCreationEventResult} [seedCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.submitServerSignerSeedEventResult']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SignatureCreationEventResult} [signatureCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.submitServerSignerSignatureEventResult']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ServerSignersApiFp = ServerSignersApiFp;\n/**\n * ServerSignersApi - factory interface\n * @export\n */\nconst ServerSignersApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ServerSignersApiFp)(configuration);\n    return {\n        /**\n         * Create a new Server-Signer\n         * @summary Create a new Server-Signer\n         * @param {CreateServerSignerRequest} [createServerSignerRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createServerSigner(createServerSignerRequest, options) {\n            return localVarFp.createServerSigner(createServerSignerRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a server signer by ID\n         * @summary Get a server signer by ID\n         * @param {string} serverSignerId The ID of the server signer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getServerSigner(serverSignerId, options) {\n            return localVarFp.getServerSigner(serverSignerId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List events for a server signer\n         * @summary List events for a server signer\n         * @param {string} serverSignerId The ID of the server signer to fetch events for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        listServerSignerEvents(serverSignerId, limit, page, options) {\n            return localVarFp.listServerSignerEvents(serverSignerId, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List server signers for the current project\n         * @summary List server signers for the current project\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listServerSigners(limit, page, options) {\n            return localVarFp.listServerSigners(limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SeedCreationEventResult} [seedCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options) {\n            return localVarFp.submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SignatureCreationEventResult} [signatureCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options) {\n            return localVarFp.submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ServerSignersApiFactory = ServerSignersApiFactory;\n/**\n * ServerSignersApi - object-oriented interface\n * @export\n * @class ServerSignersApi\n * @extends {BaseAPI}\n */\nclass ServerSignersApi extends base_1.BaseAPI {\n    /**\n     * Create a new Server-Signer\n     * @summary Create a new Server-Signer\n     * @param {CreateServerSignerRequest} [createServerSignerRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    createServerSigner(createServerSignerRequest, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).createServerSigner(createServerSignerRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a server signer by ID\n     * @summary Get a server signer by ID\n     * @param {string} serverSignerId The ID of the server signer to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    getServerSigner(serverSignerId, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).getServerSigner(serverSignerId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List events for a server signer\n     * @summary List events for a server signer\n     * @param {string} serverSignerId The ID of the server signer to fetch events for\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    listServerSignerEvents(serverSignerId, limit, page, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).listServerSignerEvents(serverSignerId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List server signers for the current project\n     * @summary List server signers for the current project\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    listServerSigners(limit, page, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).listServerSigners(limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Submit the result of a server signer event\n     * @summary Submit the result of a server signer event\n     * @param {string} serverSignerId The ID of the server signer to submit the event result for\n     * @param {SeedCreationEventResult} [seedCreationEventResult]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Submit the result of a server signer event\n     * @summary Submit the result of a server signer event\n     * @param {string} serverSignerId The ID of the server signer to submit the event result for\n     * @param {SignatureCreationEventResult} [signatureCreationEventResult]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ServerSignersApi = ServerSignersApi;\n/**\n * SmartContractsApi - axios parameter creator\n * @export\n */\nconst SmartContractsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Compile a smart contract\n         * @summary Compile a smart contract\n         * @param {CompileSmartContractRequest} compileSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        compileSmartContract: async (compileSmartContractRequest, options = {}) => {\n            // verify required parameter 'compileSmartContractRequest' is not null or undefined\n            (0, common_1.assertParamExists)('compileSmartContract', 'compileSmartContractRequest', compileSmartContractRequest);\n            const localVarPath = `/v1/smart_contracts/compile`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(compileSmartContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new smart contract\n         * @summary Create a new smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to deploy the smart contract from.\n         * @param {CreateSmartContractRequest} createSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createSmartContract: async (walletId, addressId, createSmartContractRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createSmartContract', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createSmartContract', 'addressId', addressId);\n            // verify required parameter 'createSmartContractRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createSmartContract', 'createSmartContractRequest', createSmartContractRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createSmartContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Deploys a smart contract, by broadcasting the transaction to the network.\n         * @summary Deploy a smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to broadcast the transaction from.\n         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.\n         * @param {DeploySmartContractRequest} deploySmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deploySmartContract: async (walletId, addressId, smartContractId, deploySmartContractRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('deploySmartContract', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('deploySmartContract', 'addressId', addressId);\n            // verify required parameter 'smartContractId' is not null or undefined\n            (0, common_1.assertParamExists)('deploySmartContract', 'smartContractId', smartContractId);\n            // verify required parameter 'deploySmartContractRequest' is not null or undefined\n            (0, common_1.assertParamExists)('deploySmartContract', 'deploySmartContractRequest', deploySmartContractRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts/{smart_contract_id}/deploy`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"smart_contract_id\"}}`, encodeURIComponent(String(smartContractId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(deploySmartContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a specific smart contract deployed by address.\n         * @summary Get a specific smart contract deployed by address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to fetch the smart contract for.\n         * @param {string} smartContractId The UUID of the smart contract to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getSmartContract: async (walletId, addressId, smartContractId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getSmartContract', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getSmartContract', 'addressId', addressId);\n            // verify required parameter 'smartContractId' is not null or undefined\n            (0, common_1.assertParamExists)('getSmartContract', 'smartContractId', smartContractId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts/{smart_contract_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"smart_contract_id\"}}`, encodeURIComponent(String(smartContractId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List smart contracts\n         * @summary List smart contracts\n         * @param {string} [page] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listSmartContracts: async (page, options = {}) => {\n            const localVarPath = `/v1/smart_contracts`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Perform a read operation on a smart contract without creating a transaction\n         * @summary Read data from a smart contract\n         * @param {string} networkId\n         * @param {string} contractAddress\n         * @param {ReadContractRequest} readContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        readContract: async (networkId, contractAddress, readContractRequest, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('readContract', 'networkId', networkId);\n            // verify required parameter 'contractAddress' is not null or undefined\n            (0, common_1.assertParamExists)('readContract', 'contractAddress', contractAddress);\n            // verify required parameter 'readContractRequest' is not null or undefined\n            (0, common_1.assertParamExists)('readContract', 'readContractRequest', readContractRequest);\n            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/read`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"contract_address\"}}`, encodeURIComponent(String(contractAddress)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(readContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Register a smart contract\n         * @summary Register a smart contract\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {RegisterSmartContractRequest} [registerSmartContractRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registerSmartContract: async (networkId, contractAddress, registerSmartContractRequest, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('registerSmartContract', 'networkId', networkId);\n            // verify required parameter 'contractAddress' is not null or undefined\n            (0, common_1.assertParamExists)('registerSmartContract', 'contractAddress', contractAddress);\n            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/register`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"contract_address\"}}`, encodeURIComponent(String(contractAddress)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(registerSmartContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Update a smart contract\n         * @summary Update a smart contract\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {UpdateSmartContractRequest} [updateSmartContractRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateSmartContract: async (networkId, contractAddress, updateSmartContractRequest, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('updateSmartContract', 'networkId', networkId);\n            // verify required parameter 'contractAddress' is not null or undefined\n            (0, common_1.assertParamExists)('updateSmartContract', 'contractAddress', contractAddress);\n            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"contract_address\"}}`, encodeURIComponent(String(contractAddress)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateSmartContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.SmartContractsApiAxiosParamCreator = SmartContractsApiAxiosParamCreator;\n/**\n * SmartContractsApi - functional programming interface\n * @export\n */\nconst SmartContractsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.SmartContractsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Compile a smart contract\n         * @summary Compile a smart contract\n         * @param {CompileSmartContractRequest} compileSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async compileSmartContract(compileSmartContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.compileSmartContract(compileSmartContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.compileSmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new smart contract\n         * @summary Create a new smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to deploy the smart contract from.\n         * @param {CreateSmartContractRequest} createSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createSmartContract(walletId, addressId, createSmartContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createSmartContract(walletId, addressId, createSmartContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.createSmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Deploys a smart contract, by broadcasting the transaction to the network.\n         * @summary Deploy a smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to broadcast the transaction from.\n         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.\n         * @param {DeploySmartContractRequest} deploySmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.deploySmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a specific smart contract deployed by address.\n         * @summary Get a specific smart contract deployed by address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to fetch the smart contract for.\n         * @param {string} smartContractId The UUID of the smart contract to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getSmartContract(walletId, addressId, smartContractId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getSmartContract(walletId, addressId, smartContractId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.getSmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List smart contracts\n         * @summary List smart contracts\n         * @param {string} [page] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listSmartContracts(page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listSmartContracts(page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.listSmartContracts']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Perform a read operation on a smart contract without creating a transaction\n         * @summary Read data from a smart contract\n         * @param {string} networkId\n         * @param {string} contractAddress\n         * @param {ReadContractRequest} readContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async readContract(networkId, contractAddress, readContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.readContract(networkId, contractAddress, readContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.readContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Register a smart contract\n         * @summary Register a smart contract\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {RegisterSmartContractRequest} [registerSmartContractRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.registerSmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Update a smart contract\n         * @summary Update a smart contract\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {UpdateSmartContractRequest} [updateSmartContractRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.updateSmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.SmartContractsApiFp = SmartContractsApiFp;\n/**\n * SmartContractsApi - factory interface\n * @export\n */\nconst SmartContractsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.SmartContractsApiFp)(configuration);\n    return {\n        /**\n         * Compile a smart contract\n         * @summary Compile a smart contract\n         * @param {CompileSmartContractRequest} compileSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        compileSmartContract(compileSmartContractRequest, options) {\n            return localVarFp.compileSmartContract(compileSmartContractRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new smart contract\n         * @summary Create a new smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to deploy the smart contract from.\n         * @param {CreateSmartContractRequest} createSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createSmartContract(walletId, addressId, createSmartContractRequest, options) {\n            return localVarFp.createSmartContract(walletId, addressId, createSmartContractRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Deploys a smart contract, by broadcasting the transaction to the network.\n         * @summary Deploy a smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to broadcast the transaction from.\n         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.\n         * @param {DeploySmartContractRequest} deploySmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options) {\n            return localVarFp.deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a specific smart contract deployed by address.\n         * @summary Get a specific smart contract deployed by address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to fetch the smart contract for.\n         * @param {string} smartContractId The UUID of the smart contract to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getSmartContract(walletId, addressId, smartContractId, options) {\n            return localVarFp.getSmartContract(walletId, addressId, smartContractId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List smart contracts\n         * @summary List smart contracts\n         * @param {string} [page] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listSmartContracts(page, options) {\n            return localVarFp.listSmartContracts(page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Perform a read operation on a smart contract without creating a transaction\n         * @summary Read data from a smart contract\n         * @param {string} networkId\n         * @param {string} contractAddress\n         * @param {ReadContractRequest} readContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        readContract(networkId, contractAddress, readContractRequest, options) {\n            return localVarFp.readContract(networkId, contractAddress, readContractRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Register a smart contract\n         * @summary Register a smart contract\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {RegisterSmartContractRequest} [registerSmartContractRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options) {\n            return localVarFp.registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update a smart contract\n         * @summary Update a smart contract\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {UpdateSmartContractRequest} [updateSmartContractRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options) {\n            return localVarFp.updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.SmartContractsApiFactory = SmartContractsApiFactory;\n/**\n * SmartContractsApi - object-oriented interface\n * @export\n * @class SmartContractsApi\n * @extends {BaseAPI}\n */\nclass SmartContractsApi extends base_1.BaseAPI {\n    /**\n     * Compile a smart contract\n     * @summary Compile a smart contract\n     * @param {CompileSmartContractRequest} compileSmartContractRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    compileSmartContract(compileSmartContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).compileSmartContract(compileSmartContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new smart contract\n     * @summary Create a new smart contract\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to deploy the smart contract from.\n     * @param {CreateSmartContractRequest} createSmartContractRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    createSmartContract(walletId, addressId, createSmartContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).createSmartContract(walletId, addressId, createSmartContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Deploys a smart contract, by broadcasting the transaction to the network.\n     * @summary Deploy a smart contract\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to broadcast the transaction from.\n     * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.\n     * @param {DeploySmartContractRequest} deploySmartContractRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a specific smart contract deployed by address.\n     * @summary Get a specific smart contract deployed by address\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to fetch the smart contract for.\n     * @param {string} smartContractId The UUID of the smart contract to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    getSmartContract(walletId, addressId, smartContractId, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).getSmartContract(walletId, addressId, smartContractId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List smart contracts\n     * @summary List smart contracts\n     * @param {string} [page] Pagination token for retrieving the next set of results\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    listSmartContracts(page, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).listSmartContracts(page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Perform a read operation on a smart contract without creating a transaction\n     * @summary Read data from a smart contract\n     * @param {string} networkId\n     * @param {string} contractAddress\n     * @param {ReadContractRequest} readContractRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    readContract(networkId, contractAddress, readContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).readContract(networkId, contractAddress, readContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Register a smart contract\n     * @summary Register a smart contract\n     * @param {string} networkId The ID of the network to fetch.\n     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n     * @param {RegisterSmartContractRequest} [registerSmartContractRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Update a smart contract\n     * @summary Update a smart contract\n     * @param {string} networkId The ID of the network to fetch.\n     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n     * @param {UpdateSmartContractRequest} [updateSmartContractRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.SmartContractsApi = SmartContractsApi;\n/**\n * StakeApi - axios parameter creator\n * @export\n */\nconst StakeApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Build a new staking operation\n         * @summary Build a new staking operation\n         * @param {BuildStakingOperationRequest} buildStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        buildStakingOperation: async (buildStakingOperationRequest, options = {}) => {\n            // verify required parameter 'buildStakingOperationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('buildStakingOperation', 'buildStakingOperationRequest', buildStakingOperationRequest);\n            const localVarPath = `/v1/stake/build`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(buildStakingOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch historical staking balances for given address.\n         * @summary Fetch historical staking balances\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.\n         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.\n         * @param {string} startTime The start time of this historical staking balance period.\n         * @param {string} endTime The end time of this historical staking balance period.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchHistoricalStakingBalances: async (networkId, assetId, addressId, startTime, endTime, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'networkId', networkId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'assetId', assetId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'addressId', addressId);\n            // verify required parameter 'startTime' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'startTime', startTime);\n            // verify required parameter 'endTime' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'endTime', endTime);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/stake/balances`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            if (assetId !== undefined) {\n                localVarQueryParameter['asset_id'] = assetId;\n            }\n            if (startTime !== undefined) {\n                localVarQueryParameter['start_time'] = (startTime instanceof Date) ?\n                    startTime.toISOString() :\n                    startTime;\n            }\n            if (endTime !== undefined) {\n                localVarQueryParameter['end_time'] = (endTime instanceof Date) ?\n                    endTime.toISOString() :\n                    endTime;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch staking rewards for a list of addresses\n         * @summary Fetch staking rewards\n         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchStakingRewards: async (fetchStakingRewardsRequest, limit, page, options = {}) => {\n            // verify required parameter 'fetchStakingRewardsRequest' is not null or undefined\n            (0, common_1.assertParamExists)('fetchStakingRewards', 'fetchStakingRewardsRequest', fetchStakingRewardsRequest);\n            const localVarPath = `/v1/stake/rewards/search`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(fetchStakingRewardsRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the latest state of a staking operation\n         * @summary Get the latest state of a staking operation\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the staking operation for\n         * @param {string} stakingOperationId The ID of the staking operation\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalStakingOperation: async (networkId, addressId, stakingOperationId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalStakingOperation', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalStakingOperation', 'addressId', addressId);\n            // verify required parameter 'stakingOperationId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalStakingOperation', 'stakingOperationId', stakingOperationId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/staking_operations/{staking_operation_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"staking_operation_id\"}}`, encodeURIComponent(String(stakingOperationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get staking context for an address\n         * @summary Get staking context\n         * @param {GetStakingContextRequest} getStakingContextRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getStakingContext: async (getStakingContextRequest, options = {}) => {\n            // verify required parameter 'getStakingContextRequest' is not null or undefined\n            (0, common_1.assertParamExists)('getStakingContext', 'getStakingContextRequest', getStakingContextRequest);\n            const localVarPath = `/v1/stake/context`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(getStakingContextRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a validator belonging to the user for a given network, asset and id.\n         * @summary Get a validator belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validator for.\n         * @param {string} validatorId The unique id of the validator to fetch details for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getValidator: async (networkId, assetId, validatorId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getValidator', 'networkId', networkId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getValidator', 'assetId', assetId);\n            // verify required parameter 'validatorId' is not null or undefined\n            (0, common_1.assertParamExists)('getValidator', 'validatorId', validatorId);\n            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}/validators/{validator_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)))\n                .replace(`{${\"validator_id\"}}`, encodeURIComponent(String(validatorId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List validators belonging to the user for a given network and asset.\n         * @summary List validators belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validators for.\n         * @param {ValidatorStatus} [status] A filter to list validators based on a status.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listValidators: async (networkId, assetId, status, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listValidators', 'networkId', networkId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('listValidators', 'assetId', assetId);\n            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}/validators`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (status !== undefined) {\n                localVarQueryParameter['status'] = status;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.StakeApiAxiosParamCreator = StakeApiAxiosParamCreator;\n/**\n * StakeApi - functional programming interface\n * @export\n */\nconst StakeApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.StakeApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Build a new staking operation\n         * @summary Build a new staking operation\n         * @param {BuildStakingOperationRequest} buildStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async buildStakingOperation(buildStakingOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.buildStakingOperation(buildStakingOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.buildStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch historical staking balances for given address.\n         * @summary Fetch historical staking balances\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.\n         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.\n         * @param {string} startTime The start time of this historical staking balance period.\n         * @param {string} endTime The end time of this historical staking balance period.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.fetchHistoricalStakingBalances']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch staking rewards for a list of addresses\n         * @summary Fetch staking rewards\n         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.fetchStakingRewards']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the latest state of a staking operation\n         * @summary Get the latest state of a staking operation\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the staking operation for\n         * @param {string} stakingOperationId The ID of the staking operation\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getExternalStakingOperation(networkId, addressId, stakingOperationId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalStakingOperation(networkId, addressId, stakingOperationId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.getExternalStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get staking context for an address\n         * @summary Get staking context\n         * @param {GetStakingContextRequest} getStakingContextRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getStakingContext(getStakingContextRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingContext(getStakingContextRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.getStakingContext']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a validator belonging to the user for a given network, asset and id.\n         * @summary Get a validator belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validator for.\n         * @param {string} validatorId The unique id of the validator to fetch details for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getValidator(networkId, assetId, validatorId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidator(networkId, assetId, validatorId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.getValidator']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List validators belonging to the user for a given network and asset.\n         * @summary List validators belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validators for.\n         * @param {ValidatorStatus} [status] A filter to list validators based on a status.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listValidators(networkId, assetId, status, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listValidators(networkId, assetId, status, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.listValidators']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.StakeApiFp = StakeApiFp;\n/**\n * StakeApi - factory interface\n * @export\n */\nconst StakeApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.StakeApiFp)(configuration);\n    return {\n        /**\n         * Build a new staking operation\n         * @summary Build a new staking operation\n         * @param {BuildStakingOperationRequest} buildStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        buildStakingOperation(buildStakingOperationRequest, options) {\n            return localVarFp.buildStakingOperation(buildStakingOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch historical staking balances for given address.\n         * @summary Fetch historical staking balances\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.\n         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.\n         * @param {string} startTime The start time of this historical staking balance period.\n         * @param {string} endTime The end time of this historical staking balance period.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options) {\n            return localVarFp.fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch staking rewards for a list of addresses\n         * @summary Fetch staking rewards\n         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options) {\n            return localVarFp.fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the latest state of a staking operation\n         * @summary Get the latest state of a staking operation\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the staking operation for\n         * @param {string} stakingOperationId The ID of the staking operation\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalStakingOperation(networkId, addressId, stakingOperationId, options) {\n            return localVarFp.getExternalStakingOperation(networkId, addressId, stakingOperationId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get staking context for an address\n         * @summary Get staking context\n         * @param {GetStakingContextRequest} getStakingContextRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getStakingContext(getStakingContextRequest, options) {\n            return localVarFp.getStakingContext(getStakingContextRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a validator belonging to the user for a given network, asset and id.\n         * @summary Get a validator belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validator for.\n         * @param {string} validatorId The unique id of the validator to fetch details for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getValidator(networkId, assetId, validatorId, options) {\n            return localVarFp.getValidator(networkId, assetId, validatorId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List validators belonging to the user for a given network and asset.\n         * @summary List validators belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validators for.\n         * @param {ValidatorStatus} [status] A filter to list validators based on a status.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listValidators(networkId, assetId, status, limit, page, options) {\n            return localVarFp.listValidators(networkId, assetId, status, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.StakeApiFactory = StakeApiFactory;\n/**\n * StakeApi - object-oriented interface\n * @export\n * @class StakeApi\n * @extends {BaseAPI}\n */\nclass StakeApi extends base_1.BaseAPI {\n    /**\n     * Build a new staking operation\n     * @summary Build a new staking operation\n     * @param {BuildStakingOperationRequest} buildStakingOperationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    buildStakingOperation(buildStakingOperationRequest, options) {\n        return (0, exports.StakeApiFp)(this.configuration).buildStakingOperation(buildStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch historical staking balances for given address.\n     * @summary Fetch historical staking balances\n     * @param {string} networkId The ID of the blockchain network.\n     * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.\n     * @param {string} addressId The onchain address for which the historical staking balances are being fetched.\n     * @param {string} startTime The start time of this historical staking balance period.\n     * @param {string} endTime The end time of this historical staking balance period.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options) {\n        return (0, exports.StakeApiFp)(this.configuration).fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch staking rewards for a list of addresses\n     * @summary Fetch staking rewards\n     * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options) {\n        return (0, exports.StakeApiFp)(this.configuration).fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the latest state of a staking operation\n     * @summary Get the latest state of a staking operation\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the staking operation for\n     * @param {string} stakingOperationId The ID of the staking operation\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    getExternalStakingOperation(networkId, addressId, stakingOperationId, options) {\n        return (0, exports.StakeApiFp)(this.configuration).getExternalStakingOperation(networkId, addressId, stakingOperationId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get staking context for an address\n     * @summary Get staking context\n     * @param {GetStakingContextRequest} getStakingContextRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    getStakingContext(getStakingContextRequest, options) {\n        return (0, exports.StakeApiFp)(this.configuration).getStakingContext(getStakingContextRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a validator belonging to the user for a given network, asset and id.\n     * @summary Get a validator belonging to the CDP project\n     * @param {string} networkId The ID of the blockchain network.\n     * @param {string} assetId The symbol of the asset to get the validator for.\n     * @param {string} validatorId The unique id of the validator to fetch details for.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    getValidator(networkId, assetId, validatorId, options) {\n        return (0, exports.StakeApiFp)(this.configuration).getValidator(networkId, assetId, validatorId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List validators belonging to the user for a given network and asset.\n     * @summary List validators belonging to the CDP project\n     * @param {string} networkId The ID of the blockchain network.\n     * @param {string} assetId The symbol of the asset to get the validators for.\n     * @param {ValidatorStatus} [status] A filter to list validators based on a status.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    listValidators(networkId, assetId, status, limit, page, options) {\n        return (0, exports.StakeApiFp)(this.configuration).listValidators(networkId, assetId, status, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.StakeApi = StakeApi;\n/**\n * TradesApi - axios parameter creator\n * @export\n */\nconst TradesApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast a trade\n         * @summary Broadcast a trade\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to broadcast\n         * @param {BroadcastTradeRequest} broadcastTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastTrade: async (walletId, addressId, tradeId, broadcastTradeRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTrade', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTrade', 'addressId', addressId);\n            // verify required parameter 'tradeId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTrade', 'tradeId', tradeId);\n            // verify required parameter 'broadcastTradeRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTrade', 'broadcastTradeRequest', broadcastTradeRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades/{trade_id}/broadcast`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"trade_id\"}}`, encodeURIComponent(String(tradeId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastTradeRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new trade\n         * @summary Create a new trade for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to conduct the trade from\n         * @param {CreateTradeRequest} createTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createTrade: async (walletId, addressId, createTradeRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createTrade', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createTrade', 'addressId', addressId);\n            // verify required parameter 'createTradeRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createTrade', 'createTradeRequest', createTradeRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createTradeRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a trade by ID\n         * @summary Get a trade by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTrade: async (walletId, addressId, tradeId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getTrade', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getTrade', 'addressId', addressId);\n            // verify required parameter 'tradeId' is not null or undefined\n            (0, common_1.assertParamExists)('getTrade', 'tradeId', tradeId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades/{trade_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"trade_id\"}}`, encodeURIComponent(String(tradeId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List trades for an address.\n         * @summary List trades for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list trades for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listTrades: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listTrades', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listTrades', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.TradesApiAxiosParamCreator = TradesApiAxiosParamCreator;\n/**\n * TradesApi - functional programming interface\n * @export\n */\nconst TradesApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.TradesApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast a trade\n         * @summary Broadcast a trade\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to broadcast\n         * @param {BroadcastTradeRequest} broadcastTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.broadcastTrade']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new trade\n         * @summary Create a new trade for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to conduct the trade from\n         * @param {CreateTradeRequest} createTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createTrade(walletId, addressId, createTradeRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrade(walletId, addressId, createTradeRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.createTrade']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a trade by ID\n         * @summary Get a trade by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getTrade(walletId, addressId, tradeId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(walletId, addressId, tradeId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.getTrade']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List trades for an address.\n         * @summary List trades for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list trades for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listTrades(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrades(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.listTrades']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.TradesApiFp = TradesApiFp;\n/**\n * TradesApi - factory interface\n * @export\n */\nconst TradesApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.TradesApiFp)(configuration);\n    return {\n        /**\n         * Broadcast a trade\n         * @summary Broadcast a trade\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to broadcast\n         * @param {BroadcastTradeRequest} broadcastTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options) {\n            return localVarFp.broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new trade\n         * @summary Create a new trade for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to conduct the trade from\n         * @param {CreateTradeRequest} createTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createTrade(walletId, addressId, createTradeRequest, options) {\n            return localVarFp.createTrade(walletId, addressId, createTradeRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a trade by ID\n         * @summary Get a trade by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTrade(walletId, addressId, tradeId, options) {\n            return localVarFp.getTrade(walletId, addressId, tradeId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List trades for an address.\n         * @summary List trades for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list trades for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listTrades(walletId, addressId, limit, page, options) {\n            return localVarFp.listTrades(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.TradesApiFactory = TradesApiFactory;\n/**\n * TradesApi - object-oriented interface\n * @export\n * @class TradesApi\n * @extends {BaseAPI}\n */\nclass TradesApi extends base_1.BaseAPI {\n    /**\n     * Broadcast a trade\n     * @summary Broadcast a trade\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address the trade belongs to\n     * @param {string} tradeId The ID of the trade to broadcast\n     * @param {BroadcastTradeRequest} broadcastTradeRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TradesApi\n     */\n    broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options) {\n        return (0, exports.TradesApiFp)(this.configuration).broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new trade\n     * @summary Create a new trade for an address\n     * @param {string} walletId The ID of the wallet the source address belongs to\n     * @param {string} addressId The ID of the address to conduct the trade from\n     * @param {CreateTradeRequest} createTradeRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TradesApi\n     */\n    createTrade(walletId, addressId, createTradeRequest, options) {\n        return (0, exports.TradesApiFp)(this.configuration).createTrade(walletId, addressId, createTradeRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a trade by ID\n     * @summary Get a trade by ID\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address the trade belongs to\n     * @param {string} tradeId The ID of the trade to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TradesApi\n     */\n    getTrade(walletId, addressId, tradeId, options) {\n        return (0, exports.TradesApiFp)(this.configuration).getTrade(walletId, addressId, tradeId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List trades for an address.\n     * @summary List trades for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address to list trades for\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TradesApi\n     */\n    listTrades(walletId, addressId, limit, page, options) {\n        return (0, exports.TradesApiFp)(this.configuration).listTrades(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.TradesApi = TradesApi;\n/**\n * TransactionHistoryApi - axios parameter creator\n * @export\n */\nconst TransactionHistoryApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * List all transactions that interact with the address.\n         * @summary List transactions for an address.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the transactions for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressTransactions: async (networkId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressTransactions', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressTransactions', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transactions`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.TransactionHistoryApiAxiosParamCreator = TransactionHistoryApiAxiosParamCreator;\n/**\n * TransactionHistoryApi - functional programming interface\n * @export\n */\nconst TransactionHistoryApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.TransactionHistoryApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * List all transactions that interact with the address.\n         * @summary List transactions for an address.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the transactions for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listAddressTransactions(networkId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressTransactions(networkId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransactionHistoryApi.listAddressTransactions']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.TransactionHistoryApiFp = TransactionHistoryApiFp;\n/**\n * TransactionHistoryApi - factory interface\n * @export\n */\nconst TransactionHistoryApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.TransactionHistoryApiFp)(configuration);\n    return {\n        /**\n         * List all transactions that interact with the address.\n         * @summary List transactions for an address.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the transactions for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressTransactions(networkId, addressId, limit, page, options) {\n            return localVarFp.listAddressTransactions(networkId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.TransactionHistoryApiFactory = TransactionHistoryApiFactory;\n/**\n * TransactionHistoryApi - object-oriented interface\n * @export\n * @class TransactionHistoryApi\n * @extends {BaseAPI}\n */\nclass TransactionHistoryApi extends base_1.BaseAPI {\n    /**\n     * List all transactions that interact with the address.\n     * @summary List transactions for an address.\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the transactions for.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransactionHistoryApi\n     */\n    listAddressTransactions(networkId, addressId, limit, page, options) {\n        return (0, exports.TransactionHistoryApiFp)(this.configuration).listAddressTransactions(networkId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.TransactionHistoryApi = TransactionHistoryApi;\n/**\n * TransfersApi - axios parameter creator\n * @export\n */\nconst TransfersApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast a transfer\n         * @summary Broadcast a transfer\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastTransferRequest} broadcastTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastTransfer: async (walletId, addressId, transferId, broadcastTransferRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTransfer', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTransfer', 'addressId', addressId);\n            // verify required parameter 'transferId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTransfer', 'transferId', transferId);\n            // verify required parameter 'broadcastTransferRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTransfer', 'broadcastTransferRequest', broadcastTransferRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}/broadcast`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"transfer_id\"}}`, encodeURIComponent(String(transferId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastTransferRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new transfer\n         * @summary Create a new transfer for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateTransferRequest} createTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createTransfer: async (walletId, addressId, createTransferRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createTransfer', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createTransfer', 'addressId', addressId);\n            // verify required parameter 'createTransferRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createTransfer', 'createTransferRequest', createTransferRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createTransferRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a transfer by ID\n         * @summary Get a transfer by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTransfer: async (walletId, addressId, transferId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getTransfer', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getTransfer', 'addressId', addressId);\n            // verify required parameter 'transferId' is not null or undefined\n            (0, common_1.assertParamExists)('getTransfer', 'transferId', transferId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"transfer_id\"}}`, encodeURIComponent(String(transferId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List transfers for an address.\n         * @summary List transfers for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list transfers for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listTransfers: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listTransfers', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listTransfers', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.TransfersApiAxiosParamCreator = TransfersApiAxiosParamCreator;\n/**\n * TransfersApi - functional programming interface\n * @export\n */\nconst TransfersApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.TransfersApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast a transfer\n         * @summary Broadcast a transfer\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastTransferRequest} broadcastTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.broadcastTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new transfer\n         * @summary Create a new transfer for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateTransferRequest} createTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createTransfer(walletId, addressId, createTransferRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransfer(walletId, addressId, createTransferRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.createTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a transfer by ID\n         * @summary Get a transfer by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getTransfer(walletId, addressId, transferId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransfer(walletId, addressId, transferId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.getTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List transfers for an address.\n         * @summary List transfers for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list transfers for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listTransfers(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransfers(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.listTransfers']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.TransfersApiFp = TransfersApiFp;\n/**\n * TransfersApi - factory interface\n * @export\n */\nconst TransfersApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.TransfersApiFp)(configuration);\n    return {\n        /**\n         * Broadcast a transfer\n         * @summary Broadcast a transfer\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastTransferRequest} broadcastTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options) {\n            return localVarFp.broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new transfer\n         * @summary Create a new transfer for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateTransferRequest} createTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createTransfer(walletId, addressId, createTransferRequest, options) {\n            return localVarFp.createTransfer(walletId, addressId, createTransferRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a transfer by ID\n         * @summary Get a transfer by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTransfer(walletId, addressId, transferId, options) {\n            return localVarFp.getTransfer(walletId, addressId, transferId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List transfers for an address.\n         * @summary List transfers for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list transfers for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listTransfers(walletId, addressId, limit, page, options) {\n            return localVarFp.listTransfers(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.TransfersApiFactory = TransfersApiFactory;\n/**\n * TransfersApi - object-oriented interface\n * @export\n * @class TransfersApi\n * @extends {BaseAPI}\n */\nclass TransfersApi extends base_1.BaseAPI {\n    /**\n     * Broadcast a transfer\n     * @summary Broadcast a transfer\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address the transfer belongs to\n     * @param {string} transferId The ID of the transfer to broadcast\n     * @param {BroadcastTransferRequest} broadcastTransferRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransfersApi\n     */\n    broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options) {\n        return (0, exports.TransfersApiFp)(this.configuration).broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new transfer\n     * @summary Create a new transfer for an address\n     * @param {string} walletId The ID of the wallet the source address belongs to\n     * @param {string} addressId The ID of the address to transfer from\n     * @param {CreateTransferRequest} createTransferRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransfersApi\n     */\n    createTransfer(walletId, addressId, createTransferRequest, options) {\n        return (0, exports.TransfersApiFp)(this.configuration).createTransfer(walletId, addressId, createTransferRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a transfer by ID\n     * @summary Get a transfer by ID\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address the transfer belongs to\n     * @param {string} transferId The ID of the transfer to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransfersApi\n     */\n    getTransfer(walletId, addressId, transferId, options) {\n        return (0, exports.TransfersApiFp)(this.configuration).getTransfer(walletId, addressId, transferId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List transfers for an address.\n     * @summary List transfers for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address to list transfers for\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransfersApi\n     */\n    listTransfers(walletId, addressId, limit, page, options) {\n        return (0, exports.TransfersApiFp)(this.configuration).listTransfers(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.TransfersApi = TransfersApi;\n/**\n * UsersApi - axios parameter creator\n * @export\n */\nconst UsersApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get current user\n         * @summary Get current user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCurrentUser: async (options = {}) => {\n            const localVarPath = `/v1/users/me`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.UsersApiAxiosParamCreator = UsersApiAxiosParamCreator;\n/**\n * UsersApi - functional programming interface\n * @export\n */\nconst UsersApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.UsersApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Get current user\n         * @summary Get current user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getCurrentUser(options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.UsersApiFp = UsersApiFp;\n/**\n * UsersApi - factory interface\n * @export\n */\nconst UsersApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.UsersApiFp)(configuration);\n    return {\n        /**\n         * Get current user\n         * @summary Get current user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCurrentUser(options) {\n            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.UsersApiFactory = UsersApiFactory;\n/**\n * UsersApi - object-oriented interface\n * @export\n * @class UsersApi\n * @extends {BaseAPI}\n */\nclass UsersApi extends base_1.BaseAPI {\n    /**\n     * Get current user\n     * @summary Get current user\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UsersApi\n     */\n    getCurrentUser(options) {\n        return (0, exports.UsersApiFp)(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.UsersApi = UsersApi;\n/**\n * WalletsApi - axios parameter creator\n * @export\n */\nconst WalletsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new wallet scoped to the user.\n         * @summary Create a new wallet\n         * @param {CreateWalletRequest} [createWalletRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWallet: async (createWalletRequest, options = {}) => {\n            const localVarPath = `/v1/wallets`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWalletRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get wallet\n         * @summary Get wallet by ID\n         * @param {string} walletId The ID of the wallet to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getWallet: async (walletId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getWallet', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the aggregated balance of an asset across all of the addresses in the wallet.\n         * @summary Get the balance of an asset in the wallet\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getWalletBalance: async (walletId, assetId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getWalletBalance', 'walletId', walletId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getWalletBalance', 'assetId', assetId);\n            const localVarPath = `/v1/wallets/{wallet_id}/balances/{asset_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List the balances of all of the addresses in the wallet aggregated by asset.\n         * @summary List wallet balances\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWalletBalances: async (walletId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listWalletBalances', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}/balances`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List wallets belonging to the user.\n         * @summary List wallets\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWallets: async (limit, page, options = {}) => {\n            const localVarPath = `/v1/wallets`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.WalletsApiAxiosParamCreator = WalletsApiAxiosParamCreator;\n/**\n * WalletsApi - functional programming interface\n * @export\n */\nconst WalletsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.WalletsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new wallet scoped to the user.\n         * @summary Create a new wallet\n         * @param {CreateWalletRequest} [createWalletRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createWallet(createWalletRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createWallet(createWalletRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.createWallet']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get wallet\n         * @summary Get wallet by ID\n         * @param {string} walletId The ID of the wallet to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getWallet(walletId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getWallet(walletId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.getWallet']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the aggregated balance of an asset across all of the addresses in the wallet.\n         * @summary Get the balance of an asset in the wallet\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getWalletBalance(walletId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletBalance(walletId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.getWalletBalance']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List the balances of all of the addresses in the wallet aggregated by asset.\n         * @summary List wallet balances\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listWalletBalances(walletId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listWalletBalances(walletId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.listWalletBalances']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List wallets belonging to the user.\n         * @summary List wallets\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listWallets(limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listWallets(limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.listWallets']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.WalletsApiFp = WalletsApiFp;\n/**\n * WalletsApi - factory interface\n * @export\n */\nconst WalletsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.WalletsApiFp)(configuration);\n    return {\n        /**\n         * Create a new wallet scoped to the user.\n         * @summary Create a new wallet\n         * @param {CreateWalletRequest} [createWalletRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWallet(createWalletRequest, options) {\n            return localVarFp.createWallet(createWalletRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get wallet\n         * @summary Get wallet by ID\n         * @param {string} walletId The ID of the wallet to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getWallet(walletId, options) {\n            return localVarFp.getWallet(walletId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the aggregated balance of an asset across all of the addresses in the wallet.\n         * @summary Get the balance of an asset in the wallet\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getWalletBalance(walletId, assetId, options) {\n            return localVarFp.getWalletBalance(walletId, assetId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List the balances of all of the addresses in the wallet aggregated by asset.\n         * @summary List wallet balances\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWalletBalances(walletId, options) {\n            return localVarFp.listWalletBalances(walletId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List wallets belonging to the user.\n         * @summary List wallets\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWallets(limit, page, options) {\n            return localVarFp.listWallets(limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.WalletsApiFactory = WalletsApiFactory;\n/**\n * WalletsApi - object-oriented interface\n * @export\n * @class WalletsApi\n * @extends {BaseAPI}\n */\nclass WalletsApi extends base_1.BaseAPI {\n    /**\n     * Create a new wallet scoped to the user.\n     * @summary Create a new wallet\n     * @param {CreateWalletRequest} [createWalletRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    createWallet(createWalletRequest, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).createWallet(createWalletRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get wallet\n     * @summary Get wallet by ID\n     * @param {string} walletId The ID of the wallet to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    getWallet(walletId, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).getWallet(walletId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the aggregated balance of an asset across all of the addresses in the wallet.\n     * @summary Get the balance of an asset in the wallet\n     * @param {string} walletId The ID of the wallet to fetch the balance for\n     * @param {string} assetId The symbol of the asset to fetch the balance for\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    getWalletBalance(walletId, assetId, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).getWalletBalance(walletId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List the balances of all of the addresses in the wallet aggregated by asset.\n     * @summary List wallet balances\n     * @param {string} walletId The ID of the wallet to fetch the balances for\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    listWalletBalances(walletId, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).listWalletBalances(walletId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List wallets belonging to the user.\n     * @summary List wallets\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    listWallets(limit, page, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).listWallets(limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.WalletsApi = WalletsApi;\n/**\n * WebhooksApi - axios parameter creator\n * @export\n */\nconst WebhooksApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new webhook scoped to a wallet\n         * @summary Create a new webhook scoped to a wallet\n         * @param {string} walletId The ID of the wallet to create the webhook for.\n         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWalletWebhook: async (walletId, createWalletWebhookRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createWalletWebhook', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}/webhooks`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWalletWebhookRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new webhook\n         * @summary Create a new webhook\n         * @param {CreateWebhookRequest} [createWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWebhook: async (createWebhookRequest, options = {}) => {\n            const localVarPath = `/v1/webhooks`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWebhookRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Delete a webhook\n         * @summary Delete a webhook\n         * @param {string} webhookId The Webhook uuid that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteWebhook: async (webhookId, options = {}) => {\n            // verify required parameter 'webhookId' is not null or undefined\n            (0, common_1.assertParamExists)('deleteWebhook', 'webhookId', webhookId);\n            const localVarPath = `/v1/webhooks/{webhook_id}`\n                .replace(`{${\"webhook_id\"}}`, encodeURIComponent(String(webhookId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List webhooks, optionally filtered by event type.\n         * @summary List webhooks\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWebhooks: async (limit, page, options = {}) => {\n            const localVarPath = `/v1/webhooks`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Update a webhook\n         * @summary Update a webhook\n         * @param {string} webhookId The Webhook id that needs to be updated\n         * @param {UpdateWebhookRequest} [updateWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateWebhook: async (webhookId, updateWebhookRequest, options = {}) => {\n            // verify required parameter 'webhookId' is not null or undefined\n            (0, common_1.assertParamExists)('updateWebhook', 'webhookId', webhookId);\n            const localVarPath = `/v1/webhooks/{webhook_id}`\n                .replace(`{${\"webhook_id\"}}`, encodeURIComponent(String(webhookId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateWebhookRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.WebhooksApiAxiosParamCreator = WebhooksApiAxiosParamCreator;\n/**\n * WebhooksApi - functional programming interface\n * @export\n */\nconst WebhooksApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.WebhooksApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new webhook scoped to a wallet\n         * @summary Create a new webhook scoped to a wallet\n         * @param {string} walletId The ID of the wallet to create the webhook for.\n         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createWalletWebhook(walletId, createWalletWebhookRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createWalletWebhook(walletId, createWalletWebhookRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.createWalletWebhook']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new webhook\n         * @summary Create a new webhook\n         * @param {CreateWebhookRequest} [createWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createWebhook(createWebhookRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(createWebhookRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.createWebhook']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Delete a webhook\n         * @summary Delete a webhook\n         * @param {string} webhookId The Webhook uuid that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async deleteWebhook(webhookId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List webhooks, optionally filtered by event type.\n         * @summary List webhooks\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listWebhooks(limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.listWebhooks']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Update a webhook\n         * @summary Update a webhook\n         * @param {string} webhookId The Webhook id that needs to be updated\n         * @param {UpdateWebhookRequest} [updateWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async updateWebhook(webhookId, updateWebhookRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, updateWebhookRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.updateWebhook']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.WebhooksApiFp = WebhooksApiFp;\n/**\n * WebhooksApi - factory interface\n * @export\n */\nconst WebhooksApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.WebhooksApiFp)(configuration);\n    return {\n        /**\n         * Create a new webhook scoped to a wallet\n         * @summary Create a new webhook scoped to a wallet\n         * @param {string} walletId The ID of the wallet to create the webhook for.\n         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWalletWebhook(walletId, createWalletWebhookRequest, options) {\n            return localVarFp.createWalletWebhook(walletId, createWalletWebhookRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new webhook\n         * @summary Create a new webhook\n         * @param {CreateWebhookRequest} [createWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWebhook(createWebhookRequest, options) {\n            return localVarFp.createWebhook(createWebhookRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Delete a webhook\n         * @summary Delete a webhook\n         * @param {string} webhookId The Webhook uuid that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteWebhook(webhookId, options) {\n            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List webhooks, optionally filtered by event type.\n         * @summary List webhooks\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWebhooks(limit, page, options) {\n            return localVarFp.listWebhooks(limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update a webhook\n         * @summary Update a webhook\n         * @param {string} webhookId The Webhook id that needs to be updated\n         * @param {UpdateWebhookRequest} [updateWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateWebhook(webhookId, updateWebhookRequest, options) {\n            return localVarFp.updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.WebhooksApiFactory = WebhooksApiFactory;\n/**\n * WebhooksApi - object-oriented interface\n * @export\n * @class WebhooksApi\n * @extends {BaseAPI}\n */\nclass WebhooksApi extends base_1.BaseAPI {\n    /**\n     * Create a new webhook scoped to a wallet\n     * @summary Create a new webhook scoped to a wallet\n     * @param {string} walletId The ID of the wallet to create the webhook for.\n     * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    createWalletWebhook(walletId, createWalletWebhookRequest, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).createWalletWebhook(walletId, createWalletWebhookRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new webhook\n     * @summary Create a new webhook\n     * @param {CreateWebhookRequest} [createWebhookRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    createWebhook(createWebhookRequest, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).createWebhook(createWebhookRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Delete a webhook\n     * @summary Delete a webhook\n     * @param {string} webhookId The Webhook uuid that needs to be deleted\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    deleteWebhook(webhookId, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List webhooks, optionally filtered by event type.\n     * @summary List webhooks\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    listWebhooks(limit, page, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).listWebhooks(limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Update a webhook\n     * @summary Update a webhook\n     * @param {string} webhookId The Webhook id that needs to be updated\n     * @param {UpdateWebhookRequest} [updateWebhookRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    updateWebhook(webhookId, updateWebhookRequest, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.WebhooksApi = WebhooksApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9DQUFvQyxHQUFHLHlCQUF5QixHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLDBDQUEwQyxHQUFHLGVBQWUsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxnQ0FBZ0MsR0FBRyw0QkFBNEIsR0FBRyxtQ0FBbUMsR0FBRyw4QkFBOEIsR0FBRyw2Q0FBNkMsR0FBRyw4QkFBOEIsR0FBRyxxQ0FBcUMsR0FBRyxnQ0FBZ0MsR0FBRywrQ0FBK0MsR0FBRyx5QkFBeUIsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkIsR0FBRywwQ0FBMEMsR0FBRyx5QkFBeUIsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkIsR0FBRywwQ0FBMEMsR0FBRyxpQkFBaUIsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxrQ0FBa0MsR0FBRyxvQkFBb0IsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxxQ0FBcUMsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyxvQ0FBb0MsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyw2QkFBNkIsR0FBRyx5QkFBeUIsR0FBRywyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0IsR0FBRyw2QkFBNkIsR0FBRyx5QkFBeUIsR0FBRyxrQ0FBa0MsR0FBRyx5QkFBeUIsR0FBRyxpQ0FBaUMsR0FBRywrQkFBK0I7QUFDM2tELG1CQUFtQixHQUFHLDBCQUEwQixHQUFHLHFCQUFxQixHQUFHLG9DQUFvQyxHQUFHLGtCQUFrQixHQUFHLHlCQUF5QixHQUFHLG9CQUFvQixHQUFHLG1DQUFtQyxHQUFHLGdCQUFnQixHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLGlDQUFpQyxHQUFHLG9CQUFvQixHQUFHLDJCQUEyQixHQUFHLHNCQUFzQixHQUFHLHFDQUFxQyxHQUFHLDZCQUE2QixHQUFHLG9DQUFvQyxHQUFHLCtCQUErQixHQUFHLDhDQUE4QyxHQUFHLGlCQUFpQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLGtDQUFrQyxHQUFHLGdCQUFnQixHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLGlDQUFpQyxHQUFHLHlCQUF5QixHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLDBDQUEwQyxHQUFHLHdCQUF3QixHQUFHLCtCQUErQixHQUFHLDBCQUEwQixHQUFHLHlDQUF5QyxHQUFHLHFCQUFxQixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLHNDQUFzQyxHQUFHLHlDQUF5QyxHQUFHLDBCQUEwQixHQUFHLGlDQUFpQyxHQUFHLDRCQUE0QixHQUFHLDJDQUEyQyxHQUFHLG1CQUFtQixHQUFHLDBCQUEwQixHQUFHLHFCQUFxQjtBQUNsN0MsZ0NBQWdDLG1CQUFPLENBQUMsNkRBQU87QUFDL0M7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLG1GQUFVO0FBQ25DO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLCtFQUFRO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHNCQUFzQjtBQUN6QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pELDJCQUEyQixFQUFFLGFBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLCtCQUErQjtBQUNsRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVc7QUFDaEYsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVztBQUNoRiwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVyxXQUFXLFNBQVM7QUFDcEcsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVyxxQkFBcUIscUJBQXFCO0FBQzFILDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSx3QkFBd0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVztBQUNoRiwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXO0FBQ2hGLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVztBQUNoRiwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHNCQUFzQjtBQUN6QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwrQkFBK0I7QUFDbEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsK0JBQStCO0FBQ2xELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsK0JBQStCO0FBQzlDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLDBFQUEwRTtBQUNqRyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsU0FBUyxTQUFTO0FBQzdFLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsWUFBWSxXQUFXLGtCQUFrQixTQUFTO0FBQzdHLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxZQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSwwRUFBMEU7QUFDakcsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsa0ZBQWtGLFFBQVE7QUFDckgsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsOEVBQThFO0FBQ3pHLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLDRKQUE0SjtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsa0JBQWtCLGlCQUFpQjtBQUM5RiwyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLG9CQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsa0ZBQWtGLFFBQVE7QUFDckgsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsOEVBQThFO0FBQ3pHLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLGtGQUFrRixRQUFRO0FBQ3JILG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDhFQUE4RTtBQUN6RyxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLGtGQUFrRixRQUFRO0FBQ2pILGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsOEVBQThFO0FBQ3JHLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixvQ0FBb0M7QUFDdkQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsdUlBQXVJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVcsdUJBQXVCLHVCQUF1QjtBQUM5SCwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixpQ0FBaUM7QUFDcEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVztBQUNoRiwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVyx1QkFBdUIsdUJBQXVCO0FBQzlILDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSwwQkFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVztBQUNoRiwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixvQ0FBb0M7QUFDdkQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsaUNBQWlDO0FBQ3BELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLG9DQUFvQztBQUN2RCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixpQ0FBaUM7QUFDcEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsb0NBQW9DO0FBQ25ELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQ0FBaUM7QUFDaEQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLDBFQUEwRTtBQUNqRyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIscUNBQXFDO0FBQ3hELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLG9IQUFvSDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxZQUFZLFdBQVc7QUFDbEYsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsa0NBQWtDO0FBQ3JELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsWUFBWSxXQUFXLFlBQVksWUFBWTtBQUMxRywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsK0JBQStCO0FBQ2xELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxZQUFZLFdBQVc7QUFDbEYsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxZQUFZLFdBQVcsV0FBVyxTQUFTO0FBQ3RHLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxZQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxZQUFZLFdBQVcsWUFBWSxZQUFZO0FBQzFHLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLFlBQVksV0FBVyxTQUFTLFFBQVE7QUFDbkcsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLFlBQVksV0FBVztBQUNsRiwyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsWUFBWSxXQUFXO0FBQ2xGLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHFDQUFxQztBQUN4RCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixrQ0FBa0M7QUFDckQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsK0JBQStCO0FBQ2xELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHFDQUFxQztBQUN4RCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixrQ0FBa0M7QUFDckQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsK0JBQStCO0FBQ2xELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUscUNBQXFDO0FBQ3BELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsa0NBQWtDO0FBQ2pELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVc7QUFDaEYsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQix3QkFBd0I7QUFDM0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVztBQUNoRiwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVyxrQkFBa0Isa0JBQWtCO0FBQ3BILDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVztBQUNoRiwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsd0JBQXdCO0FBQzNDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQix3QkFBd0I7QUFDM0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSw0QkFBNEI7QUFDM0MsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLHdCQUF3QjtBQUN2QyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixrQ0FBa0M7QUFDckQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsaUlBQWlJO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVcscUJBQXFCLHFCQUFxQjtBQUMxSCwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwrQkFBK0I7QUFDbEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVztBQUNoRiwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVyxxQkFBcUIscUJBQXFCO0FBQzFILDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSx3QkFBd0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixrQ0FBa0M7QUFDckQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsK0JBQStCO0FBQ2xELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLGtDQUFrQztBQUNyRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwrQkFBK0I7QUFDbEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsa0NBQWtDO0FBQ2pELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRCwyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsMENBQTBDO0FBQzdELG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxZQUFZLFdBQVc7QUFDbEYsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsMENBQTBDO0FBQzdELG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsMENBQTBDO0FBQzdELG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSwwQ0FBMEM7QUFDekQsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSwwRUFBMEU7QUFDakcsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLFlBQVksV0FBVztBQUNsRiwyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0Esc0RBQXNELGlCQUFpQjtBQUN2RSwyQkFBMkIsRUFBRSxvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQSxzREFBc0QsaUJBQWlCO0FBQ3ZFLDJCQUEyQixFQUFFLG9CQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIseUJBQXlCO0FBQzVDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0Esc0RBQXNELGlCQUFpQjtBQUN2RSwyQkFBMkIsRUFBRSxvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDhCQUE4QjtBQUNqRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxpSEFBaUg7QUFDakg7QUFDQTtBQUNBLHNEQUFzRCxpQkFBaUI7QUFDdkUsMkJBQTJCLEVBQUUsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQix5QkFBeUI7QUFDNUMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsOEJBQThCO0FBQ2pELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHlCQUF5QjtBQUM1QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw4QkFBOEI7QUFDakQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSwwRUFBMEU7QUFDakcsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLDhCQUE4QjtBQUM3QyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVc7QUFDaEYsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVcsa0JBQWtCLGtCQUFrQjtBQUNwSCwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVcsa0JBQWtCLGtCQUFrQjtBQUNwSCwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixxQkFBcUI7QUFDeEMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLGtCQUFrQixpQkFBaUI7QUFDOUYsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLGtGQUFrRixRQUFRO0FBQ3JILG1CQUFtQiw4QkFBOEI7QUFDakQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsa0JBQWtCLGlCQUFpQjtBQUM5RiwyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLG9CQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsa0ZBQWtGLFFBQVE7QUFDckgsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxrQkFBa0IsaUJBQWlCO0FBQzlGLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixxQkFBcUI7QUFDeEMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSxrRkFBa0YsUUFBUTtBQUNySCxtQkFBbUIsOEJBQThCO0FBQ2pELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsa0ZBQWtGLFFBQVE7QUFDckgsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHFCQUFxQjtBQUN4QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLGtGQUFrRixRQUFRO0FBQ3JILG1CQUFtQiw4QkFBOEI7QUFDakQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSxrRkFBa0YsUUFBUTtBQUNySCxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLGtGQUFrRixRQUFRO0FBQ2pILGVBQWUsOEJBQThCO0FBQzdDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsa0ZBQWtGLFFBQVE7QUFDakgsZUFBZSw0QkFBNEI7QUFDM0MsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUE4QjtBQUNqRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSwySEFBMkg7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxZQUFZLFdBQVc7QUFDbEYsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsWUFBWSxXQUFXLHFCQUFxQixxQkFBcUI7QUFDNUgsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLFNBQVMsU0FBUyxhQUFhLGFBQWE7QUFDdkcsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxZQUFZO0FBQ3pDLDJCQUEyQixFQUFFLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsaUJBQWlCO0FBQ3BDLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxTQUFTLFNBQVM7QUFDN0UsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxZQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixpQkFBaUI7QUFDcEMsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLGlCQUFpQjtBQUNwQyxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSwwRUFBMEU7QUFDakcsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHVCQUF1QjtBQUMxQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVyxTQUFTLFNBQVM7QUFDbEcsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLG9CQUFvQjtBQUN2QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXO0FBQ2hGLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXLFNBQVMsU0FBUztBQUNsRywyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXO0FBQ2hGLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHVCQUF1QjtBQUMxQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixvQkFBb0I7QUFDdkMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsdUJBQXVCO0FBQzFDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLG9CQUFvQjtBQUN2QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxZQUFZLFdBQVc7QUFDbEYsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLDBFQUEwRTtBQUNqRyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsMEJBQTBCO0FBQzdDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXLFlBQVksWUFBWTtBQUN4RywyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsdUJBQXVCO0FBQzFDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVc7QUFDaEYsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVcsWUFBWSxZQUFZO0FBQ3hHLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVc7QUFDaEYsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsMEJBQTBCO0FBQzdDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHVCQUF1QjtBQUMxQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwwQkFBMEI7QUFDN0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsdUJBQXVCO0FBQzFDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSwwRUFBMEU7QUFDakcsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RCwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFdBQVcsU0FBUztBQUM3RSwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RCwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RCwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNELDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRCwyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSw0QkFBNEI7QUFDM0MsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogQ29pbmJhc2UgUGxhdGZvcm0gQVBJXG4gKiBUaGlzIGlzIHRoZSBPcGVuQVBJIDMuMCBzcGVjaWZpY2F0aW9uIGZvciB0aGUgQ29pbmJhc2UgUGxhdGZvcm0gQVBJcywgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBDb2luYmFzZSBQbGF0Zm9ybSBTREtzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAwLjAuMS1hbHBoYVxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmV0d29ya3NBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuTVBDV2FsbGV0U3Rha2VBcGkgPSBleHBvcnRzLk1QQ1dhbGxldFN0YWtlQXBpRmFjdG9yeSA9IGV4cG9ydHMuTVBDV2FsbGV0U3Rha2VBcGlGcCA9IGV4cG9ydHMuTVBDV2FsbGV0U3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuRnVuZEFwaSA9IGV4cG9ydHMuRnVuZEFwaUZhY3RvcnkgPSBleHBvcnRzLkZ1bmRBcGlGcCA9IGV4cG9ydHMuRnVuZEFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaSA9IGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGYWN0b3J5ID0gZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUZwID0gZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5Db250cmFjdEludm9jYXRpb25zQXBpID0gZXhwb3J0cy5Db250cmFjdEludm9jYXRpb25zQXBpRmFjdG9yeSA9IGV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZwID0gZXhwb3J0cy5Db250cmFjdEludm9jYXRpb25zQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLkNvbnRyYWN0RXZlbnRzQXBpID0gZXhwb3J0cy5Db250cmFjdEV2ZW50c0FwaUZhY3RvcnkgPSBleHBvcnRzLkNvbnRyYWN0RXZlbnRzQXBpRnAgPSBleHBvcnRzLkNvbnRyYWN0RXZlbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLkJhbGFuY2VIaXN0b3J5QXBpID0gZXhwb3J0cy5CYWxhbmNlSGlzdG9yeUFwaUZhY3RvcnkgPSBleHBvcnRzLkJhbGFuY2VIaXN0b3J5QXBpRnAgPSBleHBvcnRzLkJhbGFuY2VIaXN0b3J5QXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLkFzc2V0c0FwaSA9IGV4cG9ydHMuQXNzZXRzQXBpRmFjdG9yeSA9IGV4cG9ydHMuQXNzZXRzQXBpRnAgPSBleHBvcnRzLkFzc2V0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5BZGRyZXNzZXNBcGkgPSBleHBvcnRzLkFkZHJlc3Nlc0FwaUZhY3RvcnkgPSBleHBvcnRzLkFkZHJlc3Nlc0FwaUZwID0gZXhwb3J0cy5BZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuV2ViaG9va1N0YXR1cyA9IGV4cG9ydHMuV2ViaG9va0V2ZW50VHlwZSA9IGV4cG9ydHMuV2FsbGV0U2VydmVyU2lnbmVyU3RhdHVzRW51bSA9IGV4cG9ydHMuVmFsaWRhdG9yU3RhdHVzID0gZXhwb3J0cy5UcmFuc2FjdGlvblR5cGUgPSBleHBvcnRzLlRyYW5zYWN0aW9uU3RhdHVzRW51bSA9IGV4cG9ydHMuVG9rZW5UcmFuc2ZlclR5cGUgPSBleHBvcnRzLlN0YWtpbmdSZXdhcmRGb3JtYXQgPSBleHBvcnRzLlN0YWtpbmdSZXdhcmRTdGF0ZUVudW0gPSBleHBvcnRzLlN0YWtpbmdPcGVyYXRpb25TdGF0dXNFbnVtID0gZXhwb3J0cy5TcG9uc29yZWRTZW5kU3RhdHVzRW51bSA9IGV4cG9ydHMuU29saWRpdHlWYWx1ZVR5cGVFbnVtID0gZXhwb3J0cy5TbWFydENvbnRyYWN0VHlwZSA9IGV4cG9ydHMuUGF5bG9hZFNpZ25hdHVyZVN0YXR1c0VudW0gPSBleHBvcnRzLk5ldHdvcmtJZGVudGlmaWVyID0gZXhwb3J0cy5OZXR3b3JrUHJvdG9jb2xGYW1pbHlFbnVtID0gZXhwb3J0cy5GdW5kT3BlcmF0aW9uU3RhdHVzRW51bSA9IHZvaWQgMDtcbmV4cG9ydHMuV2ViaG9va3NBcGkgPSBleHBvcnRzLldlYmhvb2tzQXBpRmFjdG9yeSA9IGV4cG9ydHMuV2ViaG9va3NBcGlGcCA9IGV4cG9ydHMuV2ViaG9va3NBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuV2FsbGV0c0FwaSA9IGV4cG9ydHMuV2FsbGV0c0FwaUZhY3RvcnkgPSBleHBvcnRzLldhbGxldHNBcGlGcCA9IGV4cG9ydHMuV2FsbGV0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5Vc2Vyc0FwaSA9IGV4cG9ydHMuVXNlcnNBcGlGYWN0b3J5ID0gZXhwb3J0cy5Vc2Vyc0FwaUZwID0gZXhwb3J0cy5Vc2Vyc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5UcmFuc2ZlcnNBcGkgPSBleHBvcnRzLlRyYW5zZmVyc0FwaUZhY3RvcnkgPSBleHBvcnRzLlRyYW5zZmVyc0FwaUZwID0gZXhwb3J0cy5UcmFuc2ZlcnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuVHJhbnNhY3Rpb25IaXN0b3J5QXBpID0gZXhwb3J0cy5UcmFuc2FjdGlvbkhpc3RvcnlBcGlGYWN0b3J5ID0gZXhwb3J0cy5UcmFuc2FjdGlvbkhpc3RvcnlBcGlGcCA9IGV4cG9ydHMuVHJhbnNhY3Rpb25IaXN0b3J5QXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLlRyYWRlc0FwaSA9IGV4cG9ydHMuVHJhZGVzQXBpRmFjdG9yeSA9IGV4cG9ydHMuVHJhZGVzQXBpRnAgPSBleHBvcnRzLlRyYWRlc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5TdGFrZUFwaSA9IGV4cG9ydHMuU3Rha2VBcGlGYWN0b3J5ID0gZXhwb3J0cy5TdGFrZUFwaUZwID0gZXhwb3J0cy5TdGFrZUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaSA9IGV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlGYWN0b3J5ID0gZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUZwID0gZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpID0gZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRmFjdG9yeSA9IGV4cG9ydHMuU2VydmVyU2lnbmVyc0FwaUZwID0gZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLlJlcHV0YXRpb25BcGkgPSBleHBvcnRzLlJlcHV0YXRpb25BcGlGYWN0b3J5ID0gZXhwb3J0cy5SZXB1dGF0aW9uQXBpRnAgPSBleHBvcnRzLlJlcHV0YXRpb25BcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuUmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzUm9sZXNFbnVtID0gZXhwb3J0cy5PbmNoYWluSWRlbnRpdHlBcGkgPSBleHBvcnRzLk9uY2hhaW5JZGVudGl0eUFwaUZhY3RvcnkgPSBleHBvcnRzLk9uY2hhaW5JZGVudGl0eUFwaUZwID0gZXhwb3J0cy5PbmNoYWluSWRlbnRpdHlBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuTmV0d29ya3NBcGkgPSBleHBvcnRzLk5ldHdvcmtzQXBpRmFjdG9yeSA9IGV4cG9ydHMuTmV0d29ya3NBcGlGcCA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuZXhwb3J0cy5GdW5kT3BlcmF0aW9uU3RhdHVzRW51bSA9IHtcbiAgICBQZW5kaW5nOiAncGVuZGluZycsXG4gICAgQ29tcGxldGU6ICdjb21wbGV0ZScsXG4gICAgRmFpbGVkOiAnZmFpbGVkJ1xufTtcbmV4cG9ydHMuTmV0d29ya1Byb3RvY29sRmFtaWx5RW51bSA9IHtcbiAgICBFdm06ICdldm0nLFxuICAgIFNvbGFuYTogJ3NvbGFuYSdcbn07XG4vKipcbiAqIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLiBUaGlzIGlzIHVuaXF1ZSBhY3Jvc3MgYWxsIG5ldHdvcmtzLCBhbmQgdGFrZXMgdGhlIGZvcm0gb2YgYDxibG9ja2NoYWluPi08bmV0d29yaz5gLlxuICogQGV4cG9ydFxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5OZXR3b3JrSWRlbnRpZmllciA9IHtcbiAgICBCYXNlU2Vwb2xpYTogJ2Jhc2Utc2Vwb2xpYScsXG4gICAgQmFzZU1haW5uZXQ6ICdiYXNlLW1haW5uZXQnLFxuICAgIEV0aGVyZXVtSG9sZXNreTogJ2V0aGVyZXVtLWhvbGVza3knLFxuICAgIEV0aGVyZXVtU2Vwb2xpYTogJ2V0aGVyZXVtLXNlcG9saWEnLFxuICAgIEV0aGVyZXVtTWFpbm5ldDogJ2V0aGVyZXVtLW1haW5uZXQnLFxuICAgIFBvbHlnb25NYWlubmV0OiAncG9seWdvbi1tYWlubmV0JyxcbiAgICBTb2xhbmFEZXZuZXQ6ICdzb2xhbmEtZGV2bmV0JyxcbiAgICBTb2xhbmFNYWlubmV0OiAnc29sYW5hLW1haW5uZXQnLFxuICAgIEFyYml0cnVtTWFpbm5ldDogJ2FyYml0cnVtLW1haW5uZXQnLFxuICAgIEFyYml0cnVtU2Vwb2xpYTogJ2FyYml0cnVtLXNlcG9saWEnLFxuICAgIEJpdGNvaW5NYWlubmV0OiAnYml0Y29pbi1tYWlubmV0JyxcbiAgICBOZWFyVGVzdG5ldDogJ25lYXItdGVzdG5ldCcsXG4gICAgTmVhck1haW5uZXQ6ICduZWFyLW1haW5uZXQnXG59O1xuZXhwb3J0cy5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzRW51bSA9IHtcbiAgICBQZW5kaW5nOiAncGVuZGluZycsXG4gICAgU2lnbmVkOiAnc2lnbmVkJyxcbiAgICBGYWlsZWQ6ICdmYWlsZWQnXG59O1xuLyoqXG4gKiBUaGUgdHlwZSBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gKiBAZXhwb3J0XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnRzLlNtYXJ0Q29udHJhY3RUeXBlID0ge1xuICAgIEVyYzIwOiAnZXJjMjAnLFxuICAgIEVyYzcyMTogJ2VyYzcyMScsXG4gICAgRXJjMTE1NTogJ2VyYzExNTUnLFxuICAgIEN1c3RvbTogJ2N1c3RvbSdcbn07XG5leHBvcnRzLlNvbGlkaXR5VmFsdWVUeXBlRW51bSA9IHtcbiAgICBVaW50ODogJ3VpbnQ4JyxcbiAgICBVaW50MTY6ICd1aW50MTYnLFxuICAgIFVpbnQzMjogJ3VpbnQzMicsXG4gICAgVWludDY0OiAndWludDY0JyxcbiAgICBVaW50MTI4OiAndWludDEyOCcsXG4gICAgVWludDE2MDogJ3VpbnQxNjAnLFxuICAgIFVpbnQyNTY6ICd1aW50MjU2JyxcbiAgICBJbnQ4OiAnaW50OCcsXG4gICAgSW50MTY6ICdpbnQxNicsXG4gICAgSW50MjQ6ICdpbnQyNCcsXG4gICAgSW50MzI6ICdpbnQzMicsXG4gICAgSW50NTY6ICdpbnQ1NicsXG4gICAgSW50NjQ6ICdpbnQ2NCcsXG4gICAgSW50MTI4OiAnaW50MTI4JyxcbiAgICBJbnQyNTY6ICdpbnQyNTYnLFxuICAgIEFkZHJlc3M6ICdhZGRyZXNzJyxcbiAgICBCb29sOiAnYm9vbCcsXG4gICAgU3RyaW5nOiAnc3RyaW5nJyxcbiAgICBCeXRlczogJ2J5dGVzJyxcbiAgICBCeXRlczE6ICdieXRlczEnLFxuICAgIEJ5dGVzMjogJ2J5dGVzMicsXG4gICAgQnl0ZXMzOiAnYnl0ZXMzJyxcbiAgICBCeXRlczQ6ICdieXRlczQnLFxuICAgIEJ5dGVzNTogJ2J5dGVzNScsXG4gICAgQnl0ZXM2OiAnYnl0ZXM2JyxcbiAgICBCeXRlczc6ICdieXRlczcnLFxuICAgIEJ5dGVzODogJ2J5dGVzOCcsXG4gICAgQnl0ZXM5OiAnYnl0ZXM5JyxcbiAgICBCeXRlczEwOiAnYnl0ZXMxMCcsXG4gICAgQnl0ZXMxMTogJ2J5dGVzMTEnLFxuICAgIEJ5dGVzMTI6ICdieXRlczEyJyxcbiAgICBCeXRlczEzOiAnYnl0ZXMxMycsXG4gICAgQnl0ZXMxNDogJ2J5dGVzMTQnLFxuICAgIEJ5dGVzMTU6ICdieXRlczE1JyxcbiAgICBCeXRlczE2OiAnYnl0ZXMxNicsXG4gICAgQnl0ZXMxNzogJ2J5dGVzMTcnLFxuICAgIEJ5dGVzMTg6ICdieXRlczE4JyxcbiAgICBCeXRlczE5OiAnYnl0ZXMxOScsXG4gICAgQnl0ZXMyMDogJ2J5dGVzMjAnLFxuICAgIEJ5dGVzMjE6ICdieXRlczIxJyxcbiAgICBCeXRlczIyOiAnYnl0ZXMyMicsXG4gICAgQnl0ZXMyMzogJ2J5dGVzMjMnLFxuICAgIEJ5dGVzMjQ6ICdieXRlczI0JyxcbiAgICBCeXRlczI1OiAnYnl0ZXMyNScsXG4gICAgQnl0ZXMyNjogJ2J5dGVzMjYnLFxuICAgIEJ5dGVzMjc6ICdieXRlczI3JyxcbiAgICBCeXRlczI4OiAnYnl0ZXMyOCcsXG4gICAgQnl0ZXMyOTogJ2J5dGVzMjknLFxuICAgIEJ5dGVzMzA6ICdieXRlczMwJyxcbiAgICBCeXRlczMxOiAnYnl0ZXMzMScsXG4gICAgQnl0ZXMzMjogJ2J5dGVzMzInLFxuICAgIEFycmF5OiAnYXJyYXknLFxuICAgIFR1cGxlOiAndHVwbGUnXG59O1xuZXhwb3J0cy5TcG9uc29yZWRTZW5kU3RhdHVzRW51bSA9IHtcbiAgICBQZW5kaW5nOiAncGVuZGluZycsXG4gICAgU2lnbmVkOiAnc2lnbmVkJyxcbiAgICBTdWJtaXR0ZWQ6ICdzdWJtaXR0ZWQnLFxuICAgIENvbXBsZXRlOiAnY29tcGxldGUnLFxuICAgIEZhaWxlZDogJ2ZhaWxlZCdcbn07XG5leHBvcnRzLlN0YWtpbmdPcGVyYXRpb25TdGF0dXNFbnVtID0ge1xuICAgIEluaXRpYWxpemVkOiAnaW5pdGlhbGl6ZWQnLFxuICAgIENvbXBsZXRlOiAnY29tcGxldGUnLFxuICAgIEZhaWxlZDogJ2ZhaWxlZCcsXG4gICAgVW5zcGVjaWZpZWQ6ICd1bnNwZWNpZmllZCdcbn07XG5leHBvcnRzLlN0YWtpbmdSZXdhcmRTdGF0ZUVudW0gPSB7XG4gICAgUGVuZGluZzogJ3BlbmRpbmcnLFxuICAgIERpc3RyaWJ1dGVkOiAnZGlzdHJpYnV0ZWQnXG59O1xuLyoqXG4gKiBUaGUgZm9ybWF0IGluIHdoaWNoIHRoZSByZXdhcmRzIGFyZSB0byBiZSBmZXRjaGVkIGkuZSBuYXRpdmUgb3IgaW4gZXF1aXZhbGVudCBVU0RcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuU3Rha2luZ1Jld2FyZEZvcm1hdCA9IHtcbiAgICBVc2Q6ICd1c2QnLFxuICAgIE5hdGl2ZTogJ25hdGl2ZSdcbn07XG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSB0b2tlbiB0cmFuc2Zlci5cbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuVG9rZW5UcmFuc2ZlclR5cGUgPSB7XG4gICAgRXJjMjA6ICdlcmMyMCcsXG4gICAgRXJjNzIxOiAnZXJjNzIxJyxcbiAgICBFcmMxMTU1OiAnZXJjMTE1NScsXG4gICAgVW5rbm93bjogJ3Vua25vd24nXG59O1xuZXhwb3J0cy5UcmFuc2FjdGlvblN0YXR1c0VudW0gPSB7XG4gICAgUGVuZGluZzogJ3BlbmRpbmcnLFxuICAgIFNpZ25lZDogJ3NpZ25lZCcsXG4gICAgQnJvYWRjYXN0OiAnYnJvYWRjYXN0JyxcbiAgICBDb21wbGV0ZTogJ2NvbXBsZXRlJyxcbiAgICBGYWlsZWQ6ICdmYWlsZWQnLFxuICAgIFVuc3BlY2lmaWVkOiAndW5zcGVjaWZpZWQnXG59O1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5UcmFuc2FjdGlvblR5cGUgPSB7XG4gICAgVHJhbnNmZXI6ICd0cmFuc2Zlcidcbn07XG4vKipcbiAqIFRoZSBzdGF0dXMgb2YgdGhlIHZhbGlkYXRvci5cbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuVmFsaWRhdG9yU3RhdHVzID0ge1xuICAgIFVua25vd246ICd1bmtub3duJyxcbiAgICBQcm92aXNpb25pbmc6ICdwcm92aXNpb25pbmcnLFxuICAgIFByb3Zpc2lvbmVkOiAncHJvdmlzaW9uZWQnLFxuICAgIERlcG9zaXRlZDogJ2RlcG9zaXRlZCcsXG4gICAgUGVuZGluZ0FjdGl2YXRpb246ICdwZW5kaW5nX2FjdGl2YXRpb24nLFxuICAgIEFjdGl2ZTogJ2FjdGl2ZScsXG4gICAgRXhpdGluZzogJ2V4aXRpbmcnLFxuICAgIEV4aXRlZDogJ2V4aXRlZCcsXG4gICAgV2l0aGRyYXdhbEF2YWlsYWJsZTogJ3dpdGhkcmF3YWxfYXZhaWxhYmxlJyxcbiAgICBXaXRoZHJhd2FsQ29tcGxldGU6ICd3aXRoZHJhd2FsX2NvbXBsZXRlJyxcbiAgICBBY3RpdmVTbGFzaGVkOiAnYWN0aXZlX3NsYXNoZWQnLFxuICAgIEV4aXRlZFNsYXNoZWQ6ICdleGl0ZWRfc2xhc2hlZCcsXG4gICAgUmVhcGVkOiAncmVhcGVkJ1xufTtcbmV4cG9ydHMuV2FsbGV0U2VydmVyU2lnbmVyU3RhdHVzRW51bSA9IHtcbiAgICBQZW5kaW5nU2VlZENyZWF0aW9uOiAncGVuZGluZ19zZWVkX2NyZWF0aW9uJyxcbiAgICBBY3RpdmVTZWVkOiAnYWN0aXZlX3NlZWQnXG59O1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5XZWJob29rRXZlbnRUeXBlID0ge1xuICAgIFVuc3BlY2lmaWVkOiAndW5zcGVjaWZpZWQnLFxuICAgIEVyYzIwVHJhbnNmZXI6ICdlcmMyMF90cmFuc2ZlcicsXG4gICAgRXJjNzIxVHJhbnNmZXI6ICdlcmM3MjFfdHJhbnNmZXInLFxuICAgIFdhbGxldEFjdGl2aXR5OiAnd2FsbGV0X2FjdGl2aXR5JyxcbiAgICBTbWFydENvbnRyYWN0RXZlbnRBY3Rpdml0eTogJ3NtYXJ0X2NvbnRyYWN0X2V2ZW50X2FjdGl2aXR5J1xufTtcbi8qKlxuICogVGhlIHN0YXR1cyBvZiB0aGUgd2ViaG9vay5cbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuV2ViaG9va1N0YXR1cyA9IHtcbiAgICBBY3RpdmU6ICdhY3RpdmUnLFxuICAgIEluYWN0aXZlOiAnaW5hY3RpdmUnXG59O1xuLyoqXG4gKiBBZGRyZXNzZXNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBBZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBhZGRyZXNzIHNjb3BlZCB0byB0aGUgd2FsbGV0LlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gY3JlYXRlIHRoZSBhZGRyZXNzIGluLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUFkZHJlc3NSZXF1ZXN0fSBbY3JlYXRlQWRkcmVzc1JlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVBZGRyZXNzOiBhc3luYyAod2FsbGV0SWQsIGNyZWF0ZUFkZHJlc3NSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZUFkZHJlc3MnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZUFkZHJlc3NSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgcGF5bG9hZCBzaWduYXR1cmUgd2l0aCBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgcGF5bG9hZCBzaWduYXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdG8gc2lnbiB0aGUgcGF5bG9hZCB3aXRoLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0fSBbY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlUGF5bG9hZFNpZ25hdHVyZScsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVQYXlsb2FkU2lnbmF0dXJlJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9wYXlsb2FkX3NpZ25hdHVyZXNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWRkcmVzc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYWRkcmVzcyBieSBvbmNoYWluIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBZGRyZXNzOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRBZGRyZXNzJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEFkZHJlc3MnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhZGRyZXNzIGJhbGFuY2VcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFkZHJlc3MgYmFsYW5jZSBmb3IgYXNzZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEFkZHJlc3NCYWxhbmNlOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRBZGRyZXNzQmFsYW5jZScsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRBZGRyZXNzQmFsYW5jZScsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYXNzZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRBZGRyZXNzQmFsYW5jZScsICdhc3NldElkJywgYXNzZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9iYWxhbmNlcy97YXNzZXRfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFzc2V0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYXNzZXRJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBwYXlsb2FkIHNpZ25hdHVyZS5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHBheWxvYWQgc2lnbmF0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgc2lnbmVkIHRoZSBwYXlsb2FkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF5bG9hZFNpZ25hdHVyZUlkIFRoZSBJRCBvZiB0aGUgcGF5bG9hZCBzaWduYXR1cmUgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRQYXlsb2FkU2lnbmF0dXJlOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgcGF5bG9hZFNpZ25hdHVyZUlkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFBheWxvYWRTaWduYXR1cmUnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0UGF5bG9hZFNpZ25hdHVyZScsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAncGF5bG9hZFNpZ25hdHVyZUlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFBheWxvYWRTaWduYXR1cmUnLCAncGF5bG9hZFNpZ25hdHVyZUlkJywgcGF5bG9hZFNpZ25hdHVyZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3BheWxvYWRfc2lnbmF0dXJlcy97cGF5bG9hZF9zaWduYXR1cmVfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInBheWxvYWRfc2lnbmF0dXJlX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocGF5bG9hZFNpZ25hdHVyZUlkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFkZHJlc3MgYmFsYW5jZXNcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFsbCBiYWxhbmNlcyBmb3IgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2VzIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEFkZHJlc3NCYWxhbmNlczogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEFkZHJlc3NCYWxhbmNlcycsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0QWRkcmVzc0JhbGFuY2VzJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9iYWxhbmNlc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWRkcmVzc2VzIGluIHRoZSB3YWxsZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgYWRkcmVzc2VzIGluIGEgd2FsbGV0LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgd2hvc2UgYWRkcmVzc2VzIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RBZGRyZXNzZXM6IGFzeW5jICh3YWxsZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEFkZHJlc3NlcycsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBwYXlsb2FkIHNpZ25hdHVyZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgcGF5bG9hZCBzaWduYXR1cmVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHdob3NlIHBheWxvYWQgc2lnbmF0dXJlcyB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFBheWxvYWRTaWduYXR1cmVzOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdFBheWxvYWRTaWduYXR1cmVzJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RQYXlsb2FkU2lnbmF0dXJlcycsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vcGF5bG9hZF9zaWduYXR1cmVzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1ZXN0IGZhdWNldCBmdW5kcyB0byBiZSBzZW50IHRvIG9uY2hhaW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgUmVxdWVzdCBmYXVjZXQgZnVuZHMgZm9yIG9uY2hhaW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXNzZXRJZF0gVGhlIElEIG9mIHRoZSBhc3NldCB0byB0cmFuc2ZlciBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZXF1ZXN0RmF1Y2V0RnVuZHM6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3JlcXVlc3RGYXVjZXRGdW5kcycsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdyZXF1ZXN0RmF1Y2V0RnVuZHMnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2ZhdWNldGBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChhc3NldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydhc3NldF9pZCddID0gYXNzZXRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQWRkcmVzc2VzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBBZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogQWRkcmVzc2VzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQWRkcmVzc2VzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5BZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBhZGRyZXNzIHNjb3BlZCB0byB0aGUgd2FsbGV0LlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gY3JlYXRlIHRoZSBhZGRyZXNzIGluLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUFkZHJlc3NSZXF1ZXN0fSBbY3JlYXRlQWRkcmVzc1JlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBjcmVhdGVBZGRyZXNzKHdhbGxldElkLCBjcmVhdGVBZGRyZXNzUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZUFkZHJlc3Mod2FsbGV0SWQsIGNyZWF0ZUFkZHJlc3NSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0FkZHJlc3Nlc0FwaS5jcmVhdGVBZGRyZXNzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBwYXlsb2FkIHNpZ25hdHVyZSB3aXRoIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBwYXlsb2FkIHNpZ25hdHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0byBzaWduIHRoZSBwYXlsb2FkIHdpdGguXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3R9IFtjcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZVBheWxvYWRTaWduYXR1cmUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0FkZHJlc3Nlc0FwaS5jcmVhdGVQYXlsb2FkU2lnbmF0dXJlJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhZGRyZXNzIGJ5IG9uY2hhaW4gYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldEFkZHJlc3Mod2FsbGV0SWQsIGFkZHJlc3NJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldEFkZHJlc3Mod2FsbGV0SWQsIGFkZHJlc3NJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBZGRyZXNzZXNBcGkuZ2V0QWRkcmVzcyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWRkcmVzcyBiYWxhbmNlXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhZGRyZXNzIGJhbGFuY2UgZm9yIGFzc2V0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRBZGRyZXNzQmFsYW5jZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0QWRkcmVzc0JhbGFuY2Uod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBZGRyZXNzZXNBcGkuZ2V0QWRkcmVzc0JhbGFuY2UnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBheWxvYWQgc2lnbmF0dXJlLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgcGF5bG9hZCBzaWduYXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBzaWduZWQgdGhlIHBheWxvYWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXlsb2FkU2lnbmF0dXJlSWQgVGhlIElEIG9mIHRoZSBwYXlsb2FkIHNpZ25hdHVyZSB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldFBheWxvYWRTaWduYXR1cmUod2FsbGV0SWQsIGFkZHJlc3NJZCwgcGF5bG9hZFNpZ25hdHVyZUlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0UGF5bG9hZFNpZ25hdHVyZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBwYXlsb2FkU2lnbmF0dXJlSWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQWRkcmVzc2VzQXBpLmdldFBheWxvYWRTaWduYXR1cmUnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFkZHJlc3MgYmFsYW5jZXNcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFsbCBiYWxhbmNlcyBmb3IgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2VzIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdEFkZHJlc3NCYWxhbmNlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdEFkZHJlc3NCYWxhbmNlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0FkZHJlc3Nlc0FwaS5saXN0QWRkcmVzc0JhbGFuY2VzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWRkcmVzc2VzIGluIHRoZSB3YWxsZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgYWRkcmVzc2VzIGluIGEgd2FsbGV0LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgd2hvc2UgYWRkcmVzc2VzIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RBZGRyZXNzZXMod2FsbGV0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdEFkZHJlc3Nlcyh3YWxsZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQWRkcmVzc2VzQXBpLmxpc3RBZGRyZXNzZXMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBwYXlsb2FkIHNpZ25hdHVyZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgcGF5bG9hZCBzaWduYXR1cmVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHdob3NlIHBheWxvYWQgc2lnbmF0dXJlcyB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdFBheWxvYWRTaWduYXR1cmVzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdFBheWxvYWRTaWduYXR1cmVzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0FkZHJlc3Nlc0FwaS5saXN0UGF5bG9hZFNpZ25hdHVyZXMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVxdWVzdCBmYXVjZXQgZnVuZHMgdG8gYmUgc2VudCB0byBvbmNoYWluIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIGZvciBvbmNoYWluIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Fzc2V0SWRdIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gdHJhbnNmZXIgZnJvbSB0aGUgZmF1Y2V0LlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcmVxdWVzdEZhdWNldEZ1bmRzKHdhbGxldElkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5yZXF1ZXN0RmF1Y2V0RnVuZHMod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBZGRyZXNzZXNBcGkucmVxdWVzdEZhdWNldEZ1bmRzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQWRkcmVzc2VzQXBpRnAgPSBBZGRyZXNzZXNBcGlGcDtcbi8qKlxuICogQWRkcmVzc2VzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQWRkcmVzc2VzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuQWRkcmVzc2VzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgYWRkcmVzcyBzY29wZWQgdG8gdGhlIHdhbGxldC5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGNyZWF0ZSB0aGUgYWRkcmVzcyBpbi5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVBZGRyZXNzUmVxdWVzdH0gW2NyZWF0ZUFkZHJlc3NSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlQWRkcmVzcyh3YWxsZXRJZCwgY3JlYXRlQWRkcmVzc1JlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZUFkZHJlc3Mod2FsbGV0SWQsIGNyZWF0ZUFkZHJlc3NSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHBheWxvYWQgc2lnbmF0dXJlIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHBheWxvYWQgc2lnbmF0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRvIHNpZ24gdGhlIHBheWxvYWQgd2l0aC5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdH0gW2NyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlUGF5bG9hZFNpZ25hdHVyZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhZGRyZXNzIGJ5IG9uY2hhaW4gYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEFkZHJlc3Mod2FsbGV0SWQsIGFkZHJlc3NJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0QWRkcmVzcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFkZHJlc3MgYmFsYW5jZVxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYWRkcmVzcyBiYWxhbmNlIGZvciBhc3NldFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWRkcmVzc0JhbGFuY2Uod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0QWRkcmVzc0JhbGFuY2Uod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBwYXlsb2FkIHNpZ25hdHVyZS5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHBheWxvYWQgc2lnbmF0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgc2lnbmVkIHRoZSBwYXlsb2FkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF5bG9hZFNpZ25hdHVyZUlkIFRoZSBJRCBvZiB0aGUgcGF5bG9hZCBzaWduYXR1cmUgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIHBheWxvYWRTaWduYXR1cmVJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0UGF5bG9hZFNpZ25hdHVyZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBwYXlsb2FkU2lnbmF0dXJlSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWRkcmVzcyBiYWxhbmNlc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYWxsIGJhbGFuY2VzIGZvciBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZXMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0QWRkcmVzc0JhbGFuY2VzKHdhbGxldElkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RBZGRyZXNzQmFsYW5jZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWRkcmVzc2VzIGluIHRoZSB3YWxsZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgYWRkcmVzc2VzIGluIGEgd2FsbGV0LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgd2hvc2UgYWRkcmVzc2VzIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RBZGRyZXNzZXMod2FsbGV0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0QWRkcmVzc2VzKHdhbGxldElkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgcGF5bG9hZCBzaWduYXR1cmVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHBheWxvYWQgc2lnbmF0dXJlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB3aG9zZSBwYXlsb2FkIHNpZ25hdHVyZXMgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RQYXlsb2FkU2lnbmF0dXJlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdFBheWxvYWRTaWduYXR1cmVzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVxdWVzdCBmYXVjZXQgZnVuZHMgdG8gYmUgc2VudCB0byBvbmNoYWluIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIGZvciBvbmNoYWluIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Fzc2V0SWRdIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gdHJhbnNmZXIgZnJvbSB0aGUgZmF1Y2V0LlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVxdWVzdEZhdWNldEZ1bmRzKHdhbGxldElkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnJlcXVlc3RGYXVjZXRGdW5kcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5BZGRyZXNzZXNBcGlGYWN0b3J5ID0gQWRkcmVzc2VzQXBpRmFjdG9yeTtcbi8qKlxuICogQWRkcmVzc2VzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIEFkZHJlc3Nlc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEFkZHJlc3Nlc0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYWRkcmVzcyBzY29wZWQgdG8gdGhlIHdhbGxldC5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBjcmVhdGUgdGhlIGFkZHJlc3MgaW4uXG4gICAgICogQHBhcmFtIHtDcmVhdGVBZGRyZXNzUmVxdWVzdH0gW2NyZWF0ZUFkZHJlc3NSZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgY3JlYXRlQWRkcmVzcyh3YWxsZXRJZCwgY3JlYXRlQWRkcmVzc1JlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZUFkZHJlc3Mod2FsbGV0SWQsIGNyZWF0ZUFkZHJlc3NSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHBheWxvYWQgc2lnbmF0dXJlIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgcGF5bG9hZCBzaWduYXR1cmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRvIHNpZ24gdGhlIHBheWxvYWQgd2l0aC5cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0fSBbY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFkZHJlc3NcbiAgICAgKiBAc3VtbWFyeSBHZXQgYWRkcmVzcyBieSBvbmNoYWluIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgZ2V0QWRkcmVzcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRBZGRyZXNzKHdhbGxldElkLCBhZGRyZXNzSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWRkcmVzcyBiYWxhbmNlXG4gICAgICogQHN1bW1hcnkgR2V0IGFkZHJlc3MgYmFsYW5jZSBmb3IgYXNzZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3Nlc0FwaVxuICAgICAqL1xuICAgIGdldEFkZHJlc3NCYWxhbmNlKHdhbGxldElkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldEFkZHJlc3NCYWxhbmNlKHdhbGxldElkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgcGF5bG9hZCBzaWduYXR1cmUuXG4gICAgICogQHN1bW1hcnkgR2V0IHBheWxvYWQgc2lnbmF0dXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IHNpZ25lZCB0aGUgcGF5bG9hZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF5bG9hZFNpZ25hdHVyZUlkIFRoZSBJRCBvZiB0aGUgcGF5bG9hZCBzaWduYXR1cmUgdG8gZmV0Y2guXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBnZXRQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIHBheWxvYWRTaWduYXR1cmVJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0UGF5bG9hZFNpZ25hdHVyZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBwYXlsb2FkU2lnbmF0dXJlSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWRkcmVzcyBiYWxhbmNlc1xuICAgICAqIEBzdW1tYXJ5IEdldCBhbGwgYmFsYW5jZXMgZm9yIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2VzIGZvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3Nlc0FwaVxuICAgICAqL1xuICAgIGxpc3RBZGRyZXNzQmFsYW5jZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdEFkZHJlc3NCYWxhbmNlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldC5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IGFkZHJlc3NlcyBpbiBhIHdhbGxldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgd2hvc2UgYWRkcmVzc2VzIHRvIGZldGNoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBsaXN0QWRkcmVzc2VzKHdhbGxldElkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdEFkZHJlc3Nlcyh3YWxsZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHBheWxvYWQgc2lnbmF0dXJlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IHBheWxvYWQgc2lnbmF0dXJlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3Mgd2hvc2UgcGF5bG9hZCBzaWduYXR1cmVzIHRvIGZldGNoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgbGlzdFBheWxvYWRTaWduYXR1cmVzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0UGF5bG9hZFNpZ25hdHVyZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGZhdWNldCBmdW5kcyB0byBiZSBzZW50IHRvIG9uY2hhaW4gYWRkcmVzcy5cbiAgICAgKiBAc3VtbWFyeSBSZXF1ZXN0IGZhdWNldCBmdW5kcyBmb3Igb25jaGFpbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFthc3NldElkXSBUaGUgSUQgb2YgdGhlIGFzc2V0IHRvIHRyYW5zZmVyIGZyb20gdGhlIGZhdWNldC5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgcmVxdWVzdEZhdWNldEZ1bmRzKHdhbGxldElkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnJlcXVlc3RGYXVjZXRGdW5kcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLkFkZHJlc3Nlc0FwaSA9IEFkZHJlc3Nlc0FwaTtcbi8qKlxuICogQXNzZXRzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQXNzZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFzc2V0IGZvciB0aGUgc3BlY2lmaWVkIGFzc2V0IElELlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGFzc2V0IGZvciB0aGUgc3BlY2lmaWVkIGFzc2V0IElELlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2guIFRoaXMgY291bGQgYmUgYSBzeW1ib2wgb3IgYW4gRVJDMjAgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEFzc2V0OiBhc3luYyAobmV0d29ya0lkLCBhc3NldElkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRBc3NldCcsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYXNzZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRBc3NldCcsICdhc3NldElkJywgYXNzZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hc3NldHMve2Fzc2V0X2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYXNzZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhc3NldElkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Bc3NldHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IEFzc2V0c0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBBc3NldHNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBBc3NldHNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkFzc2V0c0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhc3NldCBmb3IgdGhlIHNwZWNpZmllZCBhc3NldCBJRC5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBhc3NldCBmb3IgdGhlIHNwZWNpZmllZCBhc3NldCBJRC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgSUQgb2YgdGhlIGFzc2V0IHRvIGZldGNoLiBUaGlzIGNvdWxkIGJlIGEgc3ltYm9sIG9yIGFuIEVSQzIwIGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRBc3NldChuZXR3b3JrSWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRBc3NldChuZXR3b3JrSWQsIGFzc2V0SWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQXNzZXRzQXBpLmdldEFzc2V0J10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQXNzZXRzQXBpRnAgPSBBc3NldHNBcGlGcDtcbi8qKlxuICogQXNzZXRzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQXNzZXRzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuQXNzZXRzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFzc2V0IGZvciB0aGUgc3BlY2lmaWVkIGFzc2V0IElELlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGFzc2V0IGZvciB0aGUgc3BlY2lmaWVkIGFzc2V0IElELlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2guIFRoaXMgY291bGQgYmUgYSBzeW1ib2wgb3IgYW4gRVJDMjAgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEFzc2V0KG5ldHdvcmtJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0QXNzZXQobmV0d29ya0lkLCBhc3NldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Bc3NldHNBcGlGYWN0b3J5ID0gQXNzZXRzQXBpRmFjdG9yeTtcbi8qKlxuICogQXNzZXRzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIEFzc2V0c0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEFzc2V0c0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGFzc2V0IGZvciB0aGUgc3BlY2lmaWVkIGFzc2V0IElELlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYXNzZXQgZm9yIHRoZSBzcGVjaWZpZWQgYXNzZXQgSUQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2guIFRoaXMgY291bGQgYmUgYSBzeW1ib2wgb3IgYW4gRVJDMjAgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEFzc2V0c0FwaVxuICAgICAqL1xuICAgIGdldEFzc2V0KG5ldHdvcmtJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQXNzZXRzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0QXNzZXQobmV0d29ya0lkLCBhc3NldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLkFzc2V0c0FwaSA9IEFzc2V0c0FwaTtcbi8qKlxuICogQmFsYW5jZUhpc3RvcnlBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBCYWxhbmNlSGlzdG9yeUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB0aGUgaGlzdG9yaWNhbCBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIGEgc3BlY2lmaWMgYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFkZHJlc3MgYmFsYW5jZSBoaXN0b3J5IGZvciBhc3NldFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBoaXN0b3JpY2FsIGJhbGFuY2UgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgaGlzdG9yaWNhbCBiYWxhbmNlIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZTogYXN5bmMgKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZScsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RBZGRyZXNzSGlzdG9yaWNhbEJhbGFuY2UnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Fzc2V0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZScsICdhc3NldElkJywgYXNzZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2JhbGFuY2VfaGlzdG9yeS97YXNzZXRfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYXNzZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhc3NldElkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQmFsYW5jZUhpc3RvcnlBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IEJhbGFuY2VIaXN0b3J5QXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIEJhbGFuY2VIaXN0b3J5QXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQmFsYW5jZUhpc3RvcnlBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkJhbGFuY2VIaXN0b3J5QXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHRoZSBoaXN0b3JpY2FsIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gYSBzcGVjaWZpYyBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYWRkcmVzcyBiYWxhbmNlIGhpc3RvcnkgZm9yIGFzc2V0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBoaXN0b3JpY2FsIGJhbGFuY2UgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0QWRkcmVzc0hpc3RvcmljYWxCYWxhbmNlKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RBZGRyZXNzSGlzdG9yaWNhbEJhbGFuY2UobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0JhbGFuY2VIaXN0b3J5QXBpLmxpc3RBZGRyZXNzSGlzdG9yaWNhbEJhbGFuY2UnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5CYWxhbmNlSGlzdG9yeUFwaUZwID0gQmFsYW5jZUhpc3RvcnlBcGlGcDtcbi8qKlxuICogQmFsYW5jZUhpc3RvcnlBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBCYWxhbmNlSGlzdG9yeUFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLkJhbGFuY2VIaXN0b3J5QXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHRoZSBoaXN0b3JpY2FsIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gYSBzcGVjaWZpYyBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYWRkcmVzcyBiYWxhbmNlIGhpc3RvcnkgZm9yIGFzc2V0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBoaXN0b3JpY2FsIGJhbGFuY2UgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0QWRkcmVzc0hpc3RvcmljYWxCYWxhbmNlKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkJhbGFuY2VIaXN0b3J5QXBpRmFjdG9yeSA9IEJhbGFuY2VIaXN0b3J5QXBpRmFjdG9yeTtcbi8qKlxuICogQmFsYW5jZUhpc3RvcnlBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQmFsYW5jZUhpc3RvcnlBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBCYWxhbmNlSGlzdG9yeUFwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBMaXN0IHRoZSBoaXN0b3JpY2FsIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gYSBzcGVjaWZpYyBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IEdldCBhZGRyZXNzIGJhbGFuY2UgaGlzdG9yeSBmb3IgYXNzZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBmb3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBCYWxhbmNlSGlzdG9yeUFwaVxuICAgICAqL1xuICAgIGxpc3RBZGRyZXNzSGlzdG9yaWNhbEJhbGFuY2UobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5CYWxhbmNlSGlzdG9yeUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RBZGRyZXNzSGlzdG9yaWNhbEJhbGFuY2UobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLkJhbGFuY2VIaXN0b3J5QXBpID0gQmFsYW5jZUhpc3RvcnlBcGk7XG4vKipcbiAqIENvbnRyYWN0RXZlbnRzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ29udHJhY3RFdmVudHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlIGV2ZW50cyBmb3IgYSBzcGVjaWZpYyBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IGNvbnRyYWN0IGV2ZW50c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbE5hbWUgQ2FzZS1zZW5zaXRpdmUgbmFtZSBvZiB0aGUgYmxvY2tjaGFpbiBwcm90b2NvbFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIEVWTSBhZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdCAoNDIgY2hhcmFjdGVycywgaW5jbHVkaW5nIFxcJiMzOTsweFxcJiMzOTssIGluIGxvd2VyY2FzZSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0TmFtZSBDYXNlLXNlbnNpdGl2ZSBuYW1lIG9mIHRoZSBzcGVjaWZpYyBjb250cmFjdCB3aXRoaW4gdGhlIHByb2plY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBDYXNlLXNlbnNpdGl2ZSBuYW1lIG9mIHRoZSBldmVudCB0byBmaWx0ZXIgZm9yIGluIHRoZSBjb250cmFjdFxcJiMzOTtzIGxvZ3NcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21CbG9ja0hlaWdodCBMb3dlciBib3VuZCBvZiB0aGUgYmxvY2sgcmFuZ2UgdG8gcXVlcnkgKGluY2x1c2l2ZSlcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRvQmxvY2tIZWlnaHQgVXBwZXIgYm91bmQgb2YgdGhlIGJsb2NrIHJhbmdlIHRvIHF1ZXJ5IChpbmNsdXNpdmUpXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmV4dFBhZ2VdIFBhZ2luYXRpb24gdG9rZW4gZm9yIHJldHJpZXZpbmcgdGhlIG5leHQgc2V0IG9mIHJlc3VsdHNcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RDb250cmFjdEV2ZW50czogYXN5bmMgKG5ldHdvcmtJZCwgcHJvdG9jb2xOYW1lLCBjb250cmFjdEFkZHJlc3MsIGNvbnRyYWN0TmFtZSwgZXZlbnROYW1lLCBmcm9tQmxvY2tIZWlnaHQsIHRvQmxvY2tIZWlnaHQsIG5leHRQYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0Q29udHJhY3RFdmVudHMnLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3Byb3RvY29sTmFtZScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0Q29udHJhY3RFdmVudHMnLCAncHJvdG9jb2xOYW1lJywgcHJvdG9jb2xOYW1lKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NvbnRyYWN0QWRkcmVzcycgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0Q29udHJhY3RFdmVudHMnLCAnY29udHJhY3RBZGRyZXNzJywgY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NvbnRyYWN0TmFtZScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0Q29udHJhY3RFdmVudHMnLCAnY29udHJhY3ROYW1lJywgY29udHJhY3ROYW1lKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2V2ZW50TmFtZScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0Q29udHJhY3RFdmVudHMnLCAnZXZlbnROYW1lJywgZXZlbnROYW1lKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Zyb21CbG9ja0hlaWdodCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0Q29udHJhY3RFdmVudHMnLCAnZnJvbUJsb2NrSGVpZ2h0JywgZnJvbUJsb2NrSGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3RvQmxvY2tIZWlnaHQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdENvbnRyYWN0RXZlbnRzJywgJ3RvQmxvY2tIZWlnaHQnLCB0b0Jsb2NrSGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L3NtYXJ0X2NvbnRyYWN0cy97Y29udHJhY3RfYWRkcmVzc30vZXZlbnRzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJjb250cmFjdF9hZGRyZXNzXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoY29udHJhY3RBZGRyZXNzKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHByb3RvY29sTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncHJvdG9jb2xfbmFtZSddID0gcHJvdG9jb2xOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRyYWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY29udHJhY3RfbmFtZSddID0gY29udHJhY3ROYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZXZlbnRfbmFtZSddID0gZXZlbnROYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21CbG9ja0hlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZnJvbV9ibG9ja19oZWlnaHQnXSA9IGZyb21CbG9ja0hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b0Jsb2NrSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd0b19ibG9ja19oZWlnaHQnXSA9IHRvQmxvY2tIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dFBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ25leHRfcGFnZSddID0gbmV4dFBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkNvbnRyYWN0RXZlbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBDb250cmFjdEV2ZW50c0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBDb250cmFjdEV2ZW50c0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENvbnRyYWN0RXZlbnRzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5Db250cmFjdEV2ZW50c0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmUgZXZlbnRzIGZvciBhIHNwZWNpZmljIGNvbnRyYWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgY29udHJhY3QgZXZlbnRzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sTmFtZSBDYXNlLXNlbnNpdGl2ZSBuYW1lIG9mIHRoZSBibG9ja2NoYWluIHByb3RvY29sXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgRVZNIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0ICg0MiBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgXFwmIzM5OzB4XFwmIzM5OywgaW4gbG93ZXJjYXNlKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3ROYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIHNwZWNpZmljIGNvbnRyYWN0IHdpdGhpbiB0aGUgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpbHRlciBmb3IgaW4gdGhlIGNvbnRyYWN0XFwmIzM5O3MgbG9nc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUJsb2NrSGVpZ2h0IExvd2VyIGJvdW5kIG9mIHRoZSBibG9jayByYW5nZSB0byBxdWVyeSAoaW5jbHVzaXZlKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9CbG9ja0hlaWdodCBVcHBlciBib3VuZCBvZiB0aGUgYmxvY2sgcmFuZ2UgdG8gcXVlcnkgKGluY2x1c2l2ZSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtuZXh0UGFnZV0gUGFnaW5hdGlvbiB0b2tlbiBmb3IgcmV0cmlldmluZyB0aGUgbmV4dCBzZXQgb2YgcmVzdWx0c1xuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdENvbnRyYWN0RXZlbnRzKG5ldHdvcmtJZCwgcHJvdG9jb2xOYW1lLCBjb250cmFjdEFkZHJlc3MsIGNvbnRyYWN0TmFtZSwgZXZlbnROYW1lLCBmcm9tQmxvY2tIZWlnaHQsIHRvQmxvY2tIZWlnaHQsIG5leHRQYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdENvbnRyYWN0RXZlbnRzKG5ldHdvcmtJZCwgcHJvdG9jb2xOYW1lLCBjb250cmFjdEFkZHJlc3MsIGNvbnRyYWN0TmFtZSwgZXZlbnROYW1lLCBmcm9tQmxvY2tIZWlnaHQsIHRvQmxvY2tIZWlnaHQsIG5leHRQYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0NvbnRyYWN0RXZlbnRzQXBpLmxpc3RDb250cmFjdEV2ZW50cyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkNvbnRyYWN0RXZlbnRzQXBpRnAgPSBDb250cmFjdEV2ZW50c0FwaUZwO1xuLyoqXG4gKiBDb250cmFjdEV2ZW50c0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENvbnRyYWN0RXZlbnRzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuQ29udHJhY3RFdmVudHNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlIGV2ZW50cyBmb3IgYSBzcGVjaWZpYyBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IGNvbnRyYWN0IGV2ZW50c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbE5hbWUgQ2FzZS1zZW5zaXRpdmUgbmFtZSBvZiB0aGUgYmxvY2tjaGFpbiBwcm90b2NvbFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIEVWTSBhZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdCAoNDIgY2hhcmFjdGVycywgaW5jbHVkaW5nIFxcJiMzOTsweFxcJiMzOTssIGluIGxvd2VyY2FzZSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0TmFtZSBDYXNlLXNlbnNpdGl2ZSBuYW1lIG9mIHRoZSBzcGVjaWZpYyBjb250cmFjdCB3aXRoaW4gdGhlIHByb2plY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBDYXNlLXNlbnNpdGl2ZSBuYW1lIG9mIHRoZSBldmVudCB0byBmaWx0ZXIgZm9yIGluIHRoZSBjb250cmFjdFxcJiMzOTtzIGxvZ3NcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21CbG9ja0hlaWdodCBMb3dlciBib3VuZCBvZiB0aGUgYmxvY2sgcmFuZ2UgdG8gcXVlcnkgKGluY2x1c2l2ZSlcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRvQmxvY2tIZWlnaHQgVXBwZXIgYm91bmQgb2YgdGhlIGJsb2NrIHJhbmdlIHRvIHF1ZXJ5IChpbmNsdXNpdmUpXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmV4dFBhZ2VdIFBhZ2luYXRpb24gdG9rZW4gZm9yIHJldHJpZXZpbmcgdGhlIG5leHQgc2V0IG9mIHJlc3VsdHNcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RDb250cmFjdEV2ZW50cyhuZXR3b3JrSWQsIHByb3RvY29sTmFtZSwgY29udHJhY3RBZGRyZXNzLCBjb250cmFjdE5hbWUsIGV2ZW50TmFtZSwgZnJvbUJsb2NrSGVpZ2h0LCB0b0Jsb2NrSGVpZ2h0LCBuZXh0UGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdENvbnRyYWN0RXZlbnRzKG5ldHdvcmtJZCwgcHJvdG9jb2xOYW1lLCBjb250cmFjdEFkZHJlc3MsIGNvbnRyYWN0TmFtZSwgZXZlbnROYW1lLCBmcm9tQmxvY2tIZWlnaHQsIHRvQmxvY2tIZWlnaHQsIG5leHRQYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Db250cmFjdEV2ZW50c0FwaUZhY3RvcnkgPSBDb250cmFjdEV2ZW50c0FwaUZhY3Rvcnk7XG4vKipcbiAqIENvbnRyYWN0RXZlbnRzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIENvbnRyYWN0RXZlbnRzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgQ29udHJhY3RFdmVudHNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgZXZlbnRzIGZvciBhIHNwZWNpZmljIGNvbnRyYWN0XG4gICAgICogQHN1bW1hcnkgTGlzdCBjb250cmFjdCBldmVudHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sTmFtZSBDYXNlLXNlbnNpdGl2ZSBuYW1lIG9mIHRoZSBibG9ja2NoYWluIHByb3RvY29sXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyBFVk0gYWRkcmVzcyBvZiB0aGUgc21hcnQgY29udHJhY3QgKDQyIGNoYXJhY3RlcnMsIGluY2x1ZGluZyBcXCYjMzk7MHhcXCYjMzk7LCBpbiBsb3dlcmNhc2UpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0TmFtZSBDYXNlLXNlbnNpdGl2ZSBuYW1lIG9mIHRoZSBzcGVjaWZpYyBjb250cmFjdCB3aXRoaW4gdGhlIHByb2plY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpbHRlciBmb3IgaW4gdGhlIGNvbnRyYWN0XFwmIzM5O3MgbG9nc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tQmxvY2tIZWlnaHQgTG93ZXIgYm91bmQgb2YgdGhlIGJsb2NrIHJhbmdlIHRvIHF1ZXJ5IChpbmNsdXNpdmUpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvQmxvY2tIZWlnaHQgVXBwZXIgYm91bmQgb2YgdGhlIGJsb2NrIHJhbmdlIHRvIHF1ZXJ5IChpbmNsdXNpdmUpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtuZXh0UGFnZV0gUGFnaW5hdGlvbiB0b2tlbiBmb3IgcmV0cmlldmluZyB0aGUgbmV4dCBzZXQgb2YgcmVzdWx0c1xuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQ29udHJhY3RFdmVudHNBcGlcbiAgICAgKi9cbiAgICBsaXN0Q29udHJhY3RFdmVudHMobmV0d29ya0lkLCBwcm90b2NvbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCwgbmV4dFBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNvbnRyYWN0RXZlbnRzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdENvbnRyYWN0RXZlbnRzKG5ldHdvcmtJZCwgcHJvdG9jb2xOYW1lLCBjb250cmFjdEFkZHJlc3MsIGNvbnRyYWN0TmFtZSwgZXZlbnROYW1lLCBmcm9tQmxvY2tIZWlnaHQsIHRvQmxvY2tIZWlnaHQsIG5leHRQYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyYWN0RXZlbnRzQXBpID0gQ29udHJhY3RFdmVudHNBcGk7XG4vKipcbiAqIENvbnRyYWN0SW52b2NhdGlvbnNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBDb250cmFjdEludm9jYXRpb25zQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm9hZGNhc3QgYSBjb250cmFjdCBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSBjb250cmFjdCBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIGNvbnRyYWN0IGludm9jYXRpb24gYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0SW52b2NhdGlvbklkIFRoZSBJRCBvZiB0aGUgY29udHJhY3QgaW52b2NhdGlvbiB0byBicm9hZGNhc3QuXG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdH0gYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvbicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY29udHJhY3RJbnZvY2F0aW9uSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uJywgJ2NvbnRyYWN0SW52b2NhdGlvbklkJywgY29udHJhY3RJbnZvY2F0aW9uSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RDb250cmFjdEludm9jYXRpb24nLCAnYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCcsIGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vY29udHJhY3RfaW52b2NhdGlvbnMve2NvbnRyYWN0X2ludm9jYXRpb25faWR9L2Jyb2FkY2FzdGBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJjb250cmFjdF9pbnZvY2F0aW9uX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoY29udHJhY3RJbnZvY2F0aW9uSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnZvY2F0aW9uIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIHNvdXJjZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGludm9rZSB0aGUgY29udHJhY3QgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0fSBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVDb250cmFjdEludm9jYXRpb246IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZUNvbnRyYWN0SW52b2NhdGlvbicsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVDb250cmFjdEludm9jYXRpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uJywgJ2NyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QnLCBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2NvbnRyYWN0X2ludm9jYXRpb25zYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBjb250cmFjdCBpbnZvY2F0aW9uIGJ5IElELlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSBjb250cmFjdCBpbnZvY2F0aW9uIGJ5IElELlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIGNvbnRyYWN0IGludm9jYXRpb24gYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0SW52b2NhdGlvbklkIFRoZSBJRCBvZiB0aGUgY29udHJhY3QgaW52b2NhdGlvbiB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldENvbnRyYWN0SW52b2NhdGlvbjogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldENvbnRyYWN0SW52b2NhdGlvbicsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRDb250cmFjdEludm9jYXRpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NvbnRyYWN0SW52b2NhdGlvbklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldENvbnRyYWN0SW52b2NhdGlvbicsICdjb250cmFjdEludm9jYXRpb25JZCcsIGNvbnRyYWN0SW52b2NhdGlvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2NvbnRyYWN0X2ludm9jYXRpb25zL3tjb250cmFjdF9pbnZvY2F0aW9uX2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJjb250cmFjdF9pbnZvY2F0aW9uX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoY29udHJhY3RJbnZvY2F0aW9uSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGNvbnRyYWN0IGludm9jYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IGNvbnRyYWN0IGludm9jYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCBjb250cmFjdCBpbnZvY2F0aW9ucyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RDb250cmFjdEludm9jYXRpb25zOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdENvbnRyYWN0SW52b2NhdGlvbnMnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdENvbnRyYWN0SW52b2NhdGlvbnMnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2NvbnRyYWN0X2ludm9jYXRpb25zYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IENvbnRyYWN0SW52b2NhdGlvbnNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogQ29udHJhY3RJbnZvY2F0aW9uc0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENvbnRyYWN0SW52b2NhdGlvbnNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgY29udHJhY3QgaW52b2NhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RJbnZvY2F0aW9uSWQgVGhlIElEIG9mIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIHRvIGJyb2FkY2FzdC5cbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0fSBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5icm9hZGNhc3RDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ29udHJhY3RJbnZvY2F0aW9uc0FwaS5icm9hZGNhc3RDb250cmFjdEludm9jYXRpb24nXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnZvY2F0aW9uIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIHNvdXJjZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGludm9rZSB0aGUgY29udHJhY3QgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0fSBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBjcmVhdGVDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0NvbnRyYWN0SW52b2NhdGlvbnNBcGkuY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIGNvbnRyYWN0IGludm9jYXRpb24gYnkgSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIGNvbnRyYWN0IGludm9jYXRpb24gYnkgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgY29udHJhY3QgaW52b2NhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RJbnZvY2F0aW9uSWQgVGhlIElEIG9mIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0Q29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0Q29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0NvbnRyYWN0SW52b2NhdGlvbnNBcGkuZ2V0Q29udHJhY3RJbnZvY2F0aW9uJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IGNvbnRyYWN0IGludm9jYXRpb25zIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdENvbnRyYWN0SW52b2NhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0Q29udHJhY3RJbnZvY2F0aW9ucyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydDb250cmFjdEludm9jYXRpb25zQXBpLmxpc3RDb250cmFjdEludm9jYXRpb25zJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZwID0gQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZwO1xuLyoqXG4gKiBDb250cmFjdEludm9jYXRpb25zQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgY29udHJhY3QgaW52b2NhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RJbnZvY2F0aW9uSWQgVGhlIElEIG9mIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIHRvIGJyb2FkY2FzdC5cbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0fSBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgY29udHJhY3QgaW52b2NhdGlvbiBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBpbnZva2UgdGhlIGNvbnRyYWN0IGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdH0gY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgY29udHJhY3QgaW52b2NhdGlvbiBieSBJRC5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgY29udHJhY3QgaW52b2NhdGlvbiBieSBJRC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEludm9jYXRpb25JZCBUaGUgSUQgb2YgdGhlIGNvbnRyYWN0IGludm9jYXRpb24gdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldENvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IGNvbnRyYWN0IGludm9jYXRpb25zIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdENvbnRyYWN0SW52b2NhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RDb250cmFjdEludm9jYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Db250cmFjdEludm9jYXRpb25zQXBpRmFjdG9yeSA9IENvbnRyYWN0SW52b2NhdGlvbnNBcGlGYWN0b3J5O1xuLyoqXG4gKiBDb250cmFjdEludm9jYXRpb25zQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIENvbnRyYWN0SW52b2NhdGlvbnNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBDb250cmFjdEludm9jYXRpb25zQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgY29udHJhY3QgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgY29udHJhY3QgaW52b2NhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEludm9jYXRpb25JZCBUaGUgSUQgb2YgdGhlIGNvbnRyYWN0IGludm9jYXRpb24gdG8gYnJvYWRjYXN0LlxuICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdH0gYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQ29udHJhY3RJbnZvY2F0aW9uc0FwaVxuICAgICAqL1xuICAgIGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnZvY2F0aW9uLlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnZvY2F0aW9uIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgc291cmNlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBpbnZva2UgdGhlIGNvbnRyYWN0IGZyb20uXG4gICAgICogQHBhcmFtIHtDcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0fSBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDb250cmFjdEludm9jYXRpb25zQXBpXG4gICAgICovXG4gICAgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGNvbnRyYWN0IGludm9jYXRpb24gYnkgSUQuXG4gICAgICogQHN1bW1hcnkgR2V0IGEgY29udHJhY3QgaW52b2NhdGlvbiBieSBJRC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgY29udHJhY3QgaW52b2NhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEludm9jYXRpb25JZCBUaGUgSUQgb2YgdGhlIGNvbnRyYWN0IGludm9jYXRpb24gdG8gZmV0Y2guXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDb250cmFjdEludm9jYXRpb25zQXBpXG4gICAgICovXG4gICAgZ2V0Q29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Db250cmFjdEludm9jYXRpb25zQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0Q29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBjb250cmFjdCBpbnZvY2F0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IGNvbnRyYWN0IGludm9jYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQ29udHJhY3RJbnZvY2F0aW9uc0FwaVxuICAgICAqL1xuICAgIGxpc3RDb250cmFjdEludm9jYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Db250cmFjdEludm9jYXRpb25zQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdENvbnRyYWN0SW52b2NhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaSA9IENvbnRyYWN0SW52b2NhdGlvbnNBcGk7XG4vKipcbiAqIEV4dGVybmFsQWRkcmVzc2VzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRXh0ZXJuYWxBZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhbiBhcmJpdHJhcnkgdHJhbnNhY3Rpb24gdG8gdGhlIG5vZGUgY29uc3RydWN0ZWQgYW5kIHNpZ25lZCBieSBhbiBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYW4gYXJiaXRyYXJ5IHRyYW5zYWN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0aGUgZXh0ZXJuYWwgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIHRyYW5zYWN0aW9uIHNlbmRlci5cbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdH0gYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb246IGFzeW5jIChuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvblJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb24nLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uJywgJ2Jyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0JywgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvblJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS90cmFuc2FjdGlvbnNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGFuIGV4dGVybmFsIGFkZHJlc3NcXCdzIHRyYW5zZmVyIHdpdGggYSBzaWduZWQgcGF5bG9hZFxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYW4gZXh0ZXJuYWwgYWRkcmVzc1xcJyB0cmFuc2ZlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFuc2ZlciBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2ZlcklkIFRoZSBJRCBvZiB0aGUgdHJhbnNmZXIgdG8gYnJvYWRjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3R9IGJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyOiBhc3luYyAobmV0d29ya0lkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlcicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndHJhbnNmZXJJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyJywgJ3RyYW5zZmVySWQnLCB0cmFuc2ZlcklkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Jyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXInLCAnYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QnLCBicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3RyYW5zZmVycy97dHJhbnNmZXJfaWR9L2Jyb2FkY2FzdGBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInRyYW5zZmVyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodHJhbnNmZXJJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHRyYW5zZmVyIGJldHdlZW4gYWRkcmVzc2VzLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgdHJhbnNmZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdGhlIGFkZHJlc3MgaXMgb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gdHJhbnNmZXIgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0fSBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlcjogYXN5bmMgKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlcicsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZUV4dGVybmFsVHJhbnNmZXInLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZUV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZUV4dGVybmFsVHJhbnNmZXInLCAnY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QnLCBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3RyYW5zZmVyc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEV4dGVybmFsQWRkcmVzc0JhbGFuY2U6IGFzeW5jIChuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZScsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEV4dGVybmFsQWRkcmVzc0JhbGFuY2UnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Fzc2V0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZScsICdhc3NldElkJywgYXNzZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2JhbGFuY2VzL3thc3NldF9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhc3NldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFzc2V0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYW4gZXh0ZXJuYWwgYWRkcmVzc1xcJyB0cmFuc2ZlciBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSBleHRlcm5hbCBhZGRyZXNzXFwnIHRyYW5zZmVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRoZSBhZGRyZXNzIGlzIG9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFuc2ZlciBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2ZlcklkIFRoZSBJRCBvZiB0aGUgdHJhbnNmZXIgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEV4dGVybmFsVHJhbnNmZXI6IGFzeW5jIChuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0RXh0ZXJuYWxUcmFuc2ZlcicsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEV4dGVybmFsVHJhbnNmZXInLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3RyYW5zZmVySWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0RXh0ZXJuYWxUcmFuc2ZlcicsICd0cmFuc2ZlcklkJywgdHJhbnNmZXJJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3RyYW5zZmVycy97dHJhbnNmZXJfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1widHJhbnNmZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh0cmFuc2ZlcklkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc3RhdHVzIG9mIGEgZmF1Y2V0IHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgc3RhdHVzIG9mIGEgZmF1Y2V0IHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGZhdWNldCB0cmFuc2FjdGlvbiBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR4SGFzaCBUaGUgaGFzaCBvZiB0aGUgZmF1Y2V0IHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGYXVjZXRUcmFuc2FjdGlvbjogYXN5bmMgKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCB0eEhhc2gsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEZhdWNldFRyYW5zYWN0aW9uJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0RmF1Y2V0VHJhbnNhY3Rpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3R4SGFzaCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRGYXVjZXRUcmFuc2FjdGlvbicsICd0eEhhc2gnLCB0eEhhc2gpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9mYXVjZXQve3R4X2hhc2h9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1widHhfaGFzaFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHR4SGFzaCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIG9mIHRoZSBiYWxhbmNlcyBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYmFsYW5jZXMgb2YgYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEV4dGVybmFsQWRkcmVzc0JhbGFuY2VzOiBhc3luYyAobmV0d29ya0lkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RFeHRlcm5hbEFkZHJlc3NCYWxhbmNlcycsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RFeHRlcm5hbEFkZHJlc3NCYWxhbmNlcycsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9iYWxhbmNlc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVxdWVzdCBmYXVjZXQgZnVuZHMgdG8gYmUgc2VudCB0byBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXF1ZXN0IGZhdWNldCBmdW5kcyBmb3IgZXh0ZXJuYWwgYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Fzc2V0SWRdIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gdHJhbnNmZXIgZnJvbSB0aGUgZmF1Y2V0LlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwV2FpdF0gV2hldGhlciB0byBza2lwIHdhaXRpbmcgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBtaW5lZC4gVGhpcyB3aWxsIGJlY29tZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVxdWVzdEV4dGVybmFsRmF1Y2V0RnVuZHM6IGFzeW5jIChuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgc2tpcFdhaXQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3JlcXVlc3RFeHRlcm5hbEZhdWNldEZ1bmRzJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgncmVxdWVzdEV4dGVybmFsRmF1Y2V0RnVuZHMnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vZmF1Y2V0YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChhc3NldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydhc3NldF9pZCddID0gYXNzZXRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChza2lwV2FpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnc2tpcF93YWl0J10gPSBza2lwV2FpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IEV4dGVybmFsQWRkcmVzc2VzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIEV4dGVybmFsQWRkcmVzc2VzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRXh0ZXJuYWxBZGRyZXNzZXNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkV4dGVybmFsQWRkcmVzc2VzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm9hZGNhc3QgYW4gYXJiaXRyYXJ5IHRyYW5zYWN0aW9uIHRvIHRoZSBub2RlIGNvbnN0cnVjdGVkIGFuZCBzaWduZWQgYnkgYW4gZXh0ZXJuYWwgYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGFuIGFyYml0cmFyeSB0cmFuc2FjdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdGhlIGV4dGVybmFsIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSB0cmFuc2FjdGlvbiBzZW5kZXIuXG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvblJlcXVlc3R9IGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0V4dGVybmFsQWRkcmVzc2VzQXBpLmJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb24nXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGFuIGV4dGVybmFsIGFkZHJlc3NcXCdzIHRyYW5zZmVyIHdpdGggYSBzaWduZWQgcGF5bG9hZFxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYW4gZXh0ZXJuYWwgYWRkcmVzc1xcJyB0cmFuc2ZlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFuc2ZlciBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2ZlcklkIFRoZSBJRCBvZiB0aGUgdHJhbnNmZXIgdG8gYnJvYWRjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3R9IGJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXIobmV0d29ya0lkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0V4dGVybmFsQWRkcmVzc2VzQXBpLmJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXInXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHRyYW5zZmVyIGJldHdlZW4gYWRkcmVzc2VzLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgdHJhbnNmZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdGhlIGFkZHJlc3MgaXMgb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gdHJhbnNmZXIgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0fSBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVFeHRlcm5hbFRyYW5zZmVyKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydFeHRlcm5hbEFkZHJlc3Nlc0FwaS5jcmVhdGVFeHRlcm5hbFRyYW5zZmVyJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRFeHRlcm5hbEFkZHJlc3NCYWxhbmNlKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydFeHRlcm5hbEFkZHJlc3Nlc0FwaS5nZXRFeHRlcm5hbEFkZHJlc3NCYWxhbmNlJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbiBleHRlcm5hbCBhZGRyZXNzXFwnIHRyYW5zZmVyIGJ5IElEXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIGV4dGVybmFsIGFkZHJlc3NcXCcgdHJhbnNmZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdGhlIGFkZHJlc3MgaXMgb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0RXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldEV4dGVybmFsVHJhbnNmZXIobmV0d29ya0lkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRXh0ZXJuYWxBZGRyZXNzZXNBcGkuZ2V0RXh0ZXJuYWxUcmFuc2ZlciddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHN0YXR1cyBvZiBhIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIHN0YXR1cyBvZiBhIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBmYXVjZXQgdHJhbnNhY3Rpb24gZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eEhhc2ggVGhlIGhhc2ggb2YgdGhlIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0RmF1Y2V0VHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHR4SGFzaCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldEZhdWNldFRyYW5zYWN0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCB0eEhhc2gsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRXh0ZXJuYWxBZGRyZXNzZXNBcGkuZ2V0RmF1Y2V0VHJhbnNhY3Rpb24nXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgb2YgdGhlIGJhbGFuY2VzIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlcyBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZXMobmV0d29ya0lkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZXMobmV0d29ya0lkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRXh0ZXJuYWxBZGRyZXNzZXNBcGkubGlzdEV4dGVybmFsQWRkcmVzc0JhbGFuY2VzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIHRvIGJlIHNlbnQgdG8gZXh0ZXJuYWwgYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgUmVxdWVzdCBmYXVjZXQgZnVuZHMgZm9yIGV4dGVybmFsIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFthc3NldElkXSBUaGUgSUQgb2YgdGhlIGFzc2V0IHRvIHRyYW5zZmVyIGZyb20gdGhlIGZhdWNldC5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFdhaXRdIFdoZXRoZXIgdG8gc2tpcCB3YWl0aW5nIGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgbWluZWQuIFRoaXMgd2lsbCBiZWNvbWUgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHJlcXVlc3RFeHRlcm5hbEZhdWNldEZ1bmRzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBza2lwV2FpdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnJlcXVlc3RFeHRlcm5hbEZhdWNldEZ1bmRzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBza2lwV2FpdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydFeHRlcm5hbEFkZHJlc3Nlc0FwaS5yZXF1ZXN0RXh0ZXJuYWxGYXVjZXRGdW5kcyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkV4dGVybmFsQWRkcmVzc2VzQXBpRnAgPSBFeHRlcm5hbEFkZHJlc3Nlc0FwaUZwO1xuLyoqXG4gKiBFeHRlcm5hbEFkZHJlc3Nlc0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEV4dGVybmFsQWRkcmVzc2VzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhbiBhcmJpdHJhcnkgdHJhbnNhY3Rpb24gdG8gdGhlIG5vZGUgY29uc3RydWN0ZWQgYW5kIHNpZ25lZCBieSBhbiBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYW4gYXJiaXRyYXJ5IHRyYW5zYWN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0aGUgZXh0ZXJuYWwgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIHRyYW5zYWN0aW9uIHNlbmRlci5cbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdH0gYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5icm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhbiBleHRlcm5hbCBhZGRyZXNzXFwncyB0cmFuc2ZlciB3aXRoIGEgc2lnbmVkIHBheWxvYWRcbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGFuIGV4dGVybmFsIGFkZHJlc3NcXCcgdHJhbnNmZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhbnNmZXIgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJJZCBUaGUgSUQgb2YgdGhlIHRyYW5zZmVyIHRvIGJyb2FkY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0fSBicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXIobmV0d29ya0lkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHRyYW5zZmVyIGJldHdlZW4gYWRkcmVzc2VzLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgdHJhbnNmZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdGhlIGFkZHJlc3MgaXMgb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gdHJhbnNmZXIgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0fSBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZUV4dGVybmFsVHJhbnNmZXIobmV0d29ya0lkLCBhZGRyZXNzSWQsIGNyZWF0ZUV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEV4dGVybmFsQWRkcmVzc0JhbGFuY2UobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldEV4dGVybmFsQWRkcmVzc0JhbGFuY2UobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYW4gZXh0ZXJuYWwgYWRkcmVzc1xcJyB0cmFuc2ZlciBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSBleHRlcm5hbCBhZGRyZXNzXFwnIHRyYW5zZmVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRoZSBhZGRyZXNzIGlzIG9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFuc2ZlciBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2ZlcklkIFRoZSBJRCBvZiB0aGUgdHJhbnNmZXIgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEV4dGVybmFsVHJhbnNmZXIobmV0d29ya0lkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldEV4dGVybmFsVHJhbnNmZXIobmV0d29ya0lkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHN0YXR1cyBvZiBhIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIHN0YXR1cyBvZiBhIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBmYXVjZXQgdHJhbnNhY3Rpb24gZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eEhhc2ggVGhlIGhhc2ggb2YgdGhlIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RmF1Y2V0VHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHR4SGFzaCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0RmF1Y2V0VHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHR4SGFzaCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIG9mIHRoZSBiYWxhbmNlcyBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYmFsYW5jZXMgb2YgYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEV4dGVybmFsQWRkcmVzc0JhbGFuY2VzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZXMobmV0d29ya0lkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1ZXN0IGZhdWNldCBmdW5kcyB0byBiZSBzZW50IHRvIGV4dGVybmFsIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIGZvciBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXNzZXRJZF0gVGhlIElEIG9mIHRoZSBhc3NldCB0byB0cmFuc2ZlciBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBXYWl0XSBXaGV0aGVyIHRvIHNraXAgd2FpdGluZyBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIG1pbmVkLiBUaGlzIHdpbGwgYmVjb21lIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZXF1ZXN0RXh0ZXJuYWxGYXVjZXRGdW5kcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgc2tpcFdhaXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnJlcXVlc3RFeHRlcm5hbEZhdWNldEZ1bmRzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBza2lwV2FpdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGYWN0b3J5ID0gRXh0ZXJuYWxBZGRyZXNzZXNBcGlGYWN0b3J5O1xuLyoqXG4gKiBFeHRlcm5hbEFkZHJlc3Nlc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBFeHRlcm5hbEFkZHJlc3Nlc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEV4dGVybmFsQWRkcmVzc2VzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdCBhbiBhcmJpdHJhcnkgdHJhbnNhY3Rpb24gdG8gdGhlIG5vZGUgY29uc3RydWN0ZWQgYW5kIHNpZ25lZCBieSBhbiBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhbiBhcmJpdHJhcnkgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdGhlIGV4dGVybmFsIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIHRyYW5zYWN0aW9uIHNlbmRlci5cbiAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0fSBicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRXh0ZXJuYWxBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5icm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdCBhbiBleHRlcm5hbCBhZGRyZXNzXFwncyB0cmFuc2ZlciB3aXRoIGEgc2lnbmVkIHBheWxvYWRcbiAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYW4gZXh0ZXJuYWwgYWRkcmVzc1xcJyB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhbnNmZXIgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2ZlcklkIFRoZSBJRCBvZiB0aGUgdHJhbnNmZXIgdG8gYnJvYWRjYXN0XG4gICAgICogQHBhcmFtIHtCcm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdH0gYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEV4dGVybmFsQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkV4dGVybmFsQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNmZXIgYmV0d2VlbiBhZGRyZXNzZXMuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdGhlIGFkZHJlc3MgaXMgb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byB0cmFuc2ZlciBmcm9tXG4gICAgICogQHBhcmFtIHtDcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdH0gY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEV4dGVybmFsQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkV4dGVybmFsQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBFeHRlcm5hbEFkZHJlc3Nlc0FwaVxuICAgICAqL1xuICAgIGdldEV4dGVybmFsQWRkcmVzc0JhbGFuY2UobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkV4dGVybmFsQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBleHRlcm5hbCBhZGRyZXNzXFwnIHRyYW5zZmVyIGJ5IElEXG4gICAgICogQHN1bW1hcnkgR2V0IGEgZXh0ZXJuYWwgYWRkcmVzc1xcJyB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRoZSBhZGRyZXNzIGlzIG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJJZCBUaGUgSUQgb2YgdGhlIHRyYW5zZmVyIHRvIGZldGNoXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBFeHRlcm5hbEFkZHJlc3Nlc0FwaVxuICAgICAqL1xuICAgIGdldEV4dGVybmFsVHJhbnNmZXIobmV0d29ya0lkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkV4dGVybmFsQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0RXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhdHVzIG9mIGEgZmF1Y2V0IHRyYW5zYWN0aW9uXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBzdGF0dXMgb2YgYSBmYXVjZXQgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGZhdWNldCB0cmFuc2FjdGlvbiBmb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHhIYXNoIFRoZSBoYXNoIG9mIHRoZSBmYXVjZXQgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEV4dGVybmFsQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgZ2V0RmF1Y2V0VHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHR4SGFzaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRGYXVjZXRUcmFuc2FjdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHhIYXNoLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgb2YgdGhlIGJhbGFuY2VzIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGJhbGFuY2VzIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEV4dGVybmFsQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgbGlzdEV4dGVybmFsQWRkcmVzc0JhbGFuY2VzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RFeHRlcm5hbEFkZHJlc3NCYWxhbmNlcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIHRvIGJlIHNlbnQgdG8gZXh0ZXJuYWwgYWRkcmVzcy5cbiAgICAgKiBAc3VtbWFyeSBSZXF1ZXN0IGZhdWNldCBmdW5kcyBmb3IgZXh0ZXJuYWwgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Fzc2V0SWRdIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gdHJhbnNmZXIgZnJvbSB0aGUgZmF1Y2V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBXYWl0XSBXaGV0aGVyIHRvIHNraXAgd2FpdGluZyBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIG1pbmVkLiBUaGlzIHdpbGwgYmVjb21lIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGluIHRoZSBmdXR1cmUuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBFeHRlcm5hbEFkZHJlc3Nlc0FwaVxuICAgICAqL1xuICAgIHJlcXVlc3RFeHRlcm5hbEZhdWNldEZ1bmRzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBza2lwV2FpdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5yZXF1ZXN0RXh0ZXJuYWxGYXVjZXRGdW5kcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgc2tpcFdhaXQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGkgPSBFeHRlcm5hbEFkZHJlc3Nlc0FwaTtcbi8qKlxuICogRnVuZEFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEZ1bmRBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbiB3aXRoIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyB0byBiZSBmdW5kZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3R9IGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVGdW5kT3BlcmF0aW9uOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlRnVuZE9wZXJhdGlvbicsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVGdW5kT3BlcmF0aW9uJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVGdW5kT3BlcmF0aW9uJywgJ2NyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0JywgY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vZnVuZF9vcGVyYXRpb25zYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgRnVuZCBPcGVyYXRpb24gcXVvdGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3MgdG8gYmUgZnVuZGVkLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUZ1bmRRdW90ZVJlcXVlc3R9IGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZ1bmRRdW90ZTogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlRnVuZFF1b3RlJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZUZ1bmRRdW90ZScsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY3JlYXRlRnVuZFF1b3RlUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVGdW5kUXVvdGUnLCAnY3JlYXRlRnVuZFF1b3RlUmVxdWVzdCcsIGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vZnVuZF9vcGVyYXRpb25zL3F1b3RlYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZnVuZCBvcGVyYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGNyZWF0ZWQgdGhlIGZ1bmQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuZE9wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgZnVuZCBvcGVyYXRpb24gdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGdW5kT3BlcmF0aW9uOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgZnVuZE9wZXJhdGlvbklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEZ1bmRPcGVyYXRpb24nLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0RnVuZE9wZXJhdGlvbicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZnVuZE9wZXJhdGlvbklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEZ1bmRPcGVyYXRpb24nLCAnZnVuZE9wZXJhdGlvbklkJywgZnVuZE9wZXJhdGlvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2Z1bmRfb3BlcmF0aW9ucy97ZnVuZF9vcGVyYXRpb25faWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImZ1bmRfb3BlcmF0aW9uX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoZnVuZE9wZXJhdGlvbklkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBmdW5kIG9wZXJhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgZnVuZCBvcGVyYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgZnVuZCBvcGVyYXRpb25zIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEZ1bmRPcGVyYXRpb25zOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEZ1bmRPcGVyYXRpb25zJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RGdW5kT3BlcmF0aW9ucycsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vZnVuZF9vcGVyYXRpb25zYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkZ1bmRBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IEZ1bmRBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogRnVuZEFwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEZ1bmRBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkZ1bmRBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbiB3aXRoIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyB0byBiZSBmdW5kZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3R9IGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBjcmVhdGVGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlRnVuZE9wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGdW5kQXBpLmNyZWF0ZUZ1bmRPcGVyYXRpb24nXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgRnVuZCBPcGVyYXRpb24gcXVvdGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3MgdG8gYmUgZnVuZGVkLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUZ1bmRRdW90ZVJlcXVlc3R9IGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZUZ1bmRRdW90ZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlRnVuZFF1b3RlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRnVuZEFwaS5jcmVhdGVGdW5kUXVvdGUnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgZnVuZCBvcGVyYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBjcmVhdGVkIHRoZSBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmRPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIGZ1bmQgb3BlcmF0aW9uIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0RnVuZE9wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBmdW5kT3BlcmF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGZ1bmRPcGVyYXRpb25JZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGdW5kQXBpLmdldEZ1bmRPcGVyYXRpb24nXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBmdW5kIG9wZXJhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgZnVuZCBvcGVyYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgZnVuZCBvcGVyYXRpb25zIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdEZ1bmRPcGVyYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdEZ1bmRPcGVyYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0Z1bmRBcGkubGlzdEZ1bmRPcGVyYXRpb25zJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuRnVuZEFwaUZwID0gRnVuZEFwaUZwO1xuLyoqXG4gKiBGdW5kQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRnVuZEFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLkZ1bmRBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbiB3aXRoIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyB0byBiZSBmdW5kZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3R9IGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgRnVuZCBPcGVyYXRpb24gcXVvdGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3MgdG8gYmUgZnVuZGVkLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUZ1bmRRdW90ZVJlcXVlc3R9IGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZ1bmRRdW90ZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVGdW5kUXVvdGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlRnVuZFF1b3RlUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgY3JlYXRlZCB0aGUgZnVuZCBvcGVyYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5kT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBmdW5kIG9wZXJhdGlvbiB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEZ1bmRPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgZnVuZE9wZXJhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGZ1bmRPcGVyYXRpb25JZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgZnVuZCBvcGVyYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IGZ1bmQgb3BlcmF0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IGZ1bmQgb3BlcmF0aW9ucyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RGdW5kT3BlcmF0aW9ucyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdEZ1bmRPcGVyYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5GdW5kQXBpRmFjdG9yeSA9IEZ1bmRBcGlGYWN0b3J5O1xuLyoqXG4gKiBGdW5kQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIEZ1bmRBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBGdW5kQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbiB3aXRoIGFuIGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyB0byBiZSBmdW5kZWQuXG4gICAgICogQHBhcmFtIHtDcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdH0gY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZ1bmRBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GdW5kQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlRnVuZE9wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbiB3aXRoIGFuIGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgRnVuZCBPcGVyYXRpb24gcXVvdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIHRvIGJlIGZ1bmRlZC5cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUZ1bmRRdW90ZVJlcXVlc3R9IGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZ1bmRBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVGdW5kUXVvdGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlRnVuZFF1b3RlUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRnVuZEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZUZ1bmRRdW90ZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAqIEBzdW1tYXJ5IEdldCBmdW5kIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBjcmVhdGVkIHRoZSBmdW5kIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuZE9wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgZnVuZCBvcGVyYXRpb24gdG8gZmV0Y2guXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGdW5kQXBpXG4gICAgICovXG4gICAgZ2V0RnVuZE9wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBmdW5kT3BlcmF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZ1bmRBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGZ1bmRPcGVyYXRpb25JZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgZnVuZCBvcGVyYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgZnVuZCBvcGVyYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IGZ1bmQgb3BlcmF0aW9ucyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGdW5kQXBpXG4gICAgICovXG4gICAgbGlzdEZ1bmRPcGVyYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GdW5kQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdEZ1bmRPcGVyYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLkZ1bmRBcGkgPSBGdW5kQXBpO1xuLyoqXG4gKiBNUENXYWxsZXRTdGFrZUFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE1QQ1dhbGxldFN0YWtlQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm9hZGNhc3QgYSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ09wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgc3Rha2luZyBvcGVyYXRpb24gdG8gYnJvYWRjYXN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0fSBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbjogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbicsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzdGFraW5nT3BlcmF0aW9uSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbicsICdzdGFraW5nT3BlcmF0aW9uSWQnLCBzdGFraW5nT3BlcmF0aW9uSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbicsICdicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCcsIGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3N0YWtpbmdfb3BlcmF0aW9ucy97c3Rha2luZ19vcGVyYXRpb25faWR9L2Jyb2FkY2FzdGBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJzdGFraW5nX29wZXJhdGlvbl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHN0YWtpbmdPcGVyYXRpb25JZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc3Rha2luZyBvcGVyYXRpb24gZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGNyZWF0ZSB0aGUgc3Rha2luZyBvcGVyYXRpb24gZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0fSBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlU3Rha2luZ09wZXJhdGlvbjogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVN0YWtpbmdPcGVyYXRpb24nLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlU3Rha2luZ09wZXJhdGlvbicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlU3Rha2luZ09wZXJhdGlvbicsICdjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCcsIGNyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3N0YWtpbmdfb3BlcmF0aW9uc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3Rha2luZ09wZXJhdGlvbjogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRTdGFraW5nT3BlcmF0aW9uJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFN0YWtpbmdPcGVyYXRpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3N0YWtpbmdPcGVyYXRpb25JZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRTdGFraW5nT3BlcmF0aW9uJywgJ3N0YWtpbmdPcGVyYXRpb25JZCcsIHN0YWtpbmdPcGVyYXRpb25JZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9zdGFraW5nX29wZXJhdGlvbnMve3N0YWtpbmdfb3BlcmF0aW9uX2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJzdGFraW5nX29wZXJhdGlvbl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHN0YWtpbmdPcGVyYXRpb25JZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuTVBDV2FsbGV0U3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IE1QQ1dhbGxldFN0YWtlQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIE1QQ1dhbGxldFN0YWtlQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTVBDV2FsbGV0U3Rha2VBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLk1QQ1dhbGxldFN0YWtlQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm9hZGNhc3QgYSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ09wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgc3Rha2luZyBvcGVyYXRpb24gdG8gYnJvYWRjYXN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0fSBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ01QQ1dhbGxldFN0YWtlQXBpLmJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb24nXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc3Rha2luZyBvcGVyYXRpb24gZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGNyZWF0ZSB0aGUgc3Rha2luZyBvcGVyYXRpb24gZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0fSBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlU3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnTVBDV2FsbGV0U3Rha2VBcGkuY3JlYXRlU3Rha2luZ09wZXJhdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFraW5nT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0U3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnTVBDV2FsbGV0U3Rha2VBcGkuZ2V0U3Rha2luZ09wZXJhdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLk1QQ1dhbGxldFN0YWtlQXBpRnAgPSBNUENXYWxsZXRTdGFrZUFwaUZwO1xuLyoqXG4gKiBNUENXYWxsZXRTdGFrZUFwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE1QQ1dhbGxldFN0YWtlQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuTVBDV2FsbGV0U3Rha2VBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFraW5nT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbiB0byBicm9hZGNhc3QuXG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uIGZvciBhbiBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBjcmVhdGUgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdH0gY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZVN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFraW5nT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuTVBDV2FsbGV0U3Rha2VBcGlGYWN0b3J5ID0gTVBDV2FsbGV0U3Rha2VBcGlGYWN0b3J5O1xuLyoqXG4gKiBNUENXYWxsZXRTdGFrZUFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBNUENXYWxsZXRTdGFrZUFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIE1QQ1dhbGxldFN0YWtlQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdCBhIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIHRvIGJyb2FkY2FzdC5cbiAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0fSBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgTVBDV2FsbGV0U3Rha2VBcGlcbiAgICAgKi9cbiAgICBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLk1QQ1dhbGxldFN0YWtlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBzdGFraW5nIG9wZXJhdGlvbiBmb3IgYW4gYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGNyZWF0ZSB0aGUgc3Rha2luZyBvcGVyYXRpb24gZm9yLlxuICAgICAqIEBwYXJhbSB7Q3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGNyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBNUENXYWxsZXRTdGFrZUFwaVxuICAgICAqL1xuICAgIGNyZWF0ZVN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLk1QQ1dhbGxldFN0YWtlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlU3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ09wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBNUENXYWxsZXRTdGFrZUFwaVxuICAgICAqL1xuICAgIGdldFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5NUENXYWxsZXRTdGFrZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLk1QQ1dhbGxldFN0YWtlQXBpID0gTVBDV2FsbGV0U3Rha2VBcGk7XG4vKipcbiAqIE5ldHdvcmtzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTmV0d29ya3NBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBuZXR3b3JrXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBuZXR3b3JrIGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TmV0d29yazogYXN5bmMgKG5ldHdvcmtJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0TmV0d29yaycsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuTmV0d29ya3NBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IE5ldHdvcmtzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIE5ldHdvcmtzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTmV0d29ya3NBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLk5ldHdvcmtzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgbmV0d29ya1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgbmV0d29yayBieSBJRFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldE5ldHdvcmsobmV0d29ya0lkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0TmV0d29yayhuZXR3b3JrSWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnTmV0d29ya3NBcGkuZ2V0TmV0d29yayddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLk5ldHdvcmtzQXBpRnAgPSBOZXR3b3Jrc0FwaUZwO1xuLyoqXG4gKiBOZXR3b3Jrc0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE5ldHdvcmtzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuTmV0d29ya3NBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBuZXR3b3JrXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBuZXR3b3JrIGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TmV0d29yayhuZXR3b3JrSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldE5ldHdvcmsobmV0d29ya0lkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5OZXR3b3Jrc0FwaUZhY3RvcnkgPSBOZXR3b3Jrc0FwaUZhY3Rvcnk7XG4vKipcbiAqIE5ldHdvcmtzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIE5ldHdvcmtzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgTmV0d29ya3NBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogR2V0IG5ldHdvcmtcbiAgICAgKiBAc3VtbWFyeSBHZXQgbmV0d29yayBieSBJRFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRvIGZldGNoLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgTmV0d29ya3NBcGlcbiAgICAgKi9cbiAgICBnZXROZXR3b3JrKG5ldHdvcmtJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuTmV0d29ya3NBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXROZXR3b3JrKG5ldHdvcmtJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5OZXR3b3Jrc0FwaSA9IE5ldHdvcmtzQXBpO1xuLyoqXG4gKiBPbmNoYWluSWRlbnRpdHlBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBPbmNoYWluSWRlbnRpdHlBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9idGFpbnMgb25jaGFpbiBpZGVudGl0eSBmb3IgYW4gYWRkcmVzcyBvbiBhIHNwZWNpZmljIG5ldHdvcmtcbiAgICAgICAgICogQHN1bW1hcnkgT2J0YWlucyBvbmNoYWluIGlkZW50aXR5IGZvciBhbiBhZGRyZXNzIG9uIGEgc3BlY2lmaWMgbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBpZGVudGl0eSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxSZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3NSb2xlc0VudW0+fSBbcm9sZXNdIEEgZmlsdGVyIGJ5IHJvbGUgb2YgdGhlIG5hbWVzIHJlbGF0ZWQgdG8gdGhpcyBhZGRyZXNzIChtYW5hZ2VkIG9yIG93bmVkKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3M6IGFzeW5jIChuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcm9sZXMsIGxpbWl0LCBwYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdyZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3MnLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdyZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3MnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vaWRlbnRpdHlgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAocm9sZXMpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydyb2xlcyddID0gcm9sZXMuam9pbihiYXNlXzEuQ09MTEVDVElPTl9GT1JNQVRTLmNzdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5PbmNoYWluSWRlbnRpdHlBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IE9uY2hhaW5JZGVudGl0eUFwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBPbmNoYWluSWRlbnRpdHlBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBPbmNoYWluSWRlbnRpdHlBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLk9uY2hhaW5JZGVudGl0eUFwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogT2J0YWlucyBvbmNoYWluIGlkZW50aXR5IGZvciBhbiBhZGRyZXNzIG9uIGEgc3BlY2lmaWMgbmV0d29ya1xuICAgICAgICAgKiBAc3VtbWFyeSBPYnRhaW5zIG9uY2hhaW4gaWRlbnRpdHkgZm9yIGFuIGFkZHJlc3Mgb24gYSBzcGVjaWZpYyBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGlkZW50aXR5IGZvclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PFJlc29sdmVJZGVudGl0eUJ5QWRkcmVzc1JvbGVzRW51bT59IFtyb2xlc10gQSBmaWx0ZXIgYnkgcm9sZSBvZiB0aGUgbmFtZXMgcmVsYXRlZCB0byB0aGlzIGFkZHJlc3MgKG1hbmFnZWQgb3Igb3duZWQpXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHJlc29sdmVJZGVudGl0eUJ5QWRkcmVzcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcm9sZXMsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IucmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCByb2xlcywgbGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnT25jaGFpbklkZW50aXR5QXBpLnJlc29sdmVJZGVudGl0eUJ5QWRkcmVzcyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLk9uY2hhaW5JZGVudGl0eUFwaUZwID0gT25jaGFpbklkZW50aXR5QXBpRnA7XG4vKipcbiAqIE9uY2hhaW5JZGVudGl0eUFwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE9uY2hhaW5JZGVudGl0eUFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLk9uY2hhaW5JZGVudGl0eUFwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogT2J0YWlucyBvbmNoYWluIGlkZW50aXR5IGZvciBhbiBhZGRyZXNzIG9uIGEgc3BlY2lmaWMgbmV0d29ya1xuICAgICAgICAgKiBAc3VtbWFyeSBPYnRhaW5zIG9uY2hhaW4gaWRlbnRpdHkgZm9yIGFuIGFkZHJlc3Mgb24gYSBzcGVjaWZpYyBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGlkZW50aXR5IGZvclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PFJlc29sdmVJZGVudGl0eUJ5QWRkcmVzc1JvbGVzRW51bT59IFtyb2xlc10gQSBmaWx0ZXIgYnkgcm9sZSBvZiB0aGUgbmFtZXMgcmVsYXRlZCB0byB0aGlzIGFkZHJlc3MgKG1hbmFnZWQgb3Igb3duZWQpXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHJlc29sdmVJZGVudGl0eUJ5QWRkcmVzcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcm9sZXMsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5yZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3MobmV0d29ya0lkLCBhZGRyZXNzSWQsIHJvbGVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuT25jaGFpbklkZW50aXR5QXBpRmFjdG9yeSA9IE9uY2hhaW5JZGVudGl0eUFwaUZhY3Rvcnk7XG4vKipcbiAqIE9uY2hhaW5JZGVudGl0eUFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBPbmNoYWluSWRlbnRpdHlBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBPbmNoYWluSWRlbnRpdHlBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogT2J0YWlucyBvbmNoYWluIGlkZW50aXR5IGZvciBhbiBhZGRyZXNzIG9uIGEgc3BlY2lmaWMgbmV0d29ya1xuICAgICAqIEBzdW1tYXJ5IE9idGFpbnMgb25jaGFpbiBpZGVudGl0eSBmb3IgYW4gYWRkcmVzcyBvbiBhIHNwZWNpZmljIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGlkZW50aXR5IGZvclxuICAgICAqIEBwYXJhbSB7QXJyYXk8UmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzUm9sZXNFbnVtPn0gW3JvbGVzXSBBIGZpbHRlciBieSByb2xlIG9mIHRoZSBuYW1lcyByZWxhdGVkIHRvIHRoaXMgYWRkcmVzcyAobWFuYWdlZCBvciBvd25lZClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE9uY2hhaW5JZGVudGl0eUFwaVxuICAgICAqL1xuICAgIHJlc29sdmVJZGVudGl0eUJ5QWRkcmVzcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcm9sZXMsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5PbmNoYWluSWRlbnRpdHlBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5yZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3MobmV0d29ya0lkLCBhZGRyZXNzSWQsIHJvbGVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5PbmNoYWluSWRlbnRpdHlBcGkgPSBPbmNoYWluSWRlbnRpdHlBcGk7XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0cy5SZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3NSb2xlc0VudW0gPSB7XG4gICAgTWFuYWdlZDogJ21hbmFnZWQnLFxuICAgIE93bmVkOiAnb3duZWQnXG59O1xuLyoqXG4gKiBSZXB1dGF0aW9uQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUmVwdXRhdGlvbkFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBvbmNoYWluIHJlcHV0YXRpb24gb2YgYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIG9uY2hhaW4gcmVwdXRhdGlvbiBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSByZXB1dGF0aW9uIGZvci5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEFkZHJlc3NSZXB1dGF0aW9uOiBhc3luYyAobmV0d29ya0lkLCBhZGRyZXNzSWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEFkZHJlc3NSZXB1dGF0aW9uJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0QWRkcmVzc1JlcHV0YXRpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vcmVwdXRhdGlvbmBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuUmVwdXRhdGlvbkFwaUF4aW9zUGFyYW1DcmVhdG9yID0gUmVwdXRhdGlvbkFwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBSZXB1dGF0aW9uQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUmVwdXRhdGlvbkFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuUmVwdXRhdGlvbkFwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBvbmNoYWluIHJlcHV0YXRpb24gb2YgYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIG9uY2hhaW4gcmVwdXRhdGlvbiBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSByZXB1dGF0aW9uIGZvci5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldEFkZHJlc3NSZXB1dGF0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0QWRkcmVzc1JlcHV0YXRpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnUmVwdXRhdGlvbkFwaS5nZXRBZGRyZXNzUmVwdXRhdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlJlcHV0YXRpb25BcGlGcCA9IFJlcHV0YXRpb25BcGlGcDtcbi8qKlxuICogUmVwdXRhdGlvbkFwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFJlcHV0YXRpb25BcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5SZXB1dGF0aW9uQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG9uY2hhaW4gcmVwdXRhdGlvbiBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgb25jaGFpbiByZXB1dGF0aW9uIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29yay5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHJlcHV0YXRpb24gZm9yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWRkcmVzc1JlcHV0YXRpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldEFkZHJlc3NSZXB1dGF0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5SZXB1dGF0aW9uQXBpRmFjdG9yeSA9IFJlcHV0YXRpb25BcGlGYWN0b3J5O1xuLyoqXG4gKiBSZXB1dGF0aW9uQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFJlcHV0YXRpb25BcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBSZXB1dGF0aW9uQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb25jaGFpbiByZXB1dGF0aW9uIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIG9uY2hhaW4gcmVwdXRhdGlvbiBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29yay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgcmVwdXRhdGlvbiBmb3IuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBSZXB1dGF0aW9uQXBpXG4gICAgICovXG4gICAgZ2V0QWRkcmVzc1JlcHV0YXRpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlJlcHV0YXRpb25BcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRBZGRyZXNzUmVwdXRhdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXB1dGF0aW9uQXBpID0gUmVwdXRhdGlvbkFwaTtcbi8qKlxuICogU2VydmVyU2lnbmVyc0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFNlcnZlclNpZ25lcnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBTZXJ2ZXItU2lnbmVyXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBTZXJ2ZXItU2lnbmVyXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlU2VydmVyU2lnbmVyUmVxdWVzdH0gW2NyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTZXJ2ZXJTaWduZXI6IGFzeW5jIChjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc2VydmVyX3NpZ25lcnNgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHNlcnZlciBzaWduZXIgYnkgSURcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgc2VydmVyIHNpZ25lciBieSBJRFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZXJ2ZXJTaWduZXI6IGFzeW5jIChzZXJ2ZXJTaWduZXJJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzZXJ2ZXJTaWduZXJJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRTZXJ2ZXJTaWduZXInLCAnc2VydmVyU2lnbmVySWQnLCBzZXJ2ZXJTaWduZXJJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3NlcnZlcl9zaWduZXJzL3tzZXJ2ZXJfc2lnbmVyX2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJzZXJ2ZXJfc2lnbmVyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoc2VydmVyU2lnbmVySWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGV2ZW50cyBmb3IgYSBzZXJ2ZXIgc2lnbmVyXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgZXZlbnRzIGZvciBhIHNlcnZlciBzaWduZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcnZlclNpZ25lcklkIFRoZSBJRCBvZiB0aGUgc2VydmVyIHNpZ25lciB0byBmZXRjaCBldmVudHMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RTZXJ2ZXJTaWduZXJFdmVudHM6IGFzeW5jIChzZXJ2ZXJTaWduZXJJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnc2VydmVyU2lnbmVySWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdFNlcnZlclNpZ25lckV2ZW50cycsICdzZXJ2ZXJTaWduZXJJZCcsIHNlcnZlclNpZ25lcklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc2VydmVyX3NpZ25lcnMve3NlcnZlcl9zaWduZXJfaWR9L2V2ZW50c2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJzZXJ2ZXJfc2lnbmVyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoc2VydmVyU2lnbmVySWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgc2VydmVyIHNpZ25lcnMgZm9yIHRoZSBjdXJyZW50IHByb2plY3RcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBzZXJ2ZXIgc2lnbmVycyBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0U2VydmVyU2lnbmVyczogYXN5bmMgKGxpbWl0LCBwYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc2VydmVyX3NpZ25lcnNgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAgICAgKiBAc3VtbWFyeSBTdWJtaXQgdGhlIHJlc3VsdCBvZiBhIHNlcnZlciBzaWduZXIgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcnZlclNpZ25lcklkIFRoZSBJRCBvZiB0aGUgc2VydmVyIHNpZ25lciB0byBzdWJtaXQgdGhlIGV2ZW50IHJlc3VsdCBmb3JcbiAgICAgICAgICogQHBhcmFtIHtTZWVkQ3JlYXRpb25FdmVudFJlc3VsdH0gW3NlZWRDcmVhdGlvbkV2ZW50UmVzdWx0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgc3VibWl0U2VydmVyU2lnbmVyU2VlZEV2ZW50UmVzdWx0OiBhc3luYyAoc2VydmVyU2lnbmVySWQsIHNlZWRDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3NlcnZlclNpZ25lcklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3N1Ym1pdFNlcnZlclNpZ25lclNlZWRFdmVudFJlc3VsdCcsICdzZXJ2ZXJTaWduZXJJZCcsIHNlcnZlclNpZ25lcklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc2VydmVyX3NpZ25lcnMve3NlcnZlcl9zaWduZXJfaWR9L3NlZWRfZXZlbnRfcmVzdWx0YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInNlcnZlcl9zaWduZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhzZXJ2ZXJTaWduZXJJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShzZWVkQ3JlYXRpb25FdmVudFJlc3VsdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICAgICAqIEBzdW1tYXJ5IFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIHN1Ym1pdCB0aGUgZXZlbnQgcmVzdWx0IGZvclxuICAgICAgICAgKiBAcGFyYW0ge1NpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHR9IFtzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgc3VibWl0U2VydmVyU2lnbmVyU2lnbmF0dXJlRXZlbnRSZXN1bHQ6IGFzeW5jIChzZXJ2ZXJTaWduZXJJZCwgc2lnbmF0dXJlQ3JlYXRpb25FdmVudFJlc3VsdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzZXJ2ZXJTaWduZXJJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdzdWJtaXRTZXJ2ZXJTaWduZXJTaWduYXR1cmVFdmVudFJlc3VsdCcsICdzZXJ2ZXJTaWduZXJJZCcsIHNlcnZlclNpZ25lcklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc2VydmVyX3NpZ25lcnMve3NlcnZlcl9zaWduZXJfaWR9L3NpZ25hdHVyZV9ldmVudF9yZXN1bHRgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wic2VydmVyX3NpZ25lcl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHNlcnZlclNpZ25lcklkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKHNpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHQsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuU2VydmVyU2lnbmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gU2VydmVyU2lnbmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBTZXJ2ZXJTaWduZXJzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU2VydmVyU2lnbmVyc0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuU2VydmVyU2lnbmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IFNlcnZlci1TaWduZXJcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IFNlcnZlci1TaWduZXJcbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0fSBbY3JlYXRlU2VydmVyU2lnbmVyUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZVNlcnZlclNpZ25lcihjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlU2VydmVyU2lnbmVyKGNyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU2VydmVyU2lnbmVyc0FwaS5jcmVhdGVTZXJ2ZXJTaWduZXInXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgc2VydmVyIHNpZ25lciBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSBzZXJ2ZXIgc2lnbmVyIGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldFNlcnZlclNpZ25lcihzZXJ2ZXJTaWduZXJJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldFNlcnZlclNpZ25lcihzZXJ2ZXJTaWduZXJJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTZXJ2ZXJTaWduZXJzQXBpLmdldFNlcnZlclNpZ25lciddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGV2ZW50cyBmb3IgYSBzZXJ2ZXIgc2lnbmVyXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgZXZlbnRzIGZvciBhIHNlcnZlciBzaWduZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcnZlclNpZ25lcklkIFRoZSBJRCBvZiB0aGUgc2VydmVyIHNpZ25lciB0byBmZXRjaCBldmVudHMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RTZXJ2ZXJTaWduZXJFdmVudHMoc2VydmVyU2lnbmVySWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdFNlcnZlclNpZ25lckV2ZW50cyhzZXJ2ZXJTaWduZXJJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU2VydmVyU2lnbmVyc0FwaS5saXN0U2VydmVyU2lnbmVyRXZlbnRzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgc2VydmVyIHNpZ25lcnMgZm9yIHRoZSBjdXJyZW50IHByb2plY3RcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBzZXJ2ZXIgc2lnbmVycyBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0U2VydmVyU2lnbmVycyhsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RTZXJ2ZXJTaWduZXJzKGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NlcnZlclNpZ25lcnNBcGkubGlzdFNlcnZlclNpZ25lcnMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICAgICAqIEBzdW1tYXJ5IFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIHN1Ym1pdCB0aGUgZXZlbnQgcmVzdWx0IGZvclxuICAgICAgICAgKiBAcGFyYW0ge1NlZWRDcmVhdGlvbkV2ZW50UmVzdWx0fSBbc2VlZENyZWF0aW9uRXZlbnRSZXN1bHRdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBzdWJtaXRTZXJ2ZXJTaWduZXJTZWVkRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNlZWRDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3Iuc3VibWl0U2VydmVyU2lnbmVyU2VlZEV2ZW50UmVzdWx0KHNlcnZlclNpZ25lcklkLCBzZWVkQ3JlYXRpb25FdmVudFJlc3VsdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTZXJ2ZXJTaWduZXJzQXBpLnN1Ym1pdFNlcnZlclNpZ25lclNlZWRFdmVudFJlc3VsdCddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJtaXQgdGhlIHJlc3VsdCBvZiBhIHNlcnZlciBzaWduZXIgZXZlbnRcbiAgICAgICAgICogQHN1bW1hcnkgU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gc3VibWl0IHRoZSBldmVudCByZXN1bHQgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7U2lnbmF0dXJlQ3JlYXRpb25FdmVudFJlc3VsdH0gW3NpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHRdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBzdWJtaXRTZXJ2ZXJTaWduZXJTaWduYXR1cmVFdmVudFJlc3VsdChzZXJ2ZXJTaWduZXJJZCwgc2lnbmF0dXJlQ3JlYXRpb25FdmVudFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnN1Ym1pdFNlcnZlclNpZ25lclNpZ25hdHVyZUV2ZW50UmVzdWx0KHNlcnZlclNpZ25lcklkLCBzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NlcnZlclNpZ25lcnNBcGkuc3VibWl0U2VydmVyU2lnbmVyU2lnbmF0dXJlRXZlbnRSZXN1bHQnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRnAgPSBTZXJ2ZXJTaWduZXJzQXBpRnA7XG4vKipcbiAqIFNlcnZlclNpZ25lcnNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBTZXJ2ZXJTaWduZXJzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuU2VydmVyU2lnbmVyc0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IFNlcnZlci1TaWduZXJcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IFNlcnZlci1TaWduZXJcbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0fSBbY3JlYXRlU2VydmVyU2lnbmVyUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNlcnZlclNpZ25lcihjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVTZXJ2ZXJTaWduZXIoY3JlYXRlU2VydmVyU2lnbmVyUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHNlcnZlciBzaWduZXIgYnkgSURcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgc2VydmVyIHNpZ25lciBieSBJRFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZXJ2ZXJTaWduZXIoc2VydmVyU2lnbmVySWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldFNlcnZlclNpZ25lcihzZXJ2ZXJTaWduZXJJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgZXZlbnRzIGZvciBhIHNlcnZlciBzaWduZXJcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBldmVudHMgZm9yIGEgc2VydmVyIHNpZ25lclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIGZldGNoIGV2ZW50cyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFNlcnZlclNpZ25lckV2ZW50cyhzZXJ2ZXJTaWduZXJJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RTZXJ2ZXJTaWduZXJFdmVudHMoc2VydmVyU2lnbmVySWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBzZXJ2ZXIgc2lnbmVycyBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdFxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHNlcnZlciBzaWduZXJzIGZvciB0aGUgY3VycmVudCBwcm9qZWN0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RTZXJ2ZXJTaWduZXJzKGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0U2VydmVyU2lnbmVycyhsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAgICAgKiBAc3VtbWFyeSBTdWJtaXQgdGhlIHJlc3VsdCBvZiBhIHNlcnZlciBzaWduZXIgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcnZlclNpZ25lcklkIFRoZSBJRCBvZiB0aGUgc2VydmVyIHNpZ25lciB0byBzdWJtaXQgdGhlIGV2ZW50IHJlc3VsdCBmb3JcbiAgICAgICAgICogQHBhcmFtIHtTZWVkQ3JlYXRpb25FdmVudFJlc3VsdH0gW3NlZWRDcmVhdGlvbkV2ZW50UmVzdWx0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgc3VibWl0U2VydmVyU2lnbmVyU2VlZEV2ZW50UmVzdWx0KHNlcnZlclNpZ25lcklkLCBzZWVkQ3JlYXRpb25FdmVudFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuc3VibWl0U2VydmVyU2lnbmVyU2VlZEV2ZW50UmVzdWx0KHNlcnZlclNpZ25lcklkLCBzZWVkQ3JlYXRpb25FdmVudFJlc3VsdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAgICAgKiBAc3VtbWFyeSBTdWJtaXQgdGhlIHJlc3VsdCBvZiBhIHNlcnZlciBzaWduZXIgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcnZlclNpZ25lcklkIFRoZSBJRCBvZiB0aGUgc2VydmVyIHNpZ25lciB0byBzdWJtaXQgdGhlIGV2ZW50IHJlc3VsdCBmb3JcbiAgICAgICAgICogQHBhcmFtIHtTaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0fSBbc2lnbmF0dXJlQ3JlYXRpb25FdmVudFJlc3VsdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHN1Ym1pdFNlcnZlclNpZ25lclNpZ25hdHVyZUV2ZW50UmVzdWx0KHNlcnZlclNpZ25lcklkLCBzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5zdWJtaXRTZXJ2ZXJTaWduZXJTaWduYXR1cmVFdmVudFJlc3VsdChzZXJ2ZXJTaWduZXJJZCwgc2lnbmF0dXJlQ3JlYXRpb25FdmVudFJlc3VsdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuU2VydmVyU2lnbmVyc0FwaUZhY3RvcnkgPSBTZXJ2ZXJTaWduZXJzQXBpRmFjdG9yeTtcbi8qKlxuICogU2VydmVyU2lnbmVyc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBTZXJ2ZXJTaWduZXJzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgU2VydmVyU2lnbmVyc0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgU2VydmVyLVNpZ25lclxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBTZXJ2ZXItU2lnbmVyXG4gICAgICogQHBhcmFtIHtDcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0fSBbY3JlYXRlU2VydmVyU2lnbmVyUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNlcnZlclNpZ25lcnNBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVTZXJ2ZXJTaWduZXIoY3JlYXRlU2VydmVyU2lnbmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU2VydmVyU2lnbmVyc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZVNlcnZlclNpZ25lcihjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc2VydmVyIHNpZ25lciBieSBJRFxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHNlcnZlciBzaWduZXIgYnkgSURcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIGZldGNoXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJTaWduZXJzQXBpXG4gICAgICovXG4gICAgZ2V0U2VydmVyU2lnbmVyKHNlcnZlclNpZ25lcklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0U2VydmVyU2lnbmVyKHNlcnZlclNpZ25lcklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBldmVudHMgZm9yIGEgc2VydmVyIHNpZ25lclxuICAgICAqIEBzdW1tYXJ5IExpc3QgZXZlbnRzIGZvciBhIHNlcnZlciBzaWduZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIGZldGNoIGV2ZW50cyBmb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU2VydmVyU2lnbmVyc0FwaVxuICAgICAqL1xuICAgIGxpc3RTZXJ2ZXJTaWduZXJFdmVudHMoc2VydmVyU2lnbmVySWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdFNlcnZlclNpZ25lckV2ZW50cyhzZXJ2ZXJTaWduZXJJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHNlcnZlciBzaWduZXJzIGZvciB0aGUgY3VycmVudCBwcm9qZWN0XG4gICAgICogQHN1bW1hcnkgTGlzdCBzZXJ2ZXIgc2lnbmVycyBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU2VydmVyU2lnbmVyc0FwaVxuICAgICAqL1xuICAgIGxpc3RTZXJ2ZXJTaWduZXJzKGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdFNlcnZlclNpZ25lcnMobGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJtaXQgdGhlIHJlc3VsdCBvZiBhIHNlcnZlciBzaWduZXIgZXZlbnRcbiAgICAgKiBAc3VtbWFyeSBTdWJtaXQgdGhlIHJlc3VsdCBvZiBhIHNlcnZlciBzaWduZXIgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIHN1Ym1pdCB0aGUgZXZlbnQgcmVzdWx0IGZvclxuICAgICAqIEBwYXJhbSB7U2VlZENyZWF0aW9uRXZlbnRSZXN1bHR9IFtzZWVkQ3JlYXRpb25FdmVudFJlc3VsdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNlcnZlclNpZ25lcnNBcGlcbiAgICAgKi9cbiAgICBzdWJtaXRTZXJ2ZXJTaWduZXJTZWVkRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNlZWRDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuc3VibWl0U2VydmVyU2lnbmVyU2VlZEV2ZW50UmVzdWx0KHNlcnZlclNpZ25lcklkLCBzZWVkQ3JlYXRpb25FdmVudFJlc3VsdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAqIEBzdW1tYXJ5IFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gc3VibWl0IHRoZSBldmVudCByZXN1bHQgZm9yXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0fSBbc2lnbmF0dXJlQ3JlYXRpb25FdmVudFJlc3VsdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNlcnZlclNpZ25lcnNBcGlcbiAgICAgKi9cbiAgICBzdWJtaXRTZXJ2ZXJTaWduZXJTaWduYXR1cmVFdmVudFJlc3VsdChzZXJ2ZXJTaWduZXJJZCwgc2lnbmF0dXJlQ3JlYXRpb25FdmVudFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU2VydmVyU2lnbmVyc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnN1Ym1pdFNlcnZlclNpZ25lclNpZ25hdHVyZUV2ZW50UmVzdWx0KHNlcnZlclNpZ25lcklkLCBzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlclNpZ25lcnNBcGkgPSBTZXJ2ZXJTaWduZXJzQXBpO1xuLyoqXG4gKiBTbWFydENvbnRyYWN0c0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFNtYXJ0Q29udHJhY3RzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21waWxlIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHN1bW1hcnkgQ29tcGlsZSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7Q29tcGlsZVNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBjb21waWxlU21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbXBpbGVTbWFydENvbnRyYWN0OiBhc3luYyAoY29tcGlsZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NvbXBpbGVTbWFydENvbnRyYWN0UmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjb21waWxlU21hcnRDb250cmFjdCcsICdjb21waWxlU21hcnRDb250cmFjdFJlcXVlc3QnLCBjb21waWxlU21hcnRDb250cmFjdFJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zbWFydF9jb250cmFjdHMvY29tcGlsZWA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY29tcGlsZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBkZXBsb3kgdGhlIHNtYXJ0IGNvbnRyYWN0IGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3R9IGNyZWF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTbWFydENvbnRyYWN0OiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlU21hcnRDb250cmFjdCcsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVTbWFydENvbnRyYWN0JywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVTbWFydENvbnRyYWN0JywgJ2NyZWF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0JywgY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vc21hcnRfY29udHJhY3RzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVwbG95cyBhIHNtYXJ0IGNvbnRyYWN0LCBieSBicm9hZGNhc3RpbmcgdGhlIHRyYW5zYWN0aW9uIHRvIHRoZSBuZXR3b3JrLlxuICAgICAgICAgKiBAc3VtbWFyeSBEZXBsb3kgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gYnJvYWRjYXN0IHRoZSB0cmFuc2FjdGlvbiBmcm9tLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc21hcnRDb250cmFjdElkIFRoZSBVVUlEIG9mIHRoZSBzbWFydCBjb250cmFjdCB0byBicm9hZGNhc3QgdGhlIHRyYW5zYWN0aW9uIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge0RlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZGVwbG95U21hcnRDb250cmFjdDogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIHNtYXJ0Q29udHJhY3RJZCwgZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZGVwbG95U21hcnRDb250cmFjdCcsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdkZXBsb3lTbWFydENvbnRyYWN0JywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzbWFydENvbnRyYWN0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZGVwbG95U21hcnRDb250cmFjdCcsICdzbWFydENvbnRyYWN0SWQnLCBzbWFydENvbnRyYWN0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZGVwbG95U21hcnRDb250cmFjdCcsICdkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCcsIGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3NtYXJ0X2NvbnRyYWN0cy97c21hcnRfY29udHJhY3RfaWR9L2RlcGxveWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJzbWFydF9jb250cmFjdF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHNtYXJ0Q29udHJhY3RJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgc3BlY2lmaWMgc21hcnQgY29udHJhY3QgZGVwbG95ZWQgYnkgYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgc3BlY2lmaWMgc21hcnQgY29udHJhY3QgZGVwbG95ZWQgYnkgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHNtYXJ0IGNvbnRyYWN0IGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0Q29udHJhY3RJZCBUaGUgVVVJRCBvZiB0aGUgc21hcnQgY29udHJhY3QgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTbWFydENvbnRyYWN0OiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFNtYXJ0Q29udHJhY3QnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0U21hcnRDb250cmFjdCcsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnc21hcnRDb250cmFjdElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFNtYXJ0Q29udHJhY3QnLCAnc21hcnRDb250cmFjdElkJywgc21hcnRDb250cmFjdElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3NtYXJ0X2NvbnRyYWN0cy97c21hcnRfY29udHJhY3RfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInNtYXJ0X2NvbnRyYWN0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoc21hcnRDb250cmFjdElkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBzbWFydCBjb250cmFjdHNcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBzbWFydCBjb250cmFjdHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBQYWdpbmF0aW9uIHRva2VuIGZvciByZXRyaWV2aW5nIHRoZSBuZXh0IHNldCBvZiByZXN1bHRzXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0U21hcnRDb250cmFjdHM6IGFzeW5jIChwYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc21hcnRfY29udHJhY3RzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSBhIHJlYWQgb3BlcmF0aW9uIG9uIGEgc21hcnQgY29udHJhY3Qgd2l0aG91dCBjcmVhdGluZyBhIHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlYWQgZGF0YSBmcm9tIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7UmVhZENvbnRyYWN0UmVxdWVzdH0gcmVhZENvbnRyYWN0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZENvbnRyYWN0OiBhc3luYyAobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHJlYWRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3JlYWRDb250cmFjdCcsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY29udHJhY3RBZGRyZXNzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3JlYWRDb250cmFjdCcsICdjb250cmFjdEFkZHJlc3MnLCBjb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAncmVhZENvbnRyYWN0UmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdyZWFkQ29udHJhY3QnLCAncmVhZENvbnRyYWN0UmVxdWVzdCcsIHJlYWRDb250cmFjdFJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vc21hcnRfY29udHJhY3RzL3tjb250cmFjdF9hZGRyZXNzfS9yZWFkYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJjb250cmFjdF9hZGRyZXNzXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoY29udHJhY3RBZGRyZXNzKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkocmVhZENvbnRyYWN0UmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIEVWTSBhZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdCAoNDIgY2hhcmFjdGVycywgaW5jbHVkaW5nIFxcJiMzOTsweFxcJiMzOTssIGluIGxvd2VyY2FzZSlcbiAgICAgICAgICogQHBhcmFtIHtSZWdpc3RlclNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBbcmVnaXN0ZXJTbWFydENvbnRyYWN0UmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHJlZ2lzdGVyU21hcnRDb250cmFjdDogYXN5bmMgKG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCByZWdpc3RlclNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdyZWdpc3RlclNtYXJ0Q29udHJhY3QnLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NvbnRyYWN0QWRkcmVzcycgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdyZWdpc3RlclNtYXJ0Q29udHJhY3QnLCAnY29udHJhY3RBZGRyZXNzJywgY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L3NtYXJ0X2NvbnRyYWN0cy97Y29udHJhY3RfYWRkcmVzc30vcmVnaXN0ZXJgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImNvbnRyYWN0X2FkZHJlc3NcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhjb250cmFjdEFkZHJlc3MpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShyZWdpc3RlclNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBVcGRhdGUgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyBFVk0gYWRkcmVzcyBvZiB0aGUgc21hcnQgY29udHJhY3QgKDQyIGNoYXJhY3RlcnMsIGluY2x1ZGluZyBcXCYjMzk7MHhcXCYjMzk7LCBpbiBsb3dlcmNhc2UpXG4gICAgICAgICAqIEBwYXJhbSB7VXBkYXRlU21hcnRDb250cmFjdFJlcXVlc3R9IFt1cGRhdGVTbWFydENvbnRyYWN0UmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVNtYXJ0Q29udHJhY3Q6IGFzeW5jIChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgdXBkYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3VwZGF0ZVNtYXJ0Q29udHJhY3QnLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NvbnRyYWN0QWRkcmVzcycgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCd1cGRhdGVTbWFydENvbnRyYWN0JywgJ2NvbnRyYWN0QWRkcmVzcycsIGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9zbWFydF9jb250cmFjdHMve2NvbnRyYWN0X2FkZHJlc3N9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJjb250cmFjdF9hZGRyZXNzXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoY29udHJhY3RBZGRyZXNzKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BVVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKSh1cGRhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gU21hcnRDb250cmFjdHNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogU21hcnRDb250cmFjdHNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBTbWFydENvbnRyYWN0c0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBpbGUgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBDb21waWxlIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtDb21waWxlU21hcnRDb250cmFjdFJlcXVlc3R9IGNvbXBpbGVTbWFydENvbnRyYWN0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY29tcGlsZVNtYXJ0Q29udHJhY3QoY29tcGlsZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY29tcGlsZVNtYXJ0Q29udHJhY3QoY29tcGlsZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0Q29udHJhY3RzQXBpLmNvbXBpbGVTbWFydENvbnRyYWN0J10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGRlcGxveSB0aGUgc21hcnQgY29udHJhY3QgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdH0gY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0Q29udHJhY3RzQXBpLmNyZWF0ZVNtYXJ0Q29udHJhY3QnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVwbG95cyBhIHNtYXJ0IGNvbnRyYWN0LCBieSBicm9hZGNhc3RpbmcgdGhlIHRyYW5zYWN0aW9uIHRvIHRoZSBuZXR3b3JrLlxuICAgICAgICAgKiBAc3VtbWFyeSBEZXBsb3kgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gYnJvYWRjYXN0IHRoZSB0cmFuc2FjdGlvbiBmcm9tLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc21hcnRDb250cmFjdElkIFRoZSBVVUlEIG9mIHRoZSBzbWFydCBjb250cmFjdCB0byBicm9hZGNhc3QgdGhlIHRyYW5zYWN0aW9uIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge0RlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZGVwbG95U21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBzbWFydENvbnRyYWN0SWQsIGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZGVwbG95U21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBzbWFydENvbnRyYWN0SWQsIGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0Q29udHJhY3RzQXBpLmRlcGxveVNtYXJ0Q29udHJhY3QnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgc3BlY2lmaWMgc21hcnQgY29udHJhY3QgZGVwbG95ZWQgYnkgYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgc3BlY2lmaWMgc21hcnQgY29udHJhY3QgZGVwbG95ZWQgYnkgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHNtYXJ0IGNvbnRyYWN0IGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0Q29udHJhY3RJZCBUaGUgVVVJRCBvZiB0aGUgc21hcnQgY29udHJhY3QgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIHNtYXJ0Q29udHJhY3RJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldFNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0Q29udHJhY3RzQXBpLmdldFNtYXJ0Q29udHJhY3QnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBzbWFydCBjb250cmFjdHNcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBzbWFydCBjb250cmFjdHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBQYWdpbmF0aW9uIHRva2VuIGZvciByZXRyaWV2aW5nIHRoZSBuZXh0IHNldCBvZiByZXN1bHRzXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0U21hcnRDb250cmFjdHMocGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RTbWFydENvbnRyYWN0cyhwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0Q29udHJhY3RzQXBpLmxpc3RTbWFydENvbnRyYWN0cyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtIGEgcmVhZCBvcGVyYXRpb24gb24gYSBzbWFydCBjb250cmFjdCB3aXRob3V0IGNyZWF0aW5nIGEgdHJhbnNhY3Rpb25cbiAgICAgICAgICogQHN1bW1hcnkgUmVhZCBkYXRhIGZyb20gYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtSZWFkQ29udHJhY3RSZXF1ZXN0fSByZWFkQ29udHJhY3RSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyByZWFkQ29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHJlYWRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5yZWFkQ29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHJlYWRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU21hcnRDb250cmFjdHNBcGkucmVhZENvbnRyYWN0J10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyBFVk0gYWRkcmVzcyBvZiB0aGUgc21hcnQgY29udHJhY3QgKDQyIGNoYXJhY3RlcnMsIGluY2x1ZGluZyBcXCYjMzk7MHhcXCYjMzk7LCBpbiBsb3dlcmNhc2UpXG4gICAgICAgICAqIEBwYXJhbSB7UmVnaXN0ZXJTbWFydENvbnRyYWN0UmVxdWVzdH0gW3JlZ2lzdGVyU21hcnRDb250cmFjdFJlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyByZWdpc3RlclNtYXJ0Q29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHJlZ2lzdGVyU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5yZWdpc3RlclNtYXJ0Q29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHJlZ2lzdGVyU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU21hcnRDb250cmFjdHNBcGkucmVnaXN0ZXJTbWFydENvbnRyYWN0J10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIEVWTSBhZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdCAoNDIgY2hhcmFjdGVycywgaW5jbHVkaW5nIFxcJiMzOTsweFxcJiMzOTssIGluIGxvd2VyY2FzZSlcbiAgICAgICAgICogQHBhcmFtIHtVcGRhdGVTbWFydENvbnRyYWN0UmVxdWVzdH0gW3VwZGF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgdXBkYXRlU21hcnRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgdXBkYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci51cGRhdGVTbWFydENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCB1cGRhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTbWFydENvbnRyYWN0c0FwaS51cGRhdGVTbWFydENvbnRyYWN0J10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlGcCA9IFNtYXJ0Q29udHJhY3RzQXBpRnA7XG4vKipcbiAqIFNtYXJ0Q29udHJhY3RzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU21hcnRDb250cmFjdHNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGlsZSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IENvbXBpbGUgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge0NvbXBpbGVTbWFydENvbnRyYWN0UmVxdWVzdH0gY29tcGlsZVNtYXJ0Q29udHJhY3RSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjb21waWxlU21hcnRDb250cmFjdChjb21waWxlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNvbXBpbGVTbWFydENvbnRyYWN0KGNvbXBpbGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGRlcGxveSB0aGUgc21hcnQgY29udHJhY3QgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdH0gY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXBsb3lzIGEgc21hcnQgY29udHJhY3QsIGJ5IGJyb2FkY2FzdGluZyB0aGUgdHJhbnNhY3Rpb24gdG8gdGhlIG5ldHdvcmsuXG4gICAgICAgICAqIEBzdW1tYXJ5IERlcGxveSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBicm9hZGNhc3QgdGhlIHRyYW5zYWN0aW9uIGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydENvbnRyYWN0SWQgVGhlIFVVSUQgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IHRvIGJyb2FkY2FzdCB0aGUgdHJhbnNhY3Rpb24gdG8uXG4gICAgICAgICAqIEBwYXJhbSB7RGVwbG95U21hcnRDb250cmFjdFJlcXVlc3R9IGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZXBsb3lTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIHNtYXJ0Q29udHJhY3RJZCwgZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmRlcGxveVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHNwZWNpZmljIHNtYXJ0IGNvbnRyYWN0IGRlcGxveWVkIGJ5IGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIHNwZWNpZmljIHNtYXJ0IGNvbnRyYWN0IGRlcGxveWVkIGJ5IGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzbWFydCBjb250cmFjdCBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydENvbnRyYWN0SWQgVGhlIFVVSUQgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBzbWFydENvbnRyYWN0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldFNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBzbWFydCBjb250cmFjdHNcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBzbWFydCBjb250cmFjdHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBQYWdpbmF0aW9uIHRva2VuIGZvciByZXRyaWV2aW5nIHRoZSBuZXh0IHNldCBvZiByZXN1bHRzXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0U21hcnRDb250cmFjdHMocGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdFNtYXJ0Q29udHJhY3RzKHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtIGEgcmVhZCBvcGVyYXRpb24gb24gYSBzbWFydCBjb250cmFjdCB3aXRob3V0IGNyZWF0aW5nIGEgdHJhbnNhY3Rpb25cbiAgICAgICAgICogQHN1bW1hcnkgUmVhZCBkYXRhIGZyb20gYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtSZWFkQ29udHJhY3RSZXF1ZXN0fSByZWFkQ29udHJhY3RSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZWFkQ29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHJlYWRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnJlYWRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgcmVhZENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyBFVk0gYWRkcmVzcyBvZiB0aGUgc21hcnQgY29udHJhY3QgKDQyIGNoYXJhY3RlcnMsIGluY2x1ZGluZyBcXCYjMzk7MHhcXCYjMzk7LCBpbiBsb3dlcmNhc2UpXG4gICAgICAgICAqIEBwYXJhbSB7UmVnaXN0ZXJTbWFydENvbnRyYWN0UmVxdWVzdH0gW3JlZ2lzdGVyU21hcnRDb250cmFjdFJlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3RlclNtYXJ0Q29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHJlZ2lzdGVyU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnJlZ2lzdGVyU21hcnRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgcmVnaXN0ZXJTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIEVWTSBhZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdCAoNDIgY2hhcmFjdGVycywgaW5jbHVkaW5nIFxcJiMzOTsweFxcJiMzOTssIGluIGxvd2VyY2FzZSlcbiAgICAgICAgICogQHBhcmFtIHtVcGRhdGVTbWFydENvbnRyYWN0UmVxdWVzdH0gW3VwZGF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlU21hcnRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgdXBkYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnVwZGF0ZVNtYXJ0Q29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHVwZGF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUZhY3RvcnkgPSBTbWFydENvbnRyYWN0c0FwaUZhY3Rvcnk7XG4vKipcbiAqIFNtYXJ0Q29udHJhY3RzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFNtYXJ0Q29udHJhY3RzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgU21hcnRDb250cmFjdHNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQ29tcGlsZSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICogQHN1bW1hcnkgQ29tcGlsZSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHtDb21waWxlU21hcnRDb250cmFjdFJlcXVlc3R9IGNvbXBpbGVTbWFydENvbnRyYWN0UmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU21hcnRDb250cmFjdHNBcGlcbiAgICAgKi9cbiAgICBjb21waWxlU21hcnRDb250cmFjdChjb21waWxlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY29tcGlsZVNtYXJ0Q29udHJhY3QoY29tcGlsZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHNtYXJ0IGNvbnRyYWN0XG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHNtYXJ0IGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZGVwbG95IHRoZSBzbWFydCBjb250cmFjdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7Q3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3R9IGNyZWF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTbWFydENvbnRyYWN0c0FwaVxuICAgICAqL1xuICAgIGNyZWF0ZVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlU21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYSBzbWFydCBjb250cmFjdCwgYnkgYnJvYWRjYXN0aW5nIHRoZSB0cmFuc2FjdGlvbiB0byB0aGUgbmV0d29yay5cbiAgICAgKiBAc3VtbWFyeSBEZXBsb3kgYSBzbWFydCBjb250cmFjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGJyb2FkY2FzdCB0aGUgdHJhbnNhY3Rpb24gZnJvbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc21hcnRDb250cmFjdElkIFRoZSBVVUlEIG9mIHRoZSBzbWFydCBjb250cmFjdCB0byBicm9hZGNhc3QgdGhlIHRyYW5zYWN0aW9uIHRvLlxuICAgICAqIEBwYXJhbSB7RGVwbG95U21hcnRDb250cmFjdFJlcXVlc3R9IGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTbWFydENvbnRyYWN0c0FwaVxuICAgICAqL1xuICAgIGRlcGxveVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5kZXBsb3lTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIHNtYXJ0Q29udHJhY3RJZCwgZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzcGVjaWZpYyBzbWFydCBjb250cmFjdCBkZXBsb3llZCBieSBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHNwZWNpZmljIHNtYXJ0IGNvbnRyYWN0IGRlcGxveWVkIGJ5IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgc21hcnQgY29udHJhY3QgZm9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydENvbnRyYWN0SWQgVGhlIFVVSUQgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IHRvIGZldGNoLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU21hcnRDb250cmFjdHNBcGlcbiAgICAgKi9cbiAgICBnZXRTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIHNtYXJ0Q29udHJhY3RJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIHNtYXJ0Q29udHJhY3RJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgc21hcnQgY29udHJhY3RzXG4gICAgICogQHN1bW1hcnkgTGlzdCBzbWFydCBjb250cmFjdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIFBhZ2luYXRpb24gdG9rZW4gZm9yIHJldHJpZXZpbmcgdGhlIG5leHQgc2V0IG9mIHJlc3VsdHNcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNtYXJ0Q29udHJhY3RzQXBpXG4gICAgICovXG4gICAgbGlzdFNtYXJ0Q29udHJhY3RzKHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdFNtYXJ0Q29udHJhY3RzKHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgcmVhZCBvcGVyYXRpb24gb24gYSBzbWFydCBjb250cmFjdCB3aXRob3V0IGNyZWF0aW5nIGEgdHJhbnNhY3Rpb25cbiAgICAgKiBAc3VtbWFyeSBSZWFkIGRhdGEgZnJvbSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge1JlYWRDb250cmFjdFJlcXVlc3R9IHJlYWRDb250cmFjdFJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNtYXJ0Q29udHJhY3RzQXBpXG4gICAgICovXG4gICAgcmVhZENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCByZWFkQ29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnJlYWRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgcmVhZENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgc21hcnQgY29udHJhY3RcbiAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdG8gZmV0Y2guXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyBFVk0gYWRkcmVzcyBvZiB0aGUgc21hcnQgY29udHJhY3QgKDQyIGNoYXJhY3RlcnMsIGluY2x1ZGluZyBcXCYjMzk7MHhcXCYjMzk7LCBpbiBsb3dlcmNhc2UpXG4gICAgICogQHBhcmFtIHtSZWdpc3RlclNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBbcmVnaXN0ZXJTbWFydENvbnRyYWN0UmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNtYXJ0Q29udHJhY3RzQXBpXG4gICAgICovXG4gICAgcmVnaXN0ZXJTbWFydENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCByZWdpc3RlclNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnJlZ2lzdGVyU21hcnRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgcmVnaXN0ZXJTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICogQHN1bW1hcnkgVXBkYXRlIGEgc21hcnQgY29udHJhY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0byBmZXRjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIEVWTSBhZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdCAoNDIgY2hhcmFjdGVycywgaW5jbHVkaW5nIFxcJiMzOTsweFxcJiMzOTssIGluIGxvd2VyY2FzZSlcbiAgICAgKiBAcGFyYW0ge1VwZGF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBbdXBkYXRlU21hcnRDb250cmFjdFJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTbWFydENvbnRyYWN0c0FwaVxuICAgICAqL1xuICAgIHVwZGF0ZVNtYXJ0Q29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHVwZGF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnVwZGF0ZVNtYXJ0Q29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHVwZGF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpID0gU21hcnRDb250cmFjdHNBcGk7XG4vKipcbiAqIFN0YWtlQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ1aWxkIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7QnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdH0gYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYnVpbGRTdGFraW5nT3BlcmF0aW9uOiBhc3luYyAoYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2J1aWxkU3Rha2luZ09wZXJhdGlvbicsICdidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0JywgYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3N0YWtlL2J1aWxkYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGJ1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBmb3IgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgZm9yIHdoaWNoIHRoZSBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXMgYXJlIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBmb3Igd2hpY2ggdGhlIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBhcmUgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0VGltZSBUaGUgc3RhcnQgdGltZSBvZiB0aGlzIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlIHBlcmlvZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZFRpbWUgVGhlIGVuZCB0aW1lIG9mIHRoaXMgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2UgcGVyaW9kLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXM6IGFzeW5jIChuZXR3b3JrSWQsIGFzc2V0SWQsIGFkZHJlc3NJZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhc3NldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoSGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcycsICdhc3NldElkJywgYXNzZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzdGFydFRpbWUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzJywgJ3N0YXJ0VGltZScsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdlbmRUaW1lJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoSGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcycsICdlbmRUaW1lJywgZW5kVGltZSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3N0YWtlL2JhbGFuY2VzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3NldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydhc3NldF9pZCddID0gYXNzZXRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3N0YXJ0X3RpbWUnXSA9IChzdGFydFRpbWUgaW5zdGFuY2VvZiBEYXRlKSA/XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZS50b0lTT1N0cmluZygpIDpcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2VuZF90aW1lJ10gPSAoZW5kVGltZSBpbnN0YW5jZW9mIERhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgZW5kVGltZS50b0lTT1N0cmluZygpIDpcbiAgICAgICAgICAgICAgICAgICAgZW5kVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHN0YWtpbmcgcmV3YXJkcyBmb3IgYSBsaXN0IG9mIGFkZHJlc3Nlc1xuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBzdGFraW5nIHJld2FyZHNcbiAgICAgICAgICogQHBhcmFtIHtGZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdH0gZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDUwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hTdGFraW5nUmV3YXJkczogYXN5bmMgKGZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0LCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaFN0YWtpbmdSZXdhcmRzJywgJ2ZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0JywgZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zdGFrZS9yZXdhcmRzL3NlYXJjaGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb246IGFzeW5jIChuZXR3b3JrSWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24nLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3N0YWtpbmdPcGVyYXRpb25JZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24nLCAnc3Rha2luZ09wZXJhdGlvbklkJywgc3Rha2luZ09wZXJhdGlvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vc3Rha2luZ19vcGVyYXRpb25zL3tzdGFraW5nX29wZXJhdGlvbl9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJzdGFraW5nX29wZXJhdGlvbl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHN0YWtpbmdPcGVyYXRpb25JZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzdGFraW5nIGNvbnRleHQgZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHN0YWtpbmcgY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0ge0dldFN0YWtpbmdDb250ZXh0UmVxdWVzdH0gZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTdGFraW5nQ29udGV4dDogYXN5bmMgKGdldFN0YWtpbmdDb250ZXh0UmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdnZXRTdGFraW5nQ29udGV4dFJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0U3Rha2luZ0NvbnRleHQnLCAnZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0JywgZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc3Rha2UvY29udGV4dGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShnZXRTdGFraW5nQ29udGV4dFJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHZhbGlkYXRvciBiZWxvbmdpbmcgdG8gdGhlIHVzZXIgZm9yIGEgZ2l2ZW4gbmV0d29yaywgYXNzZXQgYW5kIGlkLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSB2YWxpZGF0b3IgYmVsb25naW5nIHRvIHRoZSBDRFAgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBnZXQgdGhlIHZhbGlkYXRvciBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3JJZCBUaGUgdW5pcXVlIGlkIG9mIHRoZSB2YWxpZGF0b3IgdG8gZmV0Y2ggZGV0YWlscyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWxpZGF0b3I6IGFzeW5jIChuZXR3b3JrSWQsIGFzc2V0SWQsIHZhbGlkYXRvcklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRWYWxpZGF0b3InLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Fzc2V0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0VmFsaWRhdG9yJywgJ2Fzc2V0SWQnLCBhc3NldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3ZhbGlkYXRvcklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFZhbGlkYXRvcicsICd2YWxpZGF0b3JJZCcsIHZhbGlkYXRvcklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2Fzc2V0cy97YXNzZXRfaWR9L3ZhbGlkYXRvcnMve3ZhbGlkYXRvcl9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFzc2V0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYXNzZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInZhbGlkYXRvcl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHZhbGlkYXRvcklkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB2YWxpZGF0b3JzIGJlbG9uZ2luZyB0byB0aGUgdXNlciBmb3IgYSBnaXZlbiBuZXR3b3JrIGFuZCBhc3NldC5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB2YWxpZGF0b3JzIGJlbG9uZ2luZyB0byB0aGUgQ0RQIHByb2plY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29yay5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZ2V0IHRoZSB2YWxpZGF0b3JzIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtWYWxpZGF0b3JTdGF0dXN9IFtzdGF0dXNdIEEgZmlsdGVyIHRvIGxpc3QgdmFsaWRhdG9ycyBiYXNlZCBvbiBhIHN0YXR1cy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDUwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFZhbGlkYXRvcnM6IGFzeW5jIChuZXR3b3JrSWQsIGFzc2V0SWQsIHN0YXR1cywgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RWYWxpZGF0b3JzJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhc3NldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RWYWxpZGF0b3JzJywgJ2Fzc2V0SWQnLCBhc3NldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2Fzc2V0cy97YXNzZXRfaWR9L3ZhbGlkYXRvcnNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFzc2V0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYXNzZXRJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3N0YXR1cyddID0gc3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuU3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFN0YWtlQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFN0YWtlQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU3Rha2VBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLlN0YWtlQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWlsZCBhIG5ldyBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBCdWlsZCBhIG5ldyBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0J1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGJ1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGJ1aWxkU3Rha2luZ09wZXJhdGlvbihidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuYnVpbGRTdGFraW5nT3BlcmF0aW9uKGJ1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU3Rha2VBcGkuYnVpbGRTdGFraW5nT3BlcmF0aW9uJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBmb3IgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgZm9yIHdoaWNoIHRoZSBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXMgYXJlIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBmb3Igd2hpY2ggdGhlIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBhcmUgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0VGltZSBUaGUgc3RhcnQgdGltZSBvZiB0aGlzIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlIHBlcmlvZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZFRpbWUgVGhlIGVuZCB0aW1lIG9mIHRoaXMgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2UgcGVyaW9kLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMobmV0d29ya0lkLCBhc3NldElkLCBhZGRyZXNzSWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMobmV0d29ya0lkLCBhc3NldElkLCBhZGRyZXNzSWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU3Rha2VBcGkuZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHN0YWtpbmcgcmV3YXJkcyBmb3IgYSBsaXN0IG9mIGFkZHJlc3Nlc1xuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBzdGFraW5nIHJld2FyZHNcbiAgICAgICAgICogQHBhcmFtIHtGZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdH0gZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDUwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hTdGFraW5nUmV3YXJkcyhmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFN0YWtpbmdSZXdhcmRzKGZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0LCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTdGFrZUFwaS5mZXRjaFN0YWtpbmdSZXdhcmRzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1N0YWtlQXBpLmdldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgc3Rha2luZyBjb250ZXh0IGZvciBhbiBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBzdGFraW5nIGNvbnRleHRcbiAgICAgICAgICogQHBhcmFtIHtHZXRTdGFraW5nQ29udGV4dFJlcXVlc3R9IGdldFN0YWtpbmdDb250ZXh0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0U3Rha2luZ0NvbnRleHQoZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0U3Rha2luZ0NvbnRleHQoZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1N0YWtlQXBpLmdldFN0YWtpbmdDb250ZXh0J10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHZhbGlkYXRvciBiZWxvbmdpbmcgdG8gdGhlIHVzZXIgZm9yIGEgZ2l2ZW4gbmV0d29yaywgYXNzZXQgYW5kIGlkLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSB2YWxpZGF0b3IgYmVsb25naW5nIHRvIHRoZSBDRFAgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBnZXQgdGhlIHZhbGlkYXRvciBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3JJZCBUaGUgdW5pcXVlIGlkIG9mIHRoZSB2YWxpZGF0b3IgdG8gZmV0Y2ggZGV0YWlscyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRWYWxpZGF0b3IobmV0d29ya0lkLCBhc3NldElkLCB2YWxpZGF0b3JJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldFZhbGlkYXRvcihuZXR3b3JrSWQsIGFzc2V0SWQsIHZhbGlkYXRvcklkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1N0YWtlQXBpLmdldFZhbGlkYXRvciddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHZhbGlkYXRvcnMgYmVsb25naW5nIHRvIHRoZSB1c2VyIGZvciBhIGdpdmVuIG5ldHdvcmsgYW5kIGFzc2V0LlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHZhbGlkYXRvcnMgYmVsb25naW5nIHRvIHRoZSBDRFAgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBnZXQgdGhlIHZhbGlkYXRvcnMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge1ZhbGlkYXRvclN0YXR1c30gW3N0YXR1c10gQSBmaWx0ZXIgdG8gbGlzdCB2YWxpZGF0b3JzIGJhc2VkIG9uIGEgc3RhdHVzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0VmFsaWRhdG9ycyhuZXR3b3JrSWQsIGFzc2V0SWQsIHN0YXR1cywgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0VmFsaWRhdG9ycyhuZXR3b3JrSWQsIGFzc2V0SWQsIHN0YXR1cywgbGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU3Rha2VBcGkubGlzdFZhbGlkYXRvcnMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TdGFrZUFwaUZwID0gU3Rha2VBcGlGcDtcbi8qKlxuICogU3Rha2VBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBTdGFrZUFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLlN0YWtlQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWlsZCBhIG5ldyBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBCdWlsZCBhIG5ldyBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0J1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGJ1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGJ1aWxkU3Rha2luZ09wZXJhdGlvbihidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5idWlsZFN0YWtpbmdPcGVyYXRpb24oYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBmb3IgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgZm9yIHdoaWNoIHRoZSBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXMgYXJlIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBmb3Igd2hpY2ggdGhlIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBhcmUgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0VGltZSBUaGUgc3RhcnQgdGltZSBvZiB0aGlzIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlIHBlcmlvZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZFRpbWUgVGhlIGVuZCB0aW1lIG9mIHRoaXMgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2UgcGVyaW9kLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMobmV0d29ya0lkLCBhc3NldElkLCBhZGRyZXNzSWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoSGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcyhuZXR3b3JrSWQsIGFzc2V0SWQsIGFkZHJlc3NJZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHN0YWtpbmcgcmV3YXJkcyBmb3IgYSBsaXN0IG9mIGFkZHJlc3Nlc1xuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBzdGFraW5nIHJld2FyZHNcbiAgICAgICAgICogQHBhcmFtIHtGZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdH0gZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDUwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hTdGFraW5nUmV3YXJkcyhmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoU3Rha2luZ1Jld2FyZHMoZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3QsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ09wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzdGFraW5nIGNvbnRleHQgZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHN0YWtpbmcgY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0ge0dldFN0YWtpbmdDb250ZXh0UmVxdWVzdH0gZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTdGFraW5nQ29udGV4dChnZXRTdGFraW5nQ29udGV4dFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldFN0YWtpbmdDb250ZXh0KGdldFN0YWtpbmdDb250ZXh0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHZhbGlkYXRvciBiZWxvbmdpbmcgdG8gdGhlIHVzZXIgZm9yIGEgZ2l2ZW4gbmV0d29yaywgYXNzZXQgYW5kIGlkLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSB2YWxpZGF0b3IgYmVsb25naW5nIHRvIHRoZSBDRFAgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBnZXQgdGhlIHZhbGlkYXRvciBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3JJZCBUaGUgdW5pcXVlIGlkIG9mIHRoZSB2YWxpZGF0b3IgdG8gZmV0Y2ggZGV0YWlscyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWxpZGF0b3IobmV0d29ya0lkLCBhc3NldElkLCB2YWxpZGF0b3JJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0VmFsaWRhdG9yKG5ldHdvcmtJZCwgYXNzZXRJZCwgdmFsaWRhdG9ySWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHZhbGlkYXRvcnMgYmVsb25naW5nIHRvIHRoZSB1c2VyIGZvciBhIGdpdmVuIG5ldHdvcmsgYW5kIGFzc2V0LlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHZhbGlkYXRvcnMgYmVsb25naW5nIHRvIHRoZSBDRFAgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBnZXQgdGhlIHZhbGlkYXRvcnMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge1ZhbGlkYXRvclN0YXR1c30gW3N0YXR1c10gQSBmaWx0ZXIgdG8gbGlzdCB2YWxpZGF0b3JzIGJhc2VkIG9uIGEgc3RhdHVzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0VmFsaWRhdG9ycyhuZXR3b3JrSWQsIGFzc2V0SWQsIHN0YXR1cywgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RWYWxpZGF0b3JzKG5ldHdvcmtJZCwgYXNzZXRJZCwgc3RhdHVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuU3Rha2VBcGlGYWN0b3J5ID0gU3Rha2VBcGlGYWN0b3J5O1xuLyoqXG4gKiBTdGFrZUFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBTdGFrZUFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIFN0YWtlQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEJ1aWxkIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICogQHN1bW1hcnkgQnVpbGQgYSBuZXcgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0ge0J1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGJ1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFN0YWtlQXBpXG4gICAgICovXG4gICAgYnVpbGRTdGFraW5nT3BlcmF0aW9uKGJ1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlN0YWtlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuYnVpbGRTdGFraW5nT3BlcmF0aW9uKGJ1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXMgZm9yIGdpdmVuIGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29yay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgSUQgb2YgdGhlIGFzc2V0IGZvciB3aGljaCB0aGUgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzIGFyZSBiZWluZyBmZXRjaGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBmb3Igd2hpY2ggdGhlIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBhcmUgYmVpbmcgZmV0Y2hlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRUaW1lIFRoZSBzdGFydCB0aW1lIG9mIHRoaXMgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2UgcGVyaW9kLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRUaW1lIFRoZSBlbmQgdGltZSBvZiB0aGlzIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlIHBlcmlvZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFN0YWtlQXBpXG4gICAgICovXG4gICAgZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzKG5ldHdvcmtJZCwgYXNzZXRJZCwgYWRkcmVzc0lkLCBzdGFydFRpbWUsIGVuZFRpbWUsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TdGFrZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoSGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcyhuZXR3b3JrSWQsIGFzc2V0SWQsIGFkZHJlc3NJZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIHN0YWtpbmcgcmV3YXJkcyBmb3IgYSBsaXN0IG9mIGFkZHJlc3Nlc1xuICAgICAqIEBzdW1tYXJ5IEZldGNoIHN0YWtpbmcgcmV3YXJkc1xuICAgICAqIEBwYXJhbSB7RmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3R9IGZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDUwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTdGFrZUFwaVxuICAgICAqL1xuICAgIGZldGNoU3Rha2luZ1Jld2FyZHMoZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3QsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TdGFrZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoU3Rha2luZ1Jld2FyZHMoZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3QsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFraW5nT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU3Rha2VBcGlcbiAgICAgKi9cbiAgICBnZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU3Rha2VBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzdGFraW5nIGNvbnRleHQgZm9yIGFuIGFkZHJlc3NcbiAgICAgKiBAc3VtbWFyeSBHZXQgc3Rha2luZyBjb250ZXh0XG4gICAgICogQHBhcmFtIHtHZXRTdGFraW5nQ29udGV4dFJlcXVlc3R9IGdldFN0YWtpbmdDb250ZXh0UmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU3Rha2VBcGlcbiAgICAgKi9cbiAgICBnZXRTdGFraW5nQ29udGV4dChnZXRTdGFraW5nQ29udGV4dFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlN0YWtlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0U3Rha2luZ0NvbnRleHQoZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgdmFsaWRhdG9yIGJlbG9uZ2luZyB0byB0aGUgdXNlciBmb3IgYSBnaXZlbiBuZXR3b3JrLCBhc3NldCBhbmQgaWQuXG4gICAgICogQHN1bW1hcnkgR2V0IGEgdmFsaWRhdG9yIGJlbG9uZ2luZyB0byB0aGUgQ0RQIHByb2plY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGdldCB0aGUgdmFsaWRhdG9yIGZvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsaWRhdG9ySWQgVGhlIHVuaXF1ZSBpZCBvZiB0aGUgdmFsaWRhdG9yIHRvIGZldGNoIGRldGFpbHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU3Rha2VBcGlcbiAgICAgKi9cbiAgICBnZXRWYWxpZGF0b3IobmV0d29ya0lkLCBhc3NldElkLCB2YWxpZGF0b3JJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU3Rha2VBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRWYWxpZGF0b3IobmV0d29ya0lkLCBhc3NldElkLCB2YWxpZGF0b3JJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgdmFsaWRhdG9ycyBiZWxvbmdpbmcgdG8gdGhlIHVzZXIgZm9yIGEgZ2l2ZW4gbmV0d29yayBhbmQgYXNzZXQuXG4gICAgICogQHN1bW1hcnkgTGlzdCB2YWxpZGF0b3JzIGJlbG9uZ2luZyB0byB0aGUgQ0RQIHByb2plY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGdldCB0aGUgdmFsaWRhdG9ycyBmb3IuXG4gICAgICogQHBhcmFtIHtWYWxpZGF0b3JTdGF0dXN9IFtzdGF0dXNdIEEgZmlsdGVyIHRvIGxpc3QgdmFsaWRhdG9ycyBiYXNlZCBvbiBhIHN0YXR1cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFN0YWtlQXBpXG4gICAgICovXG4gICAgbGlzdFZhbGlkYXRvcnMobmV0d29ya0lkLCBhc3NldElkLCBzdGF0dXMsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TdGFrZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RWYWxpZGF0b3JzKG5ldHdvcmtJZCwgYXNzZXRJZCwgc3RhdHVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdGFrZUFwaSA9IFN0YWtlQXBpO1xuLyoqXG4gKiBUcmFkZXNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBUcmFkZXNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIHRyYWRlXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIHRyYWRlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFkZSBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFkZUlkIFRoZSBJRCBvZiB0aGUgdHJhZGUgdG8gYnJvYWRjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0VHJhZGVSZXF1ZXN0fSBicm9hZGNhc3RUcmFkZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGJyb2FkY2FzdFRyYWRlOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgYnJvYWRjYXN0VHJhZGVSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFRyYWRlJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFRyYWRlJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0cmFkZUlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFRyYWRlJywgJ3RyYWRlSWQnLCB0cmFkZUlkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Jyb2FkY2FzdFRyYWRlUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RUcmFkZScsICdicm9hZGNhc3RUcmFkZVJlcXVlc3QnLCBicm9hZGNhc3RUcmFkZVJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vdHJhZGVzL3t0cmFkZV9pZH0vYnJvYWRjYXN0YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInRyYWRlX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodHJhZGVJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShicm9hZGNhc3RUcmFkZVJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB0cmFkZVxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgdHJhZGUgZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGNvbmR1Y3QgdGhlIHRyYWRlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVUcmFkZVJlcXVlc3R9IGNyZWF0ZVRyYWRlUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlVHJhZGU6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFkZVJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlVHJhZGUnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlVHJhZGUnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZVRyYWRlUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVUcmFkZScsICdjcmVhdGVUcmFkZVJlcXVlc3QnLCBjcmVhdGVUcmFkZVJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vdHJhZGVzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVUcmFkZVJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHRyYWRlIGJ5IElEXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIHRyYWRlIGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFkZSBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFkZUlkIFRoZSBJRCBvZiB0aGUgdHJhZGUgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRyYWRlOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRUcmFkZScsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRUcmFkZScsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndHJhZGVJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRUcmFkZScsICd0cmFkZUlkJywgdHJhZGVJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS90cmFkZXMve3RyYWRlX2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ0cmFkZV9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHRyYWRlSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHRyYWRlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB0cmFkZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgdHJhZGVzIGZvclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0VHJhZGVzOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdFRyYWRlcycsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0VHJhZGVzJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS90cmFkZXNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVHJhZGVzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBUcmFkZXNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogVHJhZGVzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVHJhZGVzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5UcmFkZXNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIHRyYWRlXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIHRyYWRlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFkZSBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFkZUlkIFRoZSBJRCBvZiB0aGUgdHJhZGUgdG8gYnJvYWRjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0VHJhZGVSZXF1ZXN0fSBicm9hZGNhc3RUcmFkZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGJyb2FkY2FzdFRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYWRlSWQsIGJyb2FkY2FzdFRyYWRlUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmJyb2FkY2FzdFRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYWRlSWQsIGJyb2FkY2FzdFRyYWRlUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydUcmFkZXNBcGkuYnJvYWRjYXN0VHJhZGUnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHRyYWRlXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB0cmFkZSBmb3IgYW4gYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIHNvdXJjZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gY29uZHVjdCB0aGUgdHJhZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVRyYWRlUmVxdWVzdH0gY3JlYXRlVHJhZGVSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBjcmVhdGVUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFkZVJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFkZVJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVHJhZGVzQXBpLmNyZWF0ZVRyYWRlJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHRyYWRlIGJ5IElEXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIHRyYWRlIGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFkZSBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFkZUlkIFRoZSBJRCBvZiB0aGUgdHJhZGUgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldFRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYWRlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1RyYWRlc0FwaS5nZXRUcmFkZSddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHRyYWRlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB0cmFkZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgdHJhZGVzIGZvclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0VHJhZGVzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdFRyYWRlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydUcmFkZXNBcGkubGlzdFRyYWRlcyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlRyYWRlc0FwaUZwID0gVHJhZGVzQXBpRnA7XG4vKipcbiAqIFRyYWRlc0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYWRlc0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLlRyYWRlc0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGEgdHJhZGVcbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgdHJhZGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYWRlIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWRlSWQgVGhlIElEIG9mIHRoZSB0cmFkZSB0byBicm9hZGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RUcmFkZVJlcXVlc3R9IGJyb2FkY2FzdFRyYWRlUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYnJvYWRjYXN0VHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgYnJvYWRjYXN0VHJhZGVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5icm9hZGNhc3RUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBicm9hZGNhc3RUcmFkZVJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgdHJhZGVcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHRyYWRlIGZvciBhbiBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgc291cmNlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBjb25kdWN0IHRoZSB0cmFkZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlVHJhZGVSZXF1ZXN0fSBjcmVhdGVUcmFkZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYWRlUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlVHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlVHJhZGVSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgdHJhZGUgYnkgSURcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgdHJhZGUgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYWRlIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWRlSWQgVGhlIElEIG9mIHRoZSB0cmFkZSB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0VHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdHJhZGVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHRyYWRlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCB0cmFkZXMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RUcmFkZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RUcmFkZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlRyYWRlc0FwaUZhY3RvcnkgPSBUcmFkZXNBcGlGYWN0b3J5O1xuLyoqXG4gKiBUcmFkZXNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgVHJhZGVzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgVHJhZGVzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdCBhIHRyYWRlXG4gICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgdHJhZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFkZSBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWRlSWQgVGhlIElEIG9mIHRoZSB0cmFkZSB0byBicm9hZGNhc3RcbiAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdFRyYWRlUmVxdWVzdH0gYnJvYWRjYXN0VHJhZGVSZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBUcmFkZXNBcGlcbiAgICAgKi9cbiAgICBicm9hZGNhc3RUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBicm9hZGNhc3RUcmFkZVJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlRyYWRlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmJyb2FkY2FzdFRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYWRlSWQsIGJyb2FkY2FzdFRyYWRlUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0cmFkZVxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB0cmFkZSBmb3IgYW4gYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgc291cmNlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGNvbmR1Y3QgdGhlIHRyYWRlIGZyb21cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZVRyYWRlUmVxdWVzdH0gY3JlYXRlVHJhZGVSZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBUcmFkZXNBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFkZVJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlRyYWRlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZVRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYWRlUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHRyYWRlIGJ5IElEXG4gICAgICogQHN1bW1hcnkgR2V0IGEgdHJhZGUgYnkgSURcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFkZSBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWRlSWQgVGhlIElEIG9mIHRoZSB0cmFkZSB0byBmZXRjaFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgVHJhZGVzQXBpXG4gICAgICovXG4gICAgZ2V0VHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVHJhZGVzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0VHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgdHJhZGVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgdHJhZGVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCB0cmFkZXMgZm9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBUcmFkZXNBcGlcbiAgICAgKi9cbiAgICBsaXN0VHJhZGVzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5UcmFkZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0VHJhZGVzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlRyYWRlc0FwaSA9IFRyYWRlc0FwaTtcbi8qKlxuICogVHJhbnNhY3Rpb25IaXN0b3J5QXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVHJhbnNhY3Rpb25IaXN0b3J5QXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGFsbCB0cmFuc2FjdGlvbnMgdGhhdCBpbnRlcmFjdCB3aXRoIHRoZSBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHRyYW5zYWN0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgdHJhbnNhY3Rpb25zIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEFkZHJlc3NUcmFuc2FjdGlvbnM6IGFzeW5jIChuZXR3b3JrSWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RBZGRyZXNzVHJhbnNhY3Rpb25zJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEFkZHJlc3NUcmFuc2FjdGlvbnMnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vdHJhbnNhY3Rpb25zYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVHJhbnNhY3Rpb25IaXN0b3J5QXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBUcmFuc2FjdGlvbkhpc3RvcnlBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogVHJhbnNhY3Rpb25IaXN0b3J5QXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVHJhbnNhY3Rpb25IaXN0b3J5QXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5UcmFuc2FjdGlvbkhpc3RvcnlBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIHRyYW5zYWN0aW9ucyB0aGF0IGludGVyYWN0IHdpdGggdGhlIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgdHJhbnNhY3Rpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSB0cmFuc2FjdGlvbnMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0QWRkcmVzc1RyYW5zYWN0aW9ucyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0QWRkcmVzc1RyYW5zYWN0aW9ucyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVHJhbnNhY3Rpb25IaXN0b3J5QXBpLmxpc3RBZGRyZXNzVHJhbnNhY3Rpb25zJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVHJhbnNhY3Rpb25IaXN0b3J5QXBpRnAgPSBUcmFuc2FjdGlvbkhpc3RvcnlBcGlGcDtcbi8qKlxuICogVHJhbnNhY3Rpb25IaXN0b3J5QXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVHJhbnNhY3Rpb25IaXN0b3J5QXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuVHJhbnNhY3Rpb25IaXN0b3J5QXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGFsbCB0cmFuc2FjdGlvbnMgdGhhdCBpbnRlcmFjdCB3aXRoIHRoZSBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHRyYW5zYWN0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgdHJhbnNhY3Rpb25zIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEFkZHJlc3NUcmFuc2FjdGlvbnMobmV0d29ya0lkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0QWRkcmVzc1RyYW5zYWN0aW9ucyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlRyYW5zYWN0aW9uSGlzdG9yeUFwaUZhY3RvcnkgPSBUcmFuc2FjdGlvbkhpc3RvcnlBcGlGYWN0b3J5O1xuLyoqXG4gKiBUcmFuc2FjdGlvbkhpc3RvcnlBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25IaXN0b3J5QXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb25IaXN0b3J5QXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIHRyYW5zYWN0aW9ucyB0aGF0IGludGVyYWN0IHdpdGggdGhlIGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgTGlzdCB0cmFuc2FjdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSB0cmFuc2FjdGlvbnMgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgVHJhbnNhY3Rpb25IaXN0b3J5QXBpXG4gICAgICovXG4gICAgbGlzdEFkZHJlc3NUcmFuc2FjdGlvbnMobmV0d29ya0lkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5UcmFuc2FjdGlvbkhpc3RvcnlBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0QWRkcmVzc1RyYW5zYWN0aW9ucyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhbnNhY3Rpb25IaXN0b3J5QXBpID0gVHJhbnNhY3Rpb25IaXN0b3J5QXBpO1xuLyoqXG4gKiBUcmFuc2ZlcnNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBUcmFuc2ZlcnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIHRyYW5zZmVyXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIHRyYW5zZmVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFuc2ZlciBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2ZlcklkIFRoZSBJRCBvZiB0aGUgdHJhbnNmZXIgdG8gYnJvYWRjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0fSBicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGJyb2FkY2FzdFRyYW5zZmVyOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFRyYW5zZmVyJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFRyYW5zZmVyJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0cmFuc2ZlcklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFRyYW5zZmVyJywgJ3RyYW5zZmVySWQnLCB0cmFuc2ZlcklkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Jyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RUcmFuc2ZlcicsICdicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3QnLCBicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vdHJhbnNmZXJzL3t0cmFuc2Zlcl9pZH0vYnJvYWRjYXN0YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInRyYW5zZmVyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodHJhbnNmZXJJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB0cmFuc2ZlclxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgdHJhbnNmZXIgZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIHRyYW5zZmVyIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVUcmFuc2ZlclJlcXVlc3R9IGNyZWF0ZVRyYW5zZmVyUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlVHJhbnNmZXI6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlVHJhbnNmZXInLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlVHJhbnNmZXInLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZVRyYW5zZmVyUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVUcmFuc2ZlcicsICdjcmVhdGVUcmFuc2ZlclJlcXVlc3QnLCBjcmVhdGVUcmFuc2ZlclJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vdHJhbnNmZXJzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVUcmFuc2ZlclJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHRyYW5zZmVyIGJ5IElEXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIHRyYW5zZmVyIGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFuc2ZlciBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2ZlcklkIFRoZSBJRCBvZiB0aGUgdHJhbnNmZXIgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRyYW5zZmVyOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRUcmFuc2ZlcicsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRUcmFuc2ZlcicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndHJhbnNmZXJJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRUcmFuc2ZlcicsICd0cmFuc2ZlcklkJywgdHJhbnNmZXJJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS90cmFuc2ZlcnMve3RyYW5zZmVyX2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ0cmFuc2Zlcl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHRyYW5zZmVySWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHRyYW5zZmVycyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB0cmFuc2ZlcnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgdHJhbnNmZXJzIGZvclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0VHJhbnNmZXJzOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdFRyYW5zZmVycycsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0VHJhbnNmZXJzJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS90cmFuc2ZlcnNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVHJhbnNmZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBUcmFuc2ZlcnNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogVHJhbnNmZXJzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVHJhbnNmZXJzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5UcmFuc2ZlcnNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIHRyYW5zZmVyXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIHRyYW5zZmVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFuc2ZlciBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2ZlcklkIFRoZSBJRCBvZiB0aGUgdHJhbnNmZXIgdG8gYnJvYWRjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0fSBicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGJyb2FkY2FzdFRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmJyb2FkY2FzdFRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydUcmFuc2ZlcnNBcGkuYnJvYWRjYXN0VHJhbnNmZXInXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHRyYW5zZmVyXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB0cmFuc2ZlciBmb3IgYW4gYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIHNvdXJjZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gdHJhbnNmZXIgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVRyYW5zZmVyUmVxdWVzdH0gY3JlYXRlVHJhbnNmZXJSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBjcmVhdGVUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVHJhbnNmZXJzQXBpLmNyZWF0ZVRyYW5zZmVyJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHRyYW5zZmVyIGJ5IElEXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIHRyYW5zZmVyIGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFuc2ZlciBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2ZlcklkIFRoZSBJRCBvZiB0aGUgdHJhbnNmZXIgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldFRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1RyYW5zZmVyc0FwaS5nZXRUcmFuc2ZlciddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHRyYW5zZmVycyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB0cmFuc2ZlcnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgdHJhbnNmZXJzIGZvclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0VHJhbnNmZXJzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdFRyYW5zZmVycyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydUcmFuc2ZlcnNBcGkubGlzdFRyYW5zZmVycyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlRyYW5zZmVyc0FwaUZwID0gVHJhbnNmZXJzQXBpRnA7XG4vKipcbiAqIFRyYW5zZmVyc0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zZmVyc0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLlRyYW5zZmVyc0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGEgdHJhbnNmZXJcbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgdHJhbnNmZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBicm9hZGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RUcmFuc2ZlclJlcXVlc3R9IGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYnJvYWRjYXN0VHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5icm9hZGNhc3RUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNmZXJcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHRyYW5zZmVyIGZvciBhbiBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgc291cmNlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byB0cmFuc2ZlciBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlVHJhbnNmZXJSZXF1ZXN0fSBjcmVhdGVUcmFuc2ZlclJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlVHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlVHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgdHJhbnNmZXIgYnkgSURcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgdHJhbnNmZXIgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0VHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdHJhbnNmZXJzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHRyYW5zZmVycyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCB0cmFuc2ZlcnMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RUcmFuc2ZlcnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RUcmFuc2ZlcnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlRyYW5zZmVyc0FwaUZhY3RvcnkgPSBUcmFuc2ZlcnNBcGlGYWN0b3J5O1xuLyoqXG4gKiBUcmFuc2ZlcnNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgVHJhbnNmZXJzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgVHJhbnNmZXJzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdCBhIHRyYW5zZmVyXG4gICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgdHJhbnNmZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFuc2ZlciBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBicm9hZGNhc3RcbiAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdH0gYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBUcmFuc2ZlcnNBcGlcbiAgICAgKi9cbiAgICBicm9hZGNhc3RUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlRyYW5zZmVyc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmJyb2FkY2FzdFRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0cmFuc2ZlclxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB0cmFuc2ZlciBmb3IgYW4gYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgc291cmNlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIHRyYW5zZmVyIGZyb21cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZVRyYW5zZmVyUmVxdWVzdH0gY3JlYXRlVHJhbnNmZXJSZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBUcmFuc2ZlcnNBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlRyYW5zZmVyc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZVRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHRyYW5zZmVyIGJ5IElEXG4gICAgICogQHN1bW1hcnkgR2V0IGEgdHJhbnNmZXIgYnkgSURcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFuc2ZlciBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBmZXRjaFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgVHJhbnNmZXJzQXBpXG4gICAgICovXG4gICAgZ2V0VHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVHJhbnNmZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0VHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgdHJhbnNmZXJzIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgdHJhbnNmZXJzIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCB0cmFuc2ZlcnMgZm9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBUcmFuc2ZlcnNBcGlcbiAgICAgKi9cbiAgICBsaXN0VHJhbnNmZXJzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5UcmFuc2ZlcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0VHJhbnNmZXJzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zZmVyc0FwaSA9IFRyYW5zZmVyc0FwaTtcbi8qKlxuICogVXNlcnNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBVc2Vyc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGN1cnJlbnQgdXNlclxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgY3VycmVudCB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDdXJyZW50VXNlcjogYXN5bmMgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS91c2Vycy9tZWA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlVzZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBVc2Vyc0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBVc2Vyc0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVzZXJzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5Vc2Vyc0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGN1cnJlbnQgdXNlclxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgY3VycmVudCB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRDdXJyZW50VXNlcihvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0Q3VycmVudFVzZXIob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydVc2Vyc0FwaS5nZXRDdXJyZW50VXNlciddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlVzZXJzQXBpRnAgPSBVc2Vyc0FwaUZwO1xuLyoqXG4gKiBVc2Vyc0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVzZXJzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuVXNlcnNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjdXJyZW50IHVzZXJcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGN1cnJlbnQgdXNlclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q3VycmVudFVzZXIob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0Q3VycmVudFVzZXIob3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVXNlcnNBcGlGYWN0b3J5ID0gVXNlcnNBcGlGYWN0b3J5O1xuLyoqXG4gKiBVc2Vyc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBVc2Vyc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIFVzZXJzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IHVzZXJcbiAgICAgKiBAc3VtbWFyeSBHZXQgY3VycmVudCB1c2VyXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBVc2Vyc0FwaVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRVc2VyKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlVzZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0Q3VycmVudFVzZXIob3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Vc2Vyc0FwaSA9IFVzZXJzQXBpO1xuLyoqXG4gKiBXYWxsZXRzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgV2FsbGV0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHdhbGxldCBzY29wZWQgdG8gdGhlIHVzZXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB3YWxsZXRcbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVXYWxsZXRSZXF1ZXN0fSBbY3JlYXRlV2FsbGV0UmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVdhbGxldDogYXN5bmMgKGNyZWF0ZVdhbGxldFJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVXYWxsZXRSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgd2FsbGV0XG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB3YWxsZXQgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRXYWxsZXQ6IGFzeW5jICh3YWxsZXRJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRXYWxsZXQnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFnZ3JlZ2F0ZWQgYmFsYW5jZSBvZiBhbiBhc3NldCBhY3Jvc3MgYWxsIG9mIHRoZSBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldC5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIHRoZSB3YWxsZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFdhbGxldEJhbGFuY2U6IGFzeW5jICh3YWxsZXRJZCwgYXNzZXRJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRXYWxsZXRCYWxhbmNlJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYXNzZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRXYWxsZXRCYWxhbmNlJywgJ2Fzc2V0SWQnLCBhc3NldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9iYWxhbmNlcy97YXNzZXRfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYXNzZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhc3NldElkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB0aGUgYmFsYW5jZXMgb2YgYWxsIG9mIHRoZSBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldCBhZ2dyZWdhdGVkIGJ5IGFzc2V0LlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHdhbGxldCBiYWxhbmNlc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2VzIGZvclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFdhbGxldEJhbGFuY2VzOiBhc3luYyAod2FsbGV0SWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdFdhbGxldEJhbGFuY2VzJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2JhbGFuY2VzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB3YWxsZXRzIGJlbG9uZ2luZyB0byB0aGUgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB3YWxsZXRzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RXYWxsZXRzOiBhc3luYyAobGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLldhbGxldHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFdhbGxldHNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogV2FsbGV0c0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFdhbGxldHNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLldhbGxldHNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB3YWxsZXQgc2NvcGVkIHRvIHRoZSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgd2FsbGV0XG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlV2FsbGV0UmVxdWVzdH0gW2NyZWF0ZVdhbGxldFJlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBjcmVhdGVXYWxsZXQoY3JlYXRlV2FsbGV0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVdhbGxldChjcmVhdGVXYWxsZXRSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1dhbGxldHNBcGkuY3JlYXRlV2FsbGV0J10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB3YWxsZXRcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHdhbGxldCBieSBJRFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldFdhbGxldCh3YWxsZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldFdhbGxldCh3YWxsZXRJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydXYWxsZXRzQXBpLmdldFdhbGxldCddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFnZ3JlZ2F0ZWQgYmFsYW5jZSBvZiBhbiBhc3NldCBhY3Jvc3MgYWxsIG9mIHRoZSBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldC5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIHRoZSB3YWxsZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldFdhbGxldEJhbGFuY2Uod2FsbGV0SWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRXYWxsZXRCYWxhbmNlKHdhbGxldElkLCBhc3NldElkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1dhbGxldHNBcGkuZ2V0V2FsbGV0QmFsYW5jZSddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHRoZSBiYWxhbmNlcyBvZiBhbGwgb2YgdGhlIGFkZHJlc3NlcyBpbiB0aGUgd2FsbGV0IGFnZ3JlZ2F0ZWQgYnkgYXNzZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgd2FsbGV0IGJhbGFuY2VzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZXMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0V2FsbGV0QmFsYW5jZXMod2FsbGV0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0V2FsbGV0QmFsYW5jZXMod2FsbGV0SWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2FsbGV0c0FwaS5saXN0V2FsbGV0QmFsYW5jZXMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB3YWxsZXRzIGJlbG9uZ2luZyB0byB0aGUgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB3YWxsZXRzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RXYWxsZXRzKGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdFdhbGxldHMobGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2FsbGV0c0FwaS5saXN0V2FsbGV0cyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLldhbGxldHNBcGlGcCA9IFdhbGxldHNBcGlGcDtcbi8qKlxuICogV2FsbGV0c0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFdhbGxldHNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5XYWxsZXRzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgd2FsbGV0IHNjb3BlZCB0byB0aGUgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHdhbGxldFxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVdhbGxldFJlcXVlc3R9IFtjcmVhdGVXYWxsZXRSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlV2FsbGV0KGNyZWF0ZVdhbGxldFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZVdhbGxldChjcmVhdGVXYWxsZXRSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHdhbGxldFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgd2FsbGV0IGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2FsbGV0KHdhbGxldElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRXYWxsZXQod2FsbGV0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFnZ3JlZ2F0ZWQgYmFsYW5jZSBvZiBhbiBhc3NldCBhY3Jvc3MgYWxsIG9mIHRoZSBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldC5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIHRoZSB3YWxsZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFdhbGxldEJhbGFuY2Uod2FsbGV0SWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldFdhbGxldEJhbGFuY2Uod2FsbGV0SWQsIGFzc2V0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHRoZSBiYWxhbmNlcyBvZiBhbGwgb2YgdGhlIGFkZHJlc3NlcyBpbiB0aGUgd2FsbGV0IGFnZ3JlZ2F0ZWQgYnkgYXNzZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgd2FsbGV0IGJhbGFuY2VzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZXMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0V2FsbGV0QmFsYW5jZXMod2FsbGV0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RXYWxsZXRCYWxhbmNlcyh3YWxsZXRJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgd2FsbGV0cyBiZWxvbmdpbmcgdG8gdGhlIHVzZXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgd2FsbGV0c1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0V2FsbGV0cyhsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdFdhbGxldHMobGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLldhbGxldHNBcGlGYWN0b3J5ID0gV2FsbGV0c0FwaUZhY3Rvcnk7XG4vKipcbiAqIFdhbGxldHNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgV2FsbGV0c0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIFdhbGxldHNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHdhbGxldCBzY29wZWQgdG8gdGhlIHVzZXIuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHdhbGxldFxuICAgICAqIEBwYXJhbSB7Q3JlYXRlV2FsbGV0UmVxdWVzdH0gW2NyZWF0ZVdhbGxldFJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXYWxsZXRzQXBpXG4gICAgICovXG4gICAgY3JlYXRlV2FsbGV0KGNyZWF0ZVdhbGxldFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLldhbGxldHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVXYWxsZXQoY3JlYXRlV2FsbGV0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB3YWxsZXRcbiAgICAgKiBAc3VtbWFyeSBHZXQgd2FsbGV0IGJ5IElEXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXYWxsZXRzQXBpXG4gICAgICovXG4gICAgZ2V0V2FsbGV0KHdhbGxldElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5XYWxsZXRzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0V2FsbGV0KHdhbGxldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhZ2dyZWdhdGVkIGJhbGFuY2Ugb2YgYW4gYXNzZXQgYWNyb3NzIGFsbCBvZiB0aGUgYWRkcmVzc2VzIGluIHRoZSB3YWxsZXQuXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIHRoZSB3YWxsZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXYWxsZXRzQXBpXG4gICAgICovXG4gICAgZ2V0V2FsbGV0QmFsYW5jZSh3YWxsZXRJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuV2FsbGV0c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldFdhbGxldEJhbGFuY2Uod2FsbGV0SWQsIGFzc2V0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHRoZSBiYWxhbmNlcyBvZiBhbGwgb2YgdGhlIGFkZHJlc3NlcyBpbiB0aGUgd2FsbGV0IGFnZ3JlZ2F0ZWQgYnkgYXNzZXQuXG4gICAgICogQHN1bW1hcnkgTGlzdCB3YWxsZXQgYmFsYW5jZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2VzIGZvclxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgV2FsbGV0c0FwaVxuICAgICAqL1xuICAgIGxpc3RXYWxsZXRCYWxhbmNlcyh3YWxsZXRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuV2FsbGV0c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RXYWxsZXRCYWxhbmNlcyh3YWxsZXRJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgd2FsbGV0cyBiZWxvbmdpbmcgdG8gdGhlIHVzZXIuXG4gICAgICogQHN1bW1hcnkgTGlzdCB3YWxsZXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXYWxsZXRzQXBpXG4gICAgICovXG4gICAgbGlzdFdhbGxldHMobGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLldhbGxldHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0V2FsbGV0cyhsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5XYWxsZXRzQXBpID0gV2FsbGV0c0FwaTtcbi8qKlxuICogV2ViaG9va3NBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBXZWJob29rc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHdlYmhvb2sgc2NvcGVkIHRvIGEgd2FsbGV0XG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB3ZWJob29rIHNjb3BlZCB0byBhIHdhbGxldFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gY3JlYXRlIHRoZSB3ZWJob29rIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdH0gW2NyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlV2FsbGV0V2ViaG9vazogYXN5bmMgKHdhbGxldElkLCBjcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVXYWxsZXRXZWJob29rJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L3dlYmhvb2tzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB3ZWJob29rXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlV2ViaG9va1JlcXVlc3R9IFtjcmVhdGVXZWJob29rUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVdlYmhvb2s6IGFzeW5jIChjcmVhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dlYmhvb2tzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZVdlYmhvb2tSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBzdW1tYXJ5IERlbGV0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdlYmhvb2tJZCBUaGUgV2ViaG9vayB1dWlkIHRoYXQgbmVlZHMgdG8gYmUgZGVsZXRlZFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlV2ViaG9vazogYXN5bmMgKHdlYmhvb2tJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3ZWJob29rSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZGVsZXRlV2ViaG9vaycsICd3ZWJob29rSWQnLCB3ZWJob29rSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93ZWJob29rcy97d2ViaG9va19pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2ViaG9va19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdlYmhvb2tJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdERUxFVEUnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgd2ViaG9va3MsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgZXZlbnQgdHlwZS5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB3ZWJob29rc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0V2ViaG9va3M6IGFzeW5jIChsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dlYmhvb2tzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdlYmhvb2tJZCBUaGUgV2ViaG9vayBpZCB0aGF0IG5lZWRzIHRvIGJlIHVwZGF0ZWRcbiAgICAgICAgICogQHBhcmFtIHtVcGRhdGVXZWJob29rUmVxdWVzdH0gW3VwZGF0ZVdlYmhvb2tSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlV2ViaG9vazogYXN5bmMgKHdlYmhvb2tJZCwgdXBkYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2ViaG9va0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3VwZGF0ZVdlYmhvb2snLCAnd2ViaG9va0lkJywgd2ViaG9va0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2ViaG9va3Mve3dlYmhvb2tfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndlYmhvb2tfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3ZWJob29rSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUFVUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKHVwZGF0ZVdlYmhvb2tSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLldlYmhvb2tzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBXZWJob29rc0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBXZWJob29rc0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFdlYmhvb2tzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5XZWJob29rc0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHdlYmhvb2sgc2NvcGVkIHRvIGEgd2FsbGV0XG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB3ZWJob29rIHNjb3BlZCB0byBhIHdhbGxldFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gY3JlYXRlIHRoZSB3ZWJob29rIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdH0gW2NyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlV2FsbGV0V2ViaG9vayh3YWxsZXRJZCwgY3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVXYWxsZXRXZWJob29rKHdhbGxldElkLCBjcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydXZWJob29rc0FwaS5jcmVhdGVXYWxsZXRXZWJob29rJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB3ZWJob29rXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlV2ViaG9va1JlcXVlc3R9IFtjcmVhdGVXZWJob29rUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZVdlYmhvb2soY3JlYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVXZWJob29rKGNyZWF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1dlYmhvb2tzQXBpLmNyZWF0ZVdlYmhvb2snXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAc3VtbWFyeSBEZWxldGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3ZWJob29rSWQgVGhlIFdlYmhvb2sgdXVpZCB0aGF0IG5lZWRzIHRvIGJlIGRlbGV0ZWRcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGRlbGV0ZVdlYmhvb2sod2ViaG9va0lkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZGVsZXRlV2ViaG9vayh3ZWJob29rSWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2ViaG9va3NBcGkuZGVsZXRlV2ViaG9vayddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHdlYmhvb2tzLCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IGV2ZW50IHR5cGUuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgd2ViaG9va3NcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdFdlYmhvb2tzKGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdFdlYmhvb2tzKGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1dlYmhvb2tzQXBpLmxpc3RXZWJob29rcyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdlYmhvb2tJZCBUaGUgV2ViaG9vayBpZCB0aGF0IG5lZWRzIHRvIGJlIHVwZGF0ZWRcbiAgICAgICAgICogQHBhcmFtIHtVcGRhdGVXZWJob29rUmVxdWVzdH0gW3VwZGF0ZVdlYmhvb2tSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgdXBkYXRlV2ViaG9vayh3ZWJob29rSWQsIHVwZGF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IudXBkYXRlV2ViaG9vayh3ZWJob29rSWQsIHVwZGF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1dlYmhvb2tzQXBpLnVwZGF0ZVdlYmhvb2snXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5XZWJob29rc0FwaUZwID0gV2ViaG9va3NBcGlGcDtcbi8qKlxuICogV2ViaG9va3NBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBXZWJob29rc0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLldlYmhvb2tzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgd2ViaG9vayBzY29wZWQgdG8gYSB3YWxsZXRcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHdlYmhvb2sgc2NvcGVkIHRvIGEgd2FsbGV0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBjcmVhdGUgdGhlIHdlYmhvb2sgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0fSBbY3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVXYWxsZXRXZWJob29rKHdhbGxldElkLCBjcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlV2FsbGV0V2ViaG9vayh3YWxsZXRJZCwgY3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgd2ViaG9va1xuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgd2ViaG9va1xuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVdlYmhvb2tSZXF1ZXN0fSBbY3JlYXRlV2ViaG9va1JlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVXZWJob29rKGNyZWF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVXZWJob29rKGNyZWF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAc3VtbWFyeSBEZWxldGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3ZWJob29rSWQgVGhlIFdlYmhvb2sgdXVpZCB0aGF0IG5lZWRzIHRvIGJlIGRlbGV0ZWRcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZVdlYmhvb2sod2ViaG9va0lkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5kZWxldGVXZWJob29rKHdlYmhvb2tJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgd2ViaG9va3MsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgZXZlbnQgdHlwZS5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB3ZWJob29rc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0V2ViaG9va3MobGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RXZWJob29rcyhsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgVXBkYXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2ViaG9va0lkIFRoZSBXZWJob29rIGlkIHRoYXQgbmVlZHMgdG8gYmUgdXBkYXRlZFxuICAgICAgICAgKiBAcGFyYW0ge1VwZGF0ZVdlYmhvb2tSZXF1ZXN0fSBbdXBkYXRlV2ViaG9va1JlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVXZWJob29rKHdlYmhvb2tJZCwgdXBkYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnVwZGF0ZVdlYmhvb2sod2ViaG9va0lkLCB1cGRhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuV2ViaG9va3NBcGlGYWN0b3J5ID0gV2ViaG9va3NBcGlGYWN0b3J5O1xuLyoqXG4gKiBXZWJob29rc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBXZWJob29rc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIFdlYmhvb2tzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB3ZWJob29rIHNjb3BlZCB0byBhIHdhbGxldFxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB3ZWJob29rIHNjb3BlZCB0byBhIHdhbGxldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBjcmVhdGUgdGhlIHdlYmhvb2sgZm9yLlxuICAgICAqIEBwYXJhbSB7Q3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3R9IFtjcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFdlYmhvb2tzQXBpXG4gICAgICovXG4gICAgY3JlYXRlV2FsbGV0V2ViaG9vayh3YWxsZXRJZCwgY3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLldlYmhvb2tzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlV2FsbGV0V2ViaG9vayh3YWxsZXRJZCwgY3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgd2ViaG9va1xuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB3ZWJob29rXG4gICAgICogQHBhcmFtIHtDcmVhdGVXZWJob29rUmVxdWVzdH0gW2NyZWF0ZVdlYmhvb2tSZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgV2ViaG9va3NBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVXZWJob29rKGNyZWF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5XZWJob29rc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZVdlYmhvb2soY3JlYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSB3ZWJob29rXG4gICAgICogQHN1bW1hcnkgRGVsZXRlIGEgd2ViaG9va1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3ZWJob29rSWQgVGhlIFdlYmhvb2sgdXVpZCB0aGF0IG5lZWRzIHRvIGJlIGRlbGV0ZWRcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFdlYmhvb2tzQXBpXG4gICAgICovXG4gICAgZGVsZXRlV2ViaG9vayh3ZWJob29rSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLldlYmhvb2tzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZGVsZXRlV2ViaG9vayh3ZWJob29rSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHdlYmhvb2tzLCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IGV2ZW50IHR5cGUuXG4gICAgICogQHN1bW1hcnkgTGlzdCB3ZWJob29rc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgV2ViaG9va3NBcGlcbiAgICAgKi9cbiAgICBsaXN0V2ViaG9va3MobGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLldlYmhvb2tzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdFdlYmhvb2tzKGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgd2ViaG9va1xuICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSBhIHdlYmhvb2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2ViaG9va0lkIFRoZSBXZWJob29rIGlkIHRoYXQgbmVlZHMgdG8gYmUgdXBkYXRlZFxuICAgICAqIEBwYXJhbSB7VXBkYXRlV2ViaG9va1JlcXVlc3R9IFt1cGRhdGVXZWJob29rUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFdlYmhvb2tzQXBpXG4gICAgICovXG4gICAgdXBkYXRlV2ViaG9vayh3ZWJob29rSWQsIHVwZGF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5XZWJob29rc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnVwZGF0ZVdlYmhvb2sod2ViaG9va0lkLCB1cGRhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJob29rc0FwaSA9IFdlYmhvb2tzQXBpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/base.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.operationServerMap = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\"));\nexports.BASE_PATH = \"https://api.cdp.coinbase.com/platform\".replace(/\\/+$/, \"\");\n/**\n *\n * @export\n */\nexports.COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n/**\n *\n * @export\n * @class BaseAPI\n */\nclass BaseAPI {\n    constructor(configuration, basePath = exports.BASE_PATH, axios = axios_1.default) {\n        this.basePath = basePath;\n        this.axios = axios;\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = configuration.basePath ?? basePath;\n        }\n    }\n}\nexports.BaseAPI = BaseAPI;\n;\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nclass RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n}\nexports.RequiredError = RequiredError;\n/**\n *\n * @export\n */\nexports.operationServerMap = {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxxQkFBcUIsR0FBRyxlQUFlLEdBQUcsMEJBQTBCLEdBQUcsaUJBQWlCO0FBQ3JILGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9iYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIENvaW5iYXNlIFBsYXRmb3JtIEFQSVxuICogVGhpcyBpcyB0aGUgT3BlbkFQSSAzLjAgc3BlY2lmaWNhdGlvbiBmb3IgdGhlIENvaW5iYXNlIFBsYXRmb3JtIEFQSXMsIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgQ29pbmJhc2UgUGxhdGZvcm0gU0RLcy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMC4wLjEtYWxwaGFcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9wZXJhdGlvblNlcnZlck1hcCA9IGV4cG9ydHMuUmVxdWlyZWRFcnJvciA9IGV4cG9ydHMuQmFzZUFQSSA9IGV4cG9ydHMuQ09MTEVDVElPTl9GT1JNQVRTID0gZXhwb3J0cy5CQVNFX1BBVEggPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG5leHBvcnRzLkJBU0VfUEFUSCA9IFwiaHR0cHM6Ly9hcGkuY2RwLmNvaW5iYXNlLmNvbS9wbGF0Zm9ybVwiLnJlcGxhY2UoL1xcLyskLywgXCJcIik7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydHMuQ09MTEVDVElPTl9GT1JNQVRTID0ge1xuICAgIGNzdjogXCIsXCIsXG4gICAgc3N2OiBcIiBcIixcbiAgICB0c3Y6IFwiXFx0XCIsXG4gICAgcGlwZXM6IFwifFwiLFxufTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBCYXNlQVBJXG4gKi9cbmNsYXNzIEJhc2VBUEkge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoID0gZXhwb3J0cy5CQVNFX1BBVEgsIGF4aW9zID0gYXhpb3NfMS5kZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBiYXNlUGF0aDtcbiAgICAgICAgdGhpcy5heGlvcyA9IGF4aW9zO1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhdGggPSBjb25maWd1cmF0aW9uLmJhc2VQYXRoID8/IGJhc2VQYXRoO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlQVBJID0gQmFzZUFQSTtcbjtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBSZXF1aXJlZEVycm9yXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKi9cbmNsYXNzIFJlcXVpcmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUmVxdWlyZWRFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWlyZWRFcnJvciA9IFJlcXVpcmVkRXJyb3I7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydHMub3BlcmF0aW9uU2VydmVyTWFwID0ge307XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/common.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/common.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;\nconst base_1 = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js\");\n/**\n *\n * @export\n */\nexports.DUMMY_BASE_URL = 'https://example.com';\n/**\n *\n * @throws {RequiredError}\n * @export\n */\nconst assertParamExists = function (functionName, paramName, paramValue) {\n    if (paramValue === null || paramValue === undefined) {\n        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);\n    }\n};\nexports.assertParamExists = assertParamExists;\n/**\n *\n * @export\n */\nconst setApiKeyToObject = async function (object, keyParamName, configuration) {\n    if (configuration && configuration.apiKey) {\n        const localVarApiKeyValue = typeof configuration.apiKey === 'function'\n            ? await configuration.apiKey(keyParamName)\n            : await configuration.apiKey;\n        object[keyParamName] = localVarApiKeyValue;\n    }\n};\nexports.setApiKeyToObject = setApiKeyToObject;\n/**\n *\n * @export\n */\nconst setBasicAuthToObject = function (object, configuration) {\n    if (configuration && (configuration.username || configuration.password)) {\n        object[\"auth\"] = { username: configuration.username, password: configuration.password };\n    }\n};\nexports.setBasicAuthToObject = setBasicAuthToObject;\n/**\n *\n * @export\n */\nconst setBearerAuthToObject = async function (object, configuration) {\n    if (configuration && configuration.accessToken) {\n        const accessToken = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken()\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + accessToken;\n    }\n};\nexports.setBearerAuthToObject = setBearerAuthToObject;\n/**\n *\n * @export\n */\nconst setOAuthToObject = async function (object, name, scopes, configuration) {\n    if (configuration && configuration.accessToken) {\n        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken(name, scopes)\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n    }\n};\nexports.setOAuthToObject = setOAuthToObject;\nfunction setFlattenedQueryParams(urlSearchParams, parameter, key = \"\") {\n    if (parameter == null)\n        return;\n    if (typeof parameter === \"object\") {\n        if (Array.isArray(parameter)) {\n            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));\n        }\n        else {\n            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));\n        }\n    }\n    else {\n        if (urlSearchParams.has(key)) {\n            urlSearchParams.append(key, parameter);\n        }\n        else {\n            urlSearchParams.set(key, parameter);\n        }\n    }\n}\n/**\n *\n * @export\n */\nconst setSearchParams = function (url, ...objects) {\n    const searchParams = new URLSearchParams(url.search);\n    setFlattenedQueryParams(searchParams, objects);\n    url.search = searchParams.toString();\n};\nexports.setSearchParams = setSearchParams;\n/**\n *\n * @export\n */\nconst serializeDataIfNeeded = function (value, requestOptions, configuration) {\n    const nonString = typeof value !== 'string';\n    const needsSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])\n        : nonString;\n    return needsSerialization\n        ? JSON.stringify(value !== undefined ? value : {})\n        : (value || \"\");\n};\nexports.serializeDataIfNeeded = serializeDataIfNeeded;\n/**\n *\n * @export\n */\nconst toPathString = function (url) {\n    return url.pathname + url.search + url.hash;\n};\nexports.toPathString = toPathString;\n/**\n *\n * @export\n */\nconst createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {\n    return (axios = globalAxios, basePath = BASE_PATH) => {\n        const axiosRequestArgs = { ...axiosArgs.options, url: (axios.defaults.baseURL ? '' : configuration?.basePath ?? basePath) + axiosArgs.url };\n        return axios.request(axiosRequestArgs);\n    };\n};\nexports.createRequestFunction = createRequestFunction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxvQkFBb0IsR0FBRyw2QkFBNkIsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0I7QUFDelIsZUFBZSxtQkFBTyxDQUFDLCtFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsV0FBVyxxQ0FBcUMsYUFBYTtBQUNySTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEgsSUFBSSxFQUFFLHNCQUFzQixFQUFFLFdBQVc7QUFDcks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jbGllbnQvY29tbW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIENvaW5iYXNlIFBsYXRmb3JtIEFQSVxuICogVGhpcyBpcyB0aGUgT3BlbkFQSSAzLjAgc3BlY2lmaWNhdGlvbiBmb3IgdGhlIENvaW5iYXNlIFBsYXRmb3JtIEFQSXMsIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgQ29pbmJhc2UgUGxhdGZvcm0gU0RLcy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMC4wLjEtYWxwaGFcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbiA9IGV4cG9ydHMudG9QYXRoU3RyaW5nID0gZXhwb3J0cy5zZXJpYWxpemVEYXRhSWZOZWVkZWQgPSBleHBvcnRzLnNldFNlYXJjaFBhcmFtcyA9IGV4cG9ydHMuc2V0T0F1dGhUb09iamVjdCA9IGV4cG9ydHMuc2V0QmVhcmVyQXV0aFRvT2JqZWN0ID0gZXhwb3J0cy5zZXRCYXNpY0F1dGhUb09iamVjdCA9IGV4cG9ydHMuc2V0QXBpS2V5VG9PYmplY3QgPSBleHBvcnRzLmFzc2VydFBhcmFtRXhpc3RzID0gZXhwb3J0cy5EVU1NWV9CQVNFX1VSTCA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuL2Jhc2VcIik7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydHMuRFVNTVlfQkFTRV9VUkwgPSAnaHR0cHM6Ly9leGFtcGxlLmNvbSc7XG4vKipcbiAqXG4gKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICogQGV4cG9ydFxuICovXG5jb25zdCBhc3NlcnRQYXJhbUV4aXN0cyA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUsIHBhcmFtTmFtZSwgcGFyYW1WYWx1ZSkge1xuICAgIGlmIChwYXJhbVZhbHVlID09PSBudWxsIHx8IHBhcmFtVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgYmFzZV8xLlJlcXVpcmVkRXJyb3IocGFyYW1OYW1lLCBgUmVxdWlyZWQgcGFyYW1ldGVyICR7cGFyYW1OYW1lfSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nICR7ZnVuY3Rpb25OYW1lfS5gKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRQYXJhbUV4aXN0cyA9IGFzc2VydFBhcmFtRXhpc3RzO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBzZXRBcGlLZXlUb09iamVjdCA9IGFzeW5jIGZ1bmN0aW9uIChvYmplY3QsIGtleVBhcmFtTmFtZSwgY29uZmlndXJhdGlvbikge1xuICAgIGlmIChjb25maWd1cmF0aW9uICYmIGNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgIGNvbnN0IGxvY2FsVmFyQXBpS2V5VmFsdWUgPSB0eXBlb2YgY29uZmlndXJhdGlvbi5hcGlLZXkgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYXdhaXQgY29uZmlndXJhdGlvbi5hcGlLZXkoa2V5UGFyYW1OYW1lKVxuICAgICAgICAgICAgOiBhd2FpdCBjb25maWd1cmF0aW9uLmFwaUtleTtcbiAgICAgICAgb2JqZWN0W2tleVBhcmFtTmFtZV0gPSBsb2NhbFZhckFwaUtleVZhbHVlO1xuICAgIH1cbn07XG5leHBvcnRzLnNldEFwaUtleVRvT2JqZWN0ID0gc2V0QXBpS2V5VG9PYmplY3Q7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IHNldEJhc2ljQXV0aFRvT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCwgY29uZmlndXJhdGlvbikge1xuICAgIGlmIChjb25maWd1cmF0aW9uICYmIChjb25maWd1cmF0aW9uLnVzZXJuYW1lIHx8IGNvbmZpZ3VyYXRpb24ucGFzc3dvcmQpKSB7XG4gICAgICAgIG9iamVjdFtcImF1dGhcIl0gPSB7IHVzZXJuYW1lOiBjb25maWd1cmF0aW9uLnVzZXJuYW1lLCBwYXNzd29yZDogY29uZmlndXJhdGlvbi5wYXNzd29yZCB9O1xuICAgIH1cbn07XG5leHBvcnRzLnNldEJhc2ljQXV0aFRvT2JqZWN0ID0gc2V0QmFzaWNBdXRoVG9PYmplY3Q7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IHNldEJlYXJlckF1dGhUb09iamVjdCA9IGFzeW5jIGZ1bmN0aW9uIChvYmplY3QsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gdHlwZW9mIGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW4gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYXdhaXQgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbigpXG4gICAgICAgICAgICA6IGF3YWl0IGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW47XG4gICAgICAgIG9iamVjdFtcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJlYXJlciBcIiArIGFjY2Vzc1Rva2VuO1xuICAgIH1cbn07XG5leHBvcnRzLnNldEJlYXJlckF1dGhUb09iamVjdCA9IHNldEJlYXJlckF1dGhUb09iamVjdDtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3Qgc2V0T0F1dGhUb09iamVjdCA9IGFzeW5jIGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHNjb3BlcywgY29uZmlndXJhdGlvbikge1xuICAgIGlmIChjb25maWd1cmF0aW9uICYmIGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc3QgbG9jYWxWYXJBY2Nlc3NUb2tlblZhbHVlID0gdHlwZW9mIGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW4gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYXdhaXQgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbihuYW1lLCBzY29wZXMpXG4gICAgICAgICAgICA6IGF3YWl0IGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW47XG4gICAgICAgIG9iamVjdFtcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJlYXJlciBcIiArIGxvY2FsVmFyQWNjZXNzVG9rZW5WYWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRPQXV0aFRvT2JqZWN0ID0gc2V0T0F1dGhUb09iamVjdDtcbmZ1bmN0aW9uIHNldEZsYXR0ZW5lZFF1ZXJ5UGFyYW1zKHVybFNlYXJjaFBhcmFtcywgcGFyYW1ldGVyLCBrZXkgPSBcIlwiKSB7XG4gICAgaWYgKHBhcmFtZXRlciA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgcGFyYW1ldGVyLmZvckVhY2goaXRlbSA9PiBzZXRGbGF0dGVuZWRRdWVyeVBhcmFtcyh1cmxTZWFyY2hQYXJhbXMsIGl0ZW0sIGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1ldGVyKS5mb3JFYWNoKGN1cnJlbnRLZXkgPT4gc2V0RmxhdHRlbmVkUXVlcnlQYXJhbXModXJsU2VhcmNoUGFyYW1zLCBwYXJhbWV0ZXJbY3VycmVudEtleV0sIGAke2tleX0ke2tleSAhPT0gJycgPyAnLicgOiAnJ30ke2N1cnJlbnRLZXl9YCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodXJsU2VhcmNoUGFyYW1zLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB1cmxTZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgcGFyYW1ldGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVybFNlYXJjaFBhcmFtcy5zZXQoa2V5LCBwYXJhbWV0ZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBzZXRTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiAodXJsLCAuLi5vYmplY3RzKSB7XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmwuc2VhcmNoKTtcbiAgICBzZXRGbGF0dGVuZWRRdWVyeVBhcmFtcyhzZWFyY2hQYXJhbXMsIG9iamVjdHMpO1xuICAgIHVybC5zZWFyY2ggPSBzZWFyY2hQYXJhbXMudG9TdHJpbmcoKTtcbn07XG5leHBvcnRzLnNldFNlYXJjaFBhcmFtcyA9IHNldFNlYXJjaFBhcmFtcztcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3Qgc2VyaWFsaXplRGF0YUlmTmVlZGVkID0gZnVuY3Rpb24gKHZhbHVlLCByZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IG5vblN0cmluZyA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZyc7XG4gICAgY29uc3QgbmVlZHNTZXJpYWxpemF0aW9uID0gbm9uU3RyaW5nICYmIGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5pc0pzb25NaW1lXG4gICAgICAgID8gY29uZmlndXJhdGlvbi5pc0pzb25NaW1lKHJlcXVlc3RPcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKVxuICAgICAgICA6IG5vblN0cmluZztcbiAgICByZXR1cm4gbmVlZHNTZXJpYWxpemF0aW9uXG4gICAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pXG4gICAgICAgIDogKHZhbHVlIHx8IFwiXCIpO1xufTtcbmV4cG9ydHMuc2VyaWFsaXplRGF0YUlmTmVlZGVkID0gc2VyaWFsaXplRGF0YUlmTmVlZGVkO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5jb25zdCB0b1BhdGhTdHJpbmcgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgcmV0dXJuIHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbn07XG5leHBvcnRzLnRvUGF0aFN0cmluZyA9IHRvUGF0aFN0cmluZztcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgY3JlYXRlUmVxdWVzdEZ1bmN0aW9uID0gZnVuY3Rpb24gKGF4aW9zQXJncywgZ2xvYmFsQXhpb3MsIEJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiAoYXhpb3MgPSBnbG9iYWxBeGlvcywgYmFzZVBhdGggPSBCQVNFX1BBVEgpID0+IHtcbiAgICAgICAgY29uc3QgYXhpb3NSZXF1ZXN0QXJncyA9IHsgLi4uYXhpb3NBcmdzLm9wdGlvbnMsIHVybDogKGF4aW9zLmRlZmF1bHRzLmJhc2VVUkwgPyAnJyA6IGNvbmZpZ3VyYXRpb24/LmJhc2VQYXRoID8/IGJhc2VQYXRoKSArIGF4aW9zQXJncy51cmwgfTtcbiAgICAgICAgcmV0dXJuIGF4aW9zLnJlcXVlc3QoYXhpb3NSZXF1ZXN0QXJncyk7XG4gICAgfTtcbn07XG5leHBvcnRzLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbiA9IGNyZWF0ZVJlcXVlc3RGdW5jdGlvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Configuration = void 0;\nclass Configuration {\n    constructor(param = {}) {\n        this.apiKey = param.apiKey;\n        this.username = param.username;\n        this.password = param.password;\n        this.accessToken = param.accessToken;\n        this.basePath = param.basePath;\n        this.serverIndex = param.serverIndex;\n        this.baseOptions = param.baseOptions;\n        this.formDataCtor = param.formDataCtor;\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        const jsonMime = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\nexports.Configuration = Configuration;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9jb25maWd1cmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxXQUFXLHNCQUFzQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jbGllbnQvY29uZmlndXJhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBDb2luYmFzZSBQbGF0Zm9ybSBBUElcbiAqIFRoaXMgaXMgdGhlIE9wZW5BUEkgMy4wIHNwZWNpZmljYXRpb24gZm9yIHRoZSBDb2luYmFzZSBQbGF0Zm9ybSBBUElzLCB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENvaW5iYXNlIFBsYXRmb3JtIFNES3MuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDAuMC4xLWFscGhhXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25maWd1cmF0aW9uID0gdm9pZCAwO1xuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IocGFyYW0gPSB7fSkge1xuICAgICAgICB0aGlzLmFwaUtleSA9IHBhcmFtLmFwaUtleTtcbiAgICAgICAgdGhpcy51c2VybmFtZSA9IHBhcmFtLnVzZXJuYW1lO1xuICAgICAgICB0aGlzLnBhc3N3b3JkID0gcGFyYW0ucGFzc3dvcmQ7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBwYXJhbS5hY2Nlc3NUb2tlbjtcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IHBhcmFtLmJhc2VQYXRoO1xuICAgICAgICB0aGlzLnNlcnZlckluZGV4ID0gcGFyYW0uc2VydmVySW5kZXg7XG4gICAgICAgIHRoaXMuYmFzZU9wdGlvbnMgPSBwYXJhbS5iYXNlT3B0aW9ucztcbiAgICAgICAgdGhpcy5mb3JtRGF0YUN0b3IgPSBwYXJhbS5mb3JtRGF0YUN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBNSU1FIGlzIGEgSlNPTiBNSU1FLlxuICAgICAqIEpTT04gTUlNRSBleGFtcGxlczpcbiAgICAgKiAgIGFwcGxpY2F0aW9uL2pzb25cbiAgICAgKiAgIGFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGOFxuICAgICAqICAgQVBQTElDQVRJT04vSlNPTlxuICAgICAqICAgYXBwbGljYXRpb24vdm5kLmNvbXBhbnkranNvblxuICAgICAqIEBwYXJhbSBtaW1lIC0gTUlNRSAoTXVsdGlwdXJwb3NlIEludGVybmV0IE1haWwgRXh0ZW5zaW9ucylcbiAgICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIGdpdmVuIE1JTUUgaXMgSlNPTiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzSnNvbk1pbWUobWltZSkge1xuICAgICAgICBjb25zdCBqc29uTWltZSA9IG5ldyBSZWdFeHAoJ14oYXBwbGljYXRpb25cXC9qc29ufFteOy8gXFx0XStcXC9bXjsvIFxcdF0rWytdanNvbilbIFxcdF0qKDsuKik/JCcsICdpJyk7XG4gICAgICAgIHJldHVybiBtaW1lICE9PSBudWxsICYmIChqc29uTWltZS50ZXN0KG1pbWUpIHx8IG1pbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24tcGF0Y2granNvbicpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./api */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\"), exports);\n__exportStar(__webpack_require__(/*! ./configuration */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw2RUFBTztBQUM1QixhQUFhLG1CQUFPLENBQUMsaUdBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY2xpZW50L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIENvaW5iYXNlIFBsYXRmb3JtIEFQSVxuICogVGhpcyBpcyB0aGUgT3BlbkFQSSAzLjAgc3BlY2lmaWNhdGlvbiBmb3IgdGhlIENvaW5iYXNlIFBsYXRmb3JtIEFQSXMsIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgQ29pbmJhc2UgUGxhdGZvcm0gU0RLcy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMC4wLjEtYWxwaGFcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hcGlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbmZpZ3VyYXRpb25cIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Address = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst balance_1 = __webpack_require__(/*! ./balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\");\nconst balance_map_1 = __webpack_require__(/*! ./balance_map */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js\");\nconst faucet_transaction_1 = __webpack_require__(/*! ./faucet_transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js\");\nconst historical_balance_1 = __webpack_require__(/*! ./historical_balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst staking_reward_1 = __webpack_require__(/*! ./staking_reward */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js\");\nconst staking_balance_1 = __webpack_require__(/*! ./staking_balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst address_reputation_1 = __webpack_require__(/*! ./address_reputation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address_reputation.js\");\n/**\n * A representation of a blockchain address, which is a user-controlled account on a network.\n */\nclass Address {\n    /**\n     * Initializes a new Address instance.\n     *\n     * @param networkId - The network id.\n     * @param id - The onchain address id.\n     */\n    constructor(networkId, id) {\n        this.networkId = networkId;\n        this.id = id;\n    }\n    /**\n     * Returns the network ID.\n     *\n     * @returns The network ID.\n     */\n    getNetworkId() {\n        return this.networkId;\n    }\n    /**\n     * Returns the address ID.\n     *\n     * @returns The address ID.\n     */\n    getId() {\n        return this.id;\n    }\n    /**\n     * Returns the list of balances for the address.\n     *\n     * @returns The map from asset ID to balance.\n     */\n    async listBalances() {\n        const response = await coinbase_1.Coinbase.apiClients.externalAddress.listExternalAddressBalances(this.getNetworkId(), this.getId());\n        return balance_map_1.BalanceMap.fromBalances(response.data.data);\n    }\n    /**\n     * Returns the balance of the provided asset.\n     *\n     * @param assetId - The asset ID.\n     * @returns The balance of the asset.\n     */\n    async getBalance(assetId) {\n        const response = await coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance(this.getNetworkId(), this.getId(), asset_1.Asset.primaryDenomination(assetId));\n        if (!response.data) {\n            return new decimal_js_1.default(0);\n        }\n        return balance_1.Balance.fromModelAndAssetId(response.data, assetId).amount;\n    }\n    /**\n     * Returns the historical balances of the provided asset.\n     *\n     * @param assetId - The asset ID.\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Historical Balances to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Historical Balances. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Historical Balances for the given Asset ID.\n     */\n    async listHistoricalBalances(assetId, { limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance(this.getNetworkId(), this.getId(), asset_1.Asset.primaryDenomination(assetId), limit, page);\n        response.data.data.forEach(historicalBalanceModel => {\n            const historicalBalance = historical_balance_1.HistoricalBalance.fromModel(historicalBalanceModel);\n            data.push(historicalBalance);\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Returns the transactions of the address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Transactions to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Transactions. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Transactions.\n     */\n    async listTransactions({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.transactionHistory.listAddressTransactions(this.getNetworkId(), this.getId(), limit, page);\n        response.data.data.forEach(transactionModel => {\n            const transaction = new transaction_1.Transaction(transactionModel);\n            data.push(transaction);\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Lists the staking rewards for the address.\n     *\n     * @param assetId - The asset ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @param format - The format to return the rewards in. (usd, native). Defaults to usd.\n     * @returns The staking rewards.\n     */\n    async stakingRewards(assetId, startTime = (0, utils_1.getWeekBackDate)(new Date()), endTime = (0, utils_1.formatDate)(new Date()), format = types_1.StakingRewardFormat.USD) {\n        return staking_reward_1.StakingReward.list(coinbase_1.Coinbase.normalizeNetwork(this.getNetworkId()), assetId, [this.getId()], startTime, endTime, format);\n    }\n    /**\n     * Lists the historical staking balances for the address.\n     *\n     * @param assetId - The asset ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @returns The staking balances.\n     */\n    async historicalStakingBalances(assetId, startTime = (0, utils_1.getWeekBackDate)(new Date()), endTime = (0, utils_1.formatDate)(new Date())) {\n        return staking_balance_1.StakingBalance.list(coinbase_1.Coinbase.normalizeNetwork(this.getNetworkId()), assetId, this.getId(), startTime, endTime);\n    }\n    /**\n     * Get the stakeable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check the stakeable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the stakeable balance.\n     * @returns The stakeable balance.\n     */\n    async stakeableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        const balances = await this.getStakingBalances(asset_id, mode, options);\n        return balances.stakeableBalance;\n    }\n    /**\n     * Get the unstakeable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check the unstakeable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the unstakeable balance.\n     * A. Dedicated ETH Staking\n     *  - `validator_pub_keys` (optional): List of comma separated validator public keys to retrieve unstakeable balance for. Defaults to all validators.\n     * @returns The unstakeable balance.\n     */\n    async unstakeableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        const balances = await this.getStakingBalances(asset_id, mode, options);\n        return balances.unstakeableBalance;\n    }\n    /**\n     * Get the claimable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check claimable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the claimable balance.\n     * @returns The claimable balance.\n     */\n    async claimableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        const balances = await this.getStakingBalances(asset_id, mode, options);\n        return balances.claimableBalance;\n    }\n    /**\n     * Requests faucet funds for the address.\n     * Only supported on testnet networks.\n     *\n     * @param assetId - The ID of the asset to transfer from the faucet.\n     * @returns The faucet transaction object.\n     * @throws {Error} If the request does not return a transaction hash.\n     * @throws {Error} If the request fails.\n     */\n    async faucet(assetId) {\n        const response = await coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds(this.getNetworkId(), this.getId(), assetId, true);\n        return new faucet_transaction_1.FaucetTransaction(response.data);\n    }\n    /**\n     * Returns the reputation of the Address.\n     *\n     * @returns The reputation of the Address.\n     * @throws {Error} if the API request to get the Address reputation fails.\n     * @throws {Error} if the Address reputation is not available.\n     */\n    async reputation() {\n        if (this._reputation) {\n            return this._reputation;\n        }\n        const response = await coinbase_1.Coinbase.apiClients.addressReputation.getAddressReputation(this.getNetworkId(), this.getId());\n        this._reputation = new address_reputation_1.AddressReputation(response.data);\n        return this._reputation;\n    }\n    /**\n     * Returns a string representation of the address.\n     *\n     * @returns A string representing the address.\n     */\n    toString() {\n        return `Address { addressId: '${this.getId()}', networkId: '${this.getNetworkId()}' }`;\n    }\n    /**\n     * Validate if the operation is able to stake with the supplied input.\n     *\n     * @param amount - The amount of the asset to stake.\n     * @param assetId - The asset to stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the stake operation.\n     * @private\n     * @throws {Error} If the supplied input is not able to create a stake operation.\n     */\n    async validateCanStake(amount, assetId, mode, options) {\n        const stakeableBalance = await this.stakeableBalance(assetId, mode, options);\n        if (new decimal_js_1.default(stakeableBalance).lessThan(amount.toString())) {\n            throw new Error(`Insufficient funds ${amount} requested to stake, only ${stakeableBalance} available.`);\n        }\n    }\n    /**\n     * Validate if the operation is able to unstake with the supplied input.\n     *\n     * @param amount - The amount of the asset to unstake.\n     * @param assetId - The asset to unstake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the unstake operation.\n     * @private\n     * @throws {Error} If the supplied input is not able to create an unstake operation.\n     */\n    async validateCanUnstake(amount, assetId, mode, options) {\n        const unstakeableBalance = new decimal_js_1.default(await this.unstakeableBalance(assetId, mode, options));\n        if (unstakeableBalance.lessThan(amount.toString())) {\n            throw new Error(`Insufficient funds ${amount} requested to unstake, only ${unstakeableBalance} available.`);\n        }\n    }\n    /**\n     * Validate if the operation is able to claim stake with the supplied input.\n     *\n     * @param amount - The amount of the asset to claim stake.\n     * @param assetId - The asset to claim stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the claim stake operation.\n     * @private\n     * @throws {Error} If the supplied input is not able to create a claim stake operation.\n     */\n    async validateCanClaimStake(amount, assetId, mode, options) {\n        if (assetId === \"eth\" && mode === types_1.StakeOptionsMode.NATIVE) {\n            throw new Error(`Claiming stake for ETH is not supported in native mode.`);\n        }\n        const claimableBalance = new decimal_js_1.default(await this.claimableBalance(assetId, mode, options));\n        if (claimableBalance.lessThan(amount.toString())) {\n            throw new Error(`Insufficient funds ${amount} requested to claim stake, only ${claimableBalance} available.`);\n        }\n    }\n    /**\n     * Create a shallow copy of given options.\n     *\n     * @param options - The supplied options to be copied\n     * @private\n     * @returns A copy of the options.\n     */\n    copyOptions(options) {\n        return { ...options };\n    }\n    /**\n     * Get the different staking balance types for the supplied asset.\n     *\n     * @param assetId - The asset to lookup balances for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the balance lookup.\n     * @private\n     * @returns The different balance types.\n     */\n    async getStakingBalances(assetId, mode, options) {\n        const newOptions = this.copyOptions(options);\n        if (mode) {\n            newOptions.mode = mode;\n        }\n        const request = {\n            network_id: this.getNetworkId(),\n            asset_id: asset_1.Asset.primaryDenomination(assetId),\n            address_id: this.getId(),\n            options: newOptions,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.stake.getStakingContext(request);\n        return {\n            stakeableBalance: balance_1.Balance.fromModelAndAssetId(response.data.context.stakeable_balance, assetId).amount,\n            unstakeableBalance: balance_1.Balance.fromModelAndAssetId(response.data.context.unstakeable_balance, assetId).amount,\n            claimableBalance: balance_1.Balance.fromModelAndAssetId(response.data.context.claimable_balance, assetId).amount,\n        };\n    }\n}\nexports.Address = Address;\nAddress.MAX_HISTORICAL_BALANCE = 1000;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YscUNBQXFDLG1CQUFPLENBQUMsOERBQVk7QUFDekQsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsdUZBQVc7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWU7QUFDN0MsNkJBQTZCLG1CQUFPLENBQUMsNkdBQXNCO0FBQzNELDZCQUE2QixtQkFBTyxDQUFDLDZHQUFzQjtBQUMzRCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyx5QkFBeUIsbUJBQU8sQ0FBQyxxR0FBa0I7QUFDbkQsMEJBQTBCLG1CQUFPLENBQUMsdUdBQW1CO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLCtGQUFlO0FBQzdDLDZCQUE2QixtQkFBTyxDQUFDLDZHQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RztBQUM5RztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUVBQWlFLElBQUk7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtFQUFrRSxJQUFJO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjLGFBQWEsaUJBQWlCLG9CQUFvQixHQUFHO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVEsMkJBQTJCLGtCQUFrQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVEsNkJBQTZCLG9CQUFvQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVEsaUNBQWlDLGtCQUFrQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvYWRkcmVzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWRkcmVzcyA9IHZvaWQgMDtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVjaW1hbC5qc1wiKSk7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG5jb25zdCBhc3NldF8xID0gcmVxdWlyZShcIi4vYXNzZXRcIik7XG5jb25zdCBiYWxhbmNlXzEgPSByZXF1aXJlKFwiLi9iYWxhbmNlXCIpO1xuY29uc3QgYmFsYW5jZV9tYXBfMSA9IHJlcXVpcmUoXCIuL2JhbGFuY2VfbWFwXCIpO1xuY29uc3QgZmF1Y2V0X3RyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi9mYXVjZXRfdHJhbnNhY3Rpb25cIik7XG5jb25zdCBoaXN0b3JpY2FsX2JhbGFuY2VfMSA9IHJlcXVpcmUoXCIuL2hpc3RvcmljYWxfYmFsYW5jZVwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IHN0YWtpbmdfcmV3YXJkXzEgPSByZXF1aXJlKFwiLi9zdGFraW5nX3Jld2FyZFwiKTtcbmNvbnN0IHN0YWtpbmdfYmFsYW5jZV8xID0gcmVxdWlyZShcIi4vc3Rha2luZ19iYWxhbmNlXCIpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgYWRkcmVzc19yZXB1dGF0aW9uXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzX3JlcHV0YXRpb25cIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBibG9ja2NoYWluIGFkZHJlc3MsIHdoaWNoIGlzIGEgdXNlci1jb250cm9sbGVkIGFjY291bnQgb24gYSBuZXR3b3JrLlxuICovXG5jbGFzcyBBZGRyZXNzIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBBZGRyZXNzIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCAtIFRoZSBuZXR3b3JrIGlkLlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBvbmNoYWluIGFkZHJlc3MgaWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmV0d29ya0lkLCBpZCkge1xuICAgICAgICB0aGlzLm5ldHdvcmtJZCA9IG5ldHdvcmtJZDtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXR3b3JrIElELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5ldHdvcmsgSUQuXG4gICAgICovXG4gICAgZ2V0TmV0d29ya0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFkZHJlc3MgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYWRkcmVzcyBJRC5cbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYmFsYW5jZXMgZm9yIHRoZSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG1hcCBmcm9tIGFzc2V0IElEIHRvIGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdEJhbGFuY2VzKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5leHRlcm5hbEFkZHJlc3MubGlzdEV4dGVybmFsQWRkcmVzc0JhbGFuY2VzKHRoaXMuZ2V0TmV0d29ya0lkKCksIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHJldHVybiBiYWxhbmNlX21hcF8xLkJhbGFuY2VNYXAuZnJvbUJhbGFuY2VzKHJlc3BvbnNlLmRhdGEuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJhbGFuY2Ugb2YgdGhlIHByb3ZpZGVkIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgSUQuXG4gICAgICogQHJldHVybnMgVGhlIGJhbGFuY2Ugb2YgdGhlIGFzc2V0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJhbGFuY2UoYXNzZXRJZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5leHRlcm5hbEFkZHJlc3MuZ2V0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZSh0aGlzLmdldE5ldHdvcmtJZCgpLCB0aGlzLmdldElkKCksIGFzc2V0XzEuQXNzZXQucHJpbWFyeURlbm9taW5hdGlvbihhc3NldElkKSk7XG4gICAgICAgIGlmICghcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFsYW5jZV8xLkJhbGFuY2UuZnJvbU1vZGVsQW5kQXNzZXRJZChyZXNwb25zZS5kYXRhLCBhc3NldElkKS5hbW91bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhpc3RvcmljYWwgYmFsYW5jZXMgb2YgdGhlIHByb3ZpZGVkIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgSUQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcGFnaW5hdGlvbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIEhpc3RvcmljYWwgQmFsYW5jZXMgdG8gcmV0dXJuLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFnZSAtIFRoZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIEhpc3RvcmljYWwgQmFsYW5jZXMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dCBwYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFnaW5hdGVkIGxpc3QgcmVzcG9uc2Ugb2YgSGlzdG9yaWNhbCBCYWxhbmNlcyBmb3IgdGhlIGdpdmVuIEFzc2V0IElELlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RIaXN0b3JpY2FsQmFsYW5jZXMoYXNzZXRJZCwgeyBsaW1pdCA9IGNvaW5iYXNlXzEuQ29pbmJhc2UuZGVmYXVsdFBhZ2VMaW1pdCwgcGFnZSA9IHVuZGVmaW5lZCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBsZXQgbmV4dFBhZ2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmJhbGFuY2VIaXN0b3J5Lmxpc3RBZGRyZXNzSGlzdG9yaWNhbEJhbGFuY2UodGhpcy5nZXROZXR3b3JrSWQoKSwgdGhpcy5nZXRJZCgpLCBhc3NldF8xLkFzc2V0LnByaW1hcnlEZW5vbWluYXRpb24oYXNzZXRJZCksIGxpbWl0LCBwYWdlKTtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS5kYXRhLmZvckVhY2goaGlzdG9yaWNhbEJhbGFuY2VNb2RlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBoaXN0b3JpY2FsQmFsYW5jZSA9IGhpc3RvcmljYWxfYmFsYW5jZV8xLkhpc3RvcmljYWxCYWxhbmNlLmZyb21Nb2RlbChoaXN0b3JpY2FsQmFsYW5jZU1vZGVsKTtcbiAgICAgICAgICAgIGRhdGEucHVzaChoaXN0b3JpY2FsQmFsYW5jZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYXNNb3JlID0gcmVzcG9uc2UuZGF0YS5oYXNfbW9yZTtcbiAgICAgICAgaWYgKGhhc01vcmUpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSkge1xuICAgICAgICAgICAgICAgIG5leHRQYWdlID0gcmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBoYXNNb3JlLFxuICAgICAgICAgICAgbmV4dFBhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zYWN0aW9ucyBvZiB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBUcmFuc2FjdGlvbnMgdG8gcmV0dXJuLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFnZSAtIFRoZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIFRyYW5zYWN0aW9ucy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYWdpbmF0ZWQgbGlzdCByZXNwb25zZSBvZiBUcmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFRyYW5zYWN0aW9ucyh7IGxpbWl0ID0gY29pbmJhc2VfMS5Db2luYmFzZS5kZWZhdWx0UGFnZUxpbWl0LCBwYWdlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBsZXQgbmV4dFBhZ2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnRyYW5zYWN0aW9uSGlzdG9yeS5saXN0QWRkcmVzc1RyYW5zYWN0aW9ucyh0aGlzLmdldE5ldHdvcmtJZCgpLCB0aGlzLmdldElkKCksIGxpbWl0LCBwYWdlKTtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS5kYXRhLmZvckVhY2godHJhbnNhY3Rpb25Nb2RlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTW9kZWwpO1xuICAgICAgICAgICAgZGF0YS5wdXNoKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhc01vcmUgPSByZXNwb25zZS5kYXRhLmhhc19tb3JlO1xuICAgICAgICBpZiAoaGFzTW9yZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBhZ2UgPSByZXNwb25zZS5kYXRhLm5leHRfcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGhhc01vcmUsXG4gICAgICAgICAgICBuZXh0UGFnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIHN0YWtpbmcgcmV3YXJkcyBmb3IgdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIC0gVGhlIHN0YXJ0IHRpbWUuXG4gICAgICogQHBhcmFtIGVuZFRpbWUgLSBUaGUgZW5kIHRpbWUuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgdG8gcmV0dXJuIHRoZSByZXdhcmRzIGluLiAodXNkLCBuYXRpdmUpLiBEZWZhdWx0cyB0byB1c2QuXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtpbmcgcmV3YXJkcy5cbiAgICAgKi9cbiAgICBhc3luYyBzdGFraW5nUmV3YXJkcyhhc3NldElkLCBzdGFydFRpbWUgPSAoMCwgdXRpbHNfMS5nZXRXZWVrQmFja0RhdGUpKG5ldyBEYXRlKCkpLCBlbmRUaW1lID0gKDAsIHV0aWxzXzEuZm9ybWF0RGF0ZSkobmV3IERhdGUoKSksIGZvcm1hdCA9IHR5cGVzXzEuU3Rha2luZ1Jld2FyZEZvcm1hdC5VU0QpIHtcbiAgICAgICAgcmV0dXJuIHN0YWtpbmdfcmV3YXJkXzEuU3Rha2luZ1Jld2FyZC5saXN0KGNvaW5iYXNlXzEuQ29pbmJhc2Uubm9ybWFsaXplTmV0d29yayh0aGlzLmdldE5ldHdvcmtJZCgpKSwgYXNzZXRJZCwgW3RoaXMuZ2V0SWQoKV0sIHN0YXJ0VGltZSwgZW5kVGltZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBmb3IgdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIC0gVGhlIHN0YXJ0IHRpbWUuXG4gICAgICogQHBhcmFtIGVuZFRpbWUgLSBUaGUgZW5kIHRpbWUuXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtpbmcgYmFsYW5jZXMuXG4gICAgICovXG4gICAgYXN5bmMgaGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcyhhc3NldElkLCBzdGFydFRpbWUgPSAoMCwgdXRpbHNfMS5nZXRXZWVrQmFja0RhdGUpKG5ldyBEYXRlKCkpLCBlbmRUaW1lID0gKDAsIHV0aWxzXzEuZm9ybWF0RGF0ZSkobmV3IERhdGUoKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0YWtpbmdfYmFsYW5jZV8xLlN0YWtpbmdCYWxhbmNlLmxpc3QoY29pbmJhc2VfMS5Db2luYmFzZS5ub3JtYWxpemVOZXR3b3JrKHRoaXMuZ2V0TmV0d29ya0lkKCkpLCBhc3NldElkLCB0aGlzLmdldElkKCksIHN0YXJ0VGltZSwgZW5kVGltZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3Rha2VhYmxlIGJhbGFuY2UgZm9yIHRoZSBzdXBwbGllZCBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldF9pZCAtIFRoZSBhc3NldCB0byBjaGVjayB0aGUgc3Rha2VhYmxlIGJhbGFuY2UgZm9yLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgZ2V0dGluZyB0aGUgc3Rha2VhYmxlIGJhbGFuY2UuXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtlYWJsZSBiYWxhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0YWtlYWJsZUJhbGFuY2UoYXNzZXRfaWQsIG1vZGUgPSB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5nZXRTdGFraW5nQmFsYW5jZXMoYXNzZXRfaWQsIG1vZGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYmFsYW5jZXMuc3Rha2VhYmxlQmFsYW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1bnN0YWtlYWJsZSBiYWxhbmNlIGZvciB0aGUgc3VwcGxpZWQgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRfaWQgLSBUaGUgYXNzZXQgdG8gY2hlY2sgdGhlIHVuc3Rha2VhYmxlIGJhbGFuY2UgZm9yLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgZ2V0dGluZyB0aGUgdW5zdGFrZWFibGUgYmFsYW5jZS5cbiAgICAgKiBBLiBEZWRpY2F0ZWQgRVRIIFN0YWtpbmdcbiAgICAgKiAgLSBgdmFsaWRhdG9yX3B1Yl9rZXlzYCAob3B0aW9uYWwpOiBMaXN0IG9mIGNvbW1hIHNlcGFyYXRlZCB2YWxpZGF0b3IgcHVibGljIGtleXMgdG8gcmV0cmlldmUgdW5zdGFrZWFibGUgYmFsYW5jZSBmb3IuIERlZmF1bHRzIHRvIGFsbCB2YWxpZGF0b3JzLlxuICAgICAqIEByZXR1cm5zIFRoZSB1bnN0YWtlYWJsZSBiYWxhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIHVuc3Rha2VhYmxlQmFsYW5jZShhc3NldF9pZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLmdldFN0YWtpbmdCYWxhbmNlcyhhc3NldF9pZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBiYWxhbmNlcy51bnN0YWtlYWJsZUJhbGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2xhaW1hYmxlIGJhbGFuY2UgZm9yIHRoZSBzdXBwbGllZCBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldF9pZCAtIFRoZSBhc3NldCB0byBjaGVjayBjbGFpbWFibGUgYmFsYW5jZSBmb3IuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBnZXR0aW5nIHRoZSBjbGFpbWFibGUgYmFsYW5jZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2xhaW1hYmxlIGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgY2xhaW1hYmxlQmFsYW5jZShhc3NldF9pZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLmdldFN0YWtpbmdCYWxhbmNlcyhhc3NldF9pZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBiYWxhbmNlcy5jbGFpbWFibGVCYWxhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBmYXVjZXQgZnVuZHMgZm9yIHRoZSBhZGRyZXNzLlxuICAgICAqIE9ubHkgc3VwcG9ydGVkIG9uIHRlc3RuZXQgbmV0d29ya3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gdHJhbnNmZXIgZnJvbSB0aGUgZmF1Y2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBmYXVjZXQgdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBkb2VzIG5vdCByZXR1cm4gYSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBmYXVjZXQoYXNzZXRJZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5leHRlcm5hbEFkZHJlc3MucmVxdWVzdEV4dGVybmFsRmF1Y2V0RnVuZHModGhpcy5nZXROZXR3b3JrSWQoKSwgdGhpcy5nZXRJZCgpLCBhc3NldElkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBmYXVjZXRfdHJhbnNhY3Rpb25fMS5GYXVjZXRUcmFuc2FjdGlvbihyZXNwb25zZS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVwdXRhdGlvbiBvZiB0aGUgQWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSByZXB1dGF0aW9uIG9mIHRoZSBBZGRyZXNzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gZ2V0IHRoZSBBZGRyZXNzIHJlcHV0YXRpb24gZmFpbHMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBBZGRyZXNzIHJlcHV0YXRpb24gaXMgbm90IGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXB1dGF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVwdXRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcHV0YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuYWRkcmVzc1JlcHV0YXRpb24uZ2V0QWRkcmVzc1JlcHV0YXRpb24odGhpcy5nZXROZXR3b3JrSWQoKSwgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgdGhpcy5fcmVwdXRhdGlvbiA9IG5ldyBhZGRyZXNzX3JlcHV0YXRpb25fMS5BZGRyZXNzUmVwdXRhdGlvbihyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcHV0YXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGFkZHJlc3MuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgQWRkcmVzcyB7IGFkZHJlc3NJZDogJyR7dGhpcy5nZXRJZCgpfScsIG5ldHdvcmtJZDogJyR7dGhpcy5nZXROZXR3b3JrSWQoKX0nIH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBpZiB0aGUgb3BlcmF0aW9uIGlzIGFibGUgdG8gc3Rha2Ugd2l0aCB0aGUgc3VwcGxpZWQgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgYXNzZXQgdG8gc3Rha2UuXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgdG8gc3Rha2UuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzdXBwbGllZCBpbnB1dCBpcyBub3QgYWJsZSB0byBjcmVhdGUgYSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgdmFsaWRhdGVDYW5TdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3Rha2VhYmxlQmFsYW5jZSA9IGF3YWl0IHRoaXMuc3Rha2VhYmxlQmFsYW5jZShhc3NldElkLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdChzdGFrZWFibGVCYWxhbmNlKS5sZXNzVGhhbihhbW91bnQudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IGZ1bmRzICR7YW1vdW50fSByZXF1ZXN0ZWQgdG8gc3Rha2UsIG9ubHkgJHtzdGFrZWFibGVCYWxhbmNlfSBhdmFpbGFibGUuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgaWYgdGhlIG9wZXJhdGlvbiBpcyBhYmxlIHRvIHVuc3Rha2Ugd2l0aCB0aGUgc3VwcGxpZWQgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgYXNzZXQgdG8gdW5zdGFrZS5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCB0byB1bnN0YWtlLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHVuc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzdXBwbGllZCBpbnB1dCBpcyBub3QgYWJsZSB0byBjcmVhdGUgYW4gdW5zdGFrZSBvcGVyYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgdmFsaWRhdGVDYW5VbnN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB1bnN0YWtlYWJsZUJhbGFuY2UgPSBuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoYXdhaXQgdGhpcy51bnN0YWtlYWJsZUJhbGFuY2UoYXNzZXRJZCwgbW9kZSwgb3B0aW9ucykpO1xuICAgICAgICBpZiAodW5zdGFrZWFibGVCYWxhbmNlLmxlc3NUaGFuKGFtb3VudC50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgZnVuZHMgJHthbW91bnR9IHJlcXVlc3RlZCB0byB1bnN0YWtlLCBvbmx5ICR7dW5zdGFrZWFibGVCYWxhbmNlfSBhdmFpbGFibGUuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgaWYgdGhlIG9wZXJhdGlvbiBpcyBhYmxlIHRvIGNsYWltIHN0YWtlIHdpdGggdGhlIHN1cHBsaWVkIGlucHV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIGFzc2V0IHRvIGNsYWltIHN0YWtlLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IHRvIGNsYWltIHN0YWtlLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIGNsYWltIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc3VwcGxpZWQgaW5wdXQgaXMgbm90IGFibGUgdG8gY3JlYXRlIGEgY2xhaW0gc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHZhbGlkYXRlQ2FuQ2xhaW1TdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGFzc2V0SWQgPT09IFwiZXRoXCIgJiYgbW9kZSA9PT0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLk5BVElWRSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGFpbWluZyBzdGFrZSBmb3IgRVRIIGlzIG5vdCBzdXBwb3J0ZWQgaW4gbmF0aXZlIG1vZGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xhaW1hYmxlQmFsYW5jZSA9IG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdChhd2FpdCB0aGlzLmNsYWltYWJsZUJhbGFuY2UoYXNzZXRJZCwgbW9kZSwgb3B0aW9ucykpO1xuICAgICAgICBpZiAoY2xhaW1hYmxlQmFsYW5jZS5sZXNzVGhhbihhbW91bnQudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IGZ1bmRzICR7YW1vdW50fSByZXF1ZXN0ZWQgdG8gY2xhaW0gc3Rha2UsIG9ubHkgJHtjbGFpbWFibGVCYWxhbmNlfSBhdmFpbGFibGUuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2hhbGxvdyBjb3B5IG9mIGdpdmVuIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBzdXBwbGllZCBvcHRpb25zIHRvIGJlIGNvcGllZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIHRoZSBvcHRpb25zLlxuICAgICAqL1xuICAgIGNvcHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ub3B0aW9ucyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRpZmZlcmVudCBzdGFraW5nIGJhbGFuY2UgdHlwZXMgZm9yIHRoZSBzdXBwbGllZCBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IHRvIGxvb2t1cCBiYWxhbmNlcyBmb3IuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgYmFsYW5jZSBsb29rdXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyBUaGUgZGlmZmVyZW50IGJhbGFuY2UgdHlwZXMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3Rha2luZ0JhbGFuY2VzKGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IHRoaXMuY29weU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmIChtb2RlKSB7XG4gICAgICAgICAgICBuZXdPcHRpb25zLm1vZGUgPSBtb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBuZXR3b3JrX2lkOiB0aGlzLmdldE5ldHdvcmtJZCgpLFxuICAgICAgICAgICAgYXNzZXRfaWQ6IGFzc2V0XzEuQXNzZXQucHJpbWFyeURlbm9taW5hdGlvbihhc3NldElkKSxcbiAgICAgICAgICAgIGFkZHJlc3NfaWQ6IHRoaXMuZ2V0SWQoKSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG5ld09wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnN0YWtlLmdldFN0YWtpbmdDb250ZXh0KHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Rha2VhYmxlQmFsYW5jZTogYmFsYW5jZV8xLkJhbGFuY2UuZnJvbU1vZGVsQW5kQXNzZXRJZChyZXNwb25zZS5kYXRhLmNvbnRleHQuc3Rha2VhYmxlX2JhbGFuY2UsIGFzc2V0SWQpLmFtb3VudCxcbiAgICAgICAgICAgIHVuc3Rha2VhYmxlQmFsYW5jZTogYmFsYW5jZV8xLkJhbGFuY2UuZnJvbU1vZGVsQW5kQXNzZXRJZChyZXNwb25zZS5kYXRhLmNvbnRleHQudW5zdGFrZWFibGVfYmFsYW5jZSwgYXNzZXRJZCkuYW1vdW50LFxuICAgICAgICAgICAgY2xhaW1hYmxlQmFsYW5jZTogYmFsYW5jZV8xLkJhbGFuY2UuZnJvbU1vZGVsQW5kQXNzZXRJZChyZXNwb25zZS5kYXRhLmNvbnRleHQuY2xhaW1hYmxlX2JhbGFuY2UsIGFzc2V0SWQpLmFtb3VudCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkFkZHJlc3MgPSBBZGRyZXNzO1xuQWRkcmVzcy5NQVhfSElTVE9SSUNBTF9CQUxBTkNFID0gMTAwMDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/external_address.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/external_address.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExternalAddress = void 0;\nconst address_1 = __webpack_require__(/*! ../address */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst coinbase_1 = __webpack_require__(/*! ../coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst asset_1 = __webpack_require__(/*! ../asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst staking_operation_1 = __webpack_require__(/*! ../staking_operation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js\");\n/**\n * A representation of a blockchain Address, which is a user-controlled account on a Network. Addresses are used to\n * send and receive Assets. An ExternalAddress is an Address that is not controlled by the developer, but is instead\n * controlled by the user.\n */\nclass ExternalAddress extends address_1.Address {\n    /**\n     * Builds a stake operation for the supplied asset. The stake operation\n     * may take a few minutes to complete in the case when infrastructure is spun up.\n     *\n     * @param amount - The amount of the asset to stake.\n     * @param assetId - The asset to stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the stake operation:\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the stake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * B. Dedicated ETH Staking\n     *  - `funding_address` (optional): Ethereum address for funding the stake operation. Defaults to the address initiating the stake operation.\n     *  - `withdrawal_address` (optional): Ethereum address for receiving rewards and withdrawal funds. Defaults to the address initiating the stake operation.\n     *  - `fee_recipient_address` (optional): Ethereum address for receiving transaction fees. Defaults to the address initiating the stake operation.\n     *\n     * @returns The stake operation.\n     */\n    async buildStakeOperation(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        await this.validateCanStake(amount, assetId, mode, options);\n        return this.buildStakingOperation(amount, assetId, \"stake\", mode, options);\n    }\n    /**\n     * Builds an unstake operation for the supplied asset.\n     *\n     * @param amount - The amount of the asset to unstake.\n     * @param assetId - The asset to unstake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the unstake operation:\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the unstake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * B. Dedicated ETH Staking\n     *  - `immediate` (optional): Set this to \"true\" to unstake immediately i.e. leverage \"Coinbase managed unstake\" process . Defaults to \"false\" i.e. \"User managed unstake\" process.\n     *  - `validator_pub_keys` (optional): List of comma separated validator public keys to unstake. Defaults to validators being picked up on your behalf corresponding to the unstake amount.\n     *\n     * @returns The unstake operation.\n     */\n    async buildUnstakeOperation(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        await this.validateCanUnstake(amount, assetId, mode, options);\n        return this.buildStakingOperation(amount, assetId, \"unstake\", mode, options);\n    }\n    /**\n     * Builds a claim stake operation for the supplied asset.\n     *\n     * @param amount - The amount of the asset to claim stake.\n     * @param assetId - The asset to claim stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the claim stake operation.\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the claim stake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * @returns The claim stake operation.\n     */\n    async buildClaimStakeOperation(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        await this.validateCanClaimStake(amount, assetId, mode, options);\n        return this.buildStakingOperation(amount, assetId, \"claim_stake\", mode, options);\n    }\n    /**\n     * Builds the staking operation based on the supplied input.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param action - The specific action for the staking operation. e.g. stake, unstake, claim_stake\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options to build a stake operation.\n     * @private\n     * @returns The staking operation.\n     * @throws {Error} If the supplied input cannot build a valid staking operation.\n     */\n    async buildStakingOperation(amount, assetId, action, mode, options) {\n        const stakingAmount = new decimal_js_1.default(amount.toString());\n        if (stakingAmount.lessThanOrEqualTo(0)) {\n            throw new Error(`Amount required greater than zero.`);\n        }\n        const asset = await asset_1.Asset.fetch(this.getNetworkId(), assetId);\n        const newOptions = this.copyOptions(options);\n        newOptions.mode = mode;\n        newOptions.amount = asset.toAtomicAmount(new decimal_js_1.default(amount.toString())).toString();\n        const request = {\n            network_id: this.getNetworkId(),\n            asset_id: asset_1.Asset.primaryDenomination(assetId),\n            address_id: this.getId(),\n            action: action,\n            options: newOptions,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.stake.buildStakingOperation(request);\n        return new staking_operation_1.StakingOperation(response.data);\n    }\n    /**\n     * Broadcast an external transaction\n     *\n     * @param signedPayload - The signed payload of the transaction to broadcast\n     * @returns The broadcasted transaction\n     */\n    async broadcastExternalTransaction(signedPayload) {\n        const response = await coinbase_1.Coinbase.apiClients.externalAddress.broadcastExternalTransaction(this.getNetworkId(), this.getId(), {\n            signed_payload: signedPayload,\n        });\n        return {\n            transactionHash: response.data.transaction_hash,\n            transactionLink: response.data.transaction_link,\n        };\n    }\n}\nexports.ExternalAddress = ExternalAddress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FkZHJlc3MvZXh0ZXJuYWxfYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixrQkFBa0IsbUJBQU8sQ0FBQyx3RkFBWTtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBVTtBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBYTtBQUN4QyxxQ0FBcUMsbUJBQU8sQ0FBQyw4REFBWTtBQUN6RCxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBVTtBQUNsQyw0QkFBNEIsbUJBQU8sQ0FBQyw0R0FBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvYWRkcmVzcy9leHRlcm5hbF9hZGRyZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4uL2NvaW5iYXNlXCIpO1xuY29uc3QgZGVjaW1hbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpKTtcbmNvbnN0IGFzc2V0XzEgPSByZXF1aXJlKFwiLi4vYXNzZXRcIik7XG5jb25zdCBzdGFraW5nX29wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4uL3N0YWtpbmdfb3BlcmF0aW9uXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgYmxvY2tjaGFpbiBBZGRyZXNzLCB3aGljaCBpcyBhIHVzZXItY29udHJvbGxlZCBhY2NvdW50IG9uIGEgTmV0d29yay4gQWRkcmVzc2VzIGFyZSB1c2VkIHRvXG4gKiBzZW5kIGFuZCByZWNlaXZlIEFzc2V0cy4gQW4gRXh0ZXJuYWxBZGRyZXNzIGlzIGFuIEFkZHJlc3MgdGhhdCBpcyBub3QgY29udHJvbGxlZCBieSB0aGUgZGV2ZWxvcGVyLCBidXQgaXMgaW5zdGVhZFxuICogY29udHJvbGxlZCBieSB0aGUgdXNlci5cbiAqL1xuY2xhc3MgRXh0ZXJuYWxBZGRyZXNzIGV4dGVuZHMgYWRkcmVzc18xLkFkZHJlc3Mge1xuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIHN0YWtlIG9wZXJhdGlvbiBmb3IgdGhlIHN1cHBsaWVkIGFzc2V0LiBUaGUgc3Rha2Ugb3BlcmF0aW9uXG4gICAgICogbWF5IHRha2UgYSBmZXcgbWludXRlcyB0byBjb21wbGV0ZSBpbiB0aGUgY2FzZSB3aGVuIGluZnJhc3RydWN0dXJlIGlzIHNwdW4gdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgYXNzZXQgdG8gc3Rha2UuXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgdG8gc3Rha2UuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgc3Rha2Ugb3BlcmF0aW9uOlxuICAgICAqXG4gICAgICogQS4gU2hhcmVkIEVUSCBTdGFraW5nXG4gICAgICogIC0gYGludGVncmF0b3JfY29udHJhY3RfYWRkcmVzc2AgKG9wdGlvbmFsKTogVGhlIGNvbnRyYWN0IGFkZHJlc3MgdG8gd2hpY2ggdGhlIHN0YWtlIG9wZXJhdGlvbiBpcyBkaXJlY3RlZCB0by4gRGVmYXVsdHMgdG8gdGhlIGludGVncmF0b3IgY29udHJhY3QgYWRkcmVzcyBhc3NvY2lhdGVkIHdpdGggQ0RQIGFjY291bnQgKGlmIGF2YWlsYWJsZSkgb3IgZWxzZSBkZWZhdWx0cyB0byBhIHNoYXJlZCBpbnRlZ3JhdG9yIGNvbnRyYWN0IGFkZHJlc3MgZm9yIHRoYXQgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEIuIERlZGljYXRlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGBmdW5kaW5nX2FkZHJlc3NgIChvcHRpb25hbCk6IEV0aGVyZXVtIGFkZHJlc3MgZm9yIGZ1bmRpbmcgdGhlIHN0YWtlIG9wZXJhdGlvbi4gRGVmYXVsdHMgdG8gdGhlIGFkZHJlc3MgaW5pdGlhdGluZyB0aGUgc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqICAtIGB3aXRoZHJhd2FsX2FkZHJlc3NgIChvcHRpb25hbCk6IEV0aGVyZXVtIGFkZHJlc3MgZm9yIHJlY2VpdmluZyByZXdhcmRzIGFuZCB3aXRoZHJhd2FsIGZ1bmRzLiBEZWZhdWx0cyB0byB0aGUgYWRkcmVzcyBpbml0aWF0aW5nIHRoZSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICogIC0gYGZlZV9yZWNpcGllbnRfYWRkcmVzc2AgKG9wdGlvbmFsKTogRXRoZXJldW0gYWRkcmVzcyBmb3IgcmVjZWl2aW5nIHRyYW5zYWN0aW9uIGZlZXMuIERlZmF1bHRzIHRvIHRoZSBhZGRyZXNzIGluaXRpYXRpbmcgdGhlIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgYnVpbGRTdGFrZU9wZXJhdGlvbihhbW91bnQsIGFzc2V0SWQsIG1vZGUgPSB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVDYW5TdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZFN0YWtpbmdPcGVyYXRpb24oYW1vdW50LCBhc3NldElkLCBcInN0YWtlXCIsIG1vZGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYW4gdW5zdGFrZSBvcGVyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBhc3NldCB0byB1bnN0YWtlLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IHRvIHVuc3Rha2UuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgdW5zdGFrZSBvcGVyYXRpb246XG4gICAgICpcbiAgICAgKiBBLiBTaGFyZWQgRVRIIFN0YWtpbmdcbiAgICAgKiAgLSBgaW50ZWdyYXRvcl9jb250cmFjdF9hZGRyZXNzYCAob3B0aW9uYWwpOiBUaGUgY29udHJhY3QgYWRkcmVzcyB0byB3aGljaCB0aGUgdW5zdGFrZSBvcGVyYXRpb24gaXMgZGlyZWN0ZWQgdG8uIERlZmF1bHRzIHRvIHRoZSBpbnRlZ3JhdG9yIGNvbnRyYWN0IGFkZHJlc3MgYXNzb2NpYXRlZCB3aXRoIENEUCBhY2NvdW50IChpZiBhdmFpbGFibGUpIG9yIGVsc2UgZGVmYXVsdHMgdG8gYSBzaGFyZWQgaW50ZWdyYXRvciBjb250cmFjdCBhZGRyZXNzIGZvciB0aGF0IG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBCLiBEZWRpY2F0ZWQgRVRIIFN0YWtpbmdcbiAgICAgKiAgLSBgaW1tZWRpYXRlYCAob3B0aW9uYWwpOiBTZXQgdGhpcyB0byBcInRydWVcIiB0byB1bnN0YWtlIGltbWVkaWF0ZWx5IGkuZS4gbGV2ZXJhZ2UgXCJDb2luYmFzZSBtYW5hZ2VkIHVuc3Rha2VcIiBwcm9jZXNzIC4gRGVmYXVsdHMgdG8gXCJmYWxzZVwiIGkuZS4gXCJVc2VyIG1hbmFnZWQgdW5zdGFrZVwiIHByb2Nlc3MuXG4gICAgICogIC0gYHZhbGlkYXRvcl9wdWJfa2V5c2AgKG9wdGlvbmFsKTogTGlzdCBvZiBjb21tYSBzZXBhcmF0ZWQgdmFsaWRhdG9yIHB1YmxpYyBrZXlzIHRvIHVuc3Rha2UuIERlZmF1bHRzIHRvIHZhbGlkYXRvcnMgYmVpbmcgcGlja2VkIHVwIG9uIHlvdXIgYmVoYWxmIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHVuc3Rha2UgYW1vdW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHVuc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGJ1aWxkVW5zdGFrZU9wZXJhdGlvbihhbW91bnQsIGFzc2V0SWQsIG1vZGUgPSB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVDYW5VbnN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkU3Rha2luZ09wZXJhdGlvbihhbW91bnQsIGFzc2V0SWQsIFwidW5zdGFrZVwiLCBtb2RlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgY2xhaW0gc3Rha2Ugb3BlcmF0aW9uIGZvciB0aGUgc3VwcGxpZWQgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgYXNzZXQgdG8gY2xhaW0gc3Rha2UuXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgdG8gY2xhaW0gc3Rha2UuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgY2xhaW0gc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQS4gU2hhcmVkIEVUSCBTdGFraW5nXG4gICAgICogIC0gYGludGVncmF0b3JfY29udHJhY3RfYWRkcmVzc2AgKG9wdGlvbmFsKTogVGhlIGNvbnRyYWN0IGFkZHJlc3MgdG8gd2hpY2ggdGhlIGNsYWltIHN0YWtlIG9wZXJhdGlvbiBpcyBkaXJlY3RlZCB0by4gRGVmYXVsdHMgdG8gdGhlIGludGVncmF0b3IgY29udHJhY3QgYWRkcmVzcyBhc3NvY2lhdGVkIHdpdGggQ0RQIGFjY291bnQgKGlmIGF2YWlsYWJsZSkgb3IgZWxzZSBkZWZhdWx0cyB0byBhIHNoYXJlZCBpbnRlZ3JhdG9yIGNvbnRyYWN0IGFkZHJlc3MgZm9yIHRoYXQgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjbGFpbSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgYnVpbGRDbGFpbVN0YWtlT3BlcmF0aW9uKGFtb3VudCwgYXNzZXRJZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUNhbkNsYWltU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRTdGFraW5nT3BlcmF0aW9uKGFtb3VudCwgYXNzZXRJZCwgXCJjbGFpbV9zdGFrZVwiLCBtb2RlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBiYXNlZCBvbiB0aGUgc3VwcGxpZWQgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBmb3IgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IGZvciB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIFRoZSBzcGVjaWZpYyBhY3Rpb24gZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi4gZS5nLiBzdGFrZSwgdW5zdGFrZSwgY2xhaW1fc3Rha2VcbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gYnVpbGQgYSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzdXBwbGllZCBpbnB1dCBjYW5ub3QgYnVpbGQgYSB2YWxpZCBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBidWlsZFN0YWtpbmdPcGVyYXRpb24oYW1vdW50LCBhc3NldElkLCBhY3Rpb24sIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3Rha2luZ0Ftb3VudCA9IG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdChhbW91bnQudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChzdGFraW5nQW1vdW50Lmxlc3NUaGFuT3JFcXVhbFRvKDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFtb3VudCByZXF1aXJlZCBncmVhdGVyIHRoYW4gemVyby5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc3NldCA9IGF3YWl0IGFzc2V0XzEuQXNzZXQuZmV0Y2godGhpcy5nZXROZXR3b3JrSWQoKSwgYXNzZXRJZCk7XG4gICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSB0aGlzLmNvcHlPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBuZXdPcHRpb25zLm1vZGUgPSBtb2RlO1xuICAgICAgICBuZXdPcHRpb25zLmFtb3VudCA9IGFzc2V0LnRvQXRvbWljQW1vdW50KG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdChhbW91bnQudG9TdHJpbmcoKSkpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBuZXR3b3JrX2lkOiB0aGlzLmdldE5ldHdvcmtJZCgpLFxuICAgICAgICAgICAgYXNzZXRfaWQ6IGFzc2V0XzEuQXNzZXQucHJpbWFyeURlbm9taW5hdGlvbihhc3NldElkKSxcbiAgICAgICAgICAgIGFkZHJlc3NfaWQ6IHRoaXMuZ2V0SWQoKSxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgb3B0aW9uczogbmV3T3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc3Rha2UuYnVpbGRTdGFraW5nT3BlcmF0aW9uKHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gbmV3IHN0YWtpbmdfb3BlcmF0aW9uXzEuU3Rha2luZ09wZXJhdGlvbihyZXNwb25zZS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0IGFuIGV4dGVybmFsIHRyYW5zYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2lnbmVkUGF5bG9hZCAtIFRoZSBzaWduZWQgcGF5bG9hZCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gYnJvYWRjYXN0XG4gICAgICogQHJldHVybnMgVGhlIGJyb2FkY2FzdGVkIHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgYXN5bmMgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvbihzaWduZWRQYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmV4dGVybmFsQWRkcmVzcy5icm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uKHRoaXMuZ2V0TmV0d29ya0lkKCksIHRoaXMuZ2V0SWQoKSwge1xuICAgICAgICAgICAgc2lnbmVkX3BheWxvYWQ6IHNpZ25lZFBheWxvYWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiByZXNwb25zZS5kYXRhLnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkxpbms6IHJlc3BvbnNlLmRhdGEudHJhbnNhY3Rpb25fbGluayxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkV4dGVybmFsQWRkcmVzcyA9IEV4dGVybmFsQWRkcmVzcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/external_address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletAddress = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.commonjs/index.js\");\nconst client_1 = __webpack_require__(/*! ../../client */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/index.js\");\nconst address_1 = __webpack_require__(/*! ../address */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js\");\nconst asset_1 = __webpack_require__(/*! ../asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst coinbase_1 = __webpack_require__(/*! ../coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst trade_1 = __webpack_require__(/*! ../trade */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js\");\nconst transfer_1 = __webpack_require__(/*! ../transfer */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js\");\nconst contract_invocation_1 = __webpack_require__(/*! ../contract_invocation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst wallet_1 = __webpack_require__(/*! ../wallet */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js\");\nconst staking_operation_1 = __webpack_require__(/*! ../staking_operation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js\");\nconst payload_signature_1 = __webpack_require__(/*! ../payload_signature */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js\");\nconst smart_contract_1 = __webpack_require__(/*! ../smart_contract */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js\");\nconst fund_operation_1 = __webpack_require__(/*! ../fund_operation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_operation.js\");\nconst fund_quote_1 = __webpack_require__(/*! ../fund_quote */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_quote.js\");\n/**\n * A representation of a blockchain address, which is a wallet-controlled account on a network.\n */\nclass WalletAddress extends address_1.Address {\n    /**\n     * Initializes a new Wallet Address instance.\n     *\n     * @param model - The address model data.\n     * @param key - The ethers.js SigningKey the Address uses to sign data.\n     * @throws {Error} If the address model is empty.\n     */\n    constructor(model, key) {\n        if (!model) {\n            throw new Error(\"Address model cannot be empty\");\n        }\n        super(model.network_id, model.address_id);\n        this.model = model;\n        this.key = key;\n    }\n    /**\n     * Returns a string representation of the wallet address.\n     *\n     * @returns A string representing the wallet address.\n     */\n    toString() {\n        return `WalletAddress{ addressId: '${this.getId()}', networkId: '${this.getNetworkId()}', walletId: '${this.getWalletId()}' }`;\n    }\n    /**\n     * Returns the wallet ID.\n     *\n     * @returns The wallet ID.\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Sets the private key.\n     *\n     * @param key - The ethers.js SigningKey the Address uses to sign data.\n     * @throws {Error} If the private key is already set.\n     */\n    setKey(key) {\n        if (this.key !== undefined) {\n            throw new Error(\"Private key is already set\");\n        }\n        this.key = key;\n    }\n    /**\n     * Exports the Address's private key to a hex string.\n     *\n     * @returns The Address's private key as a hex string.\n     */\n    export() {\n        if (this.key === undefined) {\n            throw new Error(\"Private key is not set\");\n        }\n        return this.key.privateKey;\n    }\n    /**\n     * Returns whether the Address has a private key backing it to sign transactions.\n     *\n     * @returns Whether the Address has a private key backing it to sign transactions.\n     */\n    canSign() {\n        return !!this.key;\n    }\n    /**\n     * Returns all the trades associated with the address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Trades to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Trades. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of trades.\n     */\n    async listTrades({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.trade.listTrades(this.model.wallet_id, this.model.address_id, limit, page);\n        response.data.data.forEach(tradeModel => {\n            data.push(new trade_1.Trade(tradeModel));\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Returns all the transfers associated with the address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Transfers to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Transfers. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of transfers.\n     */\n    async listTransfers({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.transfer.listTransfers(this.model.wallet_id, this.model.address_id, limit, page);\n        response.data.data.forEach(transferModel => {\n            data.push(transfer_1.Transfer.fromModel(transferModel));\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Transfers the given amount of the given Asset to the given address.\n     * Only same-Network Transfers are supported.\n     * This returns a `Transfer` object that has been signed and broadcasted, you\n     * can wait for this to land on-chain (or fail) by calling `transfer.wait()`.\n     *\n     * @param options - The options to create the Transfer.\n     * @param options.amount - The amount of the Asset to send.\n     * @param options.assetId - The ID of the Asset to send. For Ether, Coinbase.assets.Eth, Coinbase.assets.Gwei, and Coinbase.assets.Wei supported.\n     * @param options.destination - The destination of the transfer. If a Wallet, sends to the Wallet's default address. If a String, interprets it as the address ID.\n     * @param options.gasless - Whether the Transfer should be gasless. Defaults to false.\n     * @param options.skipBatching - When true, the Transfer will be submitted immediately. Otherwise, the Transfer will be batched. Defaults to false. Note: requires gasless option to be set to true.\n     * @returns The transfer object.\n     * @throws {APIError} if the API request to create a Transfer fails.\n     * @throws {APIError} if the API request to broadcast a Transfer fails.\n     */\n    async createTransfer({ amount, assetId, destination, gasless = false, skipBatching = false, }) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot transfer from address without private key loaded\");\n        }\n        const asset = await asset_1.Asset.fetch(this.getNetworkId(), assetId);\n        const [destinationAddress, destinationNetworkId] = await this.getDestinationAddressAndNetwork(destination);\n        const normalizedAmount = new decimal_js_1.Decimal(amount.toString());\n        const currentBalance = await this.getBalance(assetId);\n        if (currentBalance.lessThan(normalizedAmount)) {\n            throw new errors_1.ArgumentError(`Insufficient funds: ${normalizedAmount} requested, but only ${currentBalance} available`);\n        }\n        if (skipBatching && !gasless) {\n            throw new errors_1.ArgumentError(\"skipBatching requires gasless to be true\");\n        }\n        const createTransferRequest = {\n            amount: asset.toAtomicAmount(normalizedAmount).toString(),\n            network_id: destinationNetworkId,\n            asset_id: asset.primaryDenomination(),\n            destination: destinationAddress,\n            gasless: gasless,\n            skip_batching: skipBatching,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.transfer.createTransfer(this.getWalletId(), this.getId(), createTransferRequest);\n        const transfer = transfer_1.Transfer.fromModel(response.data);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return transfer;\n        }\n        await transfer.sign(this.getSigner());\n        await transfer.broadcast();\n        return transfer;\n    }\n    /**\n     * Gets a signer for the private key.\n     *\n     * @returns The signer for the private key.\n     * @throws {Error} If the private key is not loaded.\n     */\n    getSigner() {\n        if (!this.key) {\n            throw new Error(\"Cannot sign without a private key\");\n        }\n        return new ethers_1.ethers.Wallet(this.key.privateKey);\n    }\n    /**\n     * Trades the given amount of the given Asset for another Asset. Only same-network Trades are supported.\n     *\n     * @param options - The options to create the Trade.\n     * @param options.amount - The amount of the From Asset to send.\n     * @param options.fromAssetId - The ID of the Asset to trade from.\n     * @param options.toAssetId - The ID of the Asset to trade to.\n     * @returns The Trade object.\n     * @throws {APIError} if the API request to create or broadcast a Trade fails.\n     * @throws {Error} if the Trade times out.\n     */\n    async createTrade({ amount, fromAssetId, toAssetId }) {\n        const fromAsset = await asset_1.Asset.fetch(this.getNetworkId(), fromAssetId);\n        const toAsset = await asset_1.Asset.fetch(this.getNetworkId(), toAssetId);\n        await this.validateCanTrade(amount, fromAssetId);\n        const trade = await this.createTradeRequest(amount, fromAsset, toAsset);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return trade;\n        }\n        await trade.sign(this.getSigner());\n        await trade.broadcast();\n        return trade;\n    }\n    /**\n     * Invokes a contract with the given data.\n     *\n     * @param options - The options to invoke the contract\n     * @param options.contractAddress - The address of the contract the method will be invoked on.\n     * @param options.method - The method to invoke on the contract.\n     * @param options.abi - The ABI of the contract.\n     * @param options.args - The arguments to pass to the contract method invocation.\n     *   The keys should be the argument names and the values should be the argument values.\n     * @param options.amount - The amount of the asset to send to a payable contract method.\n     * @param options.assetId - The ID of the asset to send to a payable contract method.\n     *   The asset must be a denomination of the native asset. (Ex. \"wei\", \"gwei\", or \"eth\").\n     * @returns The ContractInvocation object.\n     * @throws {APIError} if the API request to create a contract invocation fails.\n     * @throws {Error} if the address cannot sign.\n     * @throws {ArgumentError} if the address does not have sufficient balance.\n     */\n    async invokeContract({ contractAddress, method, abi, args, amount, assetId, }) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot invoke contract from address without private key loaded\");\n        }\n        if (amount && !assetId) {\n            throw new errors_1.ArgumentError(\"Asset ID is required for contract ivocation if an amount is provided\");\n        }\n        let atomicAmount;\n        if (assetId && amount) {\n            const asset = await asset_1.Asset.fetch(this.getNetworkId(), assetId);\n            const normalizedAmount = new decimal_js_1.Decimal(amount.toString());\n            const currentBalance = await this.getBalance(assetId);\n            if (currentBalance.lessThan(normalizedAmount)) {\n                throw new errors_1.ArgumentError(`Insufficient funds: ${normalizedAmount} requested, but only ${currentBalance} available`);\n            }\n            atomicAmount = asset.toAtomicAmount(normalizedAmount).toString();\n        }\n        const contractInvocation = await this.createContractInvocation(contractAddress, method, abi, args, atomicAmount);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return contractInvocation;\n        }\n        await contractInvocation.sign(this.getSigner());\n        await contractInvocation.broadcast();\n        return contractInvocation;\n    }\n    /**\n     * Deploys an ERC20 token contract.\n     *\n     * @param options - The options for creating the ERC20 token.\n     * @param options.name - The name of the ERC20 token.\n     * @param options.symbol - The symbol of the ERC20 token.\n     * @param options.totalSupply - The total supply of the ERC20 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async deployToken({ name, symbol, totalSupply, }) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot deploy ERC20 without private key loaded\");\n        }\n        const smartContract = await this.createERC20({ name, symbol, totalSupply });\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return smartContract;\n        }\n        await smartContract.sign(this.getSigner());\n        await smartContract.broadcast();\n        return smartContract;\n    }\n    /**\n     * Deploys an ERC721 token contract.\n     *\n     * @param options - The options for creating the ERC721 token.\n     * @param options.name - The name of the ERC721 token.\n     * @param options.symbol - The symbol of the ERC721 token.\n     * @param options.baseURI - The base URI of the ERC721 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async deployNFT({ name, symbol, baseURI }) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot deploy ERC721 without private key loaded\");\n        }\n        const smartContract = await this.createERC721({ name, symbol, baseURI });\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return smartContract;\n        }\n        await smartContract.sign(this.getSigner());\n        await smartContract.broadcast();\n        return smartContract;\n    }\n    /**\n     * Deploys an ERC1155 multi-token contract.\n     *\n     * @param options - The options for creating the ERC1155 token.\n     * @param options.uri - The URI for all token metadata.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async deployMultiToken({ uri }) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot deploy ERC1155 without private key loaded\");\n        }\n        const smartContract = await this.createERC1155({ uri });\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return smartContract;\n        }\n        await smartContract.sign(this.getSigner());\n        await smartContract.broadcast();\n        return smartContract;\n    }\n    /**\n     * Deploys a custom contract.\n     *\n     * @param options - The options for creating the custom contract.\n     * @param options.solidityVersion - The version of the solidity compiler, must be 0.8.+, such as \"0.8.28+commit.7893614a\". See https://binaries.soliditylang.org/bin/list.json\n     * @param options.solidityInputJson - The input json for the solidity compiler. See https://docs.soliditylang.org/en/latest/using-the-compiler.html#input-description for more details.\n     * @param options.contractName - The name of the contract class to be deployed.\n     * @param options.constructorArgs - The arguments for the constructor.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async deployContract({ solidityVersion, solidityInputJson, contractName, constructorArgs, }) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot deploy custom contract without private key loaded\");\n        }\n        const smartContract = await this.createCustomContract({\n            solidityVersion,\n            solidityInputJson,\n            contractName,\n            constructorArgs,\n        });\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return smartContract;\n        }\n        await smartContract.sign(this.getSigner());\n        await smartContract.broadcast();\n        return smartContract;\n    }\n    /**\n     * Creates an ERC20 token contract.\n     *\n     * @private\n     * @param {CreateERC20Options} options - The options for creating the ERC20 token.\n     * @param {string} options.name - The name of the ERC20 token.\n     * @param {string} options.symbol - The symbol of the ERC20 token.\n     * @param {BigNumber} options.totalSupply - The total supply of the ERC20 token.\n     * @returns {Promise<SmartContract>} A Promise that resolves to the created SmartContract.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async createERC20({ name, symbol, totalSupply, }) {\n        const resp = await coinbase_1.Coinbase.apiClients.smartContract.createSmartContract(this.getWalletId(), this.getId(), {\n            type: client_1.SmartContractType.Erc20,\n            options: {\n                name,\n                symbol,\n                total_supply: totalSupply.toString(),\n            },\n        });\n        return smart_contract_1.SmartContract.fromModel(resp?.data);\n    }\n    /**\n     * Creates an ERC721 token contract.\n     *\n     * @param options - The options for creating the ERC721 token.\n     * @param options.name - The name of the ERC721 token.\n     * @param options.symbol - The symbol of the ERC721 token.\n     * @param options.baseURI - The base URI of the ERC721 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the private key is not loaded when not using server signer.\n     */\n    async createERC721({ name, symbol, baseURI, }) {\n        const resp = await coinbase_1.Coinbase.apiClients.smartContract.createSmartContract(this.getWalletId(), this.getId(), {\n            type: client_1.SmartContractType.Erc721,\n            options: {\n                name,\n                symbol,\n                base_uri: baseURI,\n            },\n        });\n        return smart_contract_1.SmartContract.fromModel(resp?.data);\n    }\n    /**\n     * Creates an ERC1155 multi-token contract.\n     *\n     * @private\n     * @param {CreateERC1155Options} options - The options for creating the ERC1155 token.\n     * @param {string} options.uri - The URI for all token metadata.\n     * @returns {Promise<SmartContract>} A Promise that resolves to the created SmartContract.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async createERC1155({ uri }) {\n        const resp = await coinbase_1.Coinbase.apiClients.smartContract.createSmartContract(this.getWalletId(), this.getId(), {\n            type: client_1.SmartContractType.Erc1155,\n            options: {\n                uri,\n            },\n        });\n        return smart_contract_1.SmartContract.fromModel(resp?.data);\n    }\n    /**\n     * Creates a custom contract.\n     *\n     * @private\n     * @param {CreateCustomContractOptions} options - The options for creating the custom contract.\n     * @param {string} options.solidityVersion - The version of the solidity compiler, must be 0.8.+, such as \"0.8.28+commit.7893614a\". See https://binaries.soliditylang.org/bin/list.json\n     * @param {string} options.solidityInputJson - The input json for the solidity compiler. See https://docs.soliditylang.org/en/latest/using-the-compiler.html#input-description for more details.\n     * @param {string} options.contractName - The name of the contract class.\n     * @param {Record<string, any>} options.constructorArgs - The arguments for the constructor.\n     * @returns {Promise<SmartContract>} A Promise that resolves to the created SmartContract.\n     * @throws {APIError} If the API request to compile or subsequently create a smart contract fails.\n     */\n    async createCustomContract({ solidityVersion, solidityInputJson, contractName, constructorArgs, }) {\n        const compileContractResp = await coinbase_1.Coinbase.apiClients.smartContract.compileSmartContract({\n            solidity_compiler_version: solidityVersion,\n            solidity_input_json: solidityInputJson,\n            contract_name: contractName,\n        });\n        const compiledContract = compileContractResp.data;\n        const compiledContractId = compiledContract.compiled_smart_contract_id;\n        const createContractResp = await coinbase_1.Coinbase.apiClients.smartContract.createSmartContract(this.getWalletId(), this.getId(), {\n            type: client_1.SmartContractType.Custom,\n            options: JSON.stringify(constructorArgs),\n            compiled_smart_contract_id: compiledContractId,\n        });\n        return smart_contract_1.SmartContract.fromModel(createContractResp?.data);\n    }\n    /**\n     * Creates a contract invocation with the given data.\n     *\n     * @param contractAddress - The address of the contract the method will be invoked on.\n     * @param method - The method to invoke on the contract.\n     * @param abi - The ABI of the contract.\n     * @param args - The arguments to pass to the contract method invocation.\n     *   The keys should be the argument names and the values should be the argument values.\n     * @param atomicAmount - The atomic amount of the native asset to send to a payable contract method.\n     * @returns The ContractInvocation object.\n     * @throws {APIError} if the API request to create a contract invocation fails.\n     */\n    async createContractInvocation(contractAddress, method, abi, args, atomicAmount) {\n        const resp = await coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation(this.getWalletId(), this.getId(), {\n            method: method,\n            abi: JSON.stringify(abi),\n            contract_address: contractAddress,\n            args: JSON.stringify(args),\n            amount: atomicAmount,\n        });\n        return contract_invocation_1.ContractInvocation.fromModel(resp?.data);\n    }\n    /**\n     * Creates a staking operation to stake.\n     *\n     * @param amount - The amount to stake.\n     * @param assetId - The asset to stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the stake operation:\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the stake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * B. Dedicated ETH Staking\n     *  - `funding_address` (optional): Ethereum address for funding the stake operation. Defaults to the address initiating the stake operation.\n     *  - `withdrawal_address` (optional): Ethereum address for receiving rewards and withdrawal funds. Defaults to the address initiating the stake operation.\n     *  - `fee_recipient_address` (optional): Ethereum address for receiving transaction fees. Defaults to the address initiating the stake operation.\n     *\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @returns The staking operation after it's completed successfully.\n     */\n    async createStake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 600, intervalSeconds = 0.2) {\n        await this.validateCanStake(amount, assetId, mode, options);\n        return this.createStakingOperation(amount, assetId, \"stake\", mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a staking operation to unstake.\n     *\n     * @param amount - The amount to unstake.\n     * @param assetId - The asset to unstake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the unstake operation:\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the unstake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * B. Dedicated ETH Staking\n     *  - `immediate` (optional): Set this to \"true\" to unstake immediately i.e. leverage \"Coinbase managed unstake\" process . Defaults to \"false\" i.e. \"User managed unstake\" process.\n     *  - `validator_pub_keys` (optional): List of comma separated validator public keys to unstake. Defaults to validators being picked up on your behalf corresponding to the unstake amount.\n     *\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @returns The staking operation after it's completed successfully.\n     */\n    async createUnstake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 600, intervalSeconds = 0.2) {\n        await this.validateCanUnstake(amount, assetId, mode, options);\n        return this.createStakingOperation(amount, assetId, \"unstake\", mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a staking operation to claim stake.\n     *\n     * @param amount - The amount to claim stake.\n     * @param assetId - The asset to claim stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the claim stake operation.\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the claim stake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @returns The staking operation after it's completed successfully.\n     */\n    async createClaimStake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 600, intervalSeconds = 0.2) {\n        await this.validateCanClaimStake(amount, assetId, mode, options);\n        return this.createStakingOperation(amount, assetId, \"claim_stake\", mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a Payload Signature.\n     *\n     * @param unsignedPayload - The Unsigned Payload to sign.\n     * @returns A promise that resolves to the Payload Signature object.\n     * @throws {APIError} if the API request to create a Payload Signature fails.\n     * @throws {Error} if the address does not have a private key loaded or an associated Server-Signer.\n     */\n    async createPayloadSignature(unsignedPayload) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot sign payload with address without private key loaded\");\n        }\n        let signature = undefined;\n        if (!coinbase_1.Coinbase.useServerSigner) {\n            signature = this.key.signingKey.sign(unsignedPayload).serialized;\n        }\n        const createPayloadSignatureRequest = {\n            unsigned_payload: unsignedPayload,\n            signature,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.address.createPayloadSignature(this.getWalletId(), this.getId(), createPayloadSignatureRequest);\n        const payloadSignature = new payload_signature_1.PayloadSignature(response.data);\n        return payloadSignature;\n    }\n    /**\n     * Gets a Payload Signature.\n     *\n     * @param payloadSignatureId - The ID of the Payload Signature to fetch.\n     * @returns A promise that resolves to the Payload Signature object.\n     * @throws {APIError} if the API request to get the Payload Signature fails.\n     */\n    async getPayloadSignature(payloadSignatureId) {\n        const response = await coinbase_1.Coinbase.apiClients.address.getPayloadSignature(this.getWalletId(), this.getId(), payloadSignatureId);\n        const payloadSignature = new payload_signature_1.PayloadSignature(response.data);\n        return payloadSignature;\n    }\n    /**\n     * Lists all the Payload Signatures associated with the Address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Payload Signatures to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Payload Signatures. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns A promise that resolves to the paginated list response of Payload Signatures.\n     * @throws {APIError} if the API request to list the Payload Signatures fails.\n     */\n    async listPayloadSignatures({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.address.listPayloadSignatures(this.model.wallet_id, this.model.address_id, 100, page?.length ? page : undefined);\n        response.data.data.forEach(payloadSignatureModel => {\n            data.push(new payload_signature_1.PayloadSignature(payloadSignatureModel));\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Fund the address from your account on the Coinbase Platform.\n     *\n     * @param options - The options to create the fund operation\n     * @param options.amount - The amount of the Asset to fund the wallet with\n     * @param options.assetId - The ID of the Asset to fund with. For Ether, eth, gwei, and wei are supported.\n     * @returns The created fund operation object\n     */\n    async fund({ amount, assetId }) {\n        const normalizedAmount = new decimal_js_1.Decimal(amount.toString());\n        return fund_operation_1.FundOperation.create(this.getWalletId(), this.getId(), normalizedAmount, assetId, this.getNetworkId());\n    }\n    /**\n     * Get a quote for funding the address from your Coinbase platform account.\n     *\n     * @param options - The options to create the fund quote\n     * @param options.amount - The amount to fund\n     * @param options.assetId - The ID of the Asset to fund with. For Ether, eth, gwei, and wei are supported.\n     * @returns The fund quote object\n     */\n    async quoteFund({ amount, assetId }) {\n        const normalizedAmount = new decimal_js_1.Decimal(amount.toString());\n        return fund_quote_1.FundQuote.create(this.getWalletId(), this.getId(), normalizedAmount, assetId, this.getNetworkId());\n    }\n    /**\n     * Returns all the fund operations associated with the address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Fund Operations to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Fund Operations. Don't include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of fund operations.\n     */\n    async listFundOperations({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        return fund_operation_1.FundOperation.listFundOperations(this.model.wallet_id, this.model.address_id, {\n            limit,\n            page,\n        });\n    }\n    /**\n     * Returns the address and network ID of the given destination.\n     *\n     * @param destination - The destination to get the address and network ID of.\n     * @returns The address and network ID of the destination.\n     */\n    async getDestinationAddressAndNetwork(destination) {\n        if (typeof destination !== \"string\" && destination.getNetworkId() !== this.getNetworkId()) {\n            throw new errors_1.ArgumentError(\"Transfer must be on the same Network\");\n        }\n        if (destination instanceof wallet_1.Wallet) {\n            return [(await destination.getDefaultAddress()).getId(), destination.getNetworkId()];\n        }\n        if (destination instanceof address_1.Address) {\n            return [destination.getId(), destination.getNetworkId()];\n        }\n        return [destination, this.getNetworkId()];\n    }\n    /**\n     * Creates a trade model for the specified amount and assets.\n     *\n     * @param amount - The amount of the Asset to send.\n     * @param fromAsset - The Asset to trade from.\n     * @param toAsset - The Asset to trade to.\n     * @returns A promise that resolves to a Trade object representing the new trade.\n     */\n    async createTradeRequest(amount, fromAsset, toAsset) {\n        const tradeRequestPayload = {\n            amount: fromAsset.toAtomicAmount(new decimal_js_1.Decimal(amount.toString())).toString(),\n            from_asset_id: fromAsset.primaryDenomination(),\n            to_asset_id: toAsset.primaryDenomination(),\n        };\n        const tradeModel = await coinbase_1.Coinbase.apiClients.trade.createTrade(this.getWalletId(), this.getId(), tradeRequestPayload);\n        return new trade_1.Trade(tradeModel?.data);\n    }\n    /**\n     * Checks if trading is possible and raises an error if not.\n     *\n     * @param amount - The amount of the Asset to send.\n     * @param fromAssetId - The ID of the Asset to trade from. For Ether, eth, gwei, and wei are supported.\n     * @throws {Error} If the private key is not loaded, or if the asset IDs are unsupported, or if there are insufficient funds.\n     */\n    async validateCanTrade(amount, fromAssetId) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot trade from address without private key loaded\");\n        }\n        const currentBalance = await this.getBalance(fromAssetId);\n        amount = new decimal_js_1.Decimal(amount.toString());\n        if (currentBalance.lessThan(amount)) {\n            throw new Error(`Insufficient funds: ${amount} requested, but only ${currentBalance} available`);\n        }\n    }\n    /**\n     * Creates a staking operation to stake, signs it, and broadcasts it on the blockchain.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset to the staking operation.\n     * @param action - The type of staking action to perform.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @throws {APIError} if the API request to create or broadcast staking operation fails.\n     * @throws {Error} if the amount is less than zero.\n     * @returns The staking operation after it's completed fully.\n     */\n    async createStakingOperation(amount, assetId, action, mode, options, timeoutSeconds, intervalSeconds) {\n        if (new decimal_js_1.Decimal(amount.toString()).lessThanOrEqualTo(0)) {\n            throw new Error(\"Amount required greater than zero.\");\n        }\n        let stakingOperation = await this.createStakingOperationRequest(amount, assetId, action, mode, options);\n        const startTime = Date.now();\n        // Loop until the timeout is reached.\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            // Loop through any unsigned transactions that are available, sign and broadcast them.\n            for (let i = 0; i < stakingOperation.getTransactions().length; i++) {\n                const transaction = stakingOperation.getTransactions()[i];\n                if (!transaction.isSigned()) {\n                    await transaction.sign(this.key);\n                    stakingOperation = await this.broadcastStakingOperationRequest(stakingOperation.getID(), transaction.getSignedPayload().slice(2), i);\n                }\n            }\n            await stakingOperation.reload();\n            if (stakingOperation.isTerminalState()) {\n                return stakingOperation;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new Error(\"Staking Operation timed out\");\n    }\n    /**\n     * A helper function that creates the staking operation.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param action - The type of staking action to perform.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @private\n     * @throws {APIError} if the API request to create staking operation fails.\n     * @returns The created staking operation.\n     */\n    async createStakingOperationRequest(amount, assetId, action, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        const asset = await asset_1.Asset.fetch(this.getNetworkId(), assetId);\n        options.amount = asset.toAtomicAmount(new decimal_js_1.Decimal(amount.toString())).toString();\n        options.mode = mode ? mode : types_1.StakeOptionsMode.DEFAULT;\n        const stakingOperationRequest = {\n            network_id: this.getNetworkId(),\n            asset_id: asset_1.Asset.primaryDenomination(assetId),\n            action: action,\n            options: options,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.walletStake.createStakingOperation(this.getWalletId(), this.getId(), stakingOperationRequest);\n        return new staking_operation_1.StakingOperation(response.data);\n    }\n    /**\n     * A helper function that broadcasts the signed payload.\n     *\n     * @param stakingOperationID - The staking operation id related to the signed payload.\n     * @param signedPayload - The payload that's being broadcasted.\n     * @param transactionIndex - The index of the transaction in the array from the staking operation.\n     * @private\n     * @returns An updated staking operation with the broadcasted transaction.\n     */\n    async broadcastStakingOperationRequest(stakingOperationID, signedPayload, transactionIndex) {\n        const broadcastStakingOperationRequest = {\n            signed_payload: signedPayload,\n            transaction_index: transactionIndex,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.walletStake.broadcastStakingOperation(this.getWalletId(), this.getId(), stakingOperationID, broadcastStakingOperationRequest);\n        return new staking_operation_1.StakingOperation(response.data);\n    }\n}\nexports.WalletAddress = WalletAddress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FkZHJlc3Mvd2FsbGV0X2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLGlFQUFRO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHNGQUFjO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLHdGQUFZO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLG9GQUFVO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFhO0FBQ3hDLGlCQUFpQixtQkFBTyxDQUFDLHNGQUFXO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLG9GQUFVO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFhO0FBQ3hDLDhCQUE4QixtQkFBTyxDQUFDLGdIQUF3QjtBQUM5RCxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBVTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBVTtBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyxzRkFBVztBQUNwQyw0QkFBNEIsbUJBQU8sQ0FBQyw0R0FBc0I7QUFDMUQsNEJBQTRCLG1CQUFPLENBQUMsNEdBQXNCO0FBQzFELHlCQUF5QixtQkFBTyxDQUFDLHNHQUFtQjtBQUNwRCx5QkFBeUIsbUJBQU8sQ0FBQyxzR0FBbUI7QUFDcEQscUJBQXFCLG1CQUFPLENBQUMsOEZBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWMsYUFBYSxpQkFBaUIsb0JBQW9CLGdCQUFnQixtQkFBbUIsR0FBRztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrRUFBa0UsSUFBSTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtFQUFrRSxJQUFJO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLDJCQUEyQixzRUFBc0U7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxrQkFBa0Isc0JBQXNCLGdCQUFnQjtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBLDJCQUEyQixzREFBc0Q7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGtCQUFrQixzQkFBc0IsZ0JBQWdCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyQkFBMkI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1QkFBdUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSwyQkFBMkIsb0VBQW9FO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQix3QkFBd0I7QUFDekMsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLHdCQUF3QjtBQUN6QyxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUIsd0JBQXdCO0FBQ3pDLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0EsaUNBQWlDLG9FQUFvRTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSxrQ0FBa0Msa0VBQWtFLElBQUk7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0VBQWtFLElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVEsc0JBQXNCLGdCQUFnQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtDQUErQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBLHNIQUFzSDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9hZGRyZXNzL3dhbGxldF9hZGRyZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XYWxsZXRBZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgZGVjaW1hbF9qc18xID0gcmVxdWlyZShcImRlY2ltYWwuanNcIik7XG5jb25zdCBldGhlcnNfMSA9IHJlcXVpcmUoXCJldGhlcnNcIik7XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jbGllbnRcIik7XG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzc1wiKTtcbmNvbnN0IGFzc2V0XzEgPSByZXF1aXJlKFwiLi4vYXNzZXRcIik7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4uL2NvaW5iYXNlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdHJhZGVfMSA9IHJlcXVpcmUoXCIuLi90cmFkZVwiKTtcbmNvbnN0IHRyYW5zZmVyXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNmZXJcIik7XG5jb25zdCBjb250cmFjdF9pbnZvY2F0aW9uXzEgPSByZXF1aXJlKFwiLi4vY29udHJhY3RfaW52b2NhdGlvblwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3Qgd2FsbGV0XzEgPSByZXF1aXJlKFwiLi4vd2FsbGV0XCIpO1xuY29uc3Qgc3Rha2luZ19vcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zdGFraW5nX29wZXJhdGlvblwiKTtcbmNvbnN0IHBheWxvYWRfc2lnbmF0dXJlXzEgPSByZXF1aXJlKFwiLi4vcGF5bG9hZF9zaWduYXR1cmVcIik7XG5jb25zdCBzbWFydF9jb250cmFjdF8xID0gcmVxdWlyZShcIi4uL3NtYXJ0X2NvbnRyYWN0XCIpO1xuY29uc3QgZnVuZF9vcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9mdW5kX29wZXJhdGlvblwiKTtcbmNvbnN0IGZ1bmRfcXVvdGVfMSA9IHJlcXVpcmUoXCIuLi9mdW5kX3F1b3RlXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgYmxvY2tjaGFpbiBhZGRyZXNzLCB3aGljaCBpcyBhIHdhbGxldC1jb250cm9sbGVkIGFjY291bnQgb24gYSBuZXR3b3JrLlxuICovXG5jbGFzcyBXYWxsZXRBZGRyZXNzIGV4dGVuZHMgYWRkcmVzc18xLkFkZHJlc3Mge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IFdhbGxldCBBZGRyZXNzIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIGFkZHJlc3MgbW9kZWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGV0aGVycy5qcyBTaWduaW5nS2V5IHRoZSBBZGRyZXNzIHVzZXMgdG8gc2lnbiBkYXRhLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgYWRkcmVzcyBtb2RlbCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCwga2V5KSB7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFkZHJlc3MgbW9kZWwgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG1vZGVsLm5ldHdvcmtfaWQsIG1vZGVsLmFkZHJlc3NfaWQpO1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB3YWxsZXQgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgd2FsbGV0IGFkZHJlc3MuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgV2FsbGV0QWRkcmVzc3sgYWRkcmVzc0lkOiAnJHt0aGlzLmdldElkKCl9JywgbmV0d29ya0lkOiAnJHt0aGlzLmdldE5ldHdvcmtJZCgpfScsIHdhbGxldElkOiAnJHt0aGlzLmdldFdhbGxldElkKCl9JyB9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2FsbGV0IElELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHdhbGxldCBJRC5cbiAgICAgKi9cbiAgICBnZXRXYWxsZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwud2FsbGV0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUgZXRoZXJzLmpzIFNpZ25pbmdLZXkgdGhlIEFkZHJlc3MgdXNlcyB0byBzaWduIGRhdGEuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcml2YXRlIGtleSBpcyBhbHJlYWR5IHNldC5cbiAgICAgKi9cbiAgICBzZXRLZXkoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcml2YXRlIGtleSBpcyBhbHJlYWR5IHNldFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgQWRkcmVzcydzIHByaXZhdGUga2V5IHRvIGEgaGV4IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBBZGRyZXNzJ3MgcHJpdmF0ZSBrZXkgYXMgYSBoZXggc3RyaW5nLlxuICAgICAqL1xuICAgIGV4cG9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMua2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByaXZhdGUga2V5IGlzIG5vdCBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMua2V5LnByaXZhdGVLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgQWRkcmVzcyBoYXMgYSBwcml2YXRlIGtleSBiYWNraW5nIGl0IHRvIHNpZ24gdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgQWRkcmVzcyBoYXMgYSBwcml2YXRlIGtleSBiYWNraW5nIGl0IHRvIHNpZ24gdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGNhblNpZ24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMua2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgdHJhZGVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBUcmFkZXMgdG8gcmV0dXJuLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFnZSAtIFRoZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIFRyYWRlcy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYWdpbmF0ZWQgbGlzdCByZXNwb25zZSBvZiB0cmFkZXMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFRyYWRlcyh7IGxpbWl0ID0gY29pbmJhc2VfMS5Db2luYmFzZS5kZWZhdWx0UGFnZUxpbWl0LCBwYWdlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBsZXQgbmV4dFBhZ2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnRyYWRlLmxpc3RUcmFkZXModGhpcy5tb2RlbC53YWxsZXRfaWQsIHRoaXMubW9kZWwuYWRkcmVzc19pZCwgbGltaXQsIHBhZ2UpO1xuICAgICAgICByZXNwb25zZS5kYXRhLmRhdGEuZm9yRWFjaCh0cmFkZU1vZGVsID0+IHtcbiAgICAgICAgICAgIGRhdGEucHVzaChuZXcgdHJhZGVfMS5UcmFkZSh0cmFkZU1vZGVsKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYXNNb3JlID0gcmVzcG9uc2UuZGF0YS5oYXNfbW9yZTtcbiAgICAgICAgaWYgKGhhc01vcmUpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSkge1xuICAgICAgICAgICAgICAgIG5leHRQYWdlID0gcmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBoYXNNb3JlLFxuICAgICAgICAgICAgbmV4dFBhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHRoZSB0cmFuc2ZlcnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcGFnaW5hdGlvbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIFRyYW5zZmVycyB0byByZXR1cm4uIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYWdlIC0gVGhlIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgVHJhbnNmZXJzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHQgcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhZ2luYXRlZCBsaXN0IHJlc3BvbnNlIG9mIHRyYW5zZmVycy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VHJhbnNmZXJzKHsgbGltaXQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLmRlZmF1bHRQYWdlTGltaXQsIHBhZ2UgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGxldCBuZXh0UGFnZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMudHJhbnNmZXIubGlzdFRyYW5zZmVycyh0aGlzLm1vZGVsLndhbGxldF9pZCwgdGhpcy5tb2RlbC5hZGRyZXNzX2lkLCBsaW1pdCwgcGFnZSk7XG4gICAgICAgIHJlc3BvbnNlLmRhdGEuZGF0YS5mb3JFYWNoKHRyYW5zZmVyTW9kZWwgPT4ge1xuICAgICAgICAgICAgZGF0YS5wdXNoKHRyYW5zZmVyXzEuVHJhbnNmZXIuZnJvbU1vZGVsKHRyYW5zZmVyTW9kZWwpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhc01vcmUgPSByZXNwb25zZS5kYXRhLmhhc19tb3JlO1xuICAgICAgICBpZiAoaGFzTW9yZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBhZ2UgPSByZXNwb25zZS5kYXRhLm5leHRfcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGhhc01vcmUsXG4gICAgICAgICAgICBuZXh0UGFnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmZXJzIHRoZSBnaXZlbiBhbW91bnQgb2YgdGhlIGdpdmVuIEFzc2V0IHRvIHRoZSBnaXZlbiBhZGRyZXNzLlxuICAgICAqIE9ubHkgc2FtZS1OZXR3b3JrIFRyYW5zZmVycyBhcmUgc3VwcG9ydGVkLlxuICAgICAqIFRoaXMgcmV0dXJucyBhIGBUcmFuc2ZlcmAgb2JqZWN0IHRoYXQgaGFzIGJlZW4gc2lnbmVkIGFuZCBicm9hZGNhc3RlZCwgeW91XG4gICAgICogY2FuIHdhaXQgZm9yIHRoaXMgdG8gbGFuZCBvbi1jaGFpbiAob3IgZmFpbCkgYnkgY2FsbGluZyBgdHJhbnNmZXIud2FpdCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBUcmFuc2Zlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBBc3NldCB0byBzZW5kLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIHNlbmQuIEZvciBFdGhlciwgQ29pbmJhc2UuYXNzZXRzLkV0aCwgQ29pbmJhc2UuYXNzZXRzLkd3ZWksIGFuZCBDb2luYmFzZS5hc3NldHMuV2VpIHN1cHBvcnRlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZXN0aW5hdGlvbiAtIFRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgdHJhbnNmZXIuIElmIGEgV2FsbGV0LCBzZW5kcyB0byB0aGUgV2FsbGV0J3MgZGVmYXVsdCBhZGRyZXNzLiBJZiBhIFN0cmluZywgaW50ZXJwcmV0cyBpdCBhcyB0aGUgYWRkcmVzcyBJRC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nYXNsZXNzIC0gV2hldGhlciB0aGUgVHJhbnNmZXIgc2hvdWxkIGJlIGdhc2xlc3MuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNraXBCYXRjaGluZyAtIFdoZW4gdHJ1ZSwgdGhlIFRyYW5zZmVyIHdpbGwgYmUgc3VibWl0dGVkIGltbWVkaWF0ZWx5LiBPdGhlcndpc2UsIHRoZSBUcmFuc2ZlciB3aWxsIGJlIGJhdGNoZWQuIERlZmF1bHRzIHRvIGZhbHNlLiBOb3RlOiByZXF1aXJlcyBnYXNsZXNzIG9wdGlvbiB0byBiZSBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNmZXIgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIGEgVHJhbnNmZXIgZmFpbHMuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBicm9hZGNhc3QgYSBUcmFuc2ZlciBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVUcmFuc2Zlcih7IGFtb3VudCwgYXNzZXRJZCwgZGVzdGluYXRpb24sIGdhc2xlc3MgPSBmYWxzZSwgc2tpcEJhdGNoaW5nID0gZmFsc2UsIH0pIHtcbiAgICAgICAgaWYgKCFjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lciAmJiAhdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0cmFuc2ZlciBmcm9tIGFkZHJlc3Mgd2l0aG91dCBwcml2YXRlIGtleSBsb2FkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXNzZXQgPSBhd2FpdCBhc3NldF8xLkFzc2V0LmZldGNoKHRoaXMuZ2V0TmV0d29ya0lkKCksIGFzc2V0SWQpO1xuICAgICAgICBjb25zdCBbZGVzdGluYXRpb25BZGRyZXNzLCBkZXN0aW5hdGlvbk5ldHdvcmtJZF0gPSBhd2FpdCB0aGlzLmdldERlc3RpbmF0aW9uQWRkcmVzc0FuZE5ldHdvcmsoZGVzdGluYXRpb24pO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQW1vdW50ID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKGFtb3VudC50b1N0cmluZygpKTtcbiAgICAgICAgY29uc3QgY3VycmVudEJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2UoYXNzZXRJZCk7XG4gICAgICAgIGlmIChjdXJyZW50QmFsYW5jZS5sZXNzVGhhbihub3JtYWxpemVkQW1vdW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoYEluc3VmZmljaWVudCBmdW5kczogJHtub3JtYWxpemVkQW1vdW50fSByZXF1ZXN0ZWQsIGJ1dCBvbmx5ICR7Y3VycmVudEJhbGFuY2V9IGF2YWlsYWJsZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwQmF0Y2hpbmcgJiYgIWdhc2xlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwic2tpcEJhdGNoaW5nIHJlcXVpcmVzIGdhc2xlc3MgdG8gYmUgdHJ1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVUcmFuc2ZlclJlcXVlc3QgPSB7XG4gICAgICAgICAgICBhbW91bnQ6IGFzc2V0LnRvQXRvbWljQW1vdW50KG5vcm1hbGl6ZWRBbW91bnQpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBuZXR3b3JrX2lkOiBkZXN0aW5hdGlvbk5ldHdvcmtJZCxcbiAgICAgICAgICAgIGFzc2V0X2lkOiBhc3NldC5wcmltYXJ5RGVub21pbmF0aW9uKCksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb25BZGRyZXNzLFxuICAgICAgICAgICAgZ2FzbGVzczogZ2FzbGVzcyxcbiAgICAgICAgICAgIHNraXBfYmF0Y2hpbmc6IHNraXBCYXRjaGluZyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMudHJhbnNmZXIuY3JlYXRlVHJhbnNmZXIodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldElkKCksIGNyZWF0ZVRyYW5zZmVyUmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHRyYW5zZmVyID0gdHJhbnNmZXJfMS5UcmFuc2Zlci5mcm9tTW9kZWwocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIGlmIChjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZmVyO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRyYW5zZmVyLnNpZ24odGhpcy5nZXRTaWduZXIoKSk7XG4gICAgICAgIGF3YWl0IHRyYW5zZmVyLmJyb2FkY2FzdCgpO1xuICAgICAgICByZXR1cm4gdHJhbnNmZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBzaWduZXIgZm9yIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduZXIgZm9yIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHByaXZhdGUga2V5IGlzIG5vdCBsb2FkZWQuXG4gICAgICovXG4gICAgZ2V0U2lnbmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMua2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2lnbiB3aXRob3V0IGEgcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBldGhlcnNfMS5ldGhlcnMuV2FsbGV0KHRoaXMua2V5LnByaXZhdGVLZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFkZXMgdGhlIGdpdmVuIGFtb3VudCBvZiB0aGUgZ2l2ZW4gQXNzZXQgZm9yIGFub3RoZXIgQXNzZXQuIE9ubHkgc2FtZS1uZXR3b3JrIFRyYWRlcyBhcmUgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjcmVhdGUgdGhlIFRyYWRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIEZyb20gQXNzZXQgdG8gc2VuZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mcm9tQXNzZXRJZCAtIFRoZSBJRCBvZiB0aGUgQXNzZXQgdG8gdHJhZGUgZnJvbS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50b0Fzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIHRyYWRlIHRvLlxuICAgICAqIEByZXR1cm5zIFRoZSBUcmFkZSBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgb3IgYnJvYWRjYXN0IGEgVHJhZGUgZmFpbHMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBUcmFkZSB0aW1lcyBvdXQuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVHJhZGUoeyBhbW91bnQsIGZyb21Bc3NldElkLCB0b0Fzc2V0SWQgfSkge1xuICAgICAgICBjb25zdCBmcm9tQXNzZXQgPSBhd2FpdCBhc3NldF8xLkFzc2V0LmZldGNoKHRoaXMuZ2V0TmV0d29ya0lkKCksIGZyb21Bc3NldElkKTtcbiAgICAgICAgY29uc3QgdG9Bc3NldCA9IGF3YWl0IGFzc2V0XzEuQXNzZXQuZmV0Y2godGhpcy5nZXROZXR3b3JrSWQoKSwgdG9Bc3NldElkKTtcbiAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUNhblRyYWRlKGFtb3VudCwgZnJvbUFzc2V0SWQpO1xuICAgICAgICBjb25zdCB0cmFkZSA9IGF3YWl0IHRoaXMuY3JlYXRlVHJhZGVSZXF1ZXN0KGFtb3VudCwgZnJvbUFzc2V0LCB0b0Fzc2V0KTtcbiAgICAgICAgaWYgKGNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhZGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdHJhZGUuc2lnbih0aGlzLmdldFNpZ25lcigpKTtcbiAgICAgICAgYXdhaXQgdHJhZGUuYnJvYWRjYXN0KCk7XG4gICAgICAgIHJldHVybiB0cmFkZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyBhIGNvbnRyYWN0IHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGludm9rZSB0aGUgY29udHJhY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb250cmFjdEFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgdGhlIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWV0aG9kIC0gVGhlIG1ldGhvZCB0byBpbnZva2Ugb24gdGhlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFiaSAtIFRoZSBBQkkgb2YgdGhlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGNvbnRyYWN0IG1ldGhvZCBpbnZvY2F0aW9uLlxuICAgICAqICAgVGhlIGtleXMgc2hvdWxkIGJlIHRoZSBhcmd1bWVudCBuYW1lcyBhbmQgdGhlIHZhbHVlcyBzaG91bGQgYmUgdGhlIGFyZ3VtZW50IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBhc3NldCB0byBzZW5kIHRvIGEgcGF5YWJsZSBjb250cmFjdCBtZXRob2QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXNzZXRJZCAtIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gc2VuZCB0byBhIHBheWFibGUgY29udHJhY3QgbWV0aG9kLlxuICAgICAqICAgVGhlIGFzc2V0IG11c3QgYmUgYSBkZW5vbWluYXRpb24gb2YgdGhlIG5hdGl2ZSBhc3NldC4gKEV4LiBcIndlaVwiLCBcImd3ZWlcIiwgb3IgXCJldGhcIikuXG4gICAgICogQHJldHVybnMgVGhlIENvbnRyYWN0SW52b2NhdGlvbiBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBjb250cmFjdCBpbnZvY2F0aW9uIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgYWRkcmVzcyBjYW5ub3Qgc2lnbi5cbiAgICAgKiBAdGhyb3dzIHtBcmd1bWVudEVycm9yfSBpZiB0aGUgYWRkcmVzcyBkb2VzIG5vdCBoYXZlIHN1ZmZpY2llbnQgYmFsYW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2VDb250cmFjdCh7IGNvbnRyYWN0QWRkcmVzcywgbWV0aG9kLCBhYmksIGFyZ3MsIGFtb3VudCwgYXNzZXRJZCwgfSkge1xuICAgICAgICBpZiAoIWNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyICYmICF0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGludm9rZSBjb250cmFjdCBmcm9tIGFkZHJlc3Mgd2l0aG91dCBwcml2YXRlIGtleSBsb2FkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFtb3VudCAmJiAhYXNzZXRJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoXCJBc3NldCBJRCBpcyByZXF1aXJlZCBmb3IgY29udHJhY3QgaXZvY2F0aW9uIGlmIGFuIGFtb3VudCBpcyBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXRvbWljQW1vdW50O1xuICAgICAgICBpZiAoYXNzZXRJZCAmJiBhbW91bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0ID0gYXdhaXQgYXNzZXRfMS5Bc3NldC5mZXRjaCh0aGlzLmdldE5ldHdvcmtJZCgpLCBhc3NldElkKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBbW91bnQgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2UoYXNzZXRJZCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudEJhbGFuY2UubGVzc1RoYW4obm9ybWFsaXplZEFtb3VudCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihgSW5zdWZmaWNpZW50IGZ1bmRzOiAke25vcm1hbGl6ZWRBbW91bnR9IHJlcXVlc3RlZCwgYnV0IG9ubHkgJHtjdXJyZW50QmFsYW5jZX0gYXZhaWxhYmxlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdG9taWNBbW91bnQgPSBhc3NldC50b0F0b21pY0Ftb3VudChub3JtYWxpemVkQW1vdW50KS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0SW52b2NhdGlvbiA9IGF3YWl0IHRoaXMuY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uKGNvbnRyYWN0QWRkcmVzcywgbWV0aG9kLCBhYmksIGFyZ3MsIGF0b21pY0Ftb3VudCk7XG4gICAgICAgIGlmIChjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0SW52b2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBjb250cmFjdEludm9jYXRpb24uc2lnbih0aGlzLmdldFNpZ25lcigpKTtcbiAgICAgICAgYXdhaXQgY29udHJhY3RJbnZvY2F0aW9uLmJyb2FkY2FzdCgpO1xuICAgICAgICByZXR1cm4gY29udHJhY3RJbnZvY2F0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBsb3lzIGFuIEVSQzIwIHRva2VuIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIEVSQzIwIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgRVJDMjAgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3ltYm9sIC0gVGhlIHN5bWJvbCBvZiB0aGUgRVJDMjAgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMudG90YWxTdXBwbHkgLSBUaGUgdG90YWwgc3VwcGx5IG9mIHRoZSBFUkMyMCB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVwbG95ZWQgU21hcnRDb250cmFjdCBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IElmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBzbWFydCBjb250cmFjdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lUb2tlbih7IG5hbWUsIHN5bWJvbCwgdG90YWxTdXBwbHksIH0pIHtcbiAgICAgICAgaWYgKCFjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lciAmJiAhdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkZXBsb3kgRVJDMjAgd2l0aG91dCBwcml2YXRlIGtleSBsb2FkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc21hcnRDb250cmFjdCA9IGF3YWl0IHRoaXMuY3JlYXRlRVJDMjAoeyBuYW1lLCBzeW1ib2wsIHRvdGFsU3VwcGx5IH0pO1xuICAgICAgICBpZiAoY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzbWFydENvbnRyYWN0O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHNtYXJ0Q29udHJhY3Quc2lnbih0aGlzLmdldFNpZ25lcigpKTtcbiAgICAgICAgYXdhaXQgc21hcnRDb250cmFjdC5icm9hZGNhc3QoKTtcbiAgICAgICAgcmV0dXJuIHNtYXJ0Q29udHJhY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYW4gRVJDNzIxIHRva2VuIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIEVSQzcyMSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEVSQzcyMSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zeW1ib2wgLSBUaGUgc3ltYm9sIG9mIHRoZSBFUkM3MjEgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYmFzZVVSSSAtIFRoZSBiYXNlIFVSSSBvZiB0aGUgRVJDNzIxIHRva2VuLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXBsb3llZCBTbWFydENvbnRyYWN0IG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gSWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIHNtYXJ0IGNvbnRyYWN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGRlcGxveU5GVCh7IG5hbWUsIHN5bWJvbCwgYmFzZVVSSSB9KSB7XG4gICAgICAgIGlmICghY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIgJiYgIXRoaXMua2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGVwbG95IEVSQzcyMSB3aXRob3V0IHByaXZhdGUga2V5IGxvYWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbWFydENvbnRyYWN0ID0gYXdhaXQgdGhpcy5jcmVhdGVFUkM3MjEoeyBuYW1lLCBzeW1ib2wsIGJhc2VVUkkgfSk7XG4gICAgICAgIGlmIChjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgcmV0dXJuIHNtYXJ0Q29udHJhY3Q7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgc21hcnRDb250cmFjdC5zaWduKHRoaXMuZ2V0U2lnbmVyKCkpO1xuICAgICAgICBhd2FpdCBzbWFydENvbnRyYWN0LmJyb2FkY2FzdCgpO1xuICAgICAgICByZXR1cm4gc21hcnRDb250cmFjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhbiBFUkMxMTU1IG11bHRpLXRva2VuIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIEVSQzExNTUgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMudXJpIC0gVGhlIFVSSSBmb3IgYWxsIHRva2VuIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXBsb3llZCBTbWFydENvbnRyYWN0IG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gSWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIHNtYXJ0IGNvbnRyYWN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGRlcGxveU11bHRpVG9rZW4oeyB1cmkgfSkge1xuICAgICAgICBpZiAoIWNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyICYmICF0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRlcGxveSBFUkMxMTU1IHdpdGhvdXQgcHJpdmF0ZSBrZXkgbG9hZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNtYXJ0Q29udHJhY3QgPSBhd2FpdCB0aGlzLmNyZWF0ZUVSQzExNTUoeyB1cmkgfSk7XG4gICAgICAgIGlmIChjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgcmV0dXJuIHNtYXJ0Q29udHJhY3Q7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgc21hcnRDb250cmFjdC5zaWduKHRoaXMuZ2V0U2lnbmVyKCkpO1xuICAgICAgICBhd2FpdCBzbWFydENvbnRyYWN0LmJyb2FkY2FzdCgpO1xuICAgICAgICByZXR1cm4gc21hcnRDb250cmFjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhIGN1c3RvbSBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBjdXN0b20gY29udHJhY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc29saWRpdHlWZXJzaW9uIC0gVGhlIHZlcnNpb24gb2YgdGhlIHNvbGlkaXR5IGNvbXBpbGVyLCBtdXN0IGJlIDAuOC4rLCBzdWNoIGFzIFwiMC44LjI4K2NvbW1pdC43ODkzNjE0YVwiLiBTZWUgaHR0cHM6Ly9iaW5hcmllcy5zb2xpZGl0eWxhbmcub3JnL2Jpbi9saXN0Lmpzb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zb2xpZGl0eUlucHV0SnNvbiAtIFRoZSBpbnB1dCBqc29uIGZvciB0aGUgc29saWRpdHkgY29tcGlsZXIuIFNlZSBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvdXNpbmctdGhlLWNvbXBpbGVyLmh0bWwjaW5wdXQtZGVzY3JpcHRpb24gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb250cmFjdE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29udHJhY3QgY2xhc3MgdG8gYmUgZGVwbG95ZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29uc3RydWN0b3JBcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXBsb3llZCBTbWFydENvbnRyYWN0IG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gSWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIHNtYXJ0IGNvbnRyYWN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGRlcGxveUNvbnRyYWN0KHsgc29saWRpdHlWZXJzaW9uLCBzb2xpZGl0eUlucHV0SnNvbiwgY29udHJhY3ROYW1lLCBjb25zdHJ1Y3RvckFyZ3MsIH0pIHtcbiAgICAgICAgaWYgKCFjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lciAmJiAhdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkZXBsb3kgY3VzdG9tIGNvbnRyYWN0IHdpdGhvdXQgcHJpdmF0ZSBrZXkgbG9hZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNtYXJ0Q29udHJhY3QgPSBhd2FpdCB0aGlzLmNyZWF0ZUN1c3RvbUNvbnRyYWN0KHtcbiAgICAgICAgICAgIHNvbGlkaXR5VmVyc2lvbixcbiAgICAgICAgICAgIHNvbGlkaXR5SW5wdXRKc29uLFxuICAgICAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICAgICAgY29uc3RydWN0b3JBcmdzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc21hcnRDb250cmFjdDtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzbWFydENvbnRyYWN0LnNpZ24odGhpcy5nZXRTaWduZXIoKSk7XG4gICAgICAgIGF3YWl0IHNtYXJ0Q29udHJhY3QuYnJvYWRjYXN0KCk7XG4gICAgICAgIHJldHVybiBzbWFydENvbnRyYWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIEVSQzIwIHRva2VuIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUVSQzIwT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgRVJDMjAgdG9rZW4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBFUkMyMCB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zeW1ib2wgLSBUaGUgc3ltYm9sIG9mIHRoZSBFUkMyMCB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gb3B0aW9ucy50b3RhbFN1cHBseSAtIFRoZSB0b3RhbCBzdXBwbHkgb2YgdGhlIEVSQzIwIHRva2VuLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNtYXJ0Q29udHJhY3Q+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY3JlYXRlZCBTbWFydENvbnRyYWN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBJZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIGEgc21hcnQgY29udHJhY3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRVJDMjAoeyBuYW1lLCBzeW1ib2wsIHRvdGFsU3VwcGx5LCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc21hcnRDb250cmFjdC5jcmVhdGVTbWFydENvbnRyYWN0KHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRJZCgpLCB7XG4gICAgICAgICAgICB0eXBlOiBjbGllbnRfMS5TbWFydENvbnRyYWN0VHlwZS5FcmMyMCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHN5bWJvbCxcbiAgICAgICAgICAgICAgICB0b3RhbF9zdXBwbHk6IHRvdGFsU3VwcGx5LnRvU3RyaW5nKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNtYXJ0X2NvbnRyYWN0XzEuU21hcnRDb250cmFjdC5mcm9tTW9kZWwocmVzcD8uZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gRVJDNzIxIHRva2VuIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIEVSQzcyMSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEVSQzcyMSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zeW1ib2wgLSBUaGUgc3ltYm9sIG9mIHRoZSBFUkM3MjEgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYmFzZVVSSSAtIFRoZSBiYXNlIFVSSSBvZiB0aGUgRVJDNzIxIHRva2VuLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXBsb3llZCBTbWFydENvbnRyYWN0IG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gSWYgdGhlIHByaXZhdGUga2V5IGlzIG5vdCBsb2FkZWQgd2hlbiBub3QgdXNpbmcgc2VydmVyIHNpZ25lci5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVFUkM3MjEoeyBuYW1lLCBzeW1ib2wsIGJhc2VVUkksIH0pIHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zbWFydENvbnRyYWN0LmNyZWF0ZVNtYXJ0Q29udHJhY3QodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldElkKCksIHtcbiAgICAgICAgICAgIHR5cGU6IGNsaWVudF8xLlNtYXJ0Q29udHJhY3RUeXBlLkVyYzcyMSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHN5bWJvbCxcbiAgICAgICAgICAgICAgICBiYXNlX3VyaTogYmFzZVVSSSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc21hcnRfY29udHJhY3RfMS5TbWFydENvbnRyYWN0LmZyb21Nb2RlbChyZXNwPy5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBFUkMxMTU1IG11bHRpLXRva2VuIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUVSQzExNTVPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBFUkMxMTU1IHRva2VuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVyaSAtIFRoZSBVUkkgZm9yIGFsbCB0b2tlbiBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTbWFydENvbnRyYWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNyZWF0ZWQgU21hcnRDb250cmFjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gSWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIHNtYXJ0IGNvbnRyYWN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUVSQzExNTUoeyB1cmkgfSkge1xuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnNtYXJ0Q29udHJhY3QuY3JlYXRlU21hcnRDb250cmFjdCh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0SWQoKSwge1xuICAgICAgICAgICAgdHlwZTogY2xpZW50XzEuU21hcnRDb250cmFjdFR5cGUuRXJjMTE1NSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB1cmksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNtYXJ0X2NvbnRyYWN0XzEuU21hcnRDb250cmFjdC5mcm9tTW9kZWwocmVzcD8uZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjdXN0b20gY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q3JlYXRlQ3VzdG9tQ29udHJhY3RPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBjdXN0b20gY29udHJhY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc29saWRpdHlWZXJzaW9uIC0gVGhlIHZlcnNpb24gb2YgdGhlIHNvbGlkaXR5IGNvbXBpbGVyLCBtdXN0IGJlIDAuOC4rLCBzdWNoIGFzIFwiMC44LjI4K2NvbW1pdC43ODkzNjE0YVwiLiBTZWUgaHR0cHM6Ly9iaW5hcmllcy5zb2xpZGl0eWxhbmcub3JnL2Jpbi9saXN0Lmpzb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zb2xpZGl0eUlucHV0SnNvbiAtIFRoZSBpbnB1dCBqc29uIGZvciB0aGUgc29saWRpdHkgY29tcGlsZXIuIFNlZSBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvdXNpbmctdGhlLWNvbXBpbGVyLmh0bWwjaW5wdXQtZGVzY3JpcHRpb24gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jb250cmFjdE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29udHJhY3QgY2xhc3MuXG4gICAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBvcHRpb25zLmNvbnN0cnVjdG9yQXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTbWFydENvbnRyYWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNyZWF0ZWQgU21hcnRDb250cmFjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gSWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNvbXBpbGUgb3Igc3Vic2VxdWVudGx5IGNyZWF0ZSBhIHNtYXJ0IGNvbnRyYWN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUN1c3RvbUNvbnRyYWN0KHsgc29saWRpdHlWZXJzaW9uLCBzb2xpZGl0eUlucHV0SnNvbiwgY29udHJhY3ROYW1lLCBjb25zdHJ1Y3RvckFyZ3MsIH0pIHtcbiAgICAgICAgY29uc3QgY29tcGlsZUNvbnRyYWN0UmVzcCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zbWFydENvbnRyYWN0LmNvbXBpbGVTbWFydENvbnRyYWN0KHtcbiAgICAgICAgICAgIHNvbGlkaXR5X2NvbXBpbGVyX3ZlcnNpb246IHNvbGlkaXR5VmVyc2lvbixcbiAgICAgICAgICAgIHNvbGlkaXR5X2lucHV0X2pzb246IHNvbGlkaXR5SW5wdXRKc29uLFxuICAgICAgICAgICAgY29udHJhY3RfbmFtZTogY29udHJhY3ROYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29tcGlsZWRDb250cmFjdCA9IGNvbXBpbGVDb250cmFjdFJlc3AuZGF0YTtcbiAgICAgICAgY29uc3QgY29tcGlsZWRDb250cmFjdElkID0gY29tcGlsZWRDb250cmFjdC5jb21waWxlZF9zbWFydF9jb250cmFjdF9pZDtcbiAgICAgICAgY29uc3QgY3JlYXRlQ29udHJhY3RSZXNwID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnNtYXJ0Q29udHJhY3QuY3JlYXRlU21hcnRDb250cmFjdCh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0SWQoKSwge1xuICAgICAgICAgICAgdHlwZTogY2xpZW50XzEuU21hcnRDb250cmFjdFR5cGUuQ3VzdG9tLFxuICAgICAgICAgICAgb3B0aW9uczogSlNPTi5zdHJpbmdpZnkoY29uc3RydWN0b3JBcmdzKSxcbiAgICAgICAgICAgIGNvbXBpbGVkX3NtYXJ0X2NvbnRyYWN0X2lkOiBjb21waWxlZENvbnRyYWN0SWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc21hcnRfY29udHJhY3RfMS5TbWFydENvbnRyYWN0LmZyb21Nb2RlbChjcmVhdGVDb250cmFjdFJlc3A/LmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29udHJhY3QgaW52b2NhdGlvbiB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCB0aGUgbWV0aG9kIHdpbGwgYmUgaW52b2tlZCBvbi5cbiAgICAgKiBAcGFyYW0gbWV0aG9kIC0gVGhlIG1ldGhvZCB0byBpbnZva2Ugb24gdGhlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBhYmkgLSBUaGUgQUJJIG9mIHRoZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgY29udHJhY3QgbWV0aG9kIGludm9jYXRpb24uXG4gICAgICogICBUaGUga2V5cyBzaG91bGQgYmUgdGhlIGFyZ3VtZW50IG5hbWVzIGFuZCB0aGUgdmFsdWVzIHNob3VsZCBiZSB0aGUgYXJndW1lbnQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSBhdG9taWNBbW91bnQgLSBUaGUgYXRvbWljIGFtb3VudCBvZiB0aGUgbmF0aXZlIGFzc2V0IHRvIHNlbmQgdG8gYSBwYXlhYmxlIGNvbnRyYWN0IG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgQ29udHJhY3RJbnZvY2F0aW9uIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIGNvbnRyYWN0IGludm9jYXRpb24gZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uKGNvbnRyYWN0QWRkcmVzcywgbWV0aG9kLCBhYmksIGFyZ3MsIGF0b21pY0Ftb3VudCkge1xuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmNvbnRyYWN0SW52b2NhdGlvbi5jcmVhdGVDb250cmFjdEludm9jYXRpb24odGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldElkKCksIHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgYWJpOiBKU09OLnN0cmluZ2lmeShhYmkpLFxuICAgICAgICAgICAgY29udHJhY3RfYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgYXJnczogSlNPTi5zdHJpbmdpZnkoYXJncyksXG4gICAgICAgICAgICBhbW91bnQ6IGF0b21pY0Ftb3VudCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250cmFjdF9pbnZvY2F0aW9uXzEuQ29udHJhY3RJbnZvY2F0aW9uLmZyb21Nb2RlbChyZXNwPy5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YWtpbmcgb3BlcmF0aW9uIHRvIHN0YWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgdG8gc3Rha2UuXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgdG8gc3Rha2UuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgc3Rha2Ugb3BlcmF0aW9uOlxuICAgICAqXG4gICAgICogQS4gU2hhcmVkIEVUSCBTdGFraW5nXG4gICAgICogIC0gYGludGVncmF0b3JfY29udHJhY3RfYWRkcmVzc2AgKG9wdGlvbmFsKTogVGhlIGNvbnRyYWN0IGFkZHJlc3MgdG8gd2hpY2ggdGhlIHN0YWtlIG9wZXJhdGlvbiBpcyBkaXJlY3RlZCB0by4gRGVmYXVsdHMgdG8gdGhlIGludGVncmF0b3IgY29udHJhY3QgYWRkcmVzcyBhc3NvY2lhdGVkIHdpdGggQ0RQIGFjY291bnQgKGlmIGF2YWlsYWJsZSkgb3IgZWxzZSBkZWZhdWx0cyB0byBhIHNoYXJlZCBpbnRlZ3JhdG9yIGNvbnRyYWN0IGFkZHJlc3MgZm9yIHRoYXQgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEIuIERlZGljYXRlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGBmdW5kaW5nX2FkZHJlc3NgIChvcHRpb25hbCk6IEV0aGVyZXVtIGFkZHJlc3MgZm9yIGZ1bmRpbmcgdGhlIHN0YWtlIG9wZXJhdGlvbi4gRGVmYXVsdHMgdG8gdGhlIGFkZHJlc3MgaW5pdGlhdGluZyB0aGUgc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqICAtIGB3aXRoZHJhd2FsX2FkZHJlc3NgIChvcHRpb25hbCk6IEV0aGVyZXVtIGFkZHJlc3MgZm9yIHJlY2VpdmluZyByZXdhcmRzIGFuZCB3aXRoZHJhd2FsIGZ1bmRzLiBEZWZhdWx0cyB0byB0aGUgYWRkcmVzcyBpbml0aWF0aW5nIHRoZSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICogIC0gYGZlZV9yZWNpcGllbnRfYWRkcmVzc2AgKG9wdGlvbmFsKTogRXRoZXJldW0gYWRkcmVzcyBmb3IgcmVjZWl2aW5nIHRyYW5zYWN0aW9uIGZlZXMuIERlZmF1bHRzIHRvIHRoZSBhZGRyZXNzIGluaXRpYXRpbmcgdGhlIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0U2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gd2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGNvbXBsZXRlIHdoZW4gYnJvYWRjYXN0ZWQuXG4gICAgICogQHBhcmFtIGludGVydmFsU2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gY2hlY2sgZWFjaCB0aW1lIGZvciBhIHN1Y2Nlc3NmdWwgYnJvYWRjYXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIG9wZXJhdGlvbiBhZnRlciBpdCdzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSwgdGltZW91dFNlY29uZHMgPSA2MDAsIGludGVydmFsU2Vjb25kcyA9IDAuMikge1xuICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlQ2FuU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU3Rha2luZ09wZXJhdGlvbihhbW91bnQsIGFzc2V0SWQsIFwic3Rha2VcIiwgbW9kZSwgb3B0aW9ucywgdGltZW91dFNlY29uZHMsIGludGVydmFsU2Vjb25kcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFraW5nIG9wZXJhdGlvbiB0byB1bnN0YWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgdG8gdW5zdGFrZS5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCB0byB1bnN0YWtlLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHVuc3Rha2Ugb3BlcmF0aW9uOlxuICAgICAqXG4gICAgICogQS4gU2hhcmVkIEVUSCBTdGFraW5nXG4gICAgICogIC0gYGludGVncmF0b3JfY29udHJhY3RfYWRkcmVzc2AgKG9wdGlvbmFsKTogVGhlIGNvbnRyYWN0IGFkZHJlc3MgdG8gd2hpY2ggdGhlIHVuc3Rha2Ugb3BlcmF0aW9uIGlzIGRpcmVjdGVkIHRvLiBEZWZhdWx0cyB0byB0aGUgaW50ZWdyYXRvciBjb250cmFjdCBhZGRyZXNzIGFzc29jaWF0ZWQgd2l0aCBDRFAgYWNjb3VudCAoaWYgYXZhaWxhYmxlKSBvciBlbHNlIGRlZmF1bHRzIHRvIGEgc2hhcmVkIGludGVncmF0b3IgY29udHJhY3QgYWRkcmVzcyBmb3IgdGhhdCBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQi4gRGVkaWNhdGVkIEVUSCBTdGFraW5nXG4gICAgICogIC0gYGltbWVkaWF0ZWAgKG9wdGlvbmFsKTogU2V0IHRoaXMgdG8gXCJ0cnVlXCIgdG8gdW5zdGFrZSBpbW1lZGlhdGVseSBpLmUuIGxldmVyYWdlIFwiQ29pbmJhc2UgbWFuYWdlZCB1bnN0YWtlXCIgcHJvY2VzcyAuIERlZmF1bHRzIHRvIFwiZmFsc2VcIiBpLmUuIFwiVXNlciBtYW5hZ2VkIHVuc3Rha2VcIiBwcm9jZXNzLlxuICAgICAqICAtIGB2YWxpZGF0b3JfcHViX2tleXNgIChvcHRpb25hbCk6IExpc3Qgb2YgY29tbWEgc2VwYXJhdGVkIHZhbGlkYXRvciBwdWJsaWMga2V5cyB0byB1bnN0YWtlLiBEZWZhdWx0cyB0byB2YWxpZGF0b3JzIGJlaW5nIHBpY2tlZCB1cCBvbiB5b3VyIGJlaGFsZiBjb3JyZXNwb25kaW5nIHRvIHRoZSB1bnN0YWtlIGFtb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0U2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gd2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGNvbXBsZXRlIHdoZW4gYnJvYWRjYXN0ZWQuXG4gICAgICogQHBhcmFtIGludGVydmFsU2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gY2hlY2sgZWFjaCB0aW1lIGZvciBhIHN1Y2Nlc3NmdWwgYnJvYWRjYXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIG9wZXJhdGlvbiBhZnRlciBpdCdzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVW5zdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUgPSB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVCwgb3B0aW9ucyA9IHt9LCB0aW1lb3V0U2Vjb25kcyA9IDYwMCwgaW50ZXJ2YWxTZWNvbmRzID0gMC4yKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVDYW5VbnN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVN0YWtpbmdPcGVyYXRpb24oYW1vdW50LCBhc3NldElkLCBcInVuc3Rha2VcIiwgbW9kZSwgb3B0aW9ucywgdGltZW91dFNlY29uZHMsIGludGVydmFsU2Vjb25kcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFraW5nIG9wZXJhdGlvbiB0byBjbGFpbSBzdGFrZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IHRvIGNsYWltIHN0YWtlLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IHRvIGNsYWltIHN0YWtlLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIGNsYWltIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEEuIFNoYXJlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGBpbnRlZ3JhdG9yX2NvbnRyYWN0X2FkZHJlc3NgIChvcHRpb25hbCk6IFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIHdoaWNoIHRoZSBjbGFpbSBzdGFrZSBvcGVyYXRpb24gaXMgZGlyZWN0ZWQgdG8uIERlZmF1bHRzIHRvIHRoZSBpbnRlZ3JhdG9yIGNvbnRyYWN0IGFkZHJlc3MgYXNzb2NpYXRlZCB3aXRoIENEUCBhY2NvdW50IChpZiBhdmFpbGFibGUpIG9yIGVsc2UgZGVmYXVsdHMgdG8gYSBzaGFyZWQgaW50ZWdyYXRvciBjb250cmFjdCBhZGRyZXNzIGZvciB0aGF0IG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZW91dFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIHdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBjb21wbGV0ZSB3aGVuIGJyb2FkY2FzdGVkLlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIGNoZWNrIGVhY2ggdGltZSBmb3IgYSBzdWNjZXNzZnVsIGJyb2FkY2FzdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyBvcGVyYXRpb24gYWZ0ZXIgaXQncyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUNsYWltU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSwgdGltZW91dFNlY29uZHMgPSA2MDAsIGludGVydmFsU2Vjb25kcyA9IDAuMikge1xuICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlQ2FuQ2xhaW1TdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTdGFraW5nT3BlcmF0aW9uKGFtb3VudCwgYXNzZXRJZCwgXCJjbGFpbV9zdGFrZVwiLCBtb2RlLCBvcHRpb25zLCB0aW1lb3V0U2Vjb25kcywgaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVuc2lnbmVkUGF5bG9hZCAtIFRoZSBVbnNpZ25lZCBQYXlsb2FkIHRvIHNpZ24uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIFBheWxvYWQgU2lnbmF0dXJlIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIFBheWxvYWQgU2lnbmF0dXJlIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgYWRkcmVzcyBkb2VzIG5vdCBoYXZlIGEgcHJpdmF0ZSBrZXkgbG9hZGVkIG9yIGFuIGFzc29jaWF0ZWQgU2VydmVyLVNpZ25lci5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlKHVuc2lnbmVkUGF5bG9hZCkge1xuICAgICAgICBpZiAoIWNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyICYmICF0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNpZ24gcGF5bG9hZCB3aXRoIGFkZHJlc3Mgd2l0aG91dCBwcml2YXRlIGtleSBsb2FkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gdGhpcy5rZXkuc2lnbmluZ0tleS5zaWduKHVuc2lnbmVkUGF5bG9hZCkuc2VyaWFsaXplZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHVuc2lnbmVkX3BheWxvYWQ6IHVuc2lnbmVkUGF5bG9hZCxcbiAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuYWRkcmVzcy5jcmVhdGVQYXlsb2FkU2lnbmF0dXJlKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRJZCgpLCBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWRTaWduYXR1cmUgPSBuZXcgcGF5bG9hZF9zaWduYXR1cmVfMS5QYXlsb2FkU2lnbmF0dXJlKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICByZXR1cm4gcGF5bG9hZFNpZ25hdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBheWxvYWRTaWduYXR1cmVJZCAtIFRoZSBJRCBvZiB0aGUgUGF5bG9hZCBTaWduYXR1cmUgdG8gZmV0Y2guXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIFBheWxvYWQgU2lnbmF0dXJlIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGdldCB0aGUgUGF5bG9hZCBTaWduYXR1cmUgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UGF5bG9hZFNpZ25hdHVyZShwYXlsb2FkU2lnbmF0dXJlSWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuYWRkcmVzcy5nZXRQYXlsb2FkU2lnbmF0dXJlKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRJZCgpLCBwYXlsb2FkU2lnbmF0dXJlSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkU2lnbmF0dXJlID0gbmV3IHBheWxvYWRfc2lnbmF0dXJlXzEuUGF5bG9hZFNpZ25hdHVyZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWRTaWduYXR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCB0aGUgUGF5bG9hZCBTaWduYXR1cmVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgQWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBQYXlsb2FkIFNpZ25hdHVyZXMgdG8gcmV0dXJuLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFnZSAtIFRoZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIFBheWxvYWQgU2lnbmF0dXJlcy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBwYWdpbmF0ZWQgbGlzdCByZXNwb25zZSBvZiBQYXlsb2FkIFNpZ25hdHVyZXMuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBsaXN0IHRoZSBQYXlsb2FkIFNpZ25hdHVyZXMgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFBheWxvYWRTaWduYXR1cmVzKHsgbGltaXQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLmRlZmF1bHRQYWdlTGltaXQsIHBhZ2UgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGxldCBuZXh0UGFnZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuYWRkcmVzcy5saXN0UGF5bG9hZFNpZ25hdHVyZXModGhpcy5tb2RlbC53YWxsZXRfaWQsIHRoaXMubW9kZWwuYWRkcmVzc19pZCwgMTAwLCBwYWdlPy5sZW5ndGggPyBwYWdlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS5kYXRhLmZvckVhY2gocGF5bG9hZFNpZ25hdHVyZU1vZGVsID0+IHtcbiAgICAgICAgICAgIGRhdGEucHVzaChuZXcgcGF5bG9hZF9zaWduYXR1cmVfMS5QYXlsb2FkU2lnbmF0dXJlKHBheWxvYWRTaWduYXR1cmVNb2RlbCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFzTW9yZSA9IHJlc3BvbnNlLmRhdGEuaGFzX21vcmU7XG4gICAgICAgIGlmIChoYXNNb3JlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0UGFnZSA9IHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaGFzTW9yZSxcbiAgICAgICAgICAgIG5leHRQYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5kIHRoZSBhZGRyZXNzIGZyb20geW91ciBhY2NvdW50IG9uIHRoZSBDb2luYmFzZSBQbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBmdW5kIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIEFzc2V0IHRvIGZ1bmQgdGhlIHdhbGxldCB3aXRoXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXNzZXRJZCAtIFRoZSBJRCBvZiB0aGUgQXNzZXQgdG8gZnVuZCB3aXRoLiBGb3IgRXRoZXIsIGV0aCwgZ3dlaSwgYW5kIHdlaSBhcmUgc3VwcG9ydGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGZ1bmQgb3BlcmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmQoeyBhbW91bnQsIGFzc2V0SWQgfSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQW1vdW50ID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKGFtb3VudC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIGZ1bmRfb3BlcmF0aW9uXzEuRnVuZE9wZXJhdGlvbi5jcmVhdGUodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldElkKCksIG5vcm1hbGl6ZWRBbW91bnQsIGFzc2V0SWQsIHRoaXMuZ2V0TmV0d29ya0lkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBxdW90ZSBmb3IgZnVuZGluZyB0aGUgYWRkcmVzcyBmcm9tIHlvdXIgQ29pbmJhc2UgcGxhdGZvcm0gYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBmdW5kIHF1b3RlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYW1vdW50IC0gVGhlIGFtb3VudCB0byBmdW5kXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXNzZXRJZCAtIFRoZSBJRCBvZiB0aGUgQXNzZXQgdG8gZnVuZCB3aXRoLiBGb3IgRXRoZXIsIGV0aCwgZ3dlaSwgYW5kIHdlaSBhcmUgc3VwcG9ydGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBmdW5kIHF1b3RlIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIHF1b3RlRnVuZCh7IGFtb3VudCwgYXNzZXRJZCB9KSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBbW91bnQgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gZnVuZF9xdW90ZV8xLkZ1bmRRdW90ZS5jcmVhdGUodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldElkKCksIG5vcm1hbGl6ZWRBbW91bnQsIGFzc2V0SWQsIHRoaXMuZ2V0TmV0d29ya0lkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgZnVuZCBvcGVyYXRpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBGdW5kIE9wZXJhdGlvbnMgdG8gcmV0dXJuLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFnZSAtIFRoZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIEZ1bmQgT3BlcmF0aW9ucy4gRG9uJ3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYWdpbmF0ZWQgbGlzdCByZXNwb25zZSBvZiBmdW5kIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdEZ1bmRPcGVyYXRpb25zKHsgbGltaXQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLmRlZmF1bHRQYWdlTGltaXQsIHBhZ2UgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gZnVuZF9vcGVyYXRpb25fMS5GdW5kT3BlcmF0aW9uLmxpc3RGdW5kT3BlcmF0aW9ucyh0aGlzLm1vZGVsLndhbGxldF9pZCwgdGhpcy5tb2RlbC5hZGRyZXNzX2lkLCB7XG4gICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgIHBhZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhZGRyZXNzIGFuZCBuZXR3b3JrIElEIG9mIHRoZSBnaXZlbiBkZXN0aW5hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvbiAtIFRoZSBkZXN0aW5hdGlvbiB0byBnZXQgdGhlIGFkZHJlc3MgYW5kIG5ldHdvcmsgSUQgb2YuXG4gICAgICogQHJldHVybnMgVGhlIGFkZHJlc3MgYW5kIG5ldHdvcmsgSUQgb2YgdGhlIGRlc3RpbmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGdldERlc3RpbmF0aW9uQWRkcmVzc0FuZE5ldHdvcmsoZGVzdGluYXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiAhPT0gXCJzdHJpbmdcIiAmJiBkZXN0aW5hdGlvbi5nZXROZXR3b3JrSWQoKSAhPT0gdGhpcy5nZXROZXR3b3JrSWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoXCJUcmFuc2ZlciBtdXN0IGJlIG9uIHRoZSBzYW1lIE5ldHdvcmtcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uIGluc3RhbmNlb2Ygd2FsbGV0XzEuV2FsbGV0KSB7XG4gICAgICAgICAgICByZXR1cm4gWyhhd2FpdCBkZXN0aW5hdGlvbi5nZXREZWZhdWx0QWRkcmVzcygpKS5nZXRJZCgpLCBkZXN0aW5hdGlvbi5nZXROZXR3b3JrSWQoKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgYWRkcmVzc18xLkFkZHJlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbZGVzdGluYXRpb24uZ2V0SWQoKSwgZGVzdGluYXRpb24uZ2V0TmV0d29ya0lkKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZGVzdGluYXRpb24sIHRoaXMuZ2V0TmV0d29ya0lkKCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHJhZGUgbW9kZWwgZm9yIHRoZSBzcGVjaWZpZWQgYW1vdW50IGFuZCBhc3NldHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgQXNzZXQgdG8gc2VuZC5cbiAgICAgKiBAcGFyYW0gZnJvbUFzc2V0IC0gVGhlIEFzc2V0IHRvIHRyYWRlIGZyb20uXG4gICAgICogQHBhcmFtIHRvQXNzZXQgLSBUaGUgQXNzZXQgdG8gdHJhZGUgdG8uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBUcmFkZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuZXcgdHJhZGUuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVHJhZGVSZXF1ZXN0KGFtb3VudCwgZnJvbUFzc2V0LCB0b0Fzc2V0KSB7XG4gICAgICAgIGNvbnN0IHRyYWRlUmVxdWVzdFBheWxvYWQgPSB7XG4gICAgICAgICAgICBhbW91bnQ6IGZyb21Bc3NldC50b0F0b21pY0Ftb3VudChuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoYW1vdW50LnRvU3RyaW5nKCkpKS50b1N0cmluZygpLFxuICAgICAgICAgICAgZnJvbV9hc3NldF9pZDogZnJvbUFzc2V0LnByaW1hcnlEZW5vbWluYXRpb24oKSxcbiAgICAgICAgICAgIHRvX2Fzc2V0X2lkOiB0b0Fzc2V0LnByaW1hcnlEZW5vbWluYXRpb24oKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdHJhZGVNb2RlbCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy50cmFkZS5jcmVhdGVUcmFkZSh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0SWQoKSwgdHJhZGVSZXF1ZXN0UGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBuZXcgdHJhZGVfMS5UcmFkZSh0cmFkZU1vZGVsPy5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRyYWRpbmcgaXMgcG9zc2libGUgYW5kIHJhaXNlcyBhbiBlcnJvciBpZiBub3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgQXNzZXQgdG8gc2VuZC5cbiAgICAgKiBAcGFyYW0gZnJvbUFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIHRyYWRlIGZyb20uIEZvciBFdGhlciwgZXRoLCBnd2VpLCBhbmQgd2VpIGFyZSBzdXBwb3J0ZWQuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcml2YXRlIGtleSBpcyBub3QgbG9hZGVkLCBvciBpZiB0aGUgYXNzZXQgSURzIGFyZSB1bnN1cHBvcnRlZCwgb3IgaWYgdGhlcmUgYXJlIGluc3VmZmljaWVudCBmdW5kcy5cbiAgICAgKi9cbiAgICBhc3luYyB2YWxpZGF0ZUNhblRyYWRlKGFtb3VudCwgZnJvbUFzc2V0SWQpIHtcbiAgICAgICAgaWYgKCFjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lciAmJiAhdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0cmFkZSBmcm9tIGFkZHJlc3Mgd2l0aG91dCBwcml2YXRlIGtleSBsb2FkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudEJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2UoZnJvbUFzc2V0SWQpO1xuICAgICAgICBhbW91bnQgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoY3VycmVudEJhbGFuY2UubGVzc1RoYW4oYW1vdW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgZnVuZHM6ICR7YW1vdW50fSByZXF1ZXN0ZWQsIGJ1dCBvbmx5ICR7Y3VycmVudEJhbGFuY2V9IGF2YWlsYWJsZWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFraW5nIG9wZXJhdGlvbiB0byBzdGFrZSwgc2lnbnMgaXQsIGFuZCBicm9hZGNhc3RzIGl0IG9uIHRoZSBibG9ja2NoYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCB0byB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIFRoZSB0eXBlIG9mIHN0YWtpbmcgYWN0aW9uIHRvIHBlcmZvcm0uXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIHN1Y2ggYXMgc2V0dGluZyB0aGUgbW9kZSBmb3IgdGhlIHN0YWtpbmcgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB0aW1lb3V0U2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gd2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGNvbXBsZXRlIHdoZW4gYnJvYWRjYXN0ZWQuXG4gICAgICogQHBhcmFtIGludGVydmFsU2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gY2hlY2sgZWFjaCB0aW1lIGZvciBhIHN1Y2Nlc3NmdWwgYnJvYWRjYXN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIG9yIGJyb2FkY2FzdCBzdGFraW5nIG9wZXJhdGlvbiBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGFtb3VudCBpcyBsZXNzIHRoYW4gemVyby5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyBvcGVyYXRpb24gYWZ0ZXIgaXQncyBjb21wbGV0ZWQgZnVsbHkuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU3Rha2luZ09wZXJhdGlvbihhbW91bnQsIGFzc2V0SWQsIGFjdGlvbiwgbW9kZSwgb3B0aW9ucywgdGltZW91dFNlY29uZHMsIGludGVydmFsU2Vjb25kcykge1xuICAgICAgICBpZiAobmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKGFtb3VudC50b1N0cmluZygpKS5sZXNzVGhhbk9yRXF1YWxUbygwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW1vdW50IHJlcXVpcmVkIGdyZWF0ZXIgdGhhbiB6ZXJvLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3Rha2luZ09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QoYW1vdW50LCBhc3NldElkLCBhY3Rpb24sIG1vZGUsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAvLyBMb29wIHVudGlsIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQuXG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dFNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggYW55IHVuc2lnbmVkIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBhdmFpbGFibGUsIHNpZ24gYW5kIGJyb2FkY2FzdCB0aGVtLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFraW5nT3BlcmF0aW9uLmdldFRyYW5zYWN0aW9ucygpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBzdGFraW5nT3BlcmF0aW9uLmdldFRyYW5zYWN0aW9ucygpW2ldO1xuICAgICAgICAgICAgICAgIGlmICghdHJhbnNhY3Rpb24uaXNTaWduZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbi5zaWduKHRoaXMua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgc3Rha2luZ09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3Qoc3Rha2luZ09wZXJhdGlvbi5nZXRJRCgpLCB0cmFuc2FjdGlvbi5nZXRTaWduZWRQYXlsb2FkKCkuc2xpY2UoMiksIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHN0YWtpbmdPcGVyYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICBpZiAoc3Rha2luZ09wZXJhdGlvbi5pc1Rlcm1pbmFsU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFraW5nT3BlcmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgKDAsIHV0aWxzXzEuZGVsYXkpKGludGVydmFsU2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3Rha2luZyBPcGVyYXRpb24gdGltZWQgb3V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBmb3IgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBUaGUgdHlwZSBvZiBzdGFraW5nIGFjdGlvbiB0byBwZXJmb3JtLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBzdWNoIGFzIHNldHRpbmcgdGhlIG1vZGUgZm9yIHRoZSBzdGFraW5nIGFjdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIHN0YWtpbmcgb3BlcmF0aW9uIGZhaWxzLlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0KGFtb3VudCwgYXNzZXRJZCwgYWN0aW9uLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBhc3NldCA9IGF3YWl0IGFzc2V0XzEuQXNzZXQuZmV0Y2godGhpcy5nZXROZXR3b3JrSWQoKSwgYXNzZXRJZCk7XG4gICAgICAgIG9wdGlvbnMuYW1vdW50ID0gYXNzZXQudG9BdG9taWNBbW91bnQobmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKGFtb3VudC50b1N0cmluZygpKSkudG9TdHJpbmcoKTtcbiAgICAgICAgb3B0aW9ucy5tb2RlID0gbW9kZSA/IG1vZGUgOiB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVDtcbiAgICAgICAgY29uc3Qgc3Rha2luZ09wZXJhdGlvblJlcXVlc3QgPSB7XG4gICAgICAgICAgICBuZXR3b3JrX2lkOiB0aGlzLmdldE5ldHdvcmtJZCgpLFxuICAgICAgICAgICAgYXNzZXRfaWQ6IGFzc2V0XzEuQXNzZXQucHJpbWFyeURlbm9taW5hdGlvbihhc3NldElkKSxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0U3Rha2UuY3JlYXRlU3Rha2luZ09wZXJhdGlvbih0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0SWQoKSwgc3Rha2luZ09wZXJhdGlvblJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gbmV3IHN0YWtpbmdfb3BlcmF0aW9uXzEuU3Rha2luZ09wZXJhdGlvbihyZXNwb25zZS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBicm9hZGNhc3RzIHRoZSBzaWduZWQgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFraW5nT3BlcmF0aW9uSUQgLSBUaGUgc3Rha2luZyBvcGVyYXRpb24gaWQgcmVsYXRlZCB0byB0aGUgc2lnbmVkIHBheWxvYWQuXG4gICAgICogQHBhcmFtIHNpZ25lZFBheWxvYWQgLSBUaGUgcGF5bG9hZCB0aGF0J3MgYmVpbmcgYnJvYWRjYXN0ZWQuXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHRyYW5zYWN0aW9uIGluIHRoZSBhcnJheSBmcm9tIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIEFuIHVwZGF0ZWQgc3Rha2luZyBvcGVyYXRpb24gd2l0aCB0aGUgYnJvYWRjYXN0ZWQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3Qoc3Rha2luZ09wZXJhdGlvbklELCBzaWduZWRQYXlsb2FkLCB0cmFuc2FjdGlvbkluZGV4KSB7XG4gICAgICAgIGNvbnN0IGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0ID0ge1xuICAgICAgICAgICAgc2lnbmVkX3BheWxvYWQ6IHNpZ25lZFBheWxvYWQsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbl9pbmRleDogdHJhbnNhY3Rpb25JbmRleCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0U3Rha2UuYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbih0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0SWQoKSwgc3Rha2luZ09wZXJhdGlvbklELCBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBuZXcgc3Rha2luZ19vcGVyYXRpb25fMS5TdGFraW5nT3BlcmF0aW9uKHJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2FsbGV0QWRkcmVzcyA9IFdhbGxldEFkZHJlc3M7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address_reputation.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address_reputation.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AddressReputation = void 0;\n/**\n * A representation of the reputation of a blockchain address.\n */\nclass AddressReputation {\n    /**\n     * A representation of the reputation of a blockchain address.\n     *\n     * @param {AddressReputationModel} model - The reputation model instance.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Address reputation model cannot be empty\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the address ID.\n     *\n     * @returns {string} The address ID.\n     */\n    get risky() {\n        return this.model.score < 0;\n    }\n    /**\n     * Returns the score of the address.\n     * The score is a number between -100 and 100.\n     *\n     * @returns {number} The score of the address.\n     */\n    get score() {\n        return this.model.score;\n    }\n    /**\n     * Returns the metadata of the address reputation.\n     * The metadata contains additional information about the address reputation.\n     *\n     * @returns {AddressReputationMetadata} The metadata of the address reputation.\n     */\n    get metadata() {\n        return this.model.metadata;\n    }\n    /**\n     * Returns the address ID.\n     *\n     * @returns {string} The address ID.\n     */\n    toString() {\n        const metadata = Object.entries(this.model.metadata).map(([key, value]) => {\n            return `${key}: ${value}`;\n        });\n        return `AddressReputation(score: ${this.score}, metadata: {${metadata.join(\", \")}})`;\n    }\n}\nexports.AddressReputation = AddressReputation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FkZHJlc3NfcmVwdXRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJLElBQUksTUFBTTtBQUNwQyxTQUFTO0FBQ1QsMkNBQTJDLFdBQVcsYUFBYSxFQUFFLHFCQUFxQjtBQUMxRjtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvYWRkcmVzc19yZXB1dGF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzUmVwdXRhdGlvbiA9IHZvaWQgMDtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVwdXRhdGlvbiBvZiBhIGJsb2NrY2hhaW4gYWRkcmVzcy5cbiAqL1xuY2xhc3MgQWRkcmVzc1JlcHV0YXRpb24ge1xuICAgIC8qKlxuICAgICAqIEEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlcHV0YXRpb24gb2YgYSBibG9ja2NoYWluIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FkZHJlc3NSZXB1dGF0aW9uTW9kZWx9IG1vZGVsIC0gVGhlIHJlcHV0YXRpb24gbW9kZWwgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWRkcmVzcyByZXB1dGF0aW9uIG1vZGVsIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFkZHJlc3MgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYWRkcmVzcyBJRC5cbiAgICAgKi9cbiAgICBnZXQgcmlza3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnNjb3JlIDwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2NvcmUgb2YgdGhlIGFkZHJlc3MuXG4gICAgICogVGhlIHNjb3JlIGlzIGEgbnVtYmVyIGJldHdlZW4gLTEwMCBhbmQgMTAwLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHNjb3JlIG9mIHRoZSBhZGRyZXNzLlxuICAgICAqL1xuICAgIGdldCBzY29yZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuc2NvcmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1ldGFkYXRhIG9mIHRoZSBhZGRyZXNzIHJlcHV0YXRpb24uXG4gICAgICogVGhlIG1ldGFkYXRhIGNvbnRhaW5zIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGFkZHJlc3MgcmVwdXRhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzUmVwdXRhdGlvbk1ldGFkYXRhfSBUaGUgbWV0YWRhdGEgb2YgdGhlIGFkZHJlc3MgcmVwdXRhdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm1ldGFkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhZGRyZXNzIElELlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGFkZHJlc3MgSUQuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gT2JqZWN0LmVudHJpZXModGhpcy5tb2RlbC5tZXRhZGF0YSkubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgJHtrZXl9OiAke3ZhbHVlfWA7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYEFkZHJlc3NSZXB1dGF0aW9uKHNjb3JlOiAke3RoaXMuc2NvcmV9LCBtZXRhZGF0YTogeyR7bWV0YWRhdGEuam9pbihcIiwgXCIpfX0pYDtcbiAgICB9XG59XG5leHBvcnRzLkFkZHJlc3NSZXB1dGF0aW9uID0gQWRkcmVzc1JlcHV0YXRpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address_reputation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js":
/*!************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NetworkFeatureUnsupportedError = exports.InvalidTransferStatusError = exports.InvalidSignedPayloadError = exports.FaucetLimitReachedError = exports.ResourceExhaustedError = exports.InvalidNetworkIDError = exports.InvalidDestinationError = exports.InvalidAssetIDError = exports.UnsupportedAssetError = exports.MalformedRequestError = exports.AlreadyExistsError = exports.InvalidLimitError = exports.InvalidPageError = exports.InvalidTransferIDError = exports.InvalidAmountError = exports.InvalidAddressError = exports.InvalidWalletError = exports.InvalidAddressIDError = exports.InvalidWalletIDError = exports.NotFoundError = exports.UnauthorizedError = exports.UnimplementedError = exports.InternalError = exports.APIError = void 0;\n/* eslint-disable jsdoc/require-jsdoc */\nconst axios_1 = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\");\n/**\n * A wrapper for API errors to provide more context.\n */\nclass APIError extends axios_1.AxiosError {\n    /**\n     * Initializes a new APIError object.\n     *\n     * @class\n     * @param {AxiosError} error - The Axios error.\n     */\n    constructor(error) {\n        super();\n        this.name = this.constructor.name;\n        this.httpCode = error.response ? error.response.status : null;\n        this.apiCode = null;\n        this.apiMessage = null;\n        this.correlationId = null;\n        if (error.response && error.response.data) {\n            const body = error.response.data;\n            this.apiCode = body.code;\n            this.apiMessage = body.message;\n            this.correlationId = body.correlation_id;\n        }\n    }\n    /**\n     * Creates a specific APIError based on the API error code.\n     *\n     * @param {AxiosError} error - The underlying error object.\n     * @returns {APIError} A specific APIError instance.\n     */\n    static fromError(error) {\n        const apiError = new APIError(error);\n        if (!error.response || !error.response.data) {\n            return apiError;\n        }\n        const body = error?.response?.data;\n        switch (body?.code) {\n            case \"unimplemented\":\n                return new UnimplementedError(error);\n            case \"unauthorized\":\n                return new UnauthorizedError(error);\n            case \"internal\":\n                return new InternalError(error);\n            case \"not_found\":\n                return new NotFoundError(error);\n            case \"invalid_wallet_id\":\n                return new InvalidWalletIDError(error);\n            case \"invalid_address_id\":\n                return new InvalidAddressIDError(error);\n            case \"invalid_wallet\":\n                return new InvalidWalletError(error);\n            case \"invalid_address\":\n                return new InvalidAddressError(error);\n            case \"invalid_amount\":\n                return new InvalidAmountError(error);\n            case \"invalid_transfer_id\":\n                return new InvalidTransferIDError(error);\n            case \"invalid_page_token\":\n                return new InvalidPageError(error);\n            case \"invalid_page_limit\":\n                return new InvalidLimitError(error);\n            case \"already_exists\":\n                return new AlreadyExistsError(error);\n            case \"malformed_request\":\n                return new MalformedRequestError(error);\n            case \"unsupported_asset\":\n                return new UnsupportedAssetError(error);\n            case \"invalid_asset_id\":\n                return new InvalidAssetIDError(error);\n            case \"invalid_destination\":\n                return new InvalidDestinationError(error);\n            case \"invalid_network_id\":\n                return new InvalidNetworkIDError(error);\n            case \"resource_exhausted\":\n                return new ResourceExhaustedError(error);\n            case \"faucet_limit_reached\":\n                return new FaucetLimitReachedError(error);\n            case \"invalid_signed_payload\":\n                return new InvalidSignedPayloadError(error);\n            case \"invalid_transfer_status\":\n                return new InvalidTransferStatusError(error);\n            case \"network_feature_unsupported\":\n                return new NetworkFeatureUnsupportedError(error);\n            default:\n                return apiError;\n        }\n    }\n    /**\n     * Returns a String representation of the APIError.\n     *\n     * @returns {string} a String representation of the APIError\n     */\n    toString() {\n        const payload = {};\n        if (this.httpCode)\n            payload.httpCode = this.httpCode;\n        if (this.apiCode)\n            payload.apiCode = this.apiCode;\n        if (this.apiMessage)\n            payload.apiMessage = this.apiMessage;\n        if (this.correlationId)\n            payload.correlationId = this.correlationId;\n        return `${this.name}{${Object.entries(payload)\n            .map(([key, value]) => `${key}: ${value}`)\n            .join(\", \")}}`;\n    }\n}\nexports.APIError = APIError;\nclass InternalError extends APIError {\n}\nexports.InternalError = InternalError;\nclass UnimplementedError extends APIError {\n}\nexports.UnimplementedError = UnimplementedError;\nclass UnauthorizedError extends APIError {\n}\nexports.UnauthorizedError = UnauthorizedError;\nclass NotFoundError extends APIError {\n}\nexports.NotFoundError = NotFoundError;\nclass InvalidWalletIDError extends APIError {\n}\nexports.InvalidWalletIDError = InvalidWalletIDError;\nclass InvalidAddressIDError extends APIError {\n}\nexports.InvalidAddressIDError = InvalidAddressIDError;\nclass InvalidWalletError extends APIError {\n}\nexports.InvalidWalletError = InvalidWalletError;\nclass InvalidAddressError extends APIError {\n}\nexports.InvalidAddressError = InvalidAddressError;\nclass InvalidAmountError extends APIError {\n}\nexports.InvalidAmountError = InvalidAmountError;\nclass InvalidTransferIDError extends APIError {\n}\nexports.InvalidTransferIDError = InvalidTransferIDError;\nclass InvalidPageError extends APIError {\n}\nexports.InvalidPageError = InvalidPageError;\nclass InvalidLimitError extends APIError {\n}\nexports.InvalidLimitError = InvalidLimitError;\nclass AlreadyExistsError extends APIError {\n}\nexports.AlreadyExistsError = AlreadyExistsError;\nclass MalformedRequestError extends APIError {\n}\nexports.MalformedRequestError = MalformedRequestError;\nclass UnsupportedAssetError extends APIError {\n}\nexports.UnsupportedAssetError = UnsupportedAssetError;\nclass InvalidAssetIDError extends APIError {\n}\nexports.InvalidAssetIDError = InvalidAssetIDError;\nclass InvalidDestinationError extends APIError {\n}\nexports.InvalidDestinationError = InvalidDestinationError;\nclass InvalidNetworkIDError extends APIError {\n}\nexports.InvalidNetworkIDError = InvalidNetworkIDError;\nclass ResourceExhaustedError extends APIError {\n}\nexports.ResourceExhaustedError = ResourceExhaustedError;\nclass FaucetLimitReachedError extends APIError {\n}\nexports.FaucetLimitReachedError = FaucetLimitReachedError;\nclass InvalidSignedPayloadError extends APIError {\n}\nexports.InvalidSignedPayloadError = InvalidSignedPayloadError;\nclass InvalidTransferStatusError extends APIError {\n}\nexports.InvalidTransferStatusError = InvalidTransferStatusError;\nclass NetworkFeatureUnsupportedError extends APIError {\n}\nexports.NetworkFeatureUnsupportedError = NetworkFeatureUnsupportedError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FwaV9lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0MsR0FBRyxrQ0FBa0MsR0FBRyxpQ0FBaUMsR0FBRywrQkFBK0IsR0FBRyw4QkFBOEIsR0FBRyw2QkFBNkIsR0FBRywrQkFBK0IsR0FBRywyQkFBMkIsR0FBRyw2QkFBNkIsR0FBRyw2QkFBNkIsR0FBRywwQkFBMEIsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyw4QkFBOEIsR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRywwQkFBMEIsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRywwQkFBMEIsR0FBRyxxQkFBcUIsR0FBRyxnQkFBZ0I7QUFDMXRCO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsRUFBRTtBQUMvQixzQ0FBc0MsSUFBSSxJQUFJLE1BQU07QUFDcEQseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esc0NBQXNDIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvYXBpX2Vycm9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZXR3b3JrRmVhdHVyZVVuc3VwcG9ydGVkRXJyb3IgPSBleHBvcnRzLkludmFsaWRUcmFuc2ZlclN0YXR1c0Vycm9yID0gZXhwb3J0cy5JbnZhbGlkU2lnbmVkUGF5bG9hZEVycm9yID0gZXhwb3J0cy5GYXVjZXRMaW1pdFJlYWNoZWRFcnJvciA9IGV4cG9ydHMuUmVzb3VyY2VFeGhhdXN0ZWRFcnJvciA9IGV4cG9ydHMuSW52YWxpZE5ldHdvcmtJREVycm9yID0gZXhwb3J0cy5JbnZhbGlkRGVzdGluYXRpb25FcnJvciA9IGV4cG9ydHMuSW52YWxpZEFzc2V0SURFcnJvciA9IGV4cG9ydHMuVW5zdXBwb3J0ZWRBc3NldEVycm9yID0gZXhwb3J0cy5NYWxmb3JtZWRSZXF1ZXN0RXJyb3IgPSBleHBvcnRzLkFscmVhZHlFeGlzdHNFcnJvciA9IGV4cG9ydHMuSW52YWxpZExpbWl0RXJyb3IgPSBleHBvcnRzLkludmFsaWRQYWdlRXJyb3IgPSBleHBvcnRzLkludmFsaWRUcmFuc2ZlcklERXJyb3IgPSBleHBvcnRzLkludmFsaWRBbW91bnRFcnJvciA9IGV4cG9ydHMuSW52YWxpZEFkZHJlc3NFcnJvciA9IGV4cG9ydHMuSW52YWxpZFdhbGxldEVycm9yID0gZXhwb3J0cy5JbnZhbGlkQWRkcmVzc0lERXJyb3IgPSBleHBvcnRzLkludmFsaWRXYWxsZXRJREVycm9yID0gZXhwb3J0cy5Ob3RGb3VuZEVycm9yID0gZXhwb3J0cy5VbmF1dGhvcml6ZWRFcnJvciA9IGV4cG9ydHMuVW5pbXBsZW1lbnRlZEVycm9yID0gZXhwb3J0cy5JbnRlcm5hbEVycm9yID0gZXhwb3J0cy5BUElFcnJvciA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIGpzZG9jL3JlcXVpcmUtanNkb2MgKi9cbmNvbnN0IGF4aW9zXzEgPSByZXF1aXJlKFwiYXhpb3NcIik7XG4vKipcbiAqIEEgd3JhcHBlciBmb3IgQVBJIGVycm9ycyB0byBwcm92aWRlIG1vcmUgY29udGV4dC5cbiAqL1xuY2xhc3MgQVBJRXJyb3IgZXh0ZW5kcyBheGlvc18xLkF4aW9zRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IEFQSUVycm9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSB7QXhpb3NFcnJvcn0gZXJyb3IgLSBUaGUgQXhpb3MgZXJyb3IuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB0aGlzLmh0dHBDb2RlID0gZXJyb3IucmVzcG9uc2UgPyBlcnJvci5yZXNwb25zZS5zdGF0dXMgOiBudWxsO1xuICAgICAgICB0aGlzLmFwaUNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFwaU1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWQgPSBudWxsO1xuICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2UgJiYgZXJyb3IucmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGVycm9yLnJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICB0aGlzLmFwaUNvZGUgPSBib2R5LmNvZGU7XG4gICAgICAgICAgICB0aGlzLmFwaU1lc3NhZ2UgPSBib2R5Lm1lc3NhZ2U7XG4gICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWQgPSBib2R5LmNvcnJlbGF0aW9uX2lkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzcGVjaWZpYyBBUElFcnJvciBiYXNlZCBvbiB0aGUgQVBJIGVycm9yIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F4aW9zRXJyb3J9IGVycm9yIC0gVGhlIHVuZGVybHlpbmcgZXJyb3Igb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtBUElFcnJvcn0gQSBzcGVjaWZpYyBBUElFcnJvciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGFwaUVycm9yID0gbmV3IEFQSUVycm9yKGVycm9yKTtcbiAgICAgICAgaWYgKCFlcnJvci5yZXNwb25zZSB8fCAhZXJyb3IucmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwaUVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBlcnJvcj8ucmVzcG9uc2U/LmRhdGE7XG4gICAgICAgIHN3aXRjaCAoYm9keT8uY29kZSkge1xuICAgICAgICAgICAgY2FzZSBcInVuaW1wbGVtZW50ZWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuaW1wbGVtZW50ZWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwidW5hdXRob3JpemVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmF1dGhvcml6ZWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW50ZXJuYWxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludGVybmFsRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcIm5vdF9mb3VuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF93YWxsZXRfaWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludmFsaWRXYWxsZXRJREVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX2FkZHJlc3NfaWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludmFsaWRBZGRyZXNzSURFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF93YWxsZXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludmFsaWRXYWxsZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF9hZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX2Ftb3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW52YWxpZEFtb3VudEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX3RyYW5zZmVyX2lkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkVHJhbnNmZXJJREVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX3BhZ2VfdG9rZW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludmFsaWRQYWdlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfcGFnZV9saW1pdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW52YWxpZExpbWl0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImFscmVhZHlfZXhpc3RzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbHJlYWR5RXhpc3RzRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcIm1hbGZvcm1lZF9yZXF1ZXN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYWxmb3JtZWRSZXF1ZXN0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcInVuc3VwcG9ydGVkX2Fzc2V0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbnN1cHBvcnRlZEFzc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfYXNzZXRfaWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludmFsaWRBc3NldElERXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfZGVzdGluYXRpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludmFsaWREZXN0aW5hdGlvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX25ldHdvcmtfaWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludmFsaWROZXR3b3JrSURFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwicmVzb3VyY2VfZXhoYXVzdGVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZUV4aGF1c3RlZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJmYXVjZXRfbGltaXRfcmVhY2hlZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmF1Y2V0TGltaXRSZWFjaGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfc2lnbmVkX3BheWxvYWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludmFsaWRTaWduZWRQYXlsb2FkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfdHJhbnNmZXJfc3RhdHVzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkVHJhbnNmZXJTdGF0dXNFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwibmV0d29ya19mZWF0dXJlX3Vuc3VwcG9ydGVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrRmVhdHVyZVVuc3VwcG9ydGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQVBJRXJyb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQVBJRXJyb3JcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodGhpcy5odHRwQ29kZSlcbiAgICAgICAgICAgIHBheWxvYWQuaHR0cENvZGUgPSB0aGlzLmh0dHBDb2RlO1xuICAgICAgICBpZiAodGhpcy5hcGlDb2RlKVxuICAgICAgICAgICAgcGF5bG9hZC5hcGlDb2RlID0gdGhpcy5hcGlDb2RlO1xuICAgICAgICBpZiAodGhpcy5hcGlNZXNzYWdlKVxuICAgICAgICAgICAgcGF5bG9hZC5hcGlNZXNzYWdlID0gdGhpcy5hcGlNZXNzYWdlO1xuICAgICAgICBpZiAodGhpcy5jb3JyZWxhdGlvbklkKVxuICAgICAgICAgICAgcGF5bG9hZC5jb3JyZWxhdGlvbklkID0gdGhpcy5jb3JyZWxhdGlvbklkO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfXske09iamVjdC5lbnRyaWVzKHBheWxvYWQpXG4gICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX06ICR7dmFsdWV9YClcbiAgICAgICAgICAgIC5qb2luKFwiLCBcIil9fWA7XG4gICAgfVxufVxuZXhwb3J0cy5BUElFcnJvciA9IEFQSUVycm9yO1xuY2xhc3MgSW50ZXJuYWxFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW50ZXJuYWxFcnJvciA9IEludGVybmFsRXJyb3I7XG5jbGFzcyBVbmltcGxlbWVudGVkRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLlVuaW1wbGVtZW50ZWRFcnJvciA9IFVuaW1wbGVtZW50ZWRFcnJvcjtcbmNsYXNzIFVuYXV0aG9yaXplZEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5VbmF1dGhvcml6ZWRFcnJvciA9IFVuYXV0aG9yaXplZEVycm9yO1xuY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuTm90Rm91bmRFcnJvciA9IE5vdEZvdW5kRXJyb3I7XG5jbGFzcyBJbnZhbGlkV2FsbGV0SURFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFdhbGxldElERXJyb3IgPSBJbnZhbGlkV2FsbGV0SURFcnJvcjtcbmNsYXNzIEludmFsaWRBZGRyZXNzSURFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZEFkZHJlc3NJREVycm9yID0gSW52YWxpZEFkZHJlc3NJREVycm9yO1xuY2xhc3MgSW52YWxpZFdhbGxldEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkV2FsbGV0RXJyb3IgPSBJbnZhbGlkV2FsbGV0RXJyb3I7XG5jbGFzcyBJbnZhbGlkQWRkcmVzc0Vycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkQWRkcmVzc0Vycm9yID0gSW52YWxpZEFkZHJlc3NFcnJvcjtcbmNsYXNzIEludmFsaWRBbW91bnRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZEFtb3VudEVycm9yID0gSW52YWxpZEFtb3VudEVycm9yO1xuY2xhc3MgSW52YWxpZFRyYW5zZmVySURFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFRyYW5zZmVySURFcnJvciA9IEludmFsaWRUcmFuc2ZlcklERXJyb3I7XG5jbGFzcyBJbnZhbGlkUGFnZUVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkUGFnZUVycm9yID0gSW52YWxpZFBhZ2VFcnJvcjtcbmNsYXNzIEludmFsaWRMaW1pdEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkTGltaXRFcnJvciA9IEludmFsaWRMaW1pdEVycm9yO1xuY2xhc3MgQWxyZWFkeUV4aXN0c0Vycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5BbHJlYWR5RXhpc3RzRXJyb3IgPSBBbHJlYWR5RXhpc3RzRXJyb3I7XG5jbGFzcyBNYWxmb3JtZWRSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLk1hbGZvcm1lZFJlcXVlc3RFcnJvciA9IE1hbGZvcm1lZFJlcXVlc3RFcnJvcjtcbmNsYXNzIFVuc3VwcG9ydGVkQXNzZXRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuVW5zdXBwb3J0ZWRBc3NldEVycm9yID0gVW5zdXBwb3J0ZWRBc3NldEVycm9yO1xuY2xhc3MgSW52YWxpZEFzc2V0SURFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZEFzc2V0SURFcnJvciA9IEludmFsaWRBc3NldElERXJyb3I7XG5jbGFzcyBJbnZhbGlkRGVzdGluYXRpb25FcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZERlc3RpbmF0aW9uRXJyb3IgPSBJbnZhbGlkRGVzdGluYXRpb25FcnJvcjtcbmNsYXNzIEludmFsaWROZXR3b3JrSURFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZE5ldHdvcmtJREVycm9yID0gSW52YWxpZE5ldHdvcmtJREVycm9yO1xuY2xhc3MgUmVzb3VyY2VFeGhhdXN0ZWRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuUmVzb3VyY2VFeGhhdXN0ZWRFcnJvciA9IFJlc291cmNlRXhoYXVzdGVkRXJyb3I7XG5jbGFzcyBGYXVjZXRMaW1pdFJlYWNoZWRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuRmF1Y2V0TGltaXRSZWFjaGVkRXJyb3IgPSBGYXVjZXRMaW1pdFJlYWNoZWRFcnJvcjtcbmNsYXNzIEludmFsaWRTaWduZWRQYXlsb2FkRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRTaWduZWRQYXlsb2FkRXJyb3IgPSBJbnZhbGlkU2lnbmVkUGF5bG9hZEVycm9yO1xuY2xhc3MgSW52YWxpZFRyYW5zZmVyU3RhdHVzRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRUcmFuc2ZlclN0YXR1c0Vycm9yID0gSW52YWxpZFRyYW5zZmVyU3RhdHVzRXJyb3I7XG5jbGFzcyBOZXR3b3JrRmVhdHVyZVVuc3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLk5ldHdvcmtGZWF0dXJlVW5zdXBwb3J0ZWRFcnJvciA9IE5ldHdvcmtGZWF0dXJlVW5zdXBwb3J0ZWRFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js":
/*!********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Asset = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/** A representation of an Asset. */\nclass Asset {\n    /**\n     * Private constructor for the Asset class.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param contractAddress - The address ID.\n     * @param decimals - The number of decimals.\n     */\n    constructor(networkId, assetId, contractAddress, decimals) {\n        this.networkId = networkId;\n        this.assetId = assetId;\n        this.contractAddress = contractAddress;\n        this.decimals = decimals;\n    }\n    /**\n     * Creates an Asset from an Asset Model.\n     *\n     * @param model - The Asset Model.\n     * @param assetId - The Asset ID.\n     * @throws If the Asset Model is invalid.\n     * @returns The Asset Class.\n     */\n    static fromModel(model, assetId) {\n        if (!model) {\n            throw new Error(\"Invalid asset model\");\n        }\n        let decimals = model.decimals;\n        // TODO: Push this logic down to the backend.\n        if (assetId && model.asset_id) {\n            const normalizedModelAssetId = model.asset_id.toLowerCase();\n            const normalizedAssetId = assetId.toLowerCase();\n            if (coinbase_1.Coinbase.toAssetId(normalizedModelAssetId) !== coinbase_1.Coinbase.toAssetId(normalizedAssetId)) {\n                switch (normalizedAssetId) {\n                    case \"gwei\":\n                        decimals = constants_1.GWEI_DECIMALS;\n                        break;\n                    case \"wei\":\n                        decimals = 0;\n                        break;\n                    case \"eth\":\n                        break;\n                    default:\n                        throw new errors_1.ArgumentError(`Invalid asset ID: ${assetId}`);\n                }\n            }\n        }\n        return new Asset(model.network_id, assetId ?? model.asset_id, model.contract_address, decimals);\n    }\n    /**\n     * Fetches the Asset with the provided Asset ID.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @throws If the Asset cannot be fetched.\n     * @returns The Asset Class.\n     */\n    static async fetch(networkId, assetId) {\n        const asset = await coinbase_1.Coinbase.apiClients.asset.getAsset(coinbase_1.Coinbase.normalizeNetwork(networkId), Asset.primaryDenomination(assetId));\n        return Asset.fromModel(asset?.data, assetId);\n    }\n    /**\n     * Returns the primary denomination for the provided Asset ID.\n     * For `gwei` and `wei` the primary denomination is `eth`.\n     * For all other assets, the primary denomination is the same asset ID.\n     *\n     * @param assetId - The Asset ID.\n     * @returns The primary denomination for the Asset ID.\n     */\n    static primaryDenomination(assetId) {\n        return [coinbase_1.Coinbase.assets.Gwei, coinbase_1.Coinbase.assets.Wei].includes(assetId)\n            ? coinbase_1.Coinbase.assets.Eth\n            : assetId;\n    }\n    /**\n     * Returns the primary denomination for the Asset.\n     *\n     * @returns The primary denomination for the Asset.\n     */\n    primaryDenomination() {\n        return Asset.primaryDenomination(this.assetId);\n    }\n    /**\n     * Converts the amount of the Asset from whole to atomic units.\n     *\n     * @param wholeAmount - The whole amount to convert to atomic units.\n     * @returns The amount in atomic units\n     */\n    toAtomicAmount(wholeAmount) {\n        const atomicAmount = wholeAmount.times(new decimal_js_1.default(10).pow(this.decimals));\n        return BigInt(atomicAmount.toFixed());\n    }\n    /**\n     * Converts the amount of the Asset from atomic to whole units.\n     *\n     * @param atomicAmount - The atomic amount to convert to whole units.\n     * @returns The amount in atomic units\n     */\n    fromAtomicAmount(atomicAmount) {\n        return atomicAmount.dividedBy(new decimal_js_1.default(10).pow(this.decimals));\n    }\n    /**\n     * Returns a string representation of the Asset.\n     *\n     * @returns a string representation of the Asset\n     */\n    toString() {\n        return `Asset{ networkId: ${this.networkId}, assetId: ${this.assetId}, contractAddress: ${this.contractAddress}, decimals: ${this.decimals} }`;\n    }\n    /**\n     * Returns the Asset ID.\n     *\n     * @returns The Asset ID.\n     */\n    getAssetId() {\n        return this.assetId;\n    }\n}\nexports.Asset = Asset;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2Fzc2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLHFDQUFxQyxtQkFBTyxDQUFDLDhEQUFZO0FBQ3pELG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLDJGQUFhO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsUUFBUTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxlQUFlLGFBQWEsYUFBYSxxQkFBcUIscUJBQXFCLGNBQWMsZ0JBQWdCO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2Fzc2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3NldCA9IHZvaWQgMDtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVjaW1hbC5qc1wiKSk7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuLyoqIEEgcmVwcmVzZW50YXRpb24gb2YgYW4gQXNzZXQuICovXG5jbGFzcyBBc3NldCB7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBjb25zdHJ1Y3RvciBmb3IgdGhlIEFzc2V0IGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCAtIFRoZSBuZXR3b3JrIElELlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgYWRkcmVzcyBJRC5cbiAgICAgKiBAcGFyYW0gZGVjaW1hbHMgLSBUaGUgbnVtYmVyIG9mIGRlY2ltYWxzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmtJZCwgYXNzZXRJZCwgY29udHJhY3RBZGRyZXNzLCBkZWNpbWFscykge1xuICAgICAgICB0aGlzLm5ldHdvcmtJZCA9IG5ldHdvcmtJZDtcbiAgICAgICAgdGhpcy5hc3NldElkID0gYXNzZXRJZDtcbiAgICAgICAgdGhpcy5jb250cmFjdEFkZHJlc3MgPSBjb250cmFjdEFkZHJlc3M7XG4gICAgICAgIHRoaXMuZGVjaW1hbHMgPSBkZWNpbWFscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBBc3NldCBmcm9tIGFuIEFzc2V0IE1vZGVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIEFzc2V0IE1vZGVsLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIEFzc2V0IElELlxuICAgICAqIEB0aHJvd3MgSWYgdGhlIEFzc2V0IE1vZGVsIGlzIGludmFsaWQuXG4gICAgICogQHJldHVybnMgVGhlIEFzc2V0IENsYXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW9kZWwobW9kZWwsIGFzc2V0SWQpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhc3NldCBtb2RlbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVjaW1hbHMgPSBtb2RlbC5kZWNpbWFscztcbiAgICAgICAgLy8gVE9ETzogUHVzaCB0aGlzIGxvZ2ljIGRvd24gdG8gdGhlIGJhY2tlbmQuXG4gICAgICAgIGlmIChhc3NldElkICYmIG1vZGVsLmFzc2V0X2lkKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkTW9kZWxBc3NldElkID0gbW9kZWwuYXNzZXRfaWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBc3NldElkID0gYXNzZXRJZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGNvaW5iYXNlXzEuQ29pbmJhc2UudG9Bc3NldElkKG5vcm1hbGl6ZWRNb2RlbEFzc2V0SWQpICE9PSBjb2luYmFzZV8xLkNvaW5iYXNlLnRvQXNzZXRJZChub3JtYWxpemVkQXNzZXRJZCkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vcm1hbGl6ZWRBc3NldElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnd2VpXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFscyA9IGNvbnN0YW50c18xLkdXRUlfREVDSU1BTFM7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIndlaVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJldGhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoYEludmFsaWQgYXNzZXQgSUQ6ICR7YXNzZXRJZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBc3NldChtb2RlbC5uZXR3b3JrX2lkLCBhc3NldElkID8/IG1vZGVsLmFzc2V0X2lkLCBtb2RlbC5jb250cmFjdF9hZGRyZXNzLCBkZWNpbWFscyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIEFzc2V0IHdpdGggdGhlIHByb3ZpZGVkIEFzc2V0IElELlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCAtIFRoZSBuZXR3b3JrIElELlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEB0aHJvd3MgSWYgdGhlIEFzc2V0IGNhbm5vdCBiZSBmZXRjaGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBBc3NldCBDbGFzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZmV0Y2gobmV0d29ya0lkLCBhc3NldElkKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmFzc2V0LmdldEFzc2V0KGNvaW5iYXNlXzEuQ29pbmJhc2Uubm9ybWFsaXplTmV0d29yayhuZXR3b3JrSWQpLCBBc3NldC5wcmltYXJ5RGVub21pbmF0aW9uKGFzc2V0SWQpKTtcbiAgICAgICAgcmV0dXJuIEFzc2V0LmZyb21Nb2RlbChhc3NldD8uZGF0YSwgYXNzZXRJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByaW1hcnkgZGVub21pbmF0aW9uIGZvciB0aGUgcHJvdmlkZWQgQXNzZXQgSUQuXG4gICAgICogRm9yIGBnd2VpYCBhbmQgYHdlaWAgdGhlIHByaW1hcnkgZGVub21pbmF0aW9uIGlzIGBldGhgLlxuICAgICAqIEZvciBhbGwgb3RoZXIgYXNzZXRzLCB0aGUgcHJpbWFyeSBkZW5vbWluYXRpb24gaXMgdGhlIHNhbWUgYXNzZXQgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBBc3NldCBJRC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcHJpbWFyeSBkZW5vbWluYXRpb24gZm9yIHRoZSBBc3NldCBJRC5cbiAgICAgKi9cbiAgICBzdGF0aWMgcHJpbWFyeURlbm9taW5hdGlvbihhc3NldElkKSB7XG4gICAgICAgIHJldHVybiBbY29pbmJhc2VfMS5Db2luYmFzZS5hc3NldHMuR3dlaSwgY29pbmJhc2VfMS5Db2luYmFzZS5hc3NldHMuV2VpXS5pbmNsdWRlcyhhc3NldElkKVxuICAgICAgICAgICAgPyBjb2luYmFzZV8xLkNvaW5iYXNlLmFzc2V0cy5FdGhcbiAgICAgICAgICAgIDogYXNzZXRJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJpbWFyeSBkZW5vbWluYXRpb24gZm9yIHRoZSBBc3NldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwcmltYXJ5IGRlbm9taW5hdGlvbiBmb3IgdGhlIEFzc2V0LlxuICAgICAqL1xuICAgIHByaW1hcnlEZW5vbWluYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBBc3NldC5wcmltYXJ5RGVub21pbmF0aW9uKHRoaXMuYXNzZXRJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBhbW91bnQgb2YgdGhlIEFzc2V0IGZyb20gd2hvbGUgdG8gYXRvbWljIHVuaXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdob2xlQW1vdW50IC0gVGhlIHdob2xlIGFtb3VudCB0byBjb252ZXJ0IHRvIGF0b21pYyB1bml0cy5cbiAgICAgKiBAcmV0dXJucyBUaGUgYW1vdW50IGluIGF0b21pYyB1bml0c1xuICAgICAqL1xuICAgIHRvQXRvbWljQW1vdW50KHdob2xlQW1vdW50KSB7XG4gICAgICAgIGNvbnN0IGF0b21pY0Ftb3VudCA9IHdob2xlQW1vdW50LnRpbWVzKG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdCgxMCkucG93KHRoaXMuZGVjaW1hbHMpKTtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChhdG9taWNBbW91bnQudG9GaXhlZCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGFtb3VudCBvZiB0aGUgQXNzZXQgZnJvbSBhdG9taWMgdG8gd2hvbGUgdW5pdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXRvbWljQW1vdW50IC0gVGhlIGF0b21pYyBhbW91bnQgdG8gY29udmVydCB0byB3aG9sZSB1bml0cy5cbiAgICAgKiBAcmV0dXJucyBUaGUgYW1vdW50IGluIGF0b21pYyB1bml0c1xuICAgICAqL1xuICAgIGZyb21BdG9taWNBbW91bnQoYXRvbWljQW1vdW50KSB7XG4gICAgICAgIHJldHVybiBhdG9taWNBbW91bnQuZGl2aWRlZEJ5KG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdCgxMCkucG93KHRoaXMuZGVjaW1hbHMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQXNzZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQXNzZXRcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBBc3NldHsgbmV0d29ya0lkOiAke3RoaXMubmV0d29ya0lkfSwgYXNzZXRJZDogJHt0aGlzLmFzc2V0SWR9LCBjb250cmFjdEFkZHJlc3M6ICR7dGhpcy5jb250cmFjdEFkZHJlc3N9LCBkZWNpbWFsczogJHt0aGlzLmRlY2ltYWxzfSB9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQXNzZXQgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQXNzZXQgSUQuXG4gICAgICovXG4gICAgZ2V0QXNzZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXRJZDtcbiAgICB9XG59XG5leHBvcnRzLkFzc2V0ID0gQXNzZXQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CoinbaseAuthenticator = void 0;\nconst node_jose_1 = __webpack_require__(/*! node-jose */ \"(ssr)/./node_modules/node-jose/lib/index.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst package_json_1 = __webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/package.json\");\nconst pemHeader = \"-----BEGIN EC PRIVATE KEY-----\";\nconst pemFooter = \"-----END EC PRIVATE KEY-----\";\n/**\n * A class that builds JWTs for authenticating with the Coinbase Platform APIs.\n */\nclass CoinbaseAuthenticator {\n    /**\n     * Initializes the Authenticator.\n     *\n     * @param {string} apiKey - The API key name.\n     * @param {string} privateKey - The private key associated with the API key.\n     * @param {string} source - The source of the request.\n     * @param {string} sourceVersion - The version of the source.\n     */\n    constructor(apiKey, privateKey, source, sourceVersion) {\n        this.apiKey = apiKey;\n        this.privateKey = privateKey;\n        this.source = source;\n        this.sourceVersion = sourceVersion;\n    }\n    /**\n     * Middleware to intercept requests and add JWT to Authorization header.\n     *\n     * @param {InternalAxiosRequestConfig} config - The request configuration.\n     * @param {boolean} debugging - Flag to enable debugging.\n     * @returns {Promise<InternalAxiosRequestConfig>} The request configuration with the Authorization header added.\n     * @throws {InvalidAPIKeyFormat} If JWT could not be built.\n     */\n    async authenticateRequest(config, debugging = false) {\n        const method = config.method?.toString().toUpperCase();\n        const token = await this.buildJWT(config.url || \"\", method);\n        if (debugging) {\n            console.log(`API REQUEST: ${method} ${config.url}`);\n        }\n        config.headers[\"Authorization\"] = `Bearer ${token}`;\n        config.headers[\"Content-Type\"] = \"application/json\";\n        config.headers[\"Correlation-Context\"] = this.getCorrelationData();\n        return config;\n    }\n    /**\n     * Builds the JWT for the given API endpoint URL.\n     *\n     * @param {string} url - URL of the API endpoint.\n     * @param {string} method - HTTP method of the request.\n     * @returns {Promise<string>} JWT token.\n     * @throws {InvalidAPIKeyFormat} If the private key is not in the correct format.\n     */\n    async buildJWT(url, method = \"GET\") {\n        const pemPrivateKey = this.extractPemKey(this.privateKey);\n        let privateKey;\n        try {\n            privateKey = await node_jose_1.JWK.asKey(pemPrivateKey, \"pem\");\n            if (privateKey.kty !== \"EC\") {\n                throw new errors_1.InvalidAPIKeyFormatError(\"Invalid key type\");\n            }\n        }\n        catch (error) {\n            throw new errors_1.InvalidAPIKeyFormatError(\"Could not parse the private key\");\n        }\n        const header = {\n            alg: \"ES256\",\n            kid: this.apiKey,\n            typ: \"JWT\",\n            nonce: this.nonce(),\n        };\n        const urlObject = new URL(url);\n        const uri = `${method} ${urlObject.host}${urlObject.pathname}`;\n        const claims = {\n            sub: this.apiKey,\n            iss: \"cdp\",\n            aud: [\"cdp_service\"],\n            nbf: Math.floor(Date.now() / 1000),\n            exp: Math.floor(Date.now() / 1000) + 60, // +1 minute\n            uris: [uri],\n        };\n        const payload = Buffer.from(JSON.stringify(claims)).toString(\"utf8\");\n        try {\n            const result = await node_jose_1.JWS.createSign({ format: \"compact\", fields: header }, privateKey)\n                .update(payload)\n                .final();\n            return result;\n        }\n        catch (err) {\n            throw new errors_1.InvalidAPIKeyFormatError(\"Could not sign the JWT\");\n        }\n    }\n    /**\n     * Extracts the PEM key from the given private key string.\n     *\n     * @param {string} privateKeyString - The private key string.\n     * @returns {string} The PEM key.\n     * @throws {InvalidAPIKeyFormat} If the private key string is not in the correct format.\n     */\n    extractPemKey(privateKeyString) {\n        privateKeyString = privateKeyString.replace(/\\n/g, \"\");\n        if (privateKeyString.startsWith(pemHeader) && privateKeyString.endsWith(pemFooter)) {\n            return privateKeyString;\n        }\n        throw new errors_1.InvalidAPIKeyFormatError(\"Invalid private key format\");\n    }\n    /**\n     * Generates a random nonce for the JWT.\n     *\n     * @returns {string} The generated nonce.\n     */\n    nonce() {\n        const range = \"0123456789\";\n        let result = \"\";\n        for (let i = 0; i < 16; i++) {\n            result += range.charAt(Math.floor(Math.random() * range.length));\n        }\n        return result;\n    }\n    /**\n     * Returns encoded correlation data including the SDK version and language.\n     *\n     * @returns {string} Encoded correlation data.\n     */\n    getCorrelationData() {\n        const data = {\n            sdk_version: package_json_1.version,\n            sdk_language: \"typescript\",\n            source: this.source,\n        };\n        if (this.sourceVersion) {\n            data[\"source_version\"] = this.sourceVersion;\n        }\n        return Object.keys(data)\n            .map(key => `${key}=${encodeURIComponent(data[key])}`)\n            .join(\",\");\n    }\n}\nexports.CoinbaseAuthenticator = CoinbaseAuthenticator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2F1dGhlbnRpY2F0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLG9CQUFvQixtQkFBTyxDQUFDLDhEQUFXO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFVO0FBQ25DLHVCQUF1QixtQkFBTyxDQUFDLG9GQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLHFDQUFxQztBQUN0RCxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUSxFQUFFLFdBQVc7QUFDN0Q7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGlCQUFpQjtBQUNsQyxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUSxFQUFFLGVBQWUsRUFBRSxtQkFBbUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsbUNBQW1DO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekIsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSSxHQUFHLDhCQUE4QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9hdXRoZW50aWNhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2luYmFzZUF1dGhlbnRpY2F0b3IgPSB2b2lkIDA7XG5jb25zdCBub2RlX2pvc2VfMSA9IHJlcXVpcmUoXCJub2RlLWpvc2VcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHBhY2thZ2VfanNvbl8xID0gcmVxdWlyZShcIi4uLy4uL3BhY2thZ2UuanNvblwiKTtcbmNvbnN0IHBlbUhlYWRlciA9IFwiLS0tLS1CRUdJTiBFQyBQUklWQVRFIEtFWS0tLS0tXCI7XG5jb25zdCBwZW1Gb290ZXIgPSBcIi0tLS0tRU5EIEVDIFBSSVZBVEUgS0VZLS0tLS1cIjtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGJ1aWxkcyBKV1RzIGZvciBhdXRoZW50aWNhdGluZyB3aXRoIHRoZSBDb2luYmFzZSBQbGF0Zm9ybSBBUElzLlxuICovXG5jbGFzcyBDb2luYmFzZUF1dGhlbnRpY2F0b3Ige1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBBdXRoZW50aWNhdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleSAtIFRoZSBBUEkga2V5IG5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIG9mIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VWZXJzaW9uIC0gVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcGlLZXksIHByaXZhdGVLZXksIHNvdXJjZSwgc291cmNlVmVyc2lvbikge1xuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICAgICAgdGhpcy5wcml2YXRlS2V5ID0gcHJpdmF0ZUtleTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc291cmNlVmVyc2lvbiA9IHNvdXJjZVZlcnNpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1pZGRsZXdhcmUgdG8gaW50ZXJjZXB0IHJlcXVlc3RzIGFuZCBhZGQgSldUIHRvIEF1dGhvcml6YXRpb24gaGVhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJbnRlcm5hbEF4aW9zUmVxdWVzdENvbmZpZ30gY29uZmlnIC0gVGhlIHJlcXVlc3QgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlYnVnZ2luZyAtIEZsYWcgdG8gZW5hYmxlIGRlYnVnZ2luZy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbnRlcm5hbEF4aW9zUmVxdWVzdENvbmZpZz59IFRoZSByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gd2l0aCB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXIgYWRkZWQuXG4gICAgICogQHRocm93cyB7SW52YWxpZEFQSUtleUZvcm1hdH0gSWYgSldUIGNvdWxkIG5vdCBiZSBidWlsdC5cbiAgICAgKi9cbiAgICBhc3luYyBhdXRoZW50aWNhdGVSZXF1ZXN0KGNvbmZpZywgZGVidWdnaW5nID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gY29uZmlnLm1ldGhvZD8udG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMuYnVpbGRKV1QoY29uZmlnLnVybCB8fCBcIlwiLCBtZXRob2QpO1xuICAgICAgICBpZiAoZGVidWdnaW5nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQVBJIFJFUVVFU1Q6ICR7bWV0aG9kfSAke2NvbmZpZy51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLmhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgICAgIGNvbmZpZy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgICAgIGNvbmZpZy5oZWFkZXJzW1wiQ29ycmVsYXRpb24tQ29udGV4dFwiXSA9IHRoaXMuZ2V0Q29ycmVsYXRpb25EYXRhKCk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgSldUIGZvciB0aGUgZ2l2ZW4gQVBJIGVuZHBvaW50IFVSTC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBVUkwgb2YgdGhlIEFQSSBlbmRwb2ludC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIC0gSFRUUCBtZXRob2Qgb2YgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gSldUIHRva2VuLlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRBUElLZXlGb3JtYXR9IElmIHRoZSBwcml2YXRlIGtleSBpcyBub3QgaW4gdGhlIGNvcnJlY3QgZm9ybWF0LlxuICAgICAqL1xuICAgIGFzeW5jIGJ1aWxkSldUKHVybCwgbWV0aG9kID0gXCJHRVRcIikge1xuICAgICAgICBjb25zdCBwZW1Qcml2YXRlS2V5ID0gdGhpcy5leHRyYWN0UGVtS2V5KHRoaXMucHJpdmF0ZUtleSk7XG4gICAgICAgIGxldCBwcml2YXRlS2V5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJpdmF0ZUtleSA9IGF3YWl0IG5vZGVfam9zZV8xLkpXSy5hc0tleShwZW1Qcml2YXRlS2V5LCBcInBlbVwiKTtcbiAgICAgICAgICAgIGlmIChwcml2YXRlS2V5Lmt0eSAhPT0gXCJFQ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRBUElLZXlGb3JtYXRFcnJvcihcIkludmFsaWQga2V5IHR5cGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFQSUtleUZvcm1hdEVycm9yKFwiQ291bGQgbm90IHBhcnNlIHRoZSBwcml2YXRlIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICAgICAgICBhbGc6IFwiRVMyNTZcIixcbiAgICAgICAgICAgIGtpZDogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICB0eXA6IFwiSldUXCIsXG4gICAgICAgICAgICBub25jZTogdGhpcy5ub25jZSgpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybCk7XG4gICAgICAgIGNvbnN0IHVyaSA9IGAke21ldGhvZH0gJHt1cmxPYmplY3QuaG9zdH0ke3VybE9iamVjdC5wYXRobmFtZX1gO1xuICAgICAgICBjb25zdCBjbGFpbXMgPSB7XG4gICAgICAgICAgICBzdWI6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgaXNzOiBcImNkcFwiLFxuICAgICAgICAgICAgYXVkOiBbXCJjZHBfc2VydmljZVwiXSxcbiAgICAgICAgICAgIG5iZjogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICAgICAgICBleHA6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICsgNjAsIC8vICsxIG1pbnV0ZVxuICAgICAgICAgICAgdXJpczogW3VyaV0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShjbGFpbXMpKS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBub2RlX2pvc2VfMS5KV1MuY3JlYXRlU2lnbih7IGZvcm1hdDogXCJjb21wYWN0XCIsIGZpZWxkczogaGVhZGVyIH0sIHByaXZhdGVLZXkpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShwYXlsb2FkKVxuICAgICAgICAgICAgICAgIC5maW5hbCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFQSUtleUZvcm1hdEVycm9yKFwiQ291bGQgbm90IHNpZ24gdGhlIEpXVFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgUEVNIGtleSBmcm9tIHRoZSBnaXZlbiBwcml2YXRlIGtleSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpdmF0ZUtleVN0cmluZyAtIFRoZSBwcml2YXRlIGtleSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIFBFTSBrZXkuXG4gICAgICogQHRocm93cyB7SW52YWxpZEFQSUtleUZvcm1hdH0gSWYgdGhlIHByaXZhdGUga2V5IHN0cmluZyBpcyBub3QgaW4gdGhlIGNvcnJlY3QgZm9ybWF0LlxuICAgICAqL1xuICAgIGV4dHJhY3RQZW1LZXkocHJpdmF0ZUtleVN0cmluZykge1xuICAgICAgICBwcml2YXRlS2V5U3RyaW5nID0gcHJpdmF0ZUtleVN0cmluZy5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgICAgIGlmIChwcml2YXRlS2V5U3RyaW5nLnN0YXJ0c1dpdGgocGVtSGVhZGVyKSAmJiBwcml2YXRlS2V5U3RyaW5nLmVuZHNXaXRoKHBlbUZvb3RlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBwcml2YXRlS2V5U3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IoXCJJbnZhbGlkIHByaXZhdGUga2V5IGZvcm1hdFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgcmFuZG9tIG5vbmNlIGZvciB0aGUgSldULlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGdlbmVyYXRlZCBub25jZS5cbiAgICAgKi9cbiAgICBub25jZSgpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBcIjAxMjM0NTY3ODlcIjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHJhbmdlLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByYW5nZS5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGVuY29kZWQgY29ycmVsYXRpb24gZGF0YSBpbmNsdWRpbmcgdGhlIFNESyB2ZXJzaW9uIGFuZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEVuY29kZWQgY29ycmVsYXRpb24gZGF0YS5cbiAgICAgKi9cbiAgICBnZXRDb3JyZWxhdGlvbkRhdGEoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBzZGtfdmVyc2lvbjogcGFja2FnZV9qc29uXzEudmVyc2lvbixcbiAgICAgICAgICAgIHNka19sYW5ndWFnZTogXCJ0eXBlc2NyaXB0XCIsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zb3VyY2VWZXJzaW9uKSB7XG4gICAgICAgICAgICBkYXRhW1wic291cmNlX3ZlcnNpb25cIl0gPSB0aGlzLnNvdXJjZVZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGRhdGEpXG4gICAgICAgICAgICAubWFwKGtleSA9PiBgJHtrZXl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KGRhdGFba2V5XSl9YClcbiAgICAgICAgICAgIC5qb2luKFwiLFwiKTtcbiAgICB9XG59XG5leHBvcnRzLkNvaW5iYXNlQXV0aGVudGljYXRvciA9IENvaW5iYXNlQXV0aGVudGljYXRvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Balance = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\n/** A representation of a balance. */\nclass Balance {\n    /**\n     * Private constructor to prevent direct instantiation outside of the factory methods.\n     *\n     * @ignore\n     * @param {Decimal} amount - The amount of the balance.\n     * @param {string} assetId - The asset ID.\n     * @hideconstructor\n     */\n    constructor(amount, assetId, asset) {\n        this.amount = amount;\n        this.assetId = assetId;\n        this.asset = asset;\n    }\n    /**\n     * Converts a BalanceModel into a Balance object.\n     *\n     * @param {BalanceModel} model - The balance model object.\n     * @returns {Balance} The Balance object.\n     */\n    static fromModel(model) {\n        const asset = asset_1.Asset.fromModel(model.asset);\n        return new Balance(asset.fromAtomicAmount(new decimal_js_1.default(model.amount)), asset.getAssetId(), asset);\n    }\n    /**\n     * Converts a BalanceModel and asset ID into a Balance object.\n     *\n     * @param {BalanceModel} model - The balance model object.\n     * @param {string} assetId - The asset ID.\n     * @returns {Balance} The Balance object.\n     */\n    static fromModelAndAssetId(model, assetId) {\n        const asset = asset_1.Asset.fromModel(model.asset, assetId);\n        return new Balance(asset.fromAtomicAmount(new decimal_js_1.default(model.amount)), asset.getAssetId(), asset);\n    }\n}\nexports.Balance = Balance;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2JhbGFuY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YscUNBQXFDLG1CQUFPLENBQUMsOERBQVk7QUFDekQsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvYmFsYW5jZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFsYW5jZSA9IHZvaWQgMDtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVjaW1hbC5qc1wiKSk7XG5jb25zdCBhc3NldF8xID0gcmVxdWlyZShcIi4vYXNzZXRcIik7XG4vKiogQSByZXByZXNlbnRhdGlvbiBvZiBhIGJhbGFuY2UuICovXG5jbGFzcyBCYWxhbmNlIHtcbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGNvbnN0cnVjdG9yIHRvIHByZXZlbnQgZGlyZWN0IGluc3RhbnRpYXRpb24gb3V0c2lkZSBvZiB0aGUgZmFjdG9yeSBtZXRob2RzLlxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBwYXJhbSB7RGVjaW1hbH0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgYmFsYW5jZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAaGlkZWNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYW1vdW50LCBhc3NldElkLCBhc3NldCkge1xuICAgICAgICB0aGlzLmFtb3VudCA9IGFtb3VudDtcbiAgICAgICAgdGhpcy5hc3NldElkID0gYXNzZXRJZDtcbiAgICAgICAgdGhpcy5hc3NldCA9IGFzc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIEJhbGFuY2VNb2RlbCBpbnRvIGEgQmFsYW5jZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0JhbGFuY2VNb2RlbH0gbW9kZWwgLSBUaGUgYmFsYW5jZSBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0JhbGFuY2V9IFRoZSBCYWxhbmNlIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU1vZGVsKG1vZGVsKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gYXNzZXRfMS5Bc3NldC5mcm9tTW9kZWwobW9kZWwuYXNzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IEJhbGFuY2UoYXNzZXQuZnJvbUF0b21pY0Ftb3VudChuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQobW9kZWwuYW1vdW50KSksIGFzc2V0LmdldEFzc2V0SWQoKSwgYXNzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIEJhbGFuY2VNb2RlbCBhbmQgYXNzZXQgSUQgaW50byBhIEJhbGFuY2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCYWxhbmNlTW9kZWx9IG1vZGVsIC0gVGhlIGJhbGFuY2UgbW9kZWwgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEByZXR1cm5zIHtCYWxhbmNlfSBUaGUgQmFsYW5jZSBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Nb2RlbEFuZEFzc2V0SWQobW9kZWwsIGFzc2V0SWQpIHtcbiAgICAgICAgY29uc3QgYXNzZXQgPSBhc3NldF8xLkFzc2V0LmZyb21Nb2RlbChtb2RlbC5hc3NldCwgYXNzZXRJZCk7XG4gICAgICAgIHJldHVybiBuZXcgQmFsYW5jZShhc3NldC5mcm9tQXRvbWljQW1vdW50KG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdChtb2RlbC5hbW91bnQpKSwgYXNzZXQuZ2V0QXNzZXRJZCgpLCBhc3NldCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYWxhbmNlID0gQmFsYW5jZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BalanceMap = void 0;\nconst balance_1 = __webpack_require__(/*! ./balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\");\n/**\n * A convenience class for storing and manipulating Asset balances in a human-readable format.\n */\nclass BalanceMap extends Map {\n    /**\n     * Converts a list of Balance models to a BalanceMap.\n     *\n     * @param {BalanceModel[]} balances - The list of balances fetched from the API.\n     * @returns {BalanceMap} The converted BalanceMap object.\n     */\n    static fromBalances(balances) {\n        const balanceMap = new BalanceMap();\n        balances.forEach(balanceModel => {\n            const balance = balance_1.Balance.fromModel(balanceModel);\n            balanceMap.add(balance);\n        });\n        return balanceMap;\n    }\n    /**\n     * Adds a balance to the map.\n     *\n     * @param {Balance} balance - The balance to add to the map.\n     */\n    add(balance) {\n        if (!(balance instanceof balance_1.Balance)) {\n            throw new Error(\"balance must be a Balance\");\n        }\n        this.set(balance.assetId, balance.amount);\n    }\n    /**\n     * Returns a string representation of the balance map.\n     *\n     * @returns The string representation of the balance map.\n     */\n    toString() {\n        const result = {};\n        this.forEach((value, key) => {\n            let str = value.toString();\n            if (value.isInteger()) {\n                str = value.toNumber().toString();\n            }\n            result[key] = str;\n        });\n        return `BalanceMap${JSON.stringify(result)}`;\n    }\n}\nexports.BalanceMap = BalanceMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2JhbGFuY2VfbWFwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixrQkFBa0IsbUJBQU8sQ0FBQyx1RkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvYmFsYW5jZV9tYXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhbGFuY2VNYXAgPSB2b2lkIDA7XG5jb25zdCBiYWxhbmNlXzEgPSByZXF1aXJlKFwiLi9iYWxhbmNlXCIpO1xuLyoqXG4gKiBBIGNvbnZlbmllbmNlIGNsYXNzIGZvciBzdG9yaW5nIGFuZCBtYW5pcHVsYXRpbmcgQXNzZXQgYmFsYW5jZXMgaW4gYSBodW1hbi1yZWFkYWJsZSBmb3JtYXQuXG4gKi9cbmNsYXNzIEJhbGFuY2VNYXAgZXh0ZW5kcyBNYXAge1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgbGlzdCBvZiBCYWxhbmNlIG1vZGVscyB0byBhIEJhbGFuY2VNYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0JhbGFuY2VNb2RlbFtdfSBiYWxhbmNlcyAtIFRoZSBsaXN0IG9mIGJhbGFuY2VzIGZldGNoZWQgZnJvbSB0aGUgQVBJLlxuICAgICAqIEByZXR1cm5zIHtCYWxhbmNlTWFwfSBUaGUgY29udmVydGVkIEJhbGFuY2VNYXAgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmFsYW5jZXMoYmFsYW5jZXMpIHtcbiAgICAgICAgY29uc3QgYmFsYW5jZU1hcCA9IG5ldyBCYWxhbmNlTWFwKCk7XG4gICAgICAgIGJhbGFuY2VzLmZvckVhY2goYmFsYW5jZU1vZGVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBiYWxhbmNlXzEuQmFsYW5jZS5mcm9tTW9kZWwoYmFsYW5jZU1vZGVsKTtcbiAgICAgICAgICAgIGJhbGFuY2VNYXAuYWRkKGJhbGFuY2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJhbGFuY2VNYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBiYWxhbmNlIHRvIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0JhbGFuY2V9IGJhbGFuY2UgLSBUaGUgYmFsYW5jZSB0byBhZGQgdG8gdGhlIG1hcC5cbiAgICAgKi9cbiAgICBhZGQoYmFsYW5jZSkge1xuICAgICAgICBpZiAoIShiYWxhbmNlIGluc3RhbmNlb2YgYmFsYW5jZV8xLkJhbGFuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWxhbmNlIG11c3QgYmUgYSBCYWxhbmNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KGJhbGFuY2UuYXNzZXRJZCwgYmFsYW5jZS5hbW91bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiYWxhbmNlIG1hcC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJhbGFuY2UgbWFwLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pc0ludGVnZXIoKSkge1xuICAgICAgICAgICAgICAgIHN0ciA9IHZhbHVlLnRvTnVtYmVyKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gc3RyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGBCYWxhbmNlTWFwJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfWA7XG4gICAgfVxufVxuZXhwb3J0cy5CYWxhbmNlTWFwID0gQmFsYW5jZU1hcDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Coinbase = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\"));\nconst axios_retry_1 = __importDefault(__webpack_require__(/*! axios-retry */ \"(ssr)/./node_modules/axios-retry/dist/cjs/index.js\"));\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst client_1 = __webpack_require__(/*! ../client */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/index.js\");\nconst base_1 = __webpack_require__(/*! ./../client/base */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js\");\nconst configuration_1 = __webpack_require__(/*! ./../client/configuration */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js\");\nconst authenticator_1 = __webpack_require__(/*! ./authenticator */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst os = __importStar(__webpack_require__(/*! os */ \"os\"));\n/**\n * The Coinbase SDK.\n */\nclass Coinbase {\n    /**\n     * Initializes the Coinbase SDK.\n     *\n     * @deprecated as of v0.5.0, use `configure` or `configureFromJson` instead.\n     *\n     * @class\n     * @param options - The constructor options.\n     * @param options.apiKeyName - The API key name.\n     * @param options.privateKey - The private key associated with the API key.\n     * @param options.useServerSigner - Whether to use a Server-Signer or not.\n     * @param options.debugging - If true, logs API requests and responses to the console.\n     * @param options.basePath - The base path for the API.\n     * @param options.maxNetworkRetries - The maximum number of network retries for the API GET requests.\n     * @param options.source - Optional source string to be sent with the API requests. Defaults to `sdk`.\n     * @param options.sourceVersion - Optional source version string to be sent with the API requests.\n     * @throws {InvalidConfigurationError} If the configuration is invalid.\n     * @throws {InvalidAPIKeyFormatError} If not able to create JWT token.\n     */\n    constructor({ apiKeyName, privateKey, useServerSigner = false, debugging = false, basePath = base_1.BASE_PATH, maxNetworkRetries = 3, source = \"sdk\", sourceVersion = undefined, }) {\n        if (apiKeyName === \"\") {\n            throw new errors_1.InvalidConfigurationError(\"Invalid configuration: apiKeyName is empty\");\n        }\n        if (privateKey === \"\") {\n            throw new errors_1.InvalidConfigurationError(\"Invalid configuration: privateKey is empty\");\n        }\n        const coinbaseAuthenticator = new authenticator_1.CoinbaseAuthenticator(apiKeyName, privateKey, source, sourceVersion);\n        const config = new configuration_1.Configuration({\n            basePath: basePath,\n        });\n        const axiosInstance = axios_1.default.create();\n        (0, axios_retry_1.default)(axiosInstance, {\n            retries: maxNetworkRetries,\n            retryCondition: (error) => {\n                return (error.config?.method?.toUpperCase() === \"GET\" &&\n                    (error.response?.status || 0) in [500, 502, 503, 504]);\n            },\n        });\n        (0, utils_1.registerAxiosInterceptors)(axiosInstance, config => coinbaseAuthenticator.authenticateRequest(config, debugging), \n        /* istanbul ignore file */\n        response => (0, utils_1.logApiResponse)(response, debugging));\n        Coinbase.apiClients.wallet = (0, client_1.WalletsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.address = (0, client_1.AddressesApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.transfer = (0, client_1.TransfersApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.trade = (0, client_1.TradesApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.serverSigner = (0, client_1.ServerSignersApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.stake = (0, client_1.StakeApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.walletStake = (0, client_1.MPCWalletStakeApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.asset = (0, client_1.AssetsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.webhook = (0, client_1.WebhooksApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.contractInvocation = (0, client_1.ContractInvocationsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.externalAddress = (0, client_1.ExternalAddressesApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.balanceHistory = (0, client_1.BalanceHistoryApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.contractEvent = (0, client_1.ContractEventsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.smartContract = (0, client_1.SmartContractsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.fund = (0, client_1.FundApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.transactionHistory = (0, client_1.TransactionHistoryApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiKeyPrivateKey = privateKey;\n        Coinbase.useServerSigner = useServerSigner;\n        Coinbase.apiClients.addressReputation = (0, client_1.ReputationApiFactory)(config, basePath, axiosInstance);\n    }\n    /**\n     * Configures the Coinbase SDK with the provided options.\n     *\n     * @param options - The configuration options.\n     * @param options.apiKeyName - The name of the API key.\n     * @param options.privateKey - The private key associated with the API key.\n     * @param options.useServerSigner - Whether to use a Server-Signer or not. Defaults to false.\n     * @param options.debugging - If true, logs API requests and responses to the console. Defaults to false.\n     * @param options.basePath - The base path for the API. Defaults to BASE_PATH.\n     * @param options.source - Optional source string to be sent with the API requests. Defaults to `sdk`.\n     * @param options.sourceVersion - Optional source version string to be sent with the API requests.\n     * @returns A new instance of the Coinbase SDK.\n     */\n    static configure({ apiKeyName, privateKey, useServerSigner = false, debugging = false, basePath = base_1.BASE_PATH, source = \"sdk\", sourceVersion = undefined, }) {\n        return new Coinbase({\n            apiKeyName,\n            privateKey,\n            useServerSigner,\n            debugging,\n            basePath,\n            source,\n            sourceVersion,\n        });\n    }\n    /**\n     * Reads the API key and private key from a JSON file and initializes the Coinbase SDK.\n     *\n     * @param options - The configuration options.\n     * @param options.filePath - The path to the JSON file containing the API key and private key.\n     * @param options.useServerSigner - Whether to use a Server-Signer or not.\n     * @param options.debugging - If true, logs API requests and responses to the console.\n     * @param options.basePath - The base path for the API.\n     * @param options.source - Optional source string to be sent with the API requests. Defaults to `sdk`.\n     * @param options.sourceVersion - Optional source version string to be sent with the API requests.\n     * @returns A new instance of the Coinbase SDK.\n     * @throws {InvalidAPIKeyFormat} If the file does not exist or the configuration values are missing/invalid.\n     * @throws {InvalidConfiguration} If the configuration is invalid.\n     * @throws {InvalidAPIKeyFormat} If not able to create JWT token.\n     */\n    static configureFromJson({ filePath = \"coinbase_cloud_api_key.json\", useServerSigner = false, debugging = false, basePath = base_1.BASE_PATH, source = \"sdk\", sourceVersion = undefined, } = {}) {\n        filePath = filePath.startsWith(\"~\") ? filePath.replace(\"~\", os.homedir()) : filePath;\n        if (!fs.existsSync(filePath)) {\n            throw new errors_1.InvalidConfigurationError(`Invalid configuration: file not found at ${filePath}`);\n        }\n        try {\n            const data = fs.readFileSync(filePath, \"utf8\");\n            const config = JSON.parse(data);\n            if (!config.name || !config.privateKey) {\n                throw new errors_1.InvalidAPIKeyFormatError(\"Invalid configuration: missing configuration values\");\n            }\n            return new Coinbase({\n                apiKeyName: config.name,\n                privateKey: config.privateKey,\n                useServerSigner: useServerSigner,\n                debugging: debugging,\n                basePath: basePath,\n                source,\n                sourceVersion,\n            });\n        }\n        catch (e) {\n            if (e instanceof SyntaxError) {\n                throw new errors_1.InvalidAPIKeyFormatError(\"Not able to parse the configuration file\");\n            }\n            else {\n                throw new errors_1.InvalidAPIKeyFormatError(`An error occurred while reading the configuration file: ${e.message}`);\n            }\n        }\n    }\n    /**\n     * Converts a network symbol to a string, replacing underscores with hyphens.\n     *\n     * @param network - The network symbol to convert\n     * @returns the converted string\n     */\n    static normalizeNetwork(network) {\n        return network.replace(/_/g, \"-\");\n    }\n    /**\n     * Converts a string to a symbol, replacing hyphens with underscores.\n     *\n     * @param asset - The string to convert\n     * @returns the converted symbol\n     */\n    static toAssetId(asset) {\n        return asset.replace(/-/g, \"_\");\n    }\n}\nexports.Coinbase = Coinbase;\n/**\n * The map of supported networks to network ID. Generated from the OpenAPI spec.\n *\n * @constant\n *\n * @example\n * ```typescript\n * Coinbase.networks.BaseMainnet\n * ```\n */\nCoinbase.networks = client_1.NetworkIdentifier;\n/**\n * The list of supported assets.\n *\n * @constant\n */\nCoinbase.assets = {\n    Eth: \"eth\",\n    Wei: \"wei\",\n    Gwei: \"gwei\",\n    Usdc: \"usdc\",\n    Weth: \"weth\",\n    Sol: \"sol\",\n    Lamport: \"lamport\",\n};\nCoinbase.apiClients = {};\n/**\n * The default page limit for list methods.\n *\n * @constant\n */\nCoinbase.defaultPageLimit = 100;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvaW5iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixnQ0FBZ0MsbUJBQU8sQ0FBQyw2REFBTztBQUMvQyxzQ0FBc0MsbUJBQU8sQ0FBQyx1RUFBYTtBQUMzRCx3QkFBd0IsbUJBQU8sQ0FBQyxjQUFJO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLG1GQUFXO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyx5RkFBa0I7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsMkdBQTJCO0FBQzNELHdCQUF3QixtQkFBTyxDQUFDLG1HQUFpQjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQyxjQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQyxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0Esa0JBQWtCLG9LQUFvSztBQUN0TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNklBQTZJO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQSwrQkFBK0IsZ0tBQWdLLElBQUk7QUFDbk07QUFDQTtBQUNBLHFHQUFxRyxTQUFTO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUgsVUFBVTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvY29pbmJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29pbmJhc2UgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG5jb25zdCBheGlvc19yZXRyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvcy1yZXRyeVwiKSk7XG5jb25zdCBmcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZnNcIikpO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi4vY2xpZW50XCIpO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4vLi4vY2xpZW50L2Jhc2VcIik7XG5jb25zdCBjb25maWd1cmF0aW9uXzEgPSByZXF1aXJlKFwiLi8uLi9jbGllbnQvY29uZmlndXJhdGlvblwiKTtcbmNvbnN0IGF1dGhlbnRpY2F0b3JfMSA9IHJlcXVpcmUoXCIuL2F1dGhlbnRpY2F0b3JcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IG9zID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJvc1wiKSk7XG4vKipcbiAqIFRoZSBDb2luYmFzZSBTREsuXG4gKi9cbmNsYXNzIENvaW5iYXNlIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgQ29pbmJhc2UgU0RLLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgYXMgb2YgdjAuNS4wLCB1c2UgYGNvbmZpZ3VyZWAgb3IgYGNvbmZpZ3VyZUZyb21Kc29uYCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQGNsYXNzXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29uc3RydWN0b3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hcGlLZXlOYW1lIC0gVGhlIEFQSSBrZXkgbmFtZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgQVBJIGtleS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy51c2VTZXJ2ZXJTaWduZXIgLSBXaGV0aGVyIHRvIHVzZSBhIFNlcnZlci1TaWduZXIgb3Igbm90LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlYnVnZ2luZyAtIElmIHRydWUsIGxvZ3MgQVBJIHJlcXVlc3RzIGFuZCByZXNwb25zZXMgdG8gdGhlIGNvbnNvbGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYmFzZVBhdGggLSBUaGUgYmFzZSBwYXRoIGZvciB0aGUgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1heE5ldHdvcmtSZXRyaWVzIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG5ldHdvcmsgcmV0cmllcyBmb3IgdGhlIEFQSSBHRVQgcmVxdWVzdHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc291cmNlIC0gT3B0aW9uYWwgc291cmNlIHN0cmluZyB0byBiZSBzZW50IHdpdGggdGhlIEFQSSByZXF1ZXN0cy4gRGVmYXVsdHMgdG8gYHNka2AuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc291cmNlVmVyc2lvbiAtIE9wdGlvbmFsIHNvdXJjZSB2ZXJzaW9uIHN0cmluZyB0byBiZSBzZW50IHdpdGggdGhlIEFQSSByZXF1ZXN0cy5cbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkQ29uZmlndXJhdGlvbkVycm9yfSBJZiB0aGUgY29uZmlndXJhdGlvbiBpcyBpbnZhbGlkLlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRBUElLZXlGb3JtYXRFcnJvcn0gSWYgbm90IGFibGUgdG8gY3JlYXRlIEpXVCB0b2tlbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGFwaUtleU5hbWUsIHByaXZhdGVLZXksIHVzZVNlcnZlclNpZ25lciA9IGZhbHNlLCBkZWJ1Z2dpbmcgPSBmYWxzZSwgYmFzZVBhdGggPSBiYXNlXzEuQkFTRV9QQVRILCBtYXhOZXR3b3JrUmV0cmllcyA9IDMsIHNvdXJjZSA9IFwic2RrXCIsIHNvdXJjZVZlcnNpb24gPSB1bmRlZmluZWQsIH0pIHtcbiAgICAgICAgaWYgKGFwaUtleU5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQ29uZmlndXJhdGlvbkVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uOiBhcGlLZXlOYW1lIGlzIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcml2YXRlS2V5ID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbjogcHJpdmF0ZUtleSBpcyBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2luYmFzZUF1dGhlbnRpY2F0b3IgPSBuZXcgYXV0aGVudGljYXRvcl8xLkNvaW5iYXNlQXV0aGVudGljYXRvcihhcGlLZXlOYW1lLCBwcml2YXRlS2V5LCBzb3VyY2UsIHNvdXJjZVZlcnNpb24pO1xuICAgICAgICBjb25zdCBjb25maWcgPSBuZXcgY29uZmlndXJhdGlvbl8xLkNvbmZpZ3VyYXRpb24oe1xuICAgICAgICAgICAgYmFzZVBhdGg6IGJhc2VQYXRoLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXhpb3NJbnN0YW5jZSA9IGF4aW9zXzEuZGVmYXVsdC5jcmVhdGUoKTtcbiAgICAgICAgKDAsIGF4aW9zX3JldHJ5XzEuZGVmYXVsdCkoYXhpb3NJbnN0YW5jZSwge1xuICAgICAgICAgICAgcmV0cmllczogbWF4TmV0d29ya1JldHJpZXMsXG4gICAgICAgICAgICByZXRyeUNvbmRpdGlvbjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChlcnJvci5jb25maWc/Lm1ldGhvZD8udG9VcHBlckNhc2UoKSA9PT0gXCJHRVRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cyB8fCAwKSBpbiBbNTAwLCA1MDIsIDUwMywgNTA0XSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIHV0aWxzXzEucmVnaXN0ZXJBeGlvc0ludGVyY2VwdG9ycykoYXhpb3NJbnN0YW5jZSwgY29uZmlnID0+IGNvaW5iYXNlQXV0aGVudGljYXRvci5hdXRoZW50aWNhdGVSZXF1ZXN0KGNvbmZpZywgZGVidWdnaW5nKSwgXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG4gICAgICAgIHJlc3BvbnNlID0+ICgwLCB1dGlsc18xLmxvZ0FwaVJlc3BvbnNlKShyZXNwb25zZSwgZGVidWdnaW5nKSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0ID0gKDAsIGNsaWVudF8xLldhbGxldHNBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy5hZGRyZXNzID0gKDAsIGNsaWVudF8xLkFkZHJlc3Nlc0FwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLnRyYW5zZmVyID0gKDAsIGNsaWVudF8xLlRyYW5zZmVyc0FwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLnRyYWRlID0gKDAsIGNsaWVudF8xLlRyYWRlc0FwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLnNlcnZlclNpZ25lciA9ICgwLCBjbGllbnRfMS5TZXJ2ZXJTaWduZXJzQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMuc3Rha2UgPSAoMCwgY2xpZW50XzEuU3Rha2VBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy53YWxsZXRTdGFrZSA9ICgwLCBjbGllbnRfMS5NUENXYWxsZXRTdGFrZUFwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLmFzc2V0ID0gKDAsIGNsaWVudF8xLkFzc2V0c0FwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLndlYmhvb2sgPSAoMCwgY2xpZW50XzEuV2ViaG9va3NBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy5jb250cmFjdEludm9jYXRpb24gPSAoMCwgY2xpZW50XzEuQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLmV4dGVybmFsQWRkcmVzcyA9ICgwLCBjbGllbnRfMS5FeHRlcm5hbEFkZHJlc3Nlc0FwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLmJhbGFuY2VIaXN0b3J5ID0gKDAsIGNsaWVudF8xLkJhbGFuY2VIaXN0b3J5QXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMuY29udHJhY3RFdmVudCA9ICgwLCBjbGllbnRfMS5Db250cmFjdEV2ZW50c0FwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLnNtYXJ0Q29udHJhY3QgPSAoMCwgY2xpZW50XzEuU21hcnRDb250cmFjdHNBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy5mdW5kID0gKDAsIGNsaWVudF8xLkZ1bmRBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy50cmFuc2FjdGlvbkhpc3RvcnkgPSAoMCwgY2xpZW50XzEuVHJhbnNhY3Rpb25IaXN0b3J5QXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUtleVByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgICAgICBDb2luYmFzZS51c2VTZXJ2ZXJTaWduZXIgPSB1c2VTZXJ2ZXJTaWduZXI7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMuYWRkcmVzc1JlcHV0YXRpb24gPSAoMCwgY2xpZW50XzEuUmVwdXRhdGlvbkFwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBDb2luYmFzZSBTREsgd2l0aCB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hcGlLZXlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEFQSSBrZXkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIEFQSSBrZXkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudXNlU2VydmVyU2lnbmVyIC0gV2hldGhlciB0byB1c2UgYSBTZXJ2ZXItU2lnbmVyIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVidWdnaW5nIC0gSWYgdHJ1ZSwgbG9ncyBBUEkgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcyB0byB0aGUgY29uc29sZS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYmFzZVBhdGggLSBUaGUgYmFzZSBwYXRoIGZvciB0aGUgQVBJLiBEZWZhdWx0cyB0byBCQVNFX1BBVEguXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc291cmNlIC0gT3B0aW9uYWwgc291cmNlIHN0cmluZyB0byBiZSBzZW50IHdpdGggdGhlIEFQSSByZXF1ZXN0cy4gRGVmYXVsdHMgdG8gYHNka2AuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc291cmNlVmVyc2lvbiAtIE9wdGlvbmFsIHNvdXJjZSB2ZXJzaW9uIHN0cmluZyB0byBiZSBzZW50IHdpdGggdGhlIEFQSSByZXF1ZXN0cy5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ29pbmJhc2UgU0RLLlxuICAgICAqL1xuICAgIHN0YXRpYyBjb25maWd1cmUoeyBhcGlLZXlOYW1lLCBwcml2YXRlS2V5LCB1c2VTZXJ2ZXJTaWduZXIgPSBmYWxzZSwgZGVidWdnaW5nID0gZmFsc2UsIGJhc2VQYXRoID0gYmFzZV8xLkJBU0VfUEFUSCwgc291cmNlID0gXCJzZGtcIiwgc291cmNlVmVyc2lvbiA9IHVuZGVmaW5lZCwgfSkge1xuICAgICAgICByZXR1cm4gbmV3IENvaW5iYXNlKHtcbiAgICAgICAgICAgIGFwaUtleU5hbWUsXG4gICAgICAgICAgICBwcml2YXRlS2V5LFxuICAgICAgICAgICAgdXNlU2VydmVyU2lnbmVyLFxuICAgICAgICAgICAgZGVidWdnaW5nLFxuICAgICAgICAgICAgYmFzZVBhdGgsXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICBzb3VyY2VWZXJzaW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIEFQSSBrZXkgYW5kIHByaXZhdGUga2V5IGZyb20gYSBKU09OIGZpbGUgYW5kIGluaXRpYWxpemVzIHRoZSBDb2luYmFzZSBTREsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmlsZVBhdGggLSBUaGUgcGF0aCB0byB0aGUgSlNPTiBmaWxlIGNvbnRhaW5pbmcgdGhlIEFQSSBrZXkgYW5kIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnVzZVNlcnZlclNpZ25lciAtIFdoZXRoZXIgdG8gdXNlIGEgU2VydmVyLVNpZ25lciBvciBub3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVidWdnaW5nIC0gSWYgdHJ1ZSwgbG9ncyBBUEkgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcyB0byB0aGUgY29uc29sZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5iYXNlUGF0aCAtIFRoZSBiYXNlIHBhdGggZm9yIHRoZSBBUEkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc291cmNlIC0gT3B0aW9uYWwgc291cmNlIHN0cmluZyB0byBiZSBzZW50IHdpdGggdGhlIEFQSSByZXF1ZXN0cy4gRGVmYXVsdHMgdG8gYHNka2AuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc291cmNlVmVyc2lvbiAtIE9wdGlvbmFsIHNvdXJjZSB2ZXJzaW9uIHN0cmluZyB0byBiZSBzZW50IHdpdGggdGhlIEFQSSByZXF1ZXN0cy5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ29pbmJhc2UgU0RLLlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRBUElLZXlGb3JtYXR9IElmIHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0IG9yIHRoZSBjb25maWd1cmF0aW9uIHZhbHVlcyBhcmUgbWlzc2luZy9pbnZhbGlkLlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRDb25maWd1cmF0aW9ufSBJZiB0aGUgY29uZmlndXJhdGlvbiBpcyBpbnZhbGlkLlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRBUElLZXlGb3JtYXR9IElmIG5vdCBhYmxlIHRvIGNyZWF0ZSBKV1QgdG9rZW4uXG4gICAgICovXG4gICAgc3RhdGljIGNvbmZpZ3VyZUZyb21Kc29uKHsgZmlsZVBhdGggPSBcImNvaW5iYXNlX2Nsb3VkX2FwaV9rZXkuanNvblwiLCB1c2VTZXJ2ZXJTaWduZXIgPSBmYWxzZSwgZGVidWdnaW5nID0gZmFsc2UsIGJhc2VQYXRoID0gYmFzZV8xLkJBU0VfUEFUSCwgc291cmNlID0gXCJzZGtcIiwgc291cmNlVmVyc2lvbiA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XG4gICAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGguc3RhcnRzV2l0aChcIn5cIikgPyBmaWxlUGF0aC5yZXBsYWNlKFwiflwiLCBvcy5ob21lZGlyKCkpIDogZmlsZVBhdGg7XG4gICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQ29uZmlndXJhdGlvbkVycm9yKGBJbnZhbGlkIGNvbmZpZ3VyYXRpb246IGZpbGUgbm90IGZvdW5kIGF0ICR7ZmlsZVBhdGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsIFwidXRmOFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5uYW1lIHx8ICFjb25maWcucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb246IG1pc3NpbmcgY29uZmlndXJhdGlvbiB2YWx1ZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvaW5iYXNlKHtcbiAgICAgICAgICAgICAgICBhcGlLZXlOYW1lOiBjb25maWcubmFtZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiBjb25maWcucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICB1c2VTZXJ2ZXJTaWduZXI6IHVzZVNlcnZlclNpZ25lcixcbiAgICAgICAgICAgICAgICBkZWJ1Z2dpbmc6IGRlYnVnZ2luZyxcbiAgICAgICAgICAgICAgICBiYXNlUGF0aDogYmFzZVBhdGgsXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIHNvdXJjZVZlcnNpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IoXCJOb3QgYWJsZSB0byBwYXJzZSB0aGUgY29uZmlndXJhdGlvbiBmaWxlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRBUElLZXlGb3JtYXRFcnJvcihgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmVhZGluZyB0aGUgY29uZmlndXJhdGlvbiBmaWxlOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIG5ldHdvcmsgc3ltYm9sIHRvIGEgc3RyaW5nLCByZXBsYWNpbmcgdW5kZXJzY29yZXMgd2l0aCBoeXBoZW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmsgLSBUaGUgbmV0d29yayBzeW1ib2wgdG8gY29udmVydFxuICAgICAqIEByZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZU5ldHdvcmsobmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV0d29yay5yZXBsYWNlKC9fL2csIFwiLVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSBzeW1ib2wsIHJlcGxhY2luZyBoeXBoZW5zIHdpdGggdW5kZXJzY29yZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXQgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnRcbiAgICAgKiBAcmV0dXJucyB0aGUgY29udmVydGVkIHN5bWJvbFxuICAgICAqL1xuICAgIHN0YXRpYyB0b0Fzc2V0SWQoYXNzZXQpIHtcbiAgICAgICAgcmV0dXJuIGFzc2V0LnJlcGxhY2UoLy0vZywgXCJfXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29pbmJhc2UgPSBDb2luYmFzZTtcbi8qKlxuICogVGhlIG1hcCBvZiBzdXBwb3J0ZWQgbmV0d29ya3MgdG8gbmV0d29yayBJRC4gR2VuZXJhdGVkIGZyb20gdGhlIE9wZW5BUEkgc3BlYy5cbiAqXG4gKiBAY29uc3RhbnRcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogQ29pbmJhc2UubmV0d29ya3MuQmFzZU1haW5uZXRcbiAqIGBgYFxuICovXG5Db2luYmFzZS5uZXR3b3JrcyA9IGNsaWVudF8xLk5ldHdvcmtJZGVudGlmaWVyO1xuLyoqXG4gKiBUaGUgbGlzdCBvZiBzdXBwb3J0ZWQgYXNzZXRzLlxuICpcbiAqIEBjb25zdGFudFxuICovXG5Db2luYmFzZS5hc3NldHMgPSB7XG4gICAgRXRoOiBcImV0aFwiLFxuICAgIFdlaTogXCJ3ZWlcIixcbiAgICBHd2VpOiBcImd3ZWlcIixcbiAgICBVc2RjOiBcInVzZGNcIixcbiAgICBXZXRoOiBcIndldGhcIixcbiAgICBTb2w6IFwic29sXCIsXG4gICAgTGFtcG9ydDogXCJsYW1wb3J0XCIsXG59O1xuQ29pbmJhc2UuYXBpQ2xpZW50cyA9IHt9O1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBwYWdlIGxpbWl0IGZvciBsaXN0IG1ldGhvZHMuXG4gKlxuICogQGNvbnN0YW50XG4gKi9cbkNvaW5iYXNlLmRlZmF1bHRQYWdlTGltaXQgPSAxMDA7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js":
/*!************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GWEI_DECIMALS = void 0;\nexports.GWEI_DECIMALS = 9;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HV0VJX0RFQ0lNQUxTID0gdm9pZCAwO1xuZXhwb3J0cy5HV0VJX0RFQ0lNQUxTID0gOTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContractEvent = void 0;\n/**\n * A representation of a single contract event.\n */\nclass ContractEvent {\n    /**\n     * Creates the ContractEvent object.\n     *\n     * @param model - The underlying contract event object.\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    /**\n     * Returns the network ID of the ContractEvent.\n     *\n     * @returns The network ID.\n     */\n    networkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the protocol name of the ContractEvent.\n     *\n     * @returns The protocol name.\n     */\n    protocolName() {\n        return this.model.protocol_name;\n    }\n    /**\n     * Returns the contract name of the ContractEvent.\n     *\n     * @returns The contract name.\n     */\n    contractName() {\n        return this.model.contract_name;\n    }\n    /**\n     * Returns the event name of the ContractEvent.\n     *\n     * @returns The event name.\n     */\n    eventName() {\n        return this.model.event_name;\n    }\n    /**\n     * Returns the signature of the ContractEvent.\n     *\n     * @returns The event signature.\n     */\n    sig() {\n        return this.model.sig;\n    }\n    /**\n     * Returns the four bytes of the Keccak hash of the event signature.\n     *\n     * @returns The four bytes of the event signature hash.\n     */\n    fourBytes() {\n        return this.model.four_bytes;\n    }\n    /**\n     * Returns the contract address of the ContractEvent.\n     *\n     * @returns The contract address.\n     */\n    contractAddress() {\n        return this.model.contract_address;\n    }\n    /**\n     * Returns the block time of the ContractEvent.\n     *\n     * @returns The block time.\n     */\n    blockTime() {\n        return new Date(this.model.block_time);\n    }\n    /**\n     * Returns the block height of the ContractEvent.\n     *\n     * @returns The block height.\n     */\n    blockHeight() {\n        return this.model.block_height;\n    }\n    /**\n     * Returns the transaction hash of the ContractEvent.\n     *\n     * @returns The transaction hash.\n     */\n    txHash() {\n        return this.model.tx_hash;\n    }\n    /**\n     * Returns the transaction index of the ContractEvent.\n     *\n     * @returns The transaction index.\n     */\n    txIndex() {\n        return this.model.tx_index;\n    }\n    /**\n     * Returns the event index of the ContractEvent.\n     *\n     * @returns The event index.\n     */\n    eventIndex() {\n        return this.model.event_index;\n    }\n    /**\n     * Returns the event data of the ContractEvent.\n     *\n     * @returns The event data.\n     */\n    data() {\n        return this.model.data;\n    }\n    /**\n     * Print the ContractEvent as a string.\n     *\n     * @returns The string representation of the ContractEvent.\n     */\n    toString() {\n        return `ContractEvent { networkId: '${this.networkId()}' protocolName: '${this.protocolName()}' contractName: '${this.contractName()}' eventName: '${this.eventName()}' contractAddress: '${this.contractAddress()}' blockHeight: ${this.blockHeight()} txHash: '${this.txHash()}' }`;\n    }\n}\nexports.ContractEvent = ContractEvent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvbnRyYWN0X2V2ZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWMsaUJBQWlCLG1CQUFtQixvQkFBb0IsbUJBQW1CLG9CQUFvQixnQkFBZ0IsaUJBQWlCLHNCQUFzQix1QkFBdUIsaUJBQWlCLG9CQUFvQixXQUFXLGNBQWMsR0FBRztBQUM1UjtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvY29udHJhY3RfZXZlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnRyYWN0RXZlbnQgPSB2b2lkIDA7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgY29udHJhY3QgZXZlbnQuXG4gKi9cbmNsYXNzIENvbnRyYWN0RXZlbnQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIENvbnRyYWN0RXZlbnQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIHVuZGVybHlpbmcgY29udHJhY3QgZXZlbnQgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV0d29yayBJRCBvZiB0aGUgQ29udHJhY3RFdmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXR3b3JrIElELlxuICAgICAqL1xuICAgIG5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwubmV0d29ya19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvdG9jb2wgbmFtZSBvZiB0aGUgQ29udHJhY3RFdmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwcm90b2NvbCBuYW1lLlxuICAgICAqL1xuICAgIHByb3RvY29sTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwucHJvdG9jb2xfbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udHJhY3QgbmFtZSBvZiB0aGUgQ29udHJhY3RFdmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjb250cmFjdCBuYW1lLlxuICAgICAqL1xuICAgIGNvbnRyYWN0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY29udHJhY3RfbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXZlbnQgbmFtZSBvZiB0aGUgQ29udHJhY3RFdmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBldmVudCBuYW1lLlxuICAgICAqL1xuICAgIGV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZXZlbnRfbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2lnbmF0dXJlIG9mIHRoZSBDb250cmFjdEV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGV2ZW50IHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBzaWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnNpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZm91ciBieXRlcyBvZiB0aGUgS2VjY2FrIGhhc2ggb2YgdGhlIGV2ZW50IHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBmb3VyIGJ5dGVzIG9mIHRoZSBldmVudCBzaWduYXR1cmUgaGFzaC5cbiAgICAgKi9cbiAgICBmb3VyQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmZvdXJfYnl0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBjb250cmFjdEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNvbnRyYWN0X2FkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJsb2NrIHRpbWUgb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYmxvY2sgdGltZS5cbiAgICAgKi9cbiAgICBibG9ja1RpbWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLm1vZGVsLmJsb2NrX3RpbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBibG9jayBoZWlnaHQgb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYmxvY2sgaGVpZ2h0LlxuICAgICAqL1xuICAgIGJsb2NrSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5ibG9ja19oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIGhhc2ggb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKi9cbiAgICB0eEhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnR4X2hhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIGluZGV4IG9mIHRoZSBDb250cmFjdEV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIGluZGV4LlxuICAgICAqL1xuICAgIHR4SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnR4X2luZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBldmVudCBpbmRleCBvZiB0aGUgQ29udHJhY3RFdmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBldmVudCBpbmRleC5cbiAgICAgKi9cbiAgICBldmVudEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5ldmVudF9pbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXZlbnQgZGF0YSBvZiB0aGUgQ29udHJhY3RFdmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBldmVudCBkYXRhLlxuICAgICAqL1xuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW50IHRoZSBDb250cmFjdEV2ZW50IGFzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ29udHJhY3RFdmVudC5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBDb250cmFjdEV2ZW50IHsgbmV0d29ya0lkOiAnJHt0aGlzLm5ldHdvcmtJZCgpfScgcHJvdG9jb2xOYW1lOiAnJHt0aGlzLnByb3RvY29sTmFtZSgpfScgY29udHJhY3ROYW1lOiAnJHt0aGlzLmNvbnRyYWN0TmFtZSgpfScgZXZlbnROYW1lOiAnJHt0aGlzLmV2ZW50TmFtZSgpfScgY29udHJhY3RBZGRyZXNzOiAnJHt0aGlzLmNvbnRyYWN0QWRkcmVzcygpfScgYmxvY2tIZWlnaHQ6ICR7dGhpcy5ibG9ja0hlaWdodCgpfSB0eEhhc2g6ICcke3RoaXMudHhIYXNoKCl9JyB9YDtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyYWN0RXZlbnQgPSBDb250cmFjdEV2ZW50O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContractInvocation = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/**\n * A representation of a ContractInvocation, which calls a smart contract method\n * onchain. The fee is assumed to be paid in the native Asset of the Network.\n */\nclass ContractInvocation {\n    /**\n     * Private constructor to prevent direct instantiation outside of the factory methods.\n     *\n     * @ignore\n     * @param contractInvocationModel - The ContractInvocation model.\n     * @hideconstructor\n     */\n    constructor(contractInvocationModel) {\n        if (!contractInvocationModel) {\n            throw new Error(\"ContractInvocation model cannot be empty\");\n        }\n        this.model = contractInvocationModel;\n    }\n    /**\n     * Converts a ContractInvocationModel into a ContractInvocation object.\n     *\n     * @param contractInvocationModel - The ContractInvocation model object.\n     * @returns The ContractInvocation object.\n     */\n    static fromModel(contractInvocationModel) {\n        return new ContractInvocation(contractInvocationModel);\n    }\n    /**\n     * Returns the ID of the ContractInvocation.\n     *\n     * @returns The ContractInvocation ID.\n     */\n    getId() {\n        return this.model.contract_invocation_id;\n    }\n    /**\n     * Returns the Network ID of the ContractInvocation.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the Wallet ID of the ContractInvocation.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the From Address ID of the ContractInvocation.\n     *\n     * @returns The From Address ID.\n     */\n    getFromAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the Destination Address ID of the ContractInvocation.\n     *\n     * @returns The Destination Address ID.\n     */\n    getContractAddressId() {\n        return this.model.contract_address;\n    }\n    /**\n     * Returns the Method of the ContractInvocation.\n     *\n     * @returns The Method.\n     */\n    getMethod() {\n        return this.model.method;\n    }\n    /**\n     * Returns the Arguments of the ContractInvocation.\n     *\n     * @returns {object} The arguments object passed to the contract invocation.\n     * The key is the argument name and the value is the argument value.\n     */\n    getArgs() {\n        return JSON.parse(this.model.args);\n    }\n    /**\n     * Returns the ABI of the ContractInvocation, if specified.\n     *\n     * @returns The ABI as an object, or undefined if not available.\n     */\n    getAbi() {\n        if (!this.model.abi)\n            return undefined;\n        return JSON.parse(this.model.abi);\n    }\n    /**\n     * Returns the amount of the native asset sent to a payable contract method, if applicable.\n     *\n     * @returns The amount in atomic units of the native asset.\n     */\n    getAmount() {\n        return new decimal_js_1.Decimal(this.model.amount);\n    }\n    /**\n     * Returns the Transaction Hash of the ContractInvocation.\n     *\n     * @returns The Transaction Hash as a Hex string, or undefined if not yet available.\n     */\n    getTransactionHash() {\n        return this.getTransaction().getTransactionHash();\n    }\n    /**\n     * Returns the Transaction of the ContractInvocation.\n     *\n     * @returns The ethers.js Transaction object.\n     * @throws (InvalidUnsignedPayload) If the Unsigned Payload is invalid.\n     */\n    getRawTransaction() {\n        return this.getTransaction().rawTransaction();\n    }\n    /**\n     * Signs the ContractInvocation with the provided key and returns the hex signature\n     * required for broadcasting the ContractInvocation.\n     *\n     * @param key - The key to sign the ContractInvocation with\n     * @returns The hex-encoded signed payload\n     */\n    async sign(key) {\n        return this.getTransaction().sign(key);\n    }\n    /**\n     * Returns the Status of the ContractInvocation.\n     *\n     * @returns The Status of the ContractInvocation.\n     */\n    getStatus() {\n        return this.getTransaction().getStatus();\n    }\n    /**\n     * Returns the Transaction of the ContractInvocation.\n     *\n     * @returns The Transaction\n     */\n    getTransaction() {\n        return new transaction_1.Transaction(this.model.transaction);\n    }\n    /**\n     * Returns the link to the Transaction on the blockchain explorer.\n     *\n     * @returns The link to the Transaction on the blockchain explorer.\n     */\n    getTransactionLink() {\n        return this.getTransaction().getTransactionLink();\n    }\n    /**\n     * Broadcasts the ContractInvocation to the Network.\n     *\n     * @returns The ContractInvocation object\n     * @throws {APIError} if the API request to broadcast a ContractInvocation fails.\n     */\n    async broadcast() {\n        if (!this.getTransaction()?.isSigned())\n            throw new Error(\"Cannot broadcast unsigned ContractInvocation\");\n        const broadcastContractInvocationRequest = {\n            signed_payload: this.getTransaction().getSignature(),\n        };\n        const response = await coinbase_1.Coinbase.apiClients.contractInvocation.broadcastContractInvocation(this.getWalletId(), this.getFromAddressId(), this.getId(), broadcastContractInvocationRequest);\n        return ContractInvocation.fromModel(response.data);\n    }\n    /**\n     * Waits for the ContractInvocation to be confirmed on the Network or fail on chain.\n     * Waits until the ContractInvocation is completed or failed on-chain by polling at the given interval.\n     * Raises an error if the ContractInvocation takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the ContractInvocation.\n     * @param options.timeoutSeconds - The maximum time to wait for the ContractInvocation to be confirmed.\n     *\n     * @returns The ContractInvocation object in a terminal state.\n     * @throws {Error} if the ContractInvocation times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10, } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the ContractInvocation is in a terminal state, return the ContractInvocation.\n            const status = this.getStatus();\n            if (status === types_1.TransactionStatus.COMPLETE || status === types_1.TransactionStatus.FAILED) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"ContractInvocation timed out\");\n    }\n    /**\n     * Reloads the ContractInvocation model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a ContractInvocation fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.contractInvocation.getContractInvocation(this.getWalletId(), this.getFromAddressId(), this.getId());\n        this.model = result?.data;\n    }\n    /**\n     * Returns a string representation of the ContractInvocation.\n     *\n     * @returns The string representation of the ContractInvocation.\n     */\n    toString() {\n        return (`ContractInvocation{contractInvocationId: '${this.getId()}', networkId: '${this.getNetworkId()}', ` +\n            `fromAddressId: '${this.getFromAddressId()}', contractAddressId: '${this.getContractAddressId()}', ` +\n            `method: '${this.getMethod()}', args: '${this.getArgs()}', transactionHash: '${this.getTransactionHash()}', ` +\n            `transactionLink: '${this.getTransactionLink()}', status: '${this.getStatus()}'}`);\n    }\n}\nexports.ContractInvocation = ContractInvocation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvbnRyYWN0X2ludm9jYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLHNCQUFzQixtQkFBTyxDQUFDLCtGQUFlO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLGlCQUFpQiw4Q0FBOEMsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlCQUF5QixhQUFhLGlCQUFpQixvQkFBb0I7QUFDL0csK0JBQStCLHdCQUF3Qix5QkFBeUIsNEJBQTRCO0FBQzVHLHdCQUF3QixpQkFBaUIsWUFBWSxlQUFlLHVCQUF1QiwwQkFBMEI7QUFDckgsaUNBQWlDLDBCQUEwQixjQUFjLGlCQUFpQixFQUFFO0FBQzVGO0FBQ0E7QUFDQSwwQkFBMEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9jb250cmFjdF9pbnZvY2F0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250cmFjdEludm9jYXRpb24gPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSByZXF1aXJlKFwiZGVjaW1hbC5qc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29udHJhY3RJbnZvY2F0aW9uLCB3aGljaCBjYWxscyBhIHNtYXJ0IGNvbnRyYWN0IG1ldGhvZFxuICogb25jaGFpbi4gVGhlIGZlZSBpcyBhc3N1bWVkIHRvIGJlIHBhaWQgaW4gdGhlIG5hdGl2ZSBBc3NldCBvZiB0aGUgTmV0d29yay5cbiAqL1xuY2xhc3MgQ29udHJhY3RJbnZvY2F0aW9uIHtcbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGNvbnN0cnVjdG9yIHRvIHByZXZlbnQgZGlyZWN0IGluc3RhbnRpYXRpb24gb3V0c2lkZSBvZiB0aGUgZmFjdG9yeSBtZXRob2RzLlxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBwYXJhbSBjb250cmFjdEludm9jYXRpb25Nb2RlbCAtIFRoZSBDb250cmFjdEludm9jYXRpb24gbW9kZWwuXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0SW52b2NhdGlvbk1vZGVsKSB7XG4gICAgICAgIGlmICghY29udHJhY3RJbnZvY2F0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRyYWN0SW52b2NhdGlvbiBtb2RlbCBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IGNvbnRyYWN0SW52b2NhdGlvbk1vZGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIENvbnRyYWN0SW52b2NhdGlvbk1vZGVsIGludG8gYSBDb250cmFjdEludm9jYXRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0SW52b2NhdGlvbk1vZGVsIC0gVGhlIENvbnRyYWN0SW52b2NhdGlvbiBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMgVGhlIENvbnRyYWN0SW52b2NhdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Nb2RlbChjb250cmFjdEludm9jYXRpb25Nb2RlbCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0SW52b2NhdGlvbihjb250cmFjdEludm9jYXRpb25Nb2RlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQ29udHJhY3RJbnZvY2F0aW9uIElELlxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5jb250cmFjdF9pbnZvY2F0aW9uX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBOZXR3b3JrIElEIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgTmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm5ldHdvcmtfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFdhbGxldCBJRCBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFdhbGxldCBJRC5cbiAgICAgKi9cbiAgICBnZXRXYWxsZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwud2FsbGV0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBGcm9tIEFkZHJlc3MgSUQgb2YgdGhlIENvbnRyYWN0SW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBGcm9tIEFkZHJlc3MgSUQuXG4gICAgICovXG4gICAgZ2V0RnJvbUFkZHJlc3NJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuYWRkcmVzc19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGVzdGluYXRpb24gQWRkcmVzcyBJRCBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIERlc3RpbmF0aW9uIEFkZHJlc3MgSUQuXG4gICAgICovXG4gICAgZ2V0Q29udHJhY3RBZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNvbnRyYWN0X2FkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE1ldGhvZCBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIE1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXRNZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm1ldGhvZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQXJndW1lbnRzIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgYXJndW1lbnRzIG9iamVjdCBwYXNzZWQgdG8gdGhlIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICogVGhlIGtleSBpcyB0aGUgYXJndW1lbnQgbmFtZSBhbmQgdGhlIHZhbHVlIGlzIHRoZSBhcmd1bWVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRBcmdzKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLm1vZGVsLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBBQkkgb2YgdGhlIENvbnRyYWN0SW52b2NhdGlvbiwgaWYgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEFCSSBhcyBhbiBvYmplY3QsIG9yIHVuZGVmaW5lZCBpZiBub3QgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGdldEFiaSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsLmFiaSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMubW9kZWwuYWJpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIHRoZSBuYXRpdmUgYXNzZXQgc2VudCB0byBhIHBheWFibGUgY29udHJhY3QgbWV0aG9kLCBpZiBhcHBsaWNhYmxlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGFtb3VudCBpbiBhdG9taWMgdW5pdHMgb2YgdGhlIG5hdGl2ZSBhc3NldC5cbiAgICAgKi9cbiAgICBnZXRBbW91bnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwodGhpcy5tb2RlbC5hbW91bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUcmFuc2FjdGlvbiBIYXNoIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVHJhbnNhY3Rpb24gSGFzaCBhcyBhIEhleCBzdHJpbmcsIG9yIHVuZGVmaW5lZCBpZiBub3QgeWV0IGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbkhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRyYW5zYWN0aW9uKCkuZ2V0VHJhbnNhY3Rpb25IYXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRyYW5zYWN0aW9uIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZXRoZXJzLmpzIFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIChJbnZhbGlkVW5zaWduZWRQYXlsb2FkKSBJZiB0aGUgVW5zaWduZWQgUGF5bG9hZCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIGdldFJhd1RyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvbigpLnJhd1RyYW5zYWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIHRoZSBDb250cmFjdEludm9jYXRpb24gd2l0aCB0aGUgcHJvdmlkZWQga2V5IGFuZCByZXR1cm5zIHRoZSBoZXggc2lnbmF0dXJlXG4gICAgICogcmVxdWlyZWQgZm9yIGJyb2FkY2FzdGluZyB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gc2lnbiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uIHdpdGhcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4LWVuY29kZWQgc2lnbmVkIHBheWxvYWRcbiAgICAgKi9cbiAgICBhc3luYyBzaWduKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvbigpLnNpZ24oa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU3RhdHVzIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgU3RhdHVzIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICovXG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvbigpLmdldFN0YXR1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUcmFuc2FjdGlvbiBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbih0aGlzLm1vZGVsLnRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGluayB0byB0aGUgVHJhbnNhY3Rpb24gb24gdGhlIGJsb2NrY2hhaW4gZXhwbG9yZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbGluayB0byB0aGUgVHJhbnNhY3Rpb24gb24gdGhlIGJsb2NrY2hhaW4gZXhwbG9yZXIuXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25MaW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvbigpLmdldFRyYW5zYWN0aW9uTGluaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3RzIHRoZSBDb250cmFjdEludm9jYXRpb24gdG8gdGhlIE5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQ29udHJhY3RJbnZvY2F0aW9uIG9iamVjdFxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gYnJvYWRjYXN0IGEgQ29udHJhY3RJbnZvY2F0aW9uIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGJyb2FkY2FzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldFRyYW5zYWN0aW9uKCk/LmlzU2lnbmVkKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYnJvYWRjYXN0IHVuc2lnbmVkIENvbnRyYWN0SW52b2NhdGlvblwiKTtcbiAgICAgICAgY29uc3QgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHNpZ25lZF9wYXlsb2FkOiB0aGlzLmdldFRyYW5zYWN0aW9uKCkuZ2V0U2lnbmF0dXJlKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmNvbnRyYWN0SW52b2NhdGlvbi5icm9hZGNhc3RDb250cmFjdEludm9jYXRpb24odGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldEZyb21BZGRyZXNzSWQoKSwgdGhpcy5nZXRJZCgpLCBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIENvbnRyYWN0SW52b2NhdGlvbi5mcm9tTW9kZWwocmVzcG9uc2UuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciB0aGUgQ29udHJhY3RJbnZvY2F0aW9uIHRvIGJlIGNvbmZpcm1lZCBvbiB0aGUgTmV0d29yayBvciBmYWlsIG9uIGNoYWluLlxuICAgICAqIFdhaXRzIHVudGlsIHRoZSBDb250cmFjdEludm9jYXRpb24gaXMgY29tcGxldGVkIG9yIGZhaWxlZCBvbi1jaGFpbiBieSBwb2xsaW5nIGF0IHRoZSBnaXZlbiBpbnRlcnZhbC5cbiAgICAgKiBSYWlzZXMgYW4gZXJyb3IgaWYgdGhlIENvbnRyYWN0SW52b2NhdGlvbiB0YWtlcyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSB3YWl0IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmludGVydmFsU2Vjb25kcyAtIFRoZSBpbnRlcnZhbCB0byBjaGVjayB0aGUgc3RhdHVzIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dFNlY29uZHMgLSBUaGUgbWF4aW11bSB0aW1lIHRvIHdhaXQgZm9yIHRoZSBDb250cmFjdEludm9jYXRpb24gdG8gYmUgY29uZmlybWVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIENvbnRyYWN0SW52b2NhdGlvbiBvYmplY3QgaW4gYSB0ZXJtaW5hbCBzdGF0ZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIENvbnRyYWN0SW52b2NhdGlvbiB0aW1lcyBvdXQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdCh7IGludGVydmFsU2Vjb25kcyA9IDAuMiwgdGltZW91dFNlY29uZHMgPSAxMCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dFNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIENvbnRyYWN0SW52b2NhdGlvbiBpcyBpbiBhIHRlcm1pbmFsIHN0YXRlLCByZXR1cm4gdGhlIENvbnRyYWN0SW52b2NhdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuZ2V0U3RhdHVzKCk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFIHx8IHN0YXR1cyA9PT0gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5GQUlMRUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgwLCB1dGlsc18xLmRlbGF5KShpbnRlcnZhbFNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5UaW1lb3V0RXJyb3IoXCJDb250cmFjdEludm9jYXRpb24gdGltZWQgb3V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSBDb250cmFjdEludm9jYXRpb24gbW9kZWwgd2l0aCB0aGUgbGF0ZXN0IGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBnZXQgYSBDb250cmFjdEludm9jYXRpb24gZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgcmVsb2FkKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuY29udHJhY3RJbnZvY2F0aW9uLmdldENvbnRyYWN0SW52b2NhdGlvbih0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0RnJvbUFkZHJlc3NJZCgpLCB0aGlzLmdldElkKCkpO1xuICAgICAgICB0aGlzLm1vZGVsID0gcmVzdWx0Py5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoYENvbnRyYWN0SW52b2NhdGlvbntjb250cmFjdEludm9jYXRpb25JZDogJyR7dGhpcy5nZXRJZCgpfScsIG5ldHdvcmtJZDogJyR7dGhpcy5nZXROZXR3b3JrSWQoKX0nLCBgICtcbiAgICAgICAgICAgIGBmcm9tQWRkcmVzc0lkOiAnJHt0aGlzLmdldEZyb21BZGRyZXNzSWQoKX0nLCBjb250cmFjdEFkZHJlc3NJZDogJyR7dGhpcy5nZXRDb250cmFjdEFkZHJlc3NJZCgpfScsIGAgK1xuICAgICAgICAgICAgYG1ldGhvZDogJyR7dGhpcy5nZXRNZXRob2QoKX0nLCBhcmdzOiAnJHt0aGlzLmdldEFyZ3MoKX0nLCB0cmFuc2FjdGlvbkhhc2g6ICcke3RoaXMuZ2V0VHJhbnNhY3Rpb25IYXNoKCl9JywgYCArXG4gICAgICAgICAgICBgdHJhbnNhY3Rpb25MaW5rOiAnJHt0aGlzLmdldFRyYW5zYWN0aW9uTGluaygpfScsIHN0YXR1czogJyR7dGhpcy5nZXRTdGF0dXMoKX0nfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uID0gQ29udHJhY3RJbnZvY2F0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/crypto_amount.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/crypto_amount.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CryptoAmount = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\n/**\n * A representation of a CryptoAmount that includes the amount and asset.\n */\nclass CryptoAmount {\n    /**\n     * Creates a new CryptoAmount instance.\n     *\n     * @param amount - The amount of the Asset\n     * @param asset - The Asset\n     * @param assetId - Optional Asset ID override\n     */\n    constructor(amount, asset, assetId) {\n        this.amount = amount;\n        this.assetObj = asset;\n        this.assetId = assetId || asset.getAssetId();\n    }\n    /**\n     * Converts a CryptoAmount model to a CryptoAmount.\n     *\n     * @param amountModel - The crypto amount from the API\n     * @returns The converted CryptoAmount object\n     */\n    static fromModel(amountModel) {\n        const asset = asset_1.Asset.fromModel(amountModel.asset);\n        return new CryptoAmount(asset.fromAtomicAmount(new decimal_js_1.default(amountModel.amount)), asset);\n    }\n    /**\n     * Converts a CryptoAmount model and asset ID to a CryptoAmount.\n     * This can be used to specify a non-primary denomination that we want the amount\n     * to be converted to.\n     *\n     * @param amountModel - The crypto amount from the API\n     * @param assetId - The Asset ID of the denomination we want returned\n     * @returns The converted CryptoAmount object\n     */\n    static fromModelAndAssetId(amountModel, assetId) {\n        const asset = asset_1.Asset.fromModel(amountModel.asset, assetId);\n        return new CryptoAmount(asset.fromAtomicAmount(new decimal_js_1.default(amountModel.amount)), asset, assetId);\n    }\n    /**\n     * Gets the amount of the Asset.\n     *\n     * @returns The amount of the Asset\n     */\n    getAmount() {\n        return this.amount;\n    }\n    /**\n     * Gets the Asset.\n     *\n     * @returns The Asset\n     */\n    getAsset() {\n        return this.assetObj;\n    }\n    /**\n     * Gets the Asset ID.\n     *\n     * @returns The Asset ID\n     */\n    getAssetId() {\n        return this.assetId;\n    }\n    /**\n     * Converts the amount to atomic units.\n     *\n     * @returns The amount in atomic units\n     */\n    toAtomicAmount() {\n        return this.assetObj.toAtomicAmount(this.amount);\n    }\n    /**\n     * Returns a string representation of the CryptoAmount.\n     *\n     * @returns A string representation of the CryptoAmount\n     */\n    toString() {\n        return `CryptoAmount{amount: '${this.amount}', assetId: '${this.assetId}'}`;\n    }\n}\nexports.CryptoAmount = CryptoAmount;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NyeXB0b19hbW91bnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIscUNBQXFDLG1CQUFPLENBQUMsOERBQVk7QUFDekQsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXLFlBQVksZUFBZSxhQUFhLEVBQUU7QUFDbEY7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NyeXB0b19hbW91bnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyeXB0b0Ftb3VudCA9IHZvaWQgMDtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVjaW1hbC5qc1wiKSk7XG5jb25zdCBhc3NldF8xID0gcmVxdWlyZShcIi4vYXNzZXRcIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBDcnlwdG9BbW91bnQgdGhhdCBpbmNsdWRlcyB0aGUgYW1vdW50IGFuZCBhc3NldC5cbiAqL1xuY2xhc3MgQ3J5cHRvQW1vdW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENyeXB0b0Ftb3VudCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBBc3NldFxuICAgICAqIEBwYXJhbSBhc3NldCAtIFRoZSBBc3NldFxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gT3B0aW9uYWwgQXNzZXQgSUQgb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhbW91bnQsIGFzc2V0LCBhc3NldElkKSB7XG4gICAgICAgIHRoaXMuYW1vdW50ID0gYW1vdW50O1xuICAgICAgICB0aGlzLmFzc2V0T2JqID0gYXNzZXQ7XG4gICAgICAgIHRoaXMuYXNzZXRJZCA9IGFzc2V0SWQgfHwgYXNzZXQuZ2V0QXNzZXRJZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIENyeXB0b0Ftb3VudCBtb2RlbCB0byBhIENyeXB0b0Ftb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnRNb2RlbCAtIFRoZSBjcnlwdG8gYW1vdW50IGZyb20gdGhlIEFQSVxuICAgICAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgQ3J5cHRvQW1vdW50IG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW9kZWwoYW1vdW50TW9kZWwpIHtcbiAgICAgICAgY29uc3QgYXNzZXQgPSBhc3NldF8xLkFzc2V0LmZyb21Nb2RlbChhbW91bnRNb2RlbC5hc3NldCk7XG4gICAgICAgIHJldHVybiBuZXcgQ3J5cHRvQW1vdW50KGFzc2V0LmZyb21BdG9taWNBbW91bnQobmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KGFtb3VudE1vZGVsLmFtb3VudCkpLCBhc3NldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgQ3J5cHRvQW1vdW50IG1vZGVsIGFuZCBhc3NldCBJRCB0byBhIENyeXB0b0Ftb3VudC5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgYSBub24tcHJpbWFyeSBkZW5vbWluYXRpb24gdGhhdCB3ZSB3YW50IHRoZSBhbW91bnRcbiAgICAgKiB0byBiZSBjb252ZXJ0ZWQgdG8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50TW9kZWwgLSBUaGUgY3J5cHRvIGFtb3VudCBmcm9tIHRoZSBBUElcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBBc3NldCBJRCBvZiB0aGUgZGVub21pbmF0aW9uIHdlIHdhbnQgcmV0dXJuZWRcbiAgICAgKiBAcmV0dXJucyBUaGUgY29udmVydGVkIENyeXB0b0Ftb3VudCBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU1vZGVsQW5kQXNzZXRJZChhbW91bnRNb2RlbCwgYXNzZXRJZCkge1xuICAgICAgICBjb25zdCBhc3NldCA9IGFzc2V0XzEuQXNzZXQuZnJvbU1vZGVsKGFtb3VudE1vZGVsLmFzc2V0LCBhc3NldElkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDcnlwdG9BbW91bnQoYXNzZXQuZnJvbUF0b21pY0Ftb3VudChuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoYW1vdW50TW9kZWwuYW1vdW50KSksIGFzc2V0LCBhc3NldElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYW1vdW50IG9mIHRoZSBBc3NldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhbW91bnQgb2YgdGhlIEFzc2V0XG4gICAgICovXG4gICAgZ2V0QW1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbW91bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEFzc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEFzc2V0XG4gICAgICovXG4gICAgZ2V0QXNzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2V0T2JqO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBBc3NldCBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBBc3NldCBJRFxuICAgICAqL1xuICAgIGdldEFzc2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2V0SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBhbW91bnQgdG8gYXRvbWljIHVuaXRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGFtb3VudCBpbiBhdG9taWMgdW5pdHNcbiAgICAgKi9cbiAgICB0b0F0b21pY0Ftb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXRPYmoudG9BdG9taWNBbW91bnQodGhpcy5hbW91bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBDcnlwdG9BbW91bnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ3J5cHRvQW1vdW50XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgQ3J5cHRvQW1vdW50e2Ftb3VudDogJyR7dGhpcy5hbW91bnR9JywgYXNzZXRJZDogJyR7dGhpcy5hc3NldElkfSd9YDtcbiAgICB9XG59XG5leHBvcnRzLkNyeXB0b0Ftb3VudCA9IENyeXB0b0Ftb3VudDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/crypto_amount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AlreadySignedError = exports.NotSignedError = exports.InvalidUnsignedPayloadError = exports.InvalidConfigurationError = exports.ArgumentError = exports.TimeoutError = exports.InvalidAPIKeyFormatError = void 0;\n/**\n * InvalidAPIKeyFormatError error is thrown when the API key format is invalid.\n */\nclass InvalidAPIKeyFormatError extends Error {\n    /**\n     * Initializes a new InvalidAPIKeyFormat instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = InvalidAPIKeyFormatError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"InvalidAPIKeyFormatError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, InvalidAPIKeyFormatError);\n        }\n    }\n}\nexports.InvalidAPIKeyFormatError = InvalidAPIKeyFormatError;\nInvalidAPIKeyFormatError.DEFAULT_MESSAGE = \"Invalid API key format\";\n/**\n * TimeoutError is thrown when an operation times out.\n */\nclass TimeoutError extends Error {\n    /**\n     * Initializes a new TimeoutError instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = \"Timeout Error\") {\n        super(message);\n        this.name = \"TimeoutError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, TimeoutError);\n        }\n    }\n}\nexports.TimeoutError = TimeoutError;\n/**\n * ArgumentError is thrown when an argument is invalid.\n */\nclass ArgumentError extends Error {\n    /**\n     * Initializes a new ArgumentError instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = ArgumentError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"ArgumentError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ArgumentError);\n        }\n    }\n}\nexports.ArgumentError = ArgumentError;\nArgumentError.DEFAULT_MESSAGE = \"Argument Error\";\n/**\n * InvalidConfigurationError error is thrown when apikey/privateKey configuration is invalid.\n */\nclass InvalidConfigurationError extends Error {\n    /**\n     * Initializes a new InvalidConfiguration instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = InvalidConfigurationError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"InvalidConfigurationError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, InvalidConfigurationError);\n        }\n    }\n}\nexports.InvalidConfigurationError = InvalidConfigurationError;\nInvalidConfigurationError.DEFAULT_MESSAGE = \"Invalid configuration\";\n/**\n * InvalidUnsignedPayload error is thrown when the unsigned payload is invalid.\n */\nclass InvalidUnsignedPayloadError extends Error {\n    /**\n     * Initializes a new InvalidUnsignedPayload instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = InvalidUnsignedPayloadError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"InvalidUnsignedPayloadError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, InvalidUnsignedPayloadError);\n        }\n    }\n}\nexports.InvalidUnsignedPayloadError = InvalidUnsignedPayloadError;\nInvalidUnsignedPayloadError.DEFAULT_MESSAGE = \"Invalid unsigned payload\";\n/**\n * NotSignedError is thrown when a resource is not signed.\n */\nclass NotSignedError extends Error {\n    /**\n     * Initializes a new NotSignedError instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = \"Resource not signed\") {\n        super(message);\n        this.name = \"NotSignedError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, NotSignedError);\n        }\n    }\n}\nexports.NotSignedError = NotSignedError;\n/**\n * AlreadySignedError is thrown when a resource is already signed.\n */\nclass AlreadySignedError extends Error {\n    /**\n     * Initializes a new AlreadySignedError instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = AlreadySignedError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"AlreadySignedError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, AlreadySignedError);\n        }\n    }\n}\nexports.AlreadySignedError = AlreadySignedError;\nAlreadySignedError.DEFAULT_MESSAGE = \"Resource already signed\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyxnQ0FBZ0M7QUFDL007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbHJlYWR5U2lnbmVkRXJyb3IgPSBleHBvcnRzLk5vdFNpZ25lZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkVW5zaWduZWRQYXlsb2FkRXJyb3IgPSBleHBvcnRzLkludmFsaWRDb25maWd1cmF0aW9uRXJyb3IgPSBleHBvcnRzLkFyZ3VtZW50RXJyb3IgPSBleHBvcnRzLlRpbWVvdXRFcnJvciA9IGV4cG9ydHMuSW52YWxpZEFQSUtleUZvcm1hdEVycm9yID0gdm9pZCAwO1xuLyoqXG4gKiBJbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IgZXJyb3IgaXMgdGhyb3duIHdoZW4gdGhlIEFQSSBrZXkgZm9ybWF0IGlzIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRBUElLZXlGb3JtYXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBJbnZhbGlkQVBJS2V5Rm9ybWF0IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gSW52YWxpZEFQSUtleUZvcm1hdEVycm9yLkRFRkFVTFRfTUVTU0FHRSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJJbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3JcIjtcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IgPSBJbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3I7XG5JbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IuREVGQVVMVF9NRVNTQUdFID0gXCJJbnZhbGlkIEFQSSBrZXkgZm9ybWF0XCI7XG4vKipcbiAqIFRpbWVvdXRFcnJvciBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gdGltZXMgb3V0LlxuICovXG5jbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgVGltZW91dEVycm9yIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gXCJUaW1lb3V0IEVycm9yXCIpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiVGltZW91dEVycm9yXCI7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgVGltZW91dEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuLyoqXG4gKiBBcmd1bWVudEVycm9yIGlzIHRocm93biB3aGVuIGFuIGFyZ3VtZW50IGlzIGludmFsaWQuXG4gKi9cbmNsYXNzIEFyZ3VtZW50RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgQXJndW1lbnRFcnJvciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSA9IEFyZ3VtZW50RXJyb3IuREVGQVVMVF9NRVNTQUdFKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFyZ3VtZW50RXJyb3JcIjtcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBBcmd1bWVudEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXJndW1lbnRFcnJvciA9IEFyZ3VtZW50RXJyb3I7XG5Bcmd1bWVudEVycm9yLkRFRkFVTFRfTUVTU0FHRSA9IFwiQXJndW1lbnQgRXJyb3JcIjtcbi8qKlxuICogSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvciBlcnJvciBpcyB0aHJvd24gd2hlbiBhcGlrZXkvcHJpdmF0ZUtleSBjb25maWd1cmF0aW9uIGlzIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRDb25maWd1cmF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgSW52YWxpZENvbmZpZ3VyYXRpb24gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBJbnZhbGlkQ29uZmlndXJhdGlvbkVycm9yLkRFRkFVTFRfTUVTU0FHRSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJJbnZhbGlkQ29uZmlndXJhdGlvbkVycm9yXCI7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRDb25maWd1cmF0aW9uRXJyb3IgPSBJbnZhbGlkQ29uZmlndXJhdGlvbkVycm9yO1xuSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvci5ERUZBVUxUX01FU1NBR0UgPSBcIkludmFsaWQgY29uZmlndXJhdGlvblwiO1xuLyoqXG4gKiBJbnZhbGlkVW5zaWduZWRQYXlsb2FkIGVycm9yIGlzIHRocm93biB3aGVuIHRoZSB1bnNpZ25lZCBwYXlsb2FkIGlzIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRVbnNpZ25lZFBheWxvYWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBJbnZhbGlkVW5zaWduZWRQYXlsb2FkIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yLkRFRkFVTFRfTUVTU0FHRSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJJbnZhbGlkVW5zaWduZWRQYXlsb2FkRXJyb3JcIjtcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnZhbGlkVW5zaWduZWRQYXlsb2FkRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkVW5zaWduZWRQYXlsb2FkRXJyb3IgPSBJbnZhbGlkVW5zaWduZWRQYXlsb2FkRXJyb3I7XG5JbnZhbGlkVW5zaWduZWRQYXlsb2FkRXJyb3IuREVGQVVMVF9NRVNTQUdFID0gXCJJbnZhbGlkIHVuc2lnbmVkIHBheWxvYWRcIjtcbi8qKlxuICogTm90U2lnbmVkRXJyb3IgaXMgdGhyb3duIHdoZW4gYSByZXNvdXJjZSBpcyBub3Qgc2lnbmVkLlxuICovXG5jbGFzcyBOb3RTaWduZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBOb3RTaWduZWRFcnJvciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSA9IFwiUmVzb3VyY2Ugbm90IHNpZ25lZFwiKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIk5vdFNpZ25lZEVycm9yXCI7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTm90U2lnbmVkRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RTaWduZWRFcnJvciA9IE5vdFNpZ25lZEVycm9yO1xuLyoqXG4gKiBBbHJlYWR5U2lnbmVkRXJyb3IgaXMgdGhyb3duIHdoZW4gYSByZXNvdXJjZSBpcyBhbHJlYWR5IHNpZ25lZC5cbiAqL1xuY2xhc3MgQWxyZWFkeVNpZ25lZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IEFscmVhZHlTaWduZWRFcnJvciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSA9IEFscmVhZHlTaWduZWRFcnJvci5ERUZBVUxUX01FU1NBR0UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQWxyZWFkeVNpZ25lZEVycm9yXCI7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQWxyZWFkeVNpZ25lZEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWxyZWFkeVNpZ25lZEVycm9yID0gQWxyZWFkeVNpZ25lZEVycm9yO1xuQWxyZWFkeVNpZ25lZEVycm9yLkRFRkFVTFRfTUVTU0FHRSA9IFwiUmVzb3VyY2UgYWxyZWFkeSBzaWduZWRcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FaucetTransaction = void 0;\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/**\n * Represents a transaction from a faucet.\n */\nclass FaucetTransaction {\n    /**\n     * Creates a new FaucetTransaction instance.\n     * Do not use this method directly - instead, use Address.faucet().\n     *\n     * @class\n     * @param {FaucetTransactionModel} model - The FaucetTransaction model.\n     * @throws {Error} If the model does not exist.\n     */\n    constructor(model) {\n        if (!model?.transaction) {\n            throw new Error(\"FaucetTransaction model cannot be empty\");\n        }\n        this.model = model;\n        this._transaction = new transaction_1.Transaction(this.model.transaction);\n    }\n    /**\n     * Returns the Transaction of the FaucetTransaction.\n     *\n     * @returns The Faucet Transaction\n     */\n    get transaction() {\n        return this._transaction;\n    }\n    /**\n     * Returns the transaction hash.\n     *\n     * @returns {string} The transaction hash.\n     */\n    getTransactionHash() {\n        return this.transaction.getTransactionHash();\n    }\n    /**\n     * Returns the link to the transaction on the blockchain explorer.\n     *\n     * @returns {string} The link to the transaction on the blockchain explorer\n     */\n    getTransactionLink() {\n        return this.transaction.getTransactionLink();\n    }\n    /**\n     * Returns the Status of the FaucetTransaction.\n     *\n     * @returns The Status of the FaucetTransaction.\n     */\n    getStatus() {\n        return this.transaction.getStatus();\n    }\n    /**\n     * Returns the network ID of the FaucetTransaction.\n     *\n     * @returns {string} The network ID.\n     */\n    getNetworkId() {\n        return this.transaction.getNetworkId();\n    }\n    /**\n     * Returns the address that is being funded by the faucet.\n     *\n     * @returns {string} The address ID.\n     */\n    getAddressId() {\n        return this.transaction.toAddressId();\n    }\n    /**\n     * Waits for the FaucetTransaction to be confirmed on the Network or fail on chain.\n     * Waits until the FaucetTransaction is completed or failed on-chain by polling at the given interval.\n     * Raises an error if the FaucetTransaction takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the FaucetTransaction.\n     * @param options.timeoutSeconds - The maximum time to wait for the FaucetTransaction to be confirmed.\n     *\n     * @returns The FaucetTransaction object in a terminal state.\n     * @throws {Error} if the FaucetTransaction times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10, } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the FaucetTransaction is in a terminal state, return the FaucetTransaction.\n            if (this.transaction.isTerminalState()) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"FaucetTransaction timed out\");\n    }\n    /**\n     * Reloads the FaucetTransaction model with the latest data from the server.\n     *\n     * @returns {FaucetTransaction} The reloaded FaucetTransaction object.\n     * @throws {APIError} if the API request to get a FaucetTransaction fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.externalAddress.getFaucetTransaction(this.transaction.getNetworkId(), this.getAddressId(), this.getTransactionHash());\n        this.model = result?.data;\n        if (!this.model?.transaction) {\n            throw new Error(\"FaucetTransaction model cannot be empty\");\n        }\n        this._transaction = new transaction_1.Transaction(this.model.transaction);\n        return this;\n    }\n    /**\n     * Returns a string representation of the FaucetTransaction.\n     *\n     * @returns {string} A string representation of the FaucetTransaction.\n     */\n    toString() {\n        return `Coinbase::FaucetTransaction{transaction_hash: '${this.getTransactionHash()}', transaction_link: '${this.getTransactionLink()}'}`;\n    }\n}\nexports.FaucetTransaction = FaucetTransaction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2ZhdWNldF90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWU7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsaUJBQWlCLDhDQUE4QyxJQUFJO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUIsMEJBQTBCLHdCQUF3QiwwQkFBMEIsRUFBRTtBQUMvSTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvZmF1Y2V0X3RyYW5zYWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GYXVjZXRUcmFuc2FjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNhY3Rpb24gZnJvbSBhIGZhdWNldC5cbiAqL1xuY2xhc3MgRmF1Y2V0VHJhbnNhY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRmF1Y2V0VHJhbnNhY3Rpb24gaW5zdGFuY2UuXG4gICAgICogRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBkaXJlY3RseSAtIGluc3RlYWQsIHVzZSBBZGRyZXNzLmZhdWNldCgpLlxuICAgICAqXG4gICAgICogQGNsYXNzXG4gICAgICogQHBhcmFtIHtGYXVjZXRUcmFuc2FjdGlvbk1vZGVsfSBtb2RlbCAtIFRoZSBGYXVjZXRUcmFuc2FjdGlvbiBtb2RlbC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1vZGVsIGRvZXMgbm90IGV4aXN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgICAgIGlmICghbW9kZWw/LnRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYXVjZXRUcmFuc2FjdGlvbiBtb2RlbCBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IG5ldyB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKHRoaXMubW9kZWwudHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUcmFuc2FjdGlvbiBvZiB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgRmF1Y2V0IFRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgZ2V0IHRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbkhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLmdldFRyYW5zYWN0aW9uSGFzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaW5rIHRvIHRoZSB0cmFuc2FjdGlvbiBvbiB0aGUgYmxvY2tjaGFpbiBleHBsb3Jlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBsaW5rIHRvIHRoZSB0cmFuc2FjdGlvbiBvbiB0aGUgYmxvY2tjaGFpbiBleHBsb3JlclxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uTGluaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24uZ2V0VHJhbnNhY3Rpb25MaW5rKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFN0YXR1cyBvZiB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgU3RhdHVzIG9mIHRoZSBGYXVjZXRUcmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLmdldFN0YXR1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXR3b3JrIElEIG9mIHRoZSBGYXVjZXRUcmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBuZXR3b3JrIElELlxuICAgICAqL1xuICAgIGdldE5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24uZ2V0TmV0d29ya0lkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmdW5kZWQgYnkgdGhlIGZhdWNldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBhZGRyZXNzIElELlxuICAgICAqL1xuICAgIGdldEFkZHJlc3NJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24udG9BZGRyZXNzSWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIHRoZSBGYXVjZXRUcmFuc2FjdGlvbiB0byBiZSBjb25maXJtZWQgb24gdGhlIE5ldHdvcmsgb3IgZmFpbCBvbiBjaGFpbi5cbiAgICAgKiBXYWl0cyB1bnRpbCB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24gaXMgY29tcGxldGVkIG9yIGZhaWxlZCBvbi1jaGFpbiBieSBwb2xsaW5nIGF0IHRoZSBnaXZlbiBpbnRlcnZhbC5cbiAgICAgKiBSYWlzZXMgYW4gZXJyb3IgaWYgdGhlIEZhdWNldFRyYW5zYWN0aW9uIHRha2VzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiB0aW1lb3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjb25maWd1cmUgdGhlIHdhaXQgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW50ZXJ2YWxTZWNvbmRzIC0gVGhlIGludGVydmFsIHRvIGNoZWNrIHRoZSBzdGF0dXMgb2YgdGhlIEZhdWNldFRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gdGltZSB0byB3YWl0IGZvciB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24gdG8gYmUgY29uZmlybWVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEZhdWNldFRyYW5zYWN0aW9uIG9iamVjdCBpbiBhIHRlcm1pbmFsIHN0YXRlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24gdGltZXMgb3V0LlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoeyBpbnRlcnZhbFNlY29uZHMgPSAwLjIsIHRpbWVvdXRTZWNvbmRzID0gMTAsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA8IHRpbWVvdXRTZWNvbmRzICogMTAwMCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBGYXVjZXRUcmFuc2FjdGlvbiBpcyBpbiBhIHRlcm1pbmFsIHN0YXRlLCByZXR1cm4gdGhlIEZhdWNldFRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNUZXJtaW5hbFN0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgwLCB1dGlsc18xLmRlbGF5KShpbnRlcnZhbFNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5UaW1lb3V0RXJyb3IoXCJGYXVjZXRUcmFuc2FjdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIEZhdWNldFRyYW5zYWN0aW9uIG1vZGVsIHdpdGggdGhlIGxhdGVzdCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGYXVjZXRUcmFuc2FjdGlvbn0gVGhlIHJlbG9hZGVkIEZhdWNldFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGdldCBhIEZhdWNldFRyYW5zYWN0aW9uIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbG9hZCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmV4dGVybmFsQWRkcmVzcy5nZXRGYXVjZXRUcmFuc2FjdGlvbih0aGlzLnRyYW5zYWN0aW9uLmdldE5ldHdvcmtJZCgpLCB0aGlzLmdldEFkZHJlc3NJZCgpLCB0aGlzLmdldFRyYW5zYWN0aW9uSGFzaCgpKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IHJlc3VsdD8uZGF0YTtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsPy50cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmF1Y2V0VHJhbnNhY3Rpb24gbW9kZWwgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odGhpcy5tb2RlbC50cmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBGYXVjZXRUcmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBGYXVjZXRUcmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBDb2luYmFzZTo6RmF1Y2V0VHJhbnNhY3Rpb257dHJhbnNhY3Rpb25faGFzaDogJyR7dGhpcy5nZXRUcmFuc2FjdGlvbkhhc2goKX0nLCB0cmFuc2FjdGlvbl9saW5rOiAnJHt0aGlzLmdldFRyYW5zYWN0aW9uTGluaygpfSd9YDtcbiAgICB9XG59XG5leHBvcnRzLkZhdWNldFRyYW5zYWN0aW9uID0gRmF1Y2V0VHJhbnNhY3Rpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fiat_amount.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fiat_amount.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FiatAmount = void 0;\n/**\n * A representation of a FiatAmount that includes the amount and currency.\n */\nclass FiatAmount {\n    /**\n     * Initialize a new FiatAmount. Do not use this directly, use the fromModel method instead.\n     *\n     * @param amount - The amount in the fiat currency\n     * @param currency - The currency code (e.g. 'USD')\n     */\n    constructor(amount, currency) {\n        this.amount = amount;\n        this.currency = currency;\n    }\n    /**\n     * Convert a FiatAmount model to a FiatAmount.\n     *\n     * @param fiatAmountModel - The fiat amount from the API.\n     * @returns The converted FiatAmount object.\n     */\n    static fromModel(fiatAmountModel) {\n        return new FiatAmount(fiatAmountModel.amount, fiatAmountModel.currency);\n    }\n    /**\n     * Get the amount in the fiat currency.\n     *\n     * @returns The amount in the fiat currency.\n     */\n    getAmount() {\n        return this.amount;\n    }\n    /**\n     * Get the currency code.\n     *\n     * @returns The currency code.\n     */\n    getCurrency() {\n        return this.currency;\n    }\n    /**\n     * Get a string representation of the FiatAmount.\n     *\n     * @returns A string representation of the FiatAmount.\n     */\n    toString() {\n        return `FiatAmount(amount: '${this.amount}', currency: '${this.currency}')`;\n    }\n}\nexports.FiatAmount = FiatAmount;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2ZpYXRfYW1vdW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWSxnQkFBZ0IsY0FBYztBQUNoRjtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvZmlhdF9hbW91bnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpYXRBbW91bnQgPSB2b2lkIDA7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBGaWF0QW1vdW50IHRoYXQgaW5jbHVkZXMgdGhlIGFtb3VudCBhbmQgY3VycmVuY3kuXG4gKi9cbmNsYXNzIEZpYXRBbW91bnQge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSBuZXcgRmlhdEFtb3VudC4gRG8gbm90IHVzZSB0aGlzIGRpcmVjdGx5LCB1c2UgdGhlIGZyb21Nb2RlbCBtZXRob2QgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IGluIHRoZSBmaWF0IGN1cnJlbmN5XG4gICAgICogQHBhcmFtIGN1cnJlbmN5IC0gVGhlIGN1cnJlbmN5IGNvZGUgKGUuZy4gJ1VTRCcpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYW1vdW50LCBjdXJyZW5jeSkge1xuICAgICAgICB0aGlzLmFtb3VudCA9IGFtb3VudDtcbiAgICAgICAgdGhpcy5jdXJyZW5jeSA9IGN1cnJlbmN5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgRmlhdEFtb3VudCBtb2RlbCB0byBhIEZpYXRBbW91bnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlhdEFtb3VudE1vZGVsIC0gVGhlIGZpYXQgYW1vdW50IGZyb20gdGhlIEFQSS5cbiAgICAgKiBAcmV0dXJucyBUaGUgY29udmVydGVkIEZpYXRBbW91bnQgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW9kZWwoZmlhdEFtb3VudE1vZGVsKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlhdEFtb3VudChmaWF0QW1vdW50TW9kZWwuYW1vdW50LCBmaWF0QW1vdW50TW9kZWwuY3VycmVuY3kpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGFtb3VudCBpbiB0aGUgZmlhdCBjdXJyZW5jeS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhbW91bnQgaW4gdGhlIGZpYXQgY3VycmVuY3kuXG4gICAgICovXG4gICAgZ2V0QW1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbW91bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVuY3kgY29kZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW5jeSBjb2RlLlxuICAgICAqL1xuICAgIGdldEN1cnJlbmN5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW5jeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBGaWF0QW1vdW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEZpYXRBbW91bnQuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgRmlhdEFtb3VudChhbW91bnQ6ICcke3RoaXMuYW1vdW50fScsIGN1cnJlbmN5OiAnJHt0aGlzLmN1cnJlbmN5fScpYDtcbiAgICB9XG59XG5leHBvcnRzLkZpYXRBbW91bnQgPSBGaWF0QW1vdW50O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fiat_amount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_operation.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_operation.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FundOperation = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst crypto_amount_1 = __webpack_require__(/*! ./crypto_amount */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/crypto_amount.js\");\n/**\n * A representation of a Fund Operation.\n */\nclass FundOperation {\n    /**\n     * Creates a new FundOperation instance.\n     *\n     * @param model - The model representing the fund operation\n     */\n    constructor(model) {\n        this.asset = null;\n        this.model = model;\n    }\n    /**\n     * Converts a FundOperationModel into a FundOperation object.\n     *\n     * @param fundOperationModel - The FundOperation model object.\n     * @returns The FundOperation object.\n     */\n    static fromModel(fundOperationModel) {\n        return new FundOperation(fundOperationModel);\n    }\n    /**\n     * Create a new Fund Operation.\n     *\n     * @param walletId - The Wallet ID\n     * @param addressId - The Address ID\n     * @param amount - The amount of the Asset\n     * @param assetId - The Asset ID\n     * @param networkId - The Network ID\n     * @param quote - Optional Fund Quote\n     * @returns The new FundOperation object\n     */\n    static async create(walletId, addressId, amount, assetId, networkId, quote) {\n        const asset = await asset_1.Asset.fetch(networkId, assetId);\n        const createRequest = {\n            amount: asset.toAtomicAmount(amount).toString(),\n            asset_id: asset_1.Asset.primaryDenomination(assetId),\n        };\n        if (quote) {\n            Object.assign(createRequest, { fund_quote_id: quote.getId() });\n        }\n        const response = await coinbase_1.Coinbase.apiClients.fund.createFundOperation(walletId, addressId, createRequest);\n        return FundOperation.fromModel(response.data);\n    }\n    /**\n     * List fund operations.\n     *\n     * @param walletId - The wallet ID\n     * @param addressId - The address ID\n     * @param options - The pagination options\n     * @param options.limit - The maximum number of Fund Operations to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Fund Operations. Don't include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     * @returns The paginated list response of fund operations\n     */\n    static async listFundOperations(walletId, addressId, { limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.fund.listFundOperations(walletId, addressId, limit, page);\n        response.data.data.forEach(operationModel => {\n            data.push(FundOperation.fromModel(operationModel));\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Gets the Fund Operation ID.\n     *\n     * @returns {string} The unique identifier of the fund operation\n     */\n    getId() {\n        return this.model.fund_operation_id;\n    }\n    /**\n     * Gets the Network ID.\n     *\n     * @returns {string} The network identifier\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Gets the Wallet ID.\n     *\n     * @returns {string} The wallet identifier\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Gets the Address ID.\n     *\n     * @returns {string} The address identifier\n     */\n    getAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Gets the Asset.\n     *\n     * @returns {Asset} The asset associated with this operation\n     */\n    getAsset() {\n        if (!this.asset) {\n            this.asset = asset_1.Asset.fromModel(this.model.crypto_amount.asset);\n        }\n        return this.asset;\n    }\n    /**\n     * Gets the amount.\n     *\n     * @returns {CryptoAmount} The crypto amount\n     */\n    getAmount() {\n        return crypto_amount_1.CryptoAmount.fromModel(this.model.crypto_amount);\n    }\n    /**\n     * Gets the fiat amount.\n     *\n     * @returns {Decimal} The fiat amount in decimal format\n     */\n    getFiatAmount() {\n        return new decimal_js_1.Decimal(this.model.fiat_amount.amount);\n    }\n    /**\n     * Gets the fiat currency.\n     *\n     * @returns {string} The fiat currency code\n     */\n    getFiatCurrency() {\n        return this.model.fiat_amount.currency;\n    }\n    /**\n     * Returns the Status of the Transfer.\n     *\n     * @returns The Status of the Transfer.\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case types_1.FundOperationStatus.PENDING:\n                return types_1.FundOperationStatus.PENDING;\n            case types_1.FundOperationStatus.COMPLETE:\n                return types_1.FundOperationStatus.COMPLETE;\n            case types_1.FundOperationStatus.FAILED:\n                return types_1.FundOperationStatus.FAILED;\n            default:\n                throw new Error(`Unknown fund operation status: ${this.model.status}`);\n        }\n    }\n    /**\n     * Reloads the fund operation from the server.\n     *\n     * @returns {Promise<FundOperation>} A promise that resolves to the updated fund operation\n     */\n    async reload() {\n        const response = await coinbase_1.Coinbase.apiClients.fund.getFundOperation(this.getWalletId(), this.getAddressId(), this.getId());\n        this.model = response.data;\n        return this;\n    }\n    /**\n     * Wait for the fund operation to complete.\n     *\n     * @param options - Options for waiting\n     * @param options.intervalSeconds - The interval between checks in seconds\n     * @param options.timeoutSeconds - The timeout in seconds\n     * @returns The completed fund operation\n     * @throws {TimeoutError} If the operation takes too long\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 20 } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            if (this.isTerminalState()) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"Fund operation timed out\");\n    }\n    /**\n     * Check if the operation is in a terminal state.\n     *\n     * @returns {boolean} True if the operation is in a terminal state, false otherwise\n     */\n    isTerminalState() {\n        return FundOperation.Status.TERMINAL_STATES.has(this.getStatus());\n    }\n}\nexports.FundOperation = FundOperation;\n/**\n * Fund Operation status constants.\n */\nFundOperation.Status = {\n    TERMINAL_STATES: new Set([\"complete\", \"failed\"]),\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2Z1bmRfb3BlcmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixxQkFBcUIsbUJBQU8sQ0FBQyw4REFBWTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQyxtR0FBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsOEJBQThCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUVBQWlFLElBQUk7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxrQkFBa0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBLGlCQUFpQiw2Q0FBNkMsSUFBSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvZnVuZF9vcGVyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZ1bmRPcGVyYXRpb24gPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSByZXF1aXJlKFwiZGVjaW1hbC5qc1wiKTtcbmNvbnN0IGFzc2V0XzEgPSByZXF1aXJlKFwiLi9hc3NldFwiKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgY3J5cHRvX2Ftb3VudF8xID0gcmVxdWlyZShcIi4vY3J5cHRvX2Ftb3VudFwiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIEZ1bmQgT3BlcmF0aW9uLlxuICovXG5jbGFzcyBGdW5kT3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZ1bmRPcGVyYXRpb24gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgbW9kZWwgcmVwcmVzZW50aW5nIHRoZSBmdW5kIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgICAgIHRoaXMuYXNzZXQgPSBudWxsO1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgRnVuZE9wZXJhdGlvbk1vZGVsIGludG8gYSBGdW5kT3BlcmF0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmdW5kT3BlcmF0aW9uTW9kZWwgLSBUaGUgRnVuZE9wZXJhdGlvbiBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMgVGhlIEZ1bmRPcGVyYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW9kZWwoZnVuZE9wZXJhdGlvbk1vZGVsKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuZE9wZXJhdGlvbihmdW5kT3BlcmF0aW9uTW9kZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgRnVuZCBPcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0SWQgLSBUaGUgV2FsbGV0IElEXG4gICAgICogQHBhcmFtIGFkZHJlc3NJZCAtIFRoZSBBZGRyZXNzIElEXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIEFzc2V0XG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgQXNzZXQgSURcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIC0gVGhlIE5ldHdvcmsgSURcbiAgICAgKiBAcGFyYW0gcXVvdGUgLSBPcHRpb25hbCBGdW5kIFF1b3RlXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBGdW5kT3BlcmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgYW1vdW50LCBhc3NldElkLCBuZXR3b3JrSWQsIHF1b3RlKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gYXdhaXQgYXNzZXRfMS5Bc3NldC5mZXRjaChuZXR3b3JrSWQsIGFzc2V0SWQpO1xuICAgICAgICBjb25zdCBjcmVhdGVSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgYW1vdW50OiBhc3NldC50b0F0b21pY0Ftb3VudChhbW91bnQpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBhc3NldF9pZDogYXNzZXRfMS5Bc3NldC5wcmltYXJ5RGVub21pbmF0aW9uKGFzc2V0SWQpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocXVvdGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY3JlYXRlUmVxdWVzdCwgeyBmdW5kX3F1b3RlX2lkOiBxdW90ZS5nZXRJZCgpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmZ1bmQuY3JlYXRlRnVuZE9wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVSZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIEZ1bmRPcGVyYXRpb24uZnJvbU1vZGVsKHJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGZ1bmQgb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRJZCAtIFRoZSB3YWxsZXQgSURcbiAgICAgKiBAcGFyYW0gYWRkcmVzc0lkIC0gVGhlIGFkZHJlc3MgSURcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYWdpbmF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBGdW5kIE9wZXJhdGlvbnMgdG8gcmV0dXJuLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFnZSAtIFRoZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIEZ1bmQgT3BlcmF0aW9ucy4gRG9uJ3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcmV0dXJucyBUaGUgcGFnaW5hdGVkIGxpc3QgcmVzcG9uc2Ugb2YgZnVuZCBvcGVyYXRpb25zXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGxpc3RGdW5kT3BlcmF0aW9ucyh3YWxsZXRJZCwgYWRkcmVzc0lkLCB7IGxpbWl0ID0gY29pbmJhc2VfMS5Db2luYmFzZS5kZWZhdWx0UGFnZUxpbWl0LCBwYWdlID0gdW5kZWZpbmVkIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGxldCBuZXh0UGFnZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuZnVuZC5saXN0RnVuZE9wZXJhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UpO1xuICAgICAgICByZXNwb25zZS5kYXRhLmRhdGEuZm9yRWFjaChvcGVyYXRpb25Nb2RlbCA9PiB7XG4gICAgICAgICAgICBkYXRhLnB1c2goRnVuZE9wZXJhdGlvbi5mcm9tTW9kZWwob3BlcmF0aW9uTW9kZWwpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhc01vcmUgPSByZXNwb25zZS5kYXRhLmhhc19tb3JlO1xuICAgICAgICBpZiAoaGFzTW9yZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBhZ2UgPSByZXNwb25zZS5kYXRhLm5leHRfcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGhhc01vcmUsXG4gICAgICAgICAgICBuZXh0UGFnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgRnVuZCBPcGVyYXRpb24gSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGZ1bmQgb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmZ1bmRfb3BlcmF0aW9uX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBOZXR3b3JrIElELlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5ldHdvcmsgaWRlbnRpZmllclxuICAgICAqL1xuICAgIGdldE5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwubmV0d29ya19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgV2FsbGV0IElELlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHdhbGxldCBpZGVudGlmaWVyXG4gICAgICovXG4gICAgZ2V0V2FsbGV0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLndhbGxldF9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgQWRkcmVzcyBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBhZGRyZXNzIGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFkZHJlc3NfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEFzc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Fzc2V0fSBUaGUgYXNzZXQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgb3BlcmF0aW9uXG4gICAgICovXG4gICAgZ2V0QXNzZXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5hc3NldCkge1xuICAgICAgICAgICAgdGhpcy5hc3NldCA9IGFzc2V0XzEuQXNzZXQuZnJvbU1vZGVsKHRoaXMubW9kZWwuY3J5cHRvX2Ftb3VudC5hc3NldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFtb3VudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDcnlwdG9BbW91bnR9IFRoZSBjcnlwdG8gYW1vdW50XG4gICAgICovXG4gICAgZ2V0QW1vdW50KCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvX2Ftb3VudF8xLkNyeXB0b0Ftb3VudC5mcm9tTW9kZWwodGhpcy5tb2RlbC5jcnlwdG9fYW1vdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlhdCBhbW91bnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RGVjaW1hbH0gVGhlIGZpYXQgYW1vdW50IGluIGRlY2ltYWwgZm9ybWF0XG4gICAgICovXG4gICAgZ2V0RmlhdEFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCh0aGlzLm1vZGVsLmZpYXRfYW1vdW50LmFtb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpYXQgY3VycmVuY3kuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZmlhdCBjdXJyZW5jeSBjb2RlXG4gICAgICovXG4gICAgZ2V0RmlhdEN1cnJlbmN5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5maWF0X2Ftb3VudC5jdXJyZW5jeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU3RhdHVzIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTdGF0dXMgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLkZ1bmRPcGVyYXRpb25TdGF0dXMuUEVORElORzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5GdW5kT3BlcmF0aW9uU3RhdHVzLlBFTkRJTkc7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuRnVuZE9wZXJhdGlvblN0YXR1cy5DT01QTEVURTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5GdW5kT3BlcmF0aW9uU3RhdHVzLkNPTVBMRVRFO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLkZ1bmRPcGVyYXRpb25TdGF0dXMuRkFJTEVEOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLkZ1bmRPcGVyYXRpb25TdGF0dXMuRkFJTEVEO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZnVuZCBvcGVyYXRpb24gc3RhdHVzOiAke3RoaXMubW9kZWwuc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIGZ1bmQgb3BlcmF0aW9uIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZ1bmRPcGVyYXRpb24+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdXBkYXRlZCBmdW5kIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGFzeW5jIHJlbG9hZCgpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuZnVuZC5nZXRGdW5kT3BlcmF0aW9uKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRBZGRyZXNzSWQoKSwgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0IGZvciB0aGUgZnVuZCBvcGVyYXRpb24gdG8gY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHdhaXRpbmdcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbFNlY29uZHMgLSBUaGUgaW50ZXJ2YWwgYmV0d2VlbiBjaGVja3MgaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzIC0gVGhlIHRpbWVvdXQgaW4gc2Vjb25kc1xuICAgICAqIEByZXR1cm5zIFRoZSBjb21wbGV0ZWQgZnVuZCBvcGVyYXRpb25cbiAgICAgKiBAdGhyb3dzIHtUaW1lb3V0RXJyb3J9IElmIHRoZSBvcGVyYXRpb24gdGFrZXMgdG9vIGxvbmdcbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KHsgaW50ZXJ2YWxTZWNvbmRzID0gMC4yLCB0aW1lb3V0U2Vjb25kcyA9IDIwIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA8IHRpbWVvdXRTZWNvbmRzICogMTAwMCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVGVybWluYWxTdGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKFwiRnVuZCBvcGVyYXRpb24gdGltZWQgb3V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgb3BlcmF0aW9uIGlzIGluIGEgdGVybWluYWwgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIGlzIGluIGEgdGVybWluYWwgc3RhdGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzVGVybWluYWxTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmRPcGVyYXRpb24uU3RhdHVzLlRFUk1JTkFMX1NUQVRFUy5oYXModGhpcy5nZXRTdGF0dXMoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5GdW5kT3BlcmF0aW9uID0gRnVuZE9wZXJhdGlvbjtcbi8qKlxuICogRnVuZCBPcGVyYXRpb24gc3RhdHVzIGNvbnN0YW50cy5cbiAqL1xuRnVuZE9wZXJhdGlvbi5TdGF0dXMgPSB7XG4gICAgVEVSTUlOQUxfU1RBVEVTOiBuZXcgU2V0KFtcImNvbXBsZXRlXCIsIFwiZmFpbGVkXCJdKSxcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_operation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_quote.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_quote.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FundQuote = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst crypto_amount_1 = __webpack_require__(/*! ./crypto_amount */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/crypto_amount.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst fund_operation_1 = __webpack_require__(/*! ./fund_operation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_operation.js\");\n/**\n * A representation of a Fund Operation Quote.\n */\nclass FundQuote {\n    /**\n     * Creates a new FundQuote instance.\n     *\n     * @param model - The model representing the fund quote\n     */\n    constructor(model) {\n        this.asset = null;\n        this.model = model;\n    }\n    /**\n     * Converts a FundQuoteModel into a FundQuote object.\n     *\n     * @param fundQuoteModel - The FundQuote model object.\n     * @returns The FundQuote object.\n     */\n    static fromModel(fundQuoteModel) {\n        return new FundQuote(fundQuoteModel);\n    }\n    /**\n     * Create a new Fund Operation Quote.\n     *\n     * @param walletId - The Wallet ID\n     * @param addressId - The Address ID\n     * @param amount - The amount of the Asset\n     * @param assetId - The Asset ID\n     * @param networkId - The Network ID\n     * @returns The new FundQuote object\n     */\n    static async create(walletId, addressId, amount, assetId, networkId) {\n        const asset = await asset_1.Asset.fetch(networkId, assetId);\n        const response = await coinbase_1.Coinbase.apiClients.fund.createFundQuote(walletId, addressId, {\n            asset_id: asset_1.Asset.primaryDenomination(assetId),\n            amount: asset.toAtomicAmount(amount).toString(),\n        });\n        return FundQuote.fromModel(response.data);\n    }\n    /**\n     * Gets the Fund Quote ID.\n     *\n     * @returns {string} The unique identifier of the fund quote\n     */\n    getId() {\n        return this.model.fund_quote_id;\n    }\n    /**\n     * Gets the Network ID.\n     *\n     * @returns {string} The network identifier\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Gets the Wallet ID.\n     *\n     * @returns {string} The wallet identifier\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Gets the Address ID.\n     *\n     * @returns {string} The address identifier\n     */\n    getAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Gets the Asset.\n     *\n     * @returns {Asset} The asset associated with this quote\n     */\n    getAsset() {\n        if (!this.asset) {\n            this.asset = asset_1.Asset.fromModel(this.model.crypto_amount.asset);\n        }\n        return this.asset;\n    }\n    /**\n     * Gets the crypto amount.\n     *\n     * @returns {CryptoAmount} The cryptocurrency amount\n     */\n    getAmount() {\n        return crypto_amount_1.CryptoAmount.fromModel(this.model.crypto_amount);\n    }\n    /**\n     * Gets the fiat amount.\n     *\n     * @returns {Decimal} The fiat amount in decimal format\n     */\n    getFiatAmount() {\n        return new decimal_js_1.Decimal(this.model.fiat_amount.amount);\n    }\n    /**\n     * Gets the fiat currency.\n     *\n     * @returns {string} The fiat currency code\n     */\n    getFiatCurrency() {\n        return this.model.fiat_amount.currency;\n    }\n    /**\n     * Gets the buy fee.\n     *\n     * @returns {{ amount: string; currency: string }} The buy fee amount and currency\n     */\n    getBuyFee() {\n        return {\n            amount: this.model.fees.buy_fee.amount,\n            currency: this.model.fees.buy_fee.currency,\n        };\n    }\n    /**\n     * Gets the transfer fee.\n     *\n     * @returns {CryptoAmount} The transfer fee as a crypto amount\n     */\n    getTransferFee() {\n        return crypto_amount_1.CryptoAmount.fromModel(this.model.fees.transfer_fee);\n    }\n    /**\n     * Execute the fund quote to create a fund operation.\n     *\n     * @returns {Promise<FundOperation>} A promise that resolves to the created fund operation\n     */\n    async execute() {\n        return fund_operation_1.FundOperation.create(this.getWalletId(), this.getAddressId(), this.getAmount().getAmount(), this.getAsset().getAssetId(), this.getNetworkId(), this);\n    }\n}\nexports.FundQuote = FundQuote;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2Z1bmRfcXVvdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLG1HQUFpQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyxxR0FBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCLG9CQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvZnVuZF9xdW90ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnVuZFF1b3RlID0gdm9pZCAwO1xuY29uc3QgZGVjaW1hbF9qc18xID0gcmVxdWlyZShcImRlY2ltYWwuanNcIik7XG5jb25zdCBhc3NldF8xID0gcmVxdWlyZShcIi4vYXNzZXRcIik7XG5jb25zdCBjcnlwdG9fYW1vdW50XzEgPSByZXF1aXJlKFwiLi9jcnlwdG9fYW1vdW50XCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuY29uc3QgZnVuZF9vcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2Z1bmRfb3BlcmF0aW9uXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgRnVuZCBPcGVyYXRpb24gUXVvdGUuXG4gKi9cbmNsYXNzIEZ1bmRRdW90ZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGdW5kUXVvdGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgbW9kZWwgcmVwcmVzZW50aW5nIHRoZSBmdW5kIHF1b3RlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgdGhpcy5hc3NldCA9IG51bGw7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBGdW5kUXVvdGVNb2RlbCBpbnRvIGEgRnVuZFF1b3RlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmdW5kUXVvdGVNb2RlbCAtIFRoZSBGdW5kUXVvdGUgbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBGdW5kUXVvdGUgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW9kZWwoZnVuZFF1b3RlTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5kUXVvdGUoZnVuZFF1b3RlTW9kZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgRnVuZCBPcGVyYXRpb24gUXVvdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0SWQgLSBUaGUgV2FsbGV0IElEXG4gICAgICogQHBhcmFtIGFkZHJlc3NJZCAtIFRoZSBBZGRyZXNzIElEXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIEFzc2V0XG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgQXNzZXQgSURcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIC0gVGhlIE5ldHdvcmsgSURcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IEZ1bmRRdW90ZSBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKHdhbGxldElkLCBhZGRyZXNzSWQsIGFtb3VudCwgYXNzZXRJZCwgbmV0d29ya0lkKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gYXdhaXQgYXNzZXRfMS5Bc3NldC5mZXRjaChuZXR3b3JrSWQsIGFzc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5mdW5kLmNyZWF0ZUZ1bmRRdW90ZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCB7XG4gICAgICAgICAgICBhc3NldF9pZDogYXNzZXRfMS5Bc3NldC5wcmltYXJ5RGVub21pbmF0aW9uKGFzc2V0SWQpLFxuICAgICAgICAgICAgYW1vdW50OiBhc3NldC50b0F0b21pY0Ftb3VudChhbW91bnQpLnRvU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRnVuZFF1b3RlLmZyb21Nb2RlbChyZXNwb25zZS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgRnVuZCBRdW90ZSBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgZnVuZCBxdW90ZVxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5mdW5kX3F1b3RlX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBOZXR3b3JrIElELlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5ldHdvcmsgaWRlbnRpZmllclxuICAgICAqL1xuICAgIGdldE5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwubmV0d29ya19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgV2FsbGV0IElELlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHdhbGxldCBpZGVudGlmaWVyXG4gICAgICovXG4gICAgZ2V0V2FsbGV0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLndhbGxldF9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgQWRkcmVzcyBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBhZGRyZXNzIGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFkZHJlc3NfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEFzc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Fzc2V0fSBUaGUgYXNzZXQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVvdGVcbiAgICAgKi9cbiAgICBnZXRBc3NldCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFzc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmFzc2V0ID0gYXNzZXRfMS5Bc3NldC5mcm9tTW9kZWwodGhpcy5tb2RlbC5jcnlwdG9fYW1vdW50LmFzc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3NldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3J5cHRvIGFtb3VudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDcnlwdG9BbW91bnR9IFRoZSBjcnlwdG9jdXJyZW5jeSBhbW91bnRcbiAgICAgKi9cbiAgICBnZXRBbW91bnQoKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG9fYW1vdW50XzEuQ3J5cHRvQW1vdW50LmZyb21Nb2RlbCh0aGlzLm1vZGVsLmNyeXB0b19hbW91bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaWF0IGFtb3VudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtEZWNpbWFsfSBUaGUgZmlhdCBhbW91bnQgaW4gZGVjaW1hbCBmb3JtYXRcbiAgICAgKi9cbiAgICBnZXRGaWF0QW1vdW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKHRoaXMubW9kZWwuZmlhdF9hbW91bnQuYW1vdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlhdCBjdXJyZW5jeS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmaWF0IGN1cnJlbmN5IGNvZGVcbiAgICAgKi9cbiAgICBnZXRGaWF0Q3VycmVuY3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmZpYXRfYW1vdW50LmN1cnJlbmN5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBidXkgZmVlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3sgYW1vdW50OiBzdHJpbmc7IGN1cnJlbmN5OiBzdHJpbmcgfX0gVGhlIGJ1eSBmZWUgYW1vdW50IGFuZCBjdXJyZW5jeVxuICAgICAqL1xuICAgIGdldEJ1eUZlZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFtb3VudDogdGhpcy5tb2RlbC5mZWVzLmJ1eV9mZWUuYW1vdW50LFxuICAgICAgICAgICAgY3VycmVuY3k6IHRoaXMubW9kZWwuZmVlcy5idXlfZmVlLmN1cnJlbmN5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0cmFuc2ZlciBmZWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q3J5cHRvQW1vdW50fSBUaGUgdHJhbnNmZXIgZmVlIGFzIGEgY3J5cHRvIGFtb3VudFxuICAgICAqL1xuICAgIGdldFRyYW5zZmVyRmVlKCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvX2Ftb3VudF8xLkNyeXB0b0Ftb3VudC5mcm9tTW9kZWwodGhpcy5tb2RlbC5mZWVzLnRyYW5zZmVyX2ZlZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGZ1bmQgcXVvdGUgdG8gY3JlYXRlIGEgZnVuZCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGdW5kT3BlcmF0aW9uPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNyZWF0ZWQgZnVuZCBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBleGVjdXRlKCkge1xuICAgICAgICByZXR1cm4gZnVuZF9vcGVyYXRpb25fMS5GdW5kT3BlcmF0aW9uLmNyZWF0ZSh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0QWRkcmVzc0lkKCksIHRoaXMuZ2V0QW1vdW50KCkuZ2V0QW1vdW50KCksIHRoaXMuZ2V0QXNzZXQoKS5nZXRBc3NldElkKCksIHRoaXMuZ2V0TmV0d29ya0lkKCksIHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuRnVuZFF1b3RlID0gRnVuZFF1b3RlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_quote.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/hash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/hash.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hashTypedDataMessage = exports.hashMessage = void 0;\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.commonjs/index.js\");\n/**\n * Computes the EIP-191 personal-sign message digest to sign.\n *\n * @returns The EIP-191 hash of the message as a string.\n * @throws {Error} if the message cannot be hashed.\n * @param message - The message to hash.\n */\nconst hashMessage = (message) => {\n    return ethers_1.ethers.hashMessage(message);\n};\nexports.hashMessage = hashMessage;\n/**\n * Computes the hash of the EIP-712 compliant typed data message.\n *\n * @param domain - The domain parameters for the EIP-712 message, including the name, version, chainId, and verifying contract.\n * @param types - The types definitions for the EIP-712 message, represented as a record of type names to their fields.\n * @param value - The actual data object to hash, conforming to the types defined.\n *\n * @returns The EIP-712 hash of the typed data as a hex-encoded string.\n * @throws {Error} if the typed data cannot be hashed.\n */\nconst hashTypedDataMessage = (domain, types, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue) => {\n    return ethers_1.ethers.TypedDataEncoder.hash(domain, types, value);\n};\nexports.hashTypedDataMessage = hashTypedDataMessage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2hhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsbUJBQW1CO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLGlFQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9oYXNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNoVHlwZWREYXRhTWVzc2FnZSA9IGV4cG9ydHMuaGFzaE1lc3NhZ2UgPSB2b2lkIDA7XG5jb25zdCBldGhlcnNfMSA9IHJlcXVpcmUoXCJldGhlcnNcIik7XG4vKipcbiAqIENvbXB1dGVzIHRoZSBFSVAtMTkxIHBlcnNvbmFsLXNpZ24gbWVzc2FnZSBkaWdlc3QgdG8gc2lnbi5cbiAqXG4gKiBAcmV0dXJucyBUaGUgRUlQLTE5MSBoYXNoIG9mIHRoZSBtZXNzYWdlIGFzIGEgc3RyaW5nLlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBoYXNoZWQuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKi9cbmNvbnN0IGhhc2hNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICByZXR1cm4gZXRoZXJzXzEuZXRoZXJzLmhhc2hNZXNzYWdlKG1lc3NhZ2UpO1xufTtcbmV4cG9ydHMuaGFzaE1lc3NhZ2UgPSBoYXNoTWVzc2FnZTtcbi8qKlxuICogQ29tcHV0ZXMgdGhlIGhhc2ggb2YgdGhlIEVJUC03MTIgY29tcGxpYW50IHR5cGVkIGRhdGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gZG9tYWluIC0gVGhlIGRvbWFpbiBwYXJhbWV0ZXJzIGZvciB0aGUgRUlQLTcxMiBtZXNzYWdlLCBpbmNsdWRpbmcgdGhlIG5hbWUsIHZlcnNpb24sIGNoYWluSWQsIGFuZCB2ZXJpZnlpbmcgY29udHJhY3QuXG4gKiBAcGFyYW0gdHlwZXMgLSBUaGUgdHlwZXMgZGVmaW5pdGlvbnMgZm9yIHRoZSBFSVAtNzEyIG1lc3NhZ2UsIHJlcHJlc2VudGVkIGFzIGEgcmVjb3JkIG9mIHR5cGUgbmFtZXMgdG8gdGhlaXIgZmllbGRzLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFjdHVhbCBkYXRhIG9iamVjdCB0byBoYXNoLCBjb25mb3JtaW5nIHRvIHRoZSB0eXBlcyBkZWZpbmVkLlxuICpcbiAqIEByZXR1cm5zIFRoZSBFSVAtNzEyIGhhc2ggb2YgdGhlIHR5cGVkIGRhdGEgYXMgYSBoZXgtZW5jb2RlZCBzdHJpbmcuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIHR5cGVkIGRhdGEgY2Fubm90IGJlIGhhc2hlZC5cbiAqL1xuY29uc3QgaGFzaFR5cGVkRGF0YU1lc3NhZ2UgPSAoZG9tYWluLCB0eXBlcywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudmFsdWUpID0+IHtcbiAgICByZXR1cm4gZXRoZXJzXzEuZXRoZXJzLlR5cGVkRGF0YUVuY29kZXIuaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSk7XG59O1xuZXhwb3J0cy5oYXNoVHlwZWREYXRhTWVzc2FnZSA9IGhhc2hUeXBlZERhdGFNZXNzYWdlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HistoricalBalance = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\n/** A representation of historical balance. */\nclass HistoricalBalance {\n    /**\n     * Private constructor to prevent direct instantiation outside of the factory methods.\n     *\n     * @ignore\n     * @param {Decimal} amount - The amount of the balance.\n     * @param {Decimal} blockHeight - The block height at which the balance was recorded.\n     * @param {string} blockHash - The block hash at which the balance was recorded\n     * @param {string} asset - The asset we want to fetch.\n     * @hideconstructor\n     */\n    constructor(amount, blockHeight, blockHash, asset) {\n        this.amount = amount;\n        this.blockHeight = blockHeight;\n        this.blockHash = blockHash;\n        this.asset = asset;\n    }\n    /**\n     * Converts a HistoricalBalanceModel into a HistoricalBalance object.\n     *\n     * @param {HistoricalBalanceModel} model - The historical balance model object.\n     * @returns {HistoricalBalance} The HistoricalBalance object.\n     */\n    static fromModel(model) {\n        const asset = asset_1.Asset.fromModel(model.asset);\n        return new HistoricalBalance(asset.fromAtomicAmount(new decimal_js_1.default(model.amount)), new decimal_js_1.default(model.block_height), model.block_hash, asset);\n    }\n}\nexports.HistoricalBalance = HistoricalBalance;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2hpc3RvcmljYWxfYmFsYW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixxQ0FBcUMsbUJBQU8sQ0FBQyw4REFBWTtBQUN6RCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvaGlzdG9yaWNhbF9iYWxhbmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IaXN0b3JpY2FsQmFsYW5jZSA9IHZvaWQgMDtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVjaW1hbC5qc1wiKSk7XG5jb25zdCBhc3NldF8xID0gcmVxdWlyZShcIi4vYXNzZXRcIik7XG4vKiogQSByZXByZXNlbnRhdGlvbiBvZiBoaXN0b3JpY2FsIGJhbGFuY2UuICovXG5jbGFzcyBIaXN0b3JpY2FsQmFsYW5jZSB7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IGRpcmVjdCBpbnN0YW50aWF0aW9uIG91dHNpZGUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAcGFyYW0ge0RlY2ltYWx9IGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIGJhbGFuY2UuXG4gICAgICogQHBhcmFtIHtEZWNpbWFsfSBibG9ja0hlaWdodCAtIFRoZSBibG9jayBoZWlnaHQgYXQgd2hpY2ggdGhlIGJhbGFuY2Ugd2FzIHJlY29yZGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja0hhc2ggLSBUaGUgYmxvY2sgaGFzaCBhdCB3aGljaCB0aGUgYmFsYW5jZSB3YXMgcmVjb3JkZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXQgLSBUaGUgYXNzZXQgd2Ugd2FudCB0byBmZXRjaC5cbiAgICAgKiBAaGlkZWNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYW1vdW50LCBibG9ja0hlaWdodCwgYmxvY2tIYXNoLCBhc3NldCkge1xuICAgICAgICB0aGlzLmFtb3VudCA9IGFtb3VudDtcbiAgICAgICAgdGhpcy5ibG9ja0hlaWdodCA9IGJsb2NrSGVpZ2h0O1xuICAgICAgICB0aGlzLmJsb2NrSGFzaCA9IGJsb2NrSGFzaDtcbiAgICAgICAgdGhpcy5hc3NldCA9IGFzc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIEhpc3RvcmljYWxCYWxhbmNlTW9kZWwgaW50byBhIEhpc3RvcmljYWxCYWxhbmNlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SGlzdG9yaWNhbEJhbGFuY2VNb2RlbH0gbW9kZWwgLSBUaGUgaGlzdG9yaWNhbCBiYWxhbmNlIG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7SGlzdG9yaWNhbEJhbGFuY2V9IFRoZSBIaXN0b3JpY2FsQmFsYW5jZSBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Nb2RlbChtb2RlbCkge1xuICAgICAgICBjb25zdCBhc3NldCA9IGFzc2V0XzEuQXNzZXQuZnJvbU1vZGVsKG1vZGVsLmFzc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3JpY2FsQmFsYW5jZShhc3NldC5mcm9tQXRvbWljQW1vdW50KG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdChtb2RlbC5hbW91bnQpKSwgbmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KG1vZGVsLmJsb2NrX2hlaWdodCksIG1vZGVsLmJsb2NrX2hhc2gsIGFzc2V0KTtcbiAgICB9XG59XG5leHBvcnRzLkhpc3RvcmljYWxCYWxhbmNlID0gSGlzdG9yaWNhbEJhbGFuY2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PayloadSignature = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * A representation of a Payload Signature.\n */\nclass PayloadSignature {\n    /**\n     * Constructs a Payload Signature.\n     *\n     * @class\n     * @param model - The underlying Payload Signature object.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the ID of the Payload Signature.\n     *\n     * @returns The ID of the Payload Signature\n     */\n    getId() {\n        return this.model.payload_signature_id;\n    }\n    /**\n     * Returns the Wallet ID of the Payload Signature.\n     *\n     * @returns The Wallet ID\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the Address ID of the Payload Signature.\n     *\n     * @returns The Address ID\n     */\n    getAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the Unsigned Payload of the Payload Signature.\n     *\n     * @returns The Unsigned Payload\n     */\n    getUnsignedPayload() {\n        return this.model.unsigned_payload;\n    }\n    /**\n     * Returns the Signature of the Payload Signature.\n     *\n     * @returns The Signature\n     */\n    getSignature() {\n        return this.model.signature;\n    }\n    /**\n     * Returns the Status of the Payload Signature.\n     *\n     * @returns The Status\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case types_1.PayloadSignatureStatus.PENDING:\n                return types_1.PayloadSignatureStatus.PENDING;\n            case types_1.PayloadSignatureStatus.SIGNED:\n                return types_1.PayloadSignatureStatus.SIGNED;\n            case types_1.PayloadSignatureStatus.FAILED:\n                return types_1.PayloadSignatureStatus.FAILED;\n            default:\n                return undefined;\n        }\n    }\n    /**\n     * Returns whether the Payload Signature is in a terminal State.\n     *\n     * @returns Whether the Payload Signature is in a terminal State\n     */\n    isTerminalState() {\n        const status = this.getStatus();\n        if (!status)\n            return false;\n        return [types_1.PayloadSignatureStatus.SIGNED, types_1.PayloadSignatureStatus.FAILED].includes(status);\n    }\n    /**\n     * Waits for the Payload Signature to be signed or for the signature operation to fail.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the Payload Signature.\n     * @param options.timeoutSeconds - The maximum time to wait for the Payload Signature to be confirmed.\n     *\n     * @returns The Payload Signature object in a terminal state.\n     * @throws {Error} if the Payload Signature times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10, } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the Payload Signature is in a terminal state, return the Payload Signature.\n            if (this.isTerminalState()) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"Payload Signature timed out\");\n    }\n    /**\n     * Reloads the Payload Signature model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a Payload Signature fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.address.getPayloadSignature(this.getWalletId(), this.getAddressId(), this.getId());\n        this.model = result?.data;\n    }\n    /**\n     * Returns a string representation of the Payload Signature.\n     *\n     * @returns A string representation of the Payload Signature.\n     */\n    toString() {\n        return `PayloadSignature { status: '${this.getStatus()}', unsignedPayload: '${this.getUnsignedPayload()}', signature: ${this.getSignature()} }`;\n    }\n}\nexports.PayloadSignature = PayloadSignature;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3BheWxvYWRfc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxpQkFBaUIsOENBQThDLElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVyxpQkFBaUIsdUJBQXVCLDBCQUEwQixnQkFBZ0Isc0JBQXNCO0FBQ3RKO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9wYXlsb2FkX3NpZ25hdHVyZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGF5bG9hZFNpZ25hdHVyZSA9IHZvaWQgMDtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgUGF5bG9hZCBTaWduYXR1cmUuXG4gKi9cbmNsYXNzIFBheWxvYWRTaWduYXR1cmUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSB1bmRlcmx5aW5nIFBheWxvYWQgU2lnbmF0dXJlIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1vZGVsIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgUGF5bG9hZCBTaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgSUQgb2YgdGhlIFBheWxvYWQgU2lnbmF0dXJlXG4gICAgICovXG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnBheWxvYWRfc2lnbmF0dXJlX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBXYWxsZXQgSUQgb2YgdGhlIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFdhbGxldCBJRFxuICAgICAqL1xuICAgIGdldFdhbGxldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC53YWxsZXRfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEFkZHJlc3MgSUQgb2YgdGhlIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEFkZHJlc3MgSURcbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFkZHJlc3NfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFVuc2lnbmVkIFBheWxvYWQgb2YgdGhlIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFVuc2lnbmVkIFBheWxvYWRcbiAgICAgKi9cbiAgICBnZXRVbnNpZ25lZFBheWxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnVuc2lnbmVkX3BheWxvYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFNpZ25hdHVyZSBvZiB0aGUgUGF5bG9hZCBTaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgU2lnbmF0dXJlXG4gICAgICovXG4gICAgZ2V0U2lnbmF0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zaWduYXR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFN0YXR1cyBvZiB0aGUgUGF5bG9hZCBTaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgU3RhdHVzXG4gICAgICovXG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuUGF5bG9hZFNpZ25hdHVyZVN0YXR1cy5QRU5ESU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlBheWxvYWRTaWduYXR1cmVTdGF0dXMuUEVORElORztcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzLlNJR05FRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzLlNJR05FRDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzLkZBSUxFRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzLkZBSUxFRDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFBheWxvYWQgU2lnbmF0dXJlIGlzIGluIGEgdGVybWluYWwgU3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBQYXlsb2FkIFNpZ25hdHVyZSBpcyBpbiBhIHRlcm1pbmFsIFN0YXRlXG4gICAgICovXG4gICAgaXNUZXJtaW5hbFN0YXRlKCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmdldFN0YXR1cygpO1xuICAgICAgICBpZiAoIXN0YXR1cylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFt0eXBlc18xLlBheWxvYWRTaWduYXR1cmVTdGF0dXMuU0lHTkVELCB0eXBlc18xLlBheWxvYWRTaWduYXR1cmVTdGF0dXMuRkFJTEVEXS5pbmNsdWRlcyhzdGF0dXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgdGhlIFBheWxvYWQgU2lnbmF0dXJlIHRvIGJlIHNpZ25lZCBvciBmb3IgdGhlIHNpZ25hdHVyZSBvcGVyYXRpb24gdG8gZmFpbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSB3YWl0IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmludGVydmFsU2Vjb25kcyAtIFRoZSBpbnRlcnZhbCB0byBjaGVjayB0aGUgc3RhdHVzIG9mIHRoZSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0U2Vjb25kcyAtIFRoZSBtYXhpbXVtIHRpbWUgdG8gd2FpdCBmb3IgdGhlIFBheWxvYWQgU2lnbmF0dXJlIHRvIGJlIGNvbmZpcm1lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBQYXlsb2FkIFNpZ25hdHVyZSBvYmplY3QgaW4gYSB0ZXJtaW5hbCBzdGF0ZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIFBheWxvYWQgU2lnbmF0dXJlIHRpbWVzIG91dC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KHsgaW50ZXJ2YWxTZWNvbmRzID0gMC4yLCB0aW1lb3V0U2Vjb25kcyA9IDEwLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgUGF5bG9hZCBTaWduYXR1cmUgaXMgaW4gYSB0ZXJtaW5hbCBzdGF0ZSwgcmV0dXJuIHRoZSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzVGVybWluYWxTdGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKFwiUGF5bG9hZCBTaWduYXR1cmUgdGltZWQgb3V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSBQYXlsb2FkIFNpZ25hdHVyZSBtb2RlbCB3aXRoIHRoZSBsYXRlc3QgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGdldCBhIFBheWxvYWQgU2lnbmF0dXJlIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbG9hZCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmFkZHJlc3MuZ2V0UGF5bG9hZFNpZ25hdHVyZSh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0QWRkcmVzc0lkKCksIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSByZXN1bHQ/LmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFBheWxvYWRTaWduYXR1cmUgeyBzdGF0dXM6ICcke3RoaXMuZ2V0U3RhdHVzKCl9JywgdW5zaWduZWRQYXlsb2FkOiAnJHt0aGlzLmdldFVuc2lnbmVkUGF5bG9hZCgpfScsIHNpZ25hdHVyZTogJHt0aGlzLmdldFNpZ25hdHVyZSgpfSB9YDtcbiAgICB9XG59XG5leHBvcnRzLlBheWxvYWRTaWduYXR1cmUgPSBQYXlsb2FkU2lnbmF0dXJlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/read_contract.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/read_contract.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.readContract = void 0;\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * Converts a SolidityValue to its corresponding JavaScript type.\n *\n * @param {SolidityValue} solidityValue - The Solidity value to convert.\n * @returns {unknown} The converted JavaScript value.\n */\nfunction convertSolidityValue(solidityValue) {\n    const { type, value, values } = solidityValue;\n    switch (type) {\n        case \"uint8\":\n        case \"uint16\":\n        case \"uint32\":\n        case \"int8\":\n        case \"int16\":\n        case \"int32\":\n            return Number(value);\n        case \"uint64\":\n        case \"uint128\":\n        case \"uint256\":\n        case \"int64\":\n        case \"int128\":\n        case \"int256\":\n            return BigInt(value);\n        case \"address\":\n            return value;\n        case \"bool\":\n            return value === \"true\";\n        case \"string\":\n            return value;\n        case \"bytes\":\n        case \"bytes1\":\n        case \"bytes2\":\n        case \"bytes3\":\n        case \"bytes4\":\n        case \"bytes5\":\n        case \"bytes6\":\n        case \"bytes7\":\n        case \"bytes8\":\n        case \"bytes9\":\n        case \"bytes10\":\n        case \"bytes11\":\n        case \"bytes12\":\n        case \"bytes13\":\n        case \"bytes14\":\n        case \"bytes15\":\n        case \"bytes16\":\n        case \"bytes17\":\n        case \"bytes18\":\n        case \"bytes19\":\n        case \"bytes20\":\n        case \"bytes21\":\n        case \"bytes22\":\n        case \"bytes23\":\n        case \"bytes24\":\n        case \"bytes25\":\n        case \"bytes26\":\n        case \"bytes27\":\n        case \"bytes28\":\n        case \"bytes29\":\n        case \"bytes30\":\n        case \"bytes31\":\n        case \"bytes32\":\n            return value;\n        case \"array\":\n            return values.map(convertSolidityValue);\n        case \"tuple\":\n            return values.reduce((acc, val) => {\n                if (!val.name) {\n                    throw new Error(\"Tuple field missing name\");\n                }\n                acc[val.name] = convertSolidityValue(val);\n                return acc;\n            }, {});\n        default:\n            throw new Error(`Unsupported Solidity type: ${type}`);\n    }\n}\n/**\n * Parses a SolidityValue to a specific type T.\n *\n * @template T\n * @param {SolidityValue} solidityValue - The Solidity value to parse.\n * @returns {T} The parsed value of type T.\n */\nfunction parseSolidityValue(solidityValue) {\n    return convertSolidityValue(solidityValue);\n}\n/**\n * Reads data from a smart contract using the Coinbase API.\n *\n * @template TAbi - The ABI type.\n * @template TFunctionName - The contract function name type.\n * @template TArgs - The function arguments type.\n * @param {object} params - The parameters for reading the contract.\n * @param {string} params.networkId - The network ID.\n * @param {string} params.contractAddress - The contract address (as a hexadecimal string).\n * @param {TFunctionName} params.method - The contract method to call.\n * @param {TArgs} params.args - The arguments for the contract method.\n * @param {TAbi} [params.abi] - The contract ABI (optional).\n * @returns {Promise<any>} The result of the contract call.\n */\nasync function readContract(params) {\n    const response = await coinbase_1.Coinbase.apiClients.smartContract.readContract(params.networkId, params.contractAddress, {\n        method: params.method,\n        args: JSON.stringify(params.args || {}),\n        abi: params.abi ? JSON.stringify(params.abi) : undefined,\n    });\n    return parseSolidityValue(response.data);\n}\nexports.readContract = readContract;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3JlYWRfY29udHJhY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvcmVhZF9jb250cmFjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVhZENvbnRyYWN0ID0gdm9pZCAwO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIFNvbGlkaXR5VmFsdWUgdG8gaXRzIGNvcnJlc3BvbmRpbmcgSmF2YVNjcmlwdCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7U29saWRpdHlWYWx1ZX0gc29saWRpdHlWYWx1ZSAtIFRoZSBTb2xpZGl0eSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3Vua25vd259IFRoZSBjb252ZXJ0ZWQgSmF2YVNjcmlwdCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY29udmVydFNvbGlkaXR5VmFsdWUoc29saWRpdHlWYWx1ZSkge1xuICAgIGNvbnN0IHsgdHlwZSwgdmFsdWUsIHZhbHVlcyB9ID0gc29saWRpdHlWYWx1ZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICBjYXNlIFwiaW50OFwiOlxuICAgICAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICBjYXNlIFwidWludDEyOFwiOlxuICAgICAgICBjYXNlIFwidWludDI1NlwiOlxuICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgY2FzZSBcImludDEyOFwiOlxuICAgICAgICBjYXNlIFwiaW50MjU2XCI6XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczFcIjpcbiAgICAgICAgY2FzZSBcImJ5dGVzMlwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMzXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczRcIjpcbiAgICAgICAgY2FzZSBcImJ5dGVzNVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXM2XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczdcIjpcbiAgICAgICAgY2FzZSBcImJ5dGVzOFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXM5XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczEwXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczExXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczEyXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczEzXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczE0XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczE1XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczE2XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczE3XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczE4XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczE5XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczIwXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczIxXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczIyXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczIzXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczI0XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczI1XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczI2XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczI3XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczI4XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczI5XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczMwXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczMxXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczMyXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoY29udmVydFNvbGlkaXR5VmFsdWUpO1xuICAgICAgICBjYXNlIFwidHVwbGVcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKChhY2MsIHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdmFsLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHVwbGUgZmllbGQgbWlzc2luZyBuYW1lXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2NbdmFsLm5hbWVdID0gY29udmVydFNvbGlkaXR5VmFsdWUodmFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBTb2xpZGl0eSB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBQYXJzZXMgYSBTb2xpZGl0eVZhbHVlIHRvIGEgc3BlY2lmaWMgdHlwZSBULlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1NvbGlkaXR5VmFsdWV9IHNvbGlkaXR5VmFsdWUgLSBUaGUgU29saWRpdHkgdmFsdWUgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyB7VH0gVGhlIHBhcnNlZCB2YWx1ZSBvZiB0eXBlIFQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU29saWRpdHlWYWx1ZShzb2xpZGl0eVZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRTb2xpZGl0eVZhbHVlKHNvbGlkaXR5VmFsdWUpO1xufVxuLyoqXG4gKiBSZWFkcyBkYXRhIGZyb20gYSBzbWFydCBjb250cmFjdCB1c2luZyB0aGUgQ29pbmJhc2UgQVBJLlxuICpcbiAqIEB0ZW1wbGF0ZSBUQWJpIC0gVGhlIEFCSSB0eXBlLlxuICogQHRlbXBsYXRlIFRGdW5jdGlvbk5hbWUgLSBUaGUgY29udHJhY3QgZnVuY3Rpb24gbmFtZSB0eXBlLlxuICogQHRlbXBsYXRlIFRBcmdzIC0gVGhlIGZ1bmN0aW9uIGFyZ3VtZW50cyB0eXBlLlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciByZWFkaW5nIHRoZSBjb250cmFjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubmV0d29ya0lkIC0gVGhlIG5ldHdvcmsgSUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNvbnRyYWN0QWRkcmVzcyAtIFRoZSBjb250cmFjdCBhZGRyZXNzIChhcyBhIGhleGFkZWNpbWFsIHN0cmluZykuXG4gKiBAcGFyYW0ge1RGdW5jdGlvbk5hbWV9IHBhcmFtcy5tZXRob2QgLSBUaGUgY29udHJhY3QgbWV0aG9kIHRvIGNhbGwuXG4gKiBAcGFyYW0ge1RBcmdzfSBwYXJhbXMuYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBjb250cmFjdCBtZXRob2QuXG4gKiBAcGFyYW0ge1RBYml9IFtwYXJhbXMuYWJpXSAtIFRoZSBjb250cmFjdCBBQkkgKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSByZXN1bHQgb2YgdGhlIGNvbnRyYWN0IGNhbGwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRDb250cmFjdChwYXJhbXMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zbWFydENvbnRyYWN0LnJlYWRDb250cmFjdChwYXJhbXMubmV0d29ya0lkLCBwYXJhbXMuY29udHJhY3RBZGRyZXNzLCB7XG4gICAgICAgIG1ldGhvZDogcGFyYW1zLm1ldGhvZCxcbiAgICAgICAgYXJnczogSlNPTi5zdHJpbmdpZnkocGFyYW1zLmFyZ3MgfHwge30pLFxuICAgICAgICBhYmk6IHBhcmFtcy5hYmkgPyBKU09OLnN0cmluZ2lmeShwYXJhbXMuYWJpKSA6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyc2VTb2xpZGl0eVZhbHVlKHJlc3BvbnNlLmRhdGEpO1xufVxuZXhwb3J0cy5yZWFkQ29udHJhY3QgPSByZWFkQ29udHJhY3Q7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/read_contract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/server_signer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/server_signer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerSigner = void 0;\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * A representation of a Server-Signer. Server-Signers are assigned to sign transactions for a Wallet.\n */\nclass ServerSigner {\n    /**\n     * Private constructor to prevent direct instantiation outside of factory method.\n     * Creates a new ServerSigner instance.\n     * Do not use this method directly. Instead, use ServerSigner.getDefault().\n     *\n     * @ignore\n     * @param serverSignerModel - The Server-Signer model.\n     * @hideconstructor\n     */\n    constructor(serverSignerModel) {\n        this.model = serverSignerModel;\n    }\n    /**\n     * Returns the default Server-Signer for the CDP Project.\n     *\n     * @returns The default Server-Signer.\n     * @throws {APIError} if the API request to list Server-Signers fails.\n     * @throws {Error} if there is no Server-Signer associated with the CDP Project.\n     */\n    static async getDefault() {\n        const response = await coinbase_1.Coinbase.apiClients.serverSigner.listServerSigners();\n        if (response.data.data.length === 0) {\n            throw new Error(\"No Server-Signer is associated with the project\");\n        }\n        return new ServerSigner(response.data.data[0]);\n    }\n    /**\n     * Returns the ID of the Server-Signer.\n     *\n     * @returns The Server-Signer ID.\n     */\n    getId() {\n        return this.model.server_signer_id;\n    }\n    /**\n     * Returns the IDs of the Wallet's the Server-Signer can sign for.\n     *\n     * @returns The Wallet IDs.\n     */\n    getWallets() {\n        return this.model.wallets;\n    }\n    /**\n     * Returns a String representation of the Server-Signer.\n     *\n     * @returns a String representation of the Server-Signer.\n     */\n    toString() {\n        return `ServerSigner{id: '${this.getId()}', wallets: '${this.getWallets()}'}`;\n    }\n}\nexports.ServerSigner = ServerSigner;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3NlcnZlcl9zaWduZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTyxhQUFhLGVBQWUsa0JBQWtCLEVBQUU7QUFDcEY7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3NlcnZlcl9zaWduZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZlclNpZ25lciA9IHZvaWQgMDtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIFNlcnZlci1TaWduZXIuIFNlcnZlci1TaWduZXJzIGFyZSBhc3NpZ25lZCB0byBzaWduIHRyYW5zYWN0aW9ucyBmb3IgYSBXYWxsZXQuXG4gKi9cbmNsYXNzIFNlcnZlclNpZ25lciB7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IGRpcmVjdCBpbnN0YW50aWF0aW9uIG91dHNpZGUgb2YgZmFjdG9yeSBtZXRob2QuXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTZXJ2ZXJTaWduZXIgaW5zdGFuY2UuXG4gICAgICogRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBkaXJlY3RseS4gSW5zdGVhZCwgdXNlIFNlcnZlclNpZ25lci5nZXREZWZhdWx0KCkuXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICogQHBhcmFtIHNlcnZlclNpZ25lck1vZGVsIC0gVGhlIFNlcnZlci1TaWduZXIgbW9kZWwuXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlclNpZ25lck1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBzZXJ2ZXJTaWduZXJNb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBTZXJ2ZXItU2lnbmVyIGZvciB0aGUgQ0RQIFByb2plY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZGVmYXVsdCBTZXJ2ZXItU2lnbmVyLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gbGlzdCBTZXJ2ZXItU2lnbmVycyBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgaXMgbm8gU2VydmVyLVNpZ25lciBhc3NvY2lhdGVkIHdpdGggdGhlIENEUCBQcm9qZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBnZXREZWZhdWx0KCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zZXJ2ZXJTaWduZXIubGlzdFNlcnZlclNpZ25lcnMoKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFNlcnZlci1TaWduZXIgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm9qZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VydmVyU2lnbmVyKHJlc3BvbnNlLmRhdGEuZGF0YVswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSBTZXJ2ZXItU2lnbmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFNlcnZlci1TaWduZXIgSUQuXG4gICAgICovXG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnNlcnZlcl9zaWduZXJfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEcyBvZiB0aGUgV2FsbGV0J3MgdGhlIFNlcnZlci1TaWduZXIgY2FuIHNpZ24gZm9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFdhbGxldCBJRHMuXG4gICAgICovXG4gICAgZ2V0V2FsbGV0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwud2FsbGV0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgU2VydmVyLVNpZ25lci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTZXJ2ZXItU2lnbmVyLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFNlcnZlclNpZ25lcntpZDogJyR7dGhpcy5nZXRJZCgpfScsIHdhbGxldHM6ICcke3RoaXMuZ2V0V2FsbGV0cygpfSd9YDtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlclNpZ25lciA9IFNlcnZlclNpZ25lcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/server_signer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SmartContract = void 0;\nconst api_1 = __webpack_require__(/*! ../client/api */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst contract_event_1 = __webpack_require__(/*! ./contract_event */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js\");\n/**\n * A representation of a SmartContract on the blockchain.\n */\nclass SmartContract {\n    /**\n     * Creates a new SmartContract instance.\n     *\n     * @param contractModel - The SmartContract model from the API.\n     */\n    constructor(contractModel) {\n        if (!contractModel) {\n            throw new Error(\"SmartContract model cannot be empty\");\n        }\n        this.model = contractModel;\n    }\n    /**\n     * Returns whether the SmartContract is external.\n     *\n     * @returns True if the SmartContract is external, false otherwise.\n     */\n    get isExternal() {\n        return this.model.is_external;\n    }\n    /**\n     * Returns a list of ContractEvents for the provided network, contract, and event details.\n     *\n     * @param networkId - The network ID.\n     * @param protocolName - The protocol name.\n     * @param contractAddress - The contract address.\n     * @param contractName - The contract name.\n     * @param eventName - The event name.\n     * @param fromBlockHeight - The start block height.\n     * @param toBlockHeight - The end block height.\n     * @returns The contract events.\n     */\n    static async listEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight) {\n        const contractEvents = [];\n        const queue = [\"\"];\n        while (queue.length > 0) {\n            const page = queue.shift();\n            const response = await coinbase_1.Coinbase.apiClients.contractEvent.listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, page?.length ? page : undefined);\n            response.data.data.forEach(contractEvent => {\n                contractEvents.push(new contract_event_1.ContractEvent(contractEvent));\n            });\n            if (response.data.has_more) {\n                if (response.data.next_page) {\n                    queue.push(response.data.next_page);\n                }\n            }\n        }\n        return contractEvents;\n    }\n    /**\n     * Register a smart contract.\n     *\n     * @param options - The options to register a smart contract.\n     * @param options.networkId - The network ID.\n     * @param options.contractAddress - The contract address.\n     * @param options.abi - The ABI of the contract.\n     * @param options.contractName - The contract name.\n     * @returns The smart contract.\n     */\n    static async register({ networkId, contractAddress, abi, contractName, }) {\n        const response = await coinbase_1.Coinbase.apiClients.smartContract.registerSmartContract(networkId, contractAddress, {\n            abi: JSON.stringify(abi),\n            contract_name: contractName,\n        });\n        return SmartContract.fromModel(response.data);\n    }\n    /**\n     * Lists Smart Contracts.\n     *\n     * @param options - The pagination options.\n     * @param options.page - The cursor for pagination across multiple pages of Smart Contract. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Smart Contracts.\n     */\n    static async list({ page = undefined } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.smartContract.listSmartContracts(page);\n        const smartContracts = response.data.data;\n        for (const sc of smartContracts) {\n            data.push(new SmartContract(sc));\n        }\n        const hasMore = response.data.has_more ? response.data.has_more : false;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Converts a SmartContractModel into a SmartContract object.\n     *\n     * @param contractModel - The SmartContract model object.\n     * @returns The SmartContract object.\n     */\n    static fromModel(contractModel) {\n        return new SmartContract(contractModel);\n    }\n    /**\n     * Returns the ID of the SmartContract.\n     *\n     * @returns The SmartContract ID.\n     */\n    getId() {\n        return this.model.smart_contract_id;\n    }\n    /**\n     * Returns the Network ID of the SmartContract.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the Wallet ID that deployed the smart contract.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletId() {\n        if (!this.model.wallet_id)\n            return undefined;\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the name of the smart contract.\n     *\n     * @returns The contract name.\n     */\n    getContractName() {\n        return this.model.contract_name;\n    }\n    /**\n     * Returns the Contract Address of the smart contract.\n     *\n     * @returns The Contract Address.\n     */\n    getContractAddress() {\n        return this.model.contract_address;\n    }\n    /**\n     * Returns the Deployer Address of the smart contract.\n     *\n     * @returns The Deployer Address.\n     */\n    getDeployerAddress() {\n        if (!this.model.deployer_address)\n            return undefined;\n        return this.model.deployer_address;\n    }\n    /**\n     * Returns the Type of the smart contract.\n     *\n     * @returns The Smart Contract Type.\n     */\n    getType() {\n        switch (this.model.type) {\n            case api_1.SmartContractType.Erc20:\n                return types_1.SmartContractType.ERC20;\n            case api_1.SmartContractType.Erc721:\n                return types_1.SmartContractType.ERC721;\n            case api_1.SmartContractType.Erc1155:\n                return types_1.SmartContractType.ERC1155;\n            case api_1.SmartContractType.Custom:\n                return types_1.SmartContractType.CUSTOM;\n            default:\n                throw new Error(`Unknown smart contract type: ${this.model.type}`);\n        }\n    }\n    /**\n     * Returns the Options of the smart contract.\n     *\n     * @returns The Smart Contract Options.\n     */\n    getOptions() {\n        if (this.isExternal)\n            throw new Error(\"SmartContract options cannot be returned for external SmartContract\");\n        const options = this.model.options;\n        if (this.isERC20(this.getType(), options)) {\n            return {\n                name: options.name,\n                symbol: options.symbol,\n                totalSupply: options.total_supply,\n            };\n        }\n        else if (this.isERC721(this.getType(), options)) {\n            return {\n                name: options.name,\n                symbol: options.symbol,\n                baseURI: options.base_uri,\n            };\n        }\n        else if (this.isERC1155(this.getType(), options)) {\n            return {\n                uri: options.uri,\n            };\n        }\n        else {\n            return options;\n        }\n    }\n    /**\n     * Returns the ABI of the smart contract.\n     *\n     * @returns The ABI as a JSON-encoded string.\n     */\n    getAbi() {\n        return JSON.parse(this.model.abi);\n    }\n    /**\n     * Returns the Transaction of the smart contract deployment.\n     *\n     * @returns The Transaction.\n     */\n    getTransaction() {\n        if (this.isExternal)\n            return undefined;\n        return new transaction_1.Transaction(this.model.transaction);\n    }\n    /**\n     * Signs the SmartContract deployment with the provided key and returns the hex signature\n     * required for broadcasting the SmartContract deployment.\n     *\n     * @param key - The key to sign the SmartContract deployment with\n     * @returns The hex-encoded signed payload\n     */\n    async sign(key) {\n        if (this.isExternal)\n            throw new Error(\"Cannot sign an external SmartContract\");\n        return this.getTransaction().sign(key);\n    }\n    /**\n     * Update a smart contract.\n     *\n     * @param options - The options to update a smart contract.\n     * @param options.abi - The new ABI of the contract.\n     * @param options.contractName - The new contract name.\n     * @returns The smart contract.\n     */\n    async update({ abi, contractName }) {\n        const response = await coinbase_1.Coinbase.apiClients.smartContract.updateSmartContract(this.getNetworkId(), this.getContractAddress(), {\n            abi: JSON.stringify(abi),\n            contract_name: contractName,\n        });\n        return SmartContract.fromModel(response.data);\n    }\n    /**\n     * Broadcasts the SmartContract deployment to the Network.\n     *\n     * @returns The SmartContract object\n     * @throws {APIError} if the API request to broadcast a SmartContract deployment fails.\n     */\n    async broadcast() {\n        if (this.isExternal)\n            throw new Error(\"Cannot broadcast an external SmartContract\");\n        if (!this.getTransaction().isSigned())\n            throw new Error(\"Cannot broadcast unsigned SmartContract deployment\");\n        const deploySmartContractRequest = {\n            signed_payload: this.getTransaction().getSignature(),\n        };\n        const response = await coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract(this.getWalletId(), this.getDeployerAddress(), this.getId(), deploySmartContractRequest);\n        return SmartContract.fromModel(response.data);\n    }\n    /**\n     * Waits for the SmartContract deployment to be confirmed on the Network or fail on chain.\n     * Waits until the SmartContract deployment is completed or failed on-chain by polling at the given interval.\n     * Raises an error if the SmartContract deployment takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the SmartContract deployment.\n     * @param options.timeoutSeconds - The maximum time to wait for the SmartContract deployment to be confirmed.\n     *\n     * @returns The SmartContract object in a terminal state.\n     * @throws {Error} if the SmartContract deployment times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10 } = {}) {\n        if (this.isExternal)\n            throw new Error(\"Cannot wait for an external SmartContract\");\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the SmartContract deployment is in a terminal state, return the SmartContract.\n            const status = this.getTransaction().getStatus();\n            if (status === types_1.TransactionStatus.COMPLETE || status === types_1.TransactionStatus.FAILED) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"SmartContract deployment timed out\");\n    }\n    /**\n     * Reloads the SmartContract model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a SmartContract fails.\n     */\n    async reload() {\n        if (this.isExternal)\n            throw new Error(\"Cannot reload an external SmartContract\");\n        const result = await coinbase_1.Coinbase.apiClients.smartContract.getSmartContract(this.getWalletId(), this.getDeployerAddress(), this.getId());\n        this.model = result?.data;\n    }\n    /**\n     * Returns a string representation of the SmartContract.\n     *\n     * @returns The string representation of the SmartContract.\n     */\n    toString() {\n        return (`SmartContract{id: '${this.getId()}', networkId: '${this.getNetworkId()}', ` +\n            `contractAddress: '${this.getContractAddress()}', deployerAddress: '${this.getDeployerAddress()}', ` +\n            `type: '${this.getType()}'}`);\n    }\n    /**\n     * Type guard for checking if the smart contract is an ERC20.\n     *\n     * @param type - The type of the smart contract.\n     * @param options - The options of the smart contract.\n     * @returns True if the smart contract is an ERC20, false otherwise.\n     */\n    isERC20(type, options) {\n        return type === types_1.SmartContractType.ERC20;\n    }\n    /**\n     * Type guard for checking if the smart contract is an ERC721.\n     *\n     * @param type - The type of the smart contract.\n     * @param options - The options of the smart contract.\n     * @returns True if the smart contract is an ERC721, false otherwise.\n     */\n    isERC721(type, options) {\n        return type === types_1.SmartContractType.ERC721;\n    }\n    /**\n     * Type guard for checking if the smart contract is an ERC1155.\n     *\n     * @param type - The type of the smart contract.\n     * @param options - The options of the smart contract.\n     * @returns True if the smart contract is an ERC1155, false otherwise.\n     */\n    isERC1155(type, options) {\n        return type === types_1.SmartContractType.ERC1155;\n    }\n}\nexports.SmartContract = SmartContract;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3NtYXJ0X2NvbnRyYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixjQUFjLG1CQUFPLENBQUMscUZBQWU7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWU7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkMseUJBQXlCLG1CQUFPLENBQUMscUdBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBZ0Q7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGdCQUFnQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsaUJBQWlCLDZDQUE2QyxJQUFJO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGFBQWEsaUJBQWlCLG9CQUFvQjtBQUN4RixpQ0FBaUMsMEJBQTBCLHVCQUF1QiwwQkFBMEI7QUFDNUcsc0JBQXNCLGVBQWUsRUFBRTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2Uvc21hcnRfY29udHJhY3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNtYXJ0Q29udHJhY3QgPSB2b2lkIDA7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCIuLi9jbGllbnQvYXBpXCIpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBjb250cmFjdF9ldmVudF8xID0gcmVxdWlyZShcIi4vY29udHJhY3RfZXZlbnRcIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBTbWFydENvbnRyYWN0IG9uIHRoZSBibG9ja2NoYWluLlxuICovXG5jbGFzcyBTbWFydENvbnRyYWN0IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNtYXJ0Q29udHJhY3QgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RNb2RlbCAtIFRoZSBTbWFydENvbnRyYWN0IG1vZGVsIGZyb20gdGhlIEFQSS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdE1vZGVsKSB7XG4gICAgICAgIGlmICghY29udHJhY3RNb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU21hcnRDb250cmFjdCBtb2RlbCBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IGNvbnRyYWN0TW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgU21hcnRDb250cmFjdCBpcyBleHRlcm5hbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIFNtYXJ0Q29udHJhY3QgaXMgZXh0ZXJuYWwsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgaXNFeHRlcm5hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuaXNfZXh0ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIENvbnRyYWN0RXZlbnRzIGZvciB0aGUgcHJvdmlkZWQgbmV0d29yaywgY29udHJhY3QsIGFuZCBldmVudCBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCAtIFRoZSBuZXR3b3JrIElELlxuICAgICAqIEBwYXJhbSBwcm90b2NvbE5hbWUgLSBUaGUgcHJvdG9jb2wgbmFtZS5cbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gVGhlIGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGNvbnRyYWN0TmFtZSAtIFRoZSBjb250cmFjdCBuYW1lLlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gZnJvbUJsb2NrSGVpZ2h0IC0gVGhlIHN0YXJ0IGJsb2NrIGhlaWdodC5cbiAgICAgKiBAcGFyYW0gdG9CbG9ja0hlaWdodCAtIFRoZSBlbmQgYmxvY2sgaGVpZ2h0LlxuICAgICAqIEByZXR1cm5zIFRoZSBjb250cmFjdCBldmVudHMuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGxpc3RFdmVudHMobmV0d29ya0lkLCBwcm90b2NvbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCkge1xuICAgICAgICBjb25zdCBjb250cmFjdEV2ZW50cyA9IFtdO1xuICAgICAgICBjb25zdCBxdWV1ZSA9IFtcIlwiXTtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuY29udHJhY3RFdmVudC5saXN0Q29udHJhY3RFdmVudHMobmV0d29ya0lkLCBwcm90b2NvbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCwgcGFnZT8ubGVuZ3RoID8gcGFnZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhLmRhdGEuZm9yRWFjaChjb250cmFjdEV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb250cmFjdEV2ZW50cy5wdXNoKG5ldyBjb250cmFjdF9ldmVudF8xLkNvbnRyYWN0RXZlbnQoY29udHJhY3RFdmVudCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5oYXNfbW9yZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0RXZlbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byByZWdpc3RlciBhIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5ldHdvcmtJZCAtIFRoZSBuZXR3b3JrIElELlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbnRyYWN0QWRkcmVzcyAtIFRoZSBjb250cmFjdCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFiaSAtIFRoZSBBQkkgb2YgdGhlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbnRyYWN0TmFtZSAtIFRoZSBjb250cmFjdCBuYW1lLlxuICAgICAqIEByZXR1cm5zIFRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcmVnaXN0ZXIoeyBuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBjb250cmFjdE5hbWUsIH0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc21hcnRDb250cmFjdC5yZWdpc3RlclNtYXJ0Q29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHtcbiAgICAgICAgICAgIGFiaTogSlNPTi5zdHJpbmdpZnkoYWJpKSxcbiAgICAgICAgICAgIGNvbnRyYWN0X25hbWU6IGNvbnRyYWN0TmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBTbWFydENvbnRyYWN0LmZyb21Nb2RlbChyZXNwb25zZS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgU21hcnQgQ29udHJhY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcGFnaW5hdGlvbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhZ2UgLSBUaGUgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiBTbWFydCBDb250cmFjdC4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYWdpbmF0ZWQgbGlzdCByZXNwb25zZSBvZiBTbWFydCBDb250cmFjdHMuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGxpc3QoeyBwYWdlID0gdW5kZWZpbmVkIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGxldCBuZXh0UGFnZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc21hcnRDb250cmFjdC5saXN0U21hcnRDb250cmFjdHMocGFnZSk7XG4gICAgICAgIGNvbnN0IHNtYXJ0Q29udHJhY3RzID0gcmVzcG9uc2UuZGF0YS5kYXRhO1xuICAgICAgICBmb3IgKGNvbnN0IHNjIG9mIHNtYXJ0Q29udHJhY3RzKSB7XG4gICAgICAgICAgICBkYXRhLnB1c2gobmV3IFNtYXJ0Q29udHJhY3Qoc2MpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNNb3JlID0gcmVzcG9uc2UuZGF0YS5oYXNfbW9yZSA/IHJlc3BvbnNlLmRhdGEuaGFzX21vcmUgOiBmYWxzZTtcbiAgICAgICAgaWYgKGhhc01vcmUpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSkge1xuICAgICAgICAgICAgICAgIG5leHRQYWdlID0gcmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBoYXNNb3JlLFxuICAgICAgICAgICAgbmV4dFBhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgU21hcnRDb250cmFjdE1vZGVsIGludG8gYSBTbWFydENvbnRyYWN0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdE1vZGVsIC0gVGhlIFNtYXJ0Q29udHJhY3QgbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBTbWFydENvbnRyYWN0IG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU1vZGVsKGNvbnRyYWN0TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbWFydENvbnRyYWN0KGNvbnRyYWN0TW9kZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgU21hcnRDb250cmFjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTbWFydENvbnRyYWN0IElELlxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zbWFydF9jb250cmFjdF9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTmV0d29yayBJRCBvZiB0aGUgU21hcnRDb250cmFjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBOZXR3b3JrIElELlxuICAgICAqL1xuICAgIGdldE5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwubmV0d29ya19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgV2FsbGV0IElEIHRoYXQgZGVwbG95ZWQgdGhlIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFdhbGxldCBJRC5cbiAgICAgKi9cbiAgICBnZXRXYWxsZXRJZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsLndhbGxldF9pZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLndhbGxldF9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY29udHJhY3QgbmFtZS5cbiAgICAgKi9cbiAgICBnZXRDb250cmFjdE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNvbnRyYWN0X25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIENvbnRyYWN0IEFkZHJlc3Mgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIENvbnRyYWN0IEFkZHJlc3MuXG4gICAgICovXG4gICAgZ2V0Q29udHJhY3RBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5jb250cmFjdF9hZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEZXBsb3llciBBZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBEZXBsb3llciBBZGRyZXNzLlxuICAgICAqL1xuICAgIGdldERlcGxveWVyQWRkcmVzcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsLmRlcGxveWVyX2FkZHJlc3MpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5kZXBsb3llcl9hZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUeXBlIG9mIHRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTbWFydCBDb250cmFjdCBUeXBlLlxuICAgICAqL1xuICAgIGdldFR5cGUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlNtYXJ0Q29udHJhY3RUeXBlLkVyYzIwOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlNtYXJ0Q29udHJhY3RUeXBlLkVSQzIwO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5TbWFydENvbnRyYWN0VHlwZS5FcmM3MjE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuU21hcnRDb250cmFjdFR5cGUuRVJDNzIxO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5TbWFydENvbnRyYWN0VHlwZS5FcmMxMTU1OlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlNtYXJ0Q29udHJhY3RUeXBlLkVSQzExNTU7XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlNtYXJ0Q29udHJhY3RUeXBlLkN1c3RvbTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5TbWFydENvbnRyYWN0VHlwZS5DVVNUT007XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzbWFydCBjb250cmFjdCB0eXBlOiAke3RoaXMubW9kZWwudHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBPcHRpb25zIG9mIHRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTbWFydCBDb250cmFjdCBPcHRpb25zLlxuICAgICAqL1xuICAgIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRXh0ZXJuYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbWFydENvbnRyYWN0IG9wdGlvbnMgY2Fubm90IGJlIHJldHVybmVkIGZvciBleHRlcm5hbCBTbWFydENvbnRyYWN0XCIpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5tb2RlbC5vcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5pc0VSQzIwKHRoaXMuZ2V0VHlwZSgpLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBvcHRpb25zLnN5bWJvbCxcbiAgICAgICAgICAgICAgICB0b3RhbFN1cHBseTogb3B0aW9ucy50b3RhbF9zdXBwbHksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNFUkM3MjEodGhpcy5nZXRUeXBlKCksIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IG9wdGlvbnMuc3ltYm9sLFxuICAgICAgICAgICAgICAgIGJhc2VVUkk6IG9wdGlvbnMuYmFzZV91cmksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNFUkMxMTU1KHRoaXMuZ2V0VHlwZSgpLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmk6IG9wdGlvbnMudXJpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEFCSSBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQUJJIGFzIGEgSlNPTi1lbmNvZGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBnZXRBYmkoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMubW9kZWwuYWJpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhbnNhY3Rpb24gb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IGRlcGxveW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRXh0ZXJuYWwpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odGhpcy5tb2RlbC50cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIHRoZSBTbWFydENvbnRyYWN0IGRlcGxveW1lbnQgd2l0aCB0aGUgcHJvdmlkZWQga2V5IGFuZCByZXR1cm5zIHRoZSBoZXggc2lnbmF0dXJlXG4gICAgICogcmVxdWlyZWQgZm9yIGJyb2FkY2FzdGluZyB0aGUgU21hcnRDb250cmFjdCBkZXBsb3ltZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gc2lnbiB0aGUgU21hcnRDb250cmFjdCBkZXBsb3ltZW50IHdpdGhcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4LWVuY29kZWQgc2lnbmVkIHBheWxvYWRcbiAgICAgKi9cbiAgICBhc3luYyBzaWduKGtleSkge1xuICAgICAgICBpZiAodGhpcy5pc0V4dGVybmFsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNpZ24gYW4gZXh0ZXJuYWwgU21hcnRDb250cmFjdFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb24oKS5zaWduKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byB1cGRhdGUgYSBzbWFydCBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hYmkgLSBUaGUgbmV3IEFCSSBvZiB0aGUgY29udHJhY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29udHJhY3ROYW1lIC0gVGhlIG5ldyBjb250cmFjdCBuYW1lLlxuICAgICAqIEByZXR1cm5zIFRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUoeyBhYmksIGNvbnRyYWN0TmFtZSB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnNtYXJ0Q29udHJhY3QudXBkYXRlU21hcnRDb250cmFjdCh0aGlzLmdldE5ldHdvcmtJZCgpLCB0aGlzLmdldENvbnRyYWN0QWRkcmVzcygpLCB7XG4gICAgICAgICAgICBhYmk6IEpTT04uc3RyaW5naWZ5KGFiaSksXG4gICAgICAgICAgICBjb250cmFjdF9uYW1lOiBjb250cmFjdE5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gU21hcnRDb250cmFjdC5mcm9tTW9kZWwocmVzcG9uc2UuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgdGhlIFNtYXJ0Q29udHJhY3QgZGVwbG95bWVudCB0byB0aGUgTmV0d29yay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTbWFydENvbnRyYWN0IG9iamVjdFxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gYnJvYWRjYXN0IGEgU21hcnRDb250cmFjdCBkZXBsb3ltZW50IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGJyb2FkY2FzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFeHRlcm5hbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBicm9hZGNhc3QgYW4gZXh0ZXJuYWwgU21hcnRDb250cmFjdFwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmdldFRyYW5zYWN0aW9uKCkuaXNTaWduZWQoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBicm9hZGNhc3QgdW5zaWduZWQgU21hcnRDb250cmFjdCBkZXBsb3ltZW50XCIpO1xuICAgICAgICBjb25zdCBkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHNpZ25lZF9wYXlsb2FkOiB0aGlzLmdldFRyYW5zYWN0aW9uKCkuZ2V0U2lnbmF0dXJlKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnNtYXJ0Q29udHJhY3QuZGVwbG95U21hcnRDb250cmFjdCh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0RGVwbG95ZXJBZGRyZXNzKCksIHRoaXMuZ2V0SWQoKSwgZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gU21hcnRDb250cmFjdC5mcm9tTW9kZWwocmVzcG9uc2UuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciB0aGUgU21hcnRDb250cmFjdCBkZXBsb3ltZW50IHRvIGJlIGNvbmZpcm1lZCBvbiB0aGUgTmV0d29yayBvciBmYWlsIG9uIGNoYWluLlxuICAgICAqIFdhaXRzIHVudGlsIHRoZSBTbWFydENvbnRyYWN0IGRlcGxveW1lbnQgaXMgY29tcGxldGVkIG9yIGZhaWxlZCBvbi1jaGFpbiBieSBwb2xsaW5nIGF0IHRoZSBnaXZlbiBpbnRlcnZhbC5cbiAgICAgKiBSYWlzZXMgYW4gZXJyb3IgaWYgdGhlIFNtYXJ0Q29udHJhY3QgZGVwbG95bWVudCB0YWtlcyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSB3YWl0IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmludGVydmFsU2Vjb25kcyAtIFRoZSBpbnRlcnZhbCB0byBjaGVjayB0aGUgc3RhdHVzIG9mIHRoZSBTbWFydENvbnRyYWN0IGRlcGxveW1lbnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dFNlY29uZHMgLSBUaGUgbWF4aW11bSB0aW1lIHRvIHdhaXQgZm9yIHRoZSBTbWFydENvbnRyYWN0IGRlcGxveW1lbnQgdG8gYmUgY29uZmlybWVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFNtYXJ0Q29udHJhY3Qgb2JqZWN0IGluIGEgdGVybWluYWwgc3RhdGUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBTbWFydENvbnRyYWN0IGRlcGxveW1lbnQgdGltZXMgb3V0LlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoeyBpbnRlcnZhbFNlY29uZHMgPSAwLjIsIHRpbWVvdXRTZWNvbmRzID0gMTAgfSA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLmlzRXh0ZXJuYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgd2FpdCBmb3IgYW4gZXh0ZXJuYWwgU21hcnRDb250cmFjdFwiKTtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgU21hcnRDb250cmFjdCBkZXBsb3ltZW50IGlzIGluIGEgdGVybWluYWwgc3RhdGUsIHJldHVybiB0aGUgU21hcnRDb250cmFjdC5cbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKS5nZXRTdGF0dXMoKTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEUgfHwgc3RhdHVzID09PSB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgKDAsIHV0aWxzXzEuZGVsYXkpKGludGVydmFsU2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlRpbWVvdXRFcnJvcihcIlNtYXJ0Q29udHJhY3QgZGVwbG95bWVudCB0aW1lZCBvdXRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIFNtYXJ0Q29udHJhY3QgbW9kZWwgd2l0aCB0aGUgbGF0ZXN0IGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBnZXQgYSBTbWFydENvbnRyYWN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbG9hZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFeHRlcm5hbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWxvYWQgYW4gZXh0ZXJuYWwgU21hcnRDb250cmFjdFwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnNtYXJ0Q29udHJhY3QuZ2V0U21hcnRDb250cmFjdCh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0RGVwbG95ZXJBZGRyZXNzKCksIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSByZXN1bHQ/LmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFNtYXJ0Q29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTbWFydENvbnRyYWN0LlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKGBTbWFydENvbnRyYWN0e2lkOiAnJHt0aGlzLmdldElkKCl9JywgbmV0d29ya0lkOiAnJHt0aGlzLmdldE5ldHdvcmtJZCgpfScsIGAgK1xuICAgICAgICAgICAgYGNvbnRyYWN0QWRkcmVzczogJyR7dGhpcy5nZXRDb250cmFjdEFkZHJlc3MoKX0nLCBkZXBsb3llckFkZHJlc3M6ICcke3RoaXMuZ2V0RGVwbG95ZXJBZGRyZXNzKCl9JywgYCArXG4gICAgICAgICAgICBgdHlwZTogJyR7dGhpcy5nZXRUeXBlKCl9J31gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHlwZSBndWFyZCBmb3IgY2hlY2tpbmcgaWYgdGhlIHNtYXJ0IGNvbnRyYWN0IGlzIGFuIEVSQzIwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc21hcnQgY29udHJhY3QgaXMgYW4gRVJDMjAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0VSQzIwKHR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IHR5cGVzXzEuU21hcnRDb250cmFjdFR5cGUuRVJDMjA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIGNoZWNraW5nIGlmIHRoZSBzbWFydCBjb250cmFjdCBpcyBhbiBFUkM3MjEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9mIHRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzbWFydCBjb250cmFjdCBpcyBhbiBFUkM3MjEsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0VSQzcyMSh0eXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0eXBlID09PSB0eXBlc18xLlNtYXJ0Q29udHJhY3RUeXBlLkVSQzcyMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHlwZSBndWFyZCBmb3IgY2hlY2tpbmcgaWYgdGhlIHNtYXJ0IGNvbnRyYWN0IGlzIGFuIEVSQzExNTUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9mIHRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzbWFydCBjb250cmFjdCBpcyBhbiBFUkMxMTU1LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNFUkMxMTU1KHR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IHR5cGVzXzEuU21hcnRDb250cmFjdFR5cGUuRVJDMTE1NTtcbiAgICB9XG59XG5leHBvcnRzLlNtYXJ0Q29udHJhY3QgPSBTbWFydENvbnRyYWN0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/sponsored_send.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/sponsored_send.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SponsoredSend = void 0;\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.commonjs/index.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\n/**\n * A representation of an onchain Sponsored Send.\n */\nclass SponsoredSend {\n    /**\n     * Sponsored Sends should be constructed via higher level abstractions like Transfer.\n     *\n     * @class\n     * @param model - The underlying Sponsored Send object.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the Keccak256 hash of the typed data. This payload must be signed\n     * by the sender to be used as an approval in the EIP-3009 transaction.\n     *\n     * @returns The Keccak256 hash of the typed data.\n     */\n    getTypedDataHash() {\n        return this.model.typed_data_hash;\n    }\n    /**\n     * Returns the signature of the typed data.\n     *\n     * @returns The hash of the typed data signature.\n     */\n    getSignature() {\n        return this.model.signature;\n    }\n    /**\n     * Signs the Sponsored Send with the provided key and returns the hex signature.\n     *\n     * @param key - The key to sign the Sponsored Send with\n     * @returns The hex-encoded signature\n     */\n    async sign(key) {\n        ethers_1.ethers.toBeArray;\n        const signature = key.signingKey.sign(ethers_1.ethers.getBytes(this.getTypedDataHash())).serialized;\n        this.model.signature = signature;\n        return signature;\n    }\n    /**\n     * Returns whether the Sponsored Send has been signed.\n     *\n     * @returns if the Sponsored Send has been signed.\n     */\n    isSigned() {\n        return !!this.getSignature();\n    }\n    /**\n     * Returns the Status of the Sponsored Send.\n     *\n     * @returns the Status of the Sponsored Send\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case types_1.SponsoredSendStatus.PENDING:\n                return types_1.SponsoredSendStatus.PENDING;\n            case types_1.SponsoredSendStatus.SIGNED:\n                return types_1.SponsoredSendStatus.SIGNED;\n            case types_1.SponsoredSendStatus.SUBMITTED:\n                return types_1.SponsoredSendStatus.SUBMITTED;\n            case types_1.SponsoredSendStatus.COMPLETE:\n                return types_1.SponsoredSendStatus.COMPLETE;\n            case types_1.SponsoredSendStatus.FAILED:\n                return types_1.SponsoredSendStatus.FAILED;\n            default:\n                undefined;\n        }\n    }\n    /**\n     * Returns whether the Sponsored Send is in a terminal State.\n     *\n     * @returns Whether the Sponsored Send is in a terminal State\n     */\n    isTerminalState() {\n        const status = this.getStatus();\n        if (!status)\n            return false;\n        return [types_1.SponsoredSendStatus.COMPLETE, types_1.SponsoredSendStatus.FAILED].includes(status);\n    }\n    /**\n     * Returns the Transaction Hash of the Sponsored Send.\n     *\n     * @returns The Transaction Hash\n     */\n    getTransactionHash() {\n        return this.model.transaction_hash;\n    }\n    /**\n     * Returns the link to the Sponsored Send on the blockchain explorer.\n     *\n     * @returns The link to the Sponsored Send on the blockchain explorer\n     */\n    getTransactionLink() {\n        return this.model.transaction_link;\n    }\n    /**\n     * Returns a string representation of the Sponsored Send.\n     *\n     * @returns A string representation of the Sponsored Send\n     */\n    toString() {\n        return `SponsoredSend { transactionHash: '${this.getTransactionHash()}', status: '${this.getStatus()}', typedDataHash: '${this.getTypedDataHash()}', signature: ${this.getSignature()}, transactionLink: ${this.getTransactionLink()} }`;\n    }\n}\nexports.SponsoredSend = SponsoredSend;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3Nwb25zb3JlZF9zZW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBUTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQiwwQkFBMEIsY0FBYyxpQkFBaUIscUJBQXFCLHdCQUF3QixnQkFBZ0Isb0JBQW9CLHFCQUFxQiw0QkFBNEI7QUFDL087QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3Nwb25zb3JlZF9zZW5kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TcG9uc29yZWRTZW5kID0gdm9pZCAwO1xuY29uc3QgZXRoZXJzXzEgPSByZXF1aXJlKFwiZXRoZXJzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9uY2hhaW4gU3BvbnNvcmVkIFNlbmQuXG4gKi9cbmNsYXNzIFNwb25zb3JlZFNlbmQge1xuICAgIC8qKlxuICAgICAqIFNwb25zb3JlZCBTZW5kcyBzaG91bGQgYmUgY29uc3RydWN0ZWQgdmlhIGhpZ2hlciBsZXZlbCBhYnN0cmFjdGlvbnMgbGlrZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSB1bmRlcmx5aW5nIFNwb25zb3JlZCBTZW5kIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1vZGVsIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBLZWNjYWsyNTYgaGFzaCBvZiB0aGUgdHlwZWQgZGF0YS4gVGhpcyBwYXlsb2FkIG11c3QgYmUgc2lnbmVkXG4gICAgICogYnkgdGhlIHNlbmRlciB0byBiZSB1c2VkIGFzIGFuIGFwcHJvdmFsIGluIHRoZSBFSVAtMzAwOSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBLZWNjYWsyNTYgaGFzaCBvZiB0aGUgdHlwZWQgZGF0YS5cbiAgICAgKi9cbiAgICBnZXRUeXBlZERhdGFIYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50eXBlZF9kYXRhX2hhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpZ25hdHVyZSBvZiB0aGUgdHlwZWQgZGF0YS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSB0eXBlZCBkYXRhIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBnZXRTaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnNpZ25hdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgdGhlIFNwb25zb3JlZCBTZW5kIHdpdGggdGhlIHByb3ZpZGVkIGtleSBhbmQgcmV0dXJucyB0aGUgaGV4IHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHNpZ24gdGhlIFNwb25zb3JlZCBTZW5kIHdpdGhcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4LWVuY29kZWQgc2lnbmF0dXJlXG4gICAgICovXG4gICAgYXN5bmMgc2lnbihrZXkpIHtcbiAgICAgICAgZXRoZXJzXzEuZXRoZXJzLnRvQmVBcnJheTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0ga2V5LnNpZ25pbmdLZXkuc2lnbihldGhlcnNfMS5ldGhlcnMuZ2V0Qnl0ZXModGhpcy5nZXRUeXBlZERhdGFIYXNoKCkpKS5zZXJpYWxpemVkO1xuICAgICAgICB0aGlzLm1vZGVsLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBTcG9uc29yZWQgU2VuZCBoYXMgYmVlbiBzaWduZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBpZiB0aGUgU3BvbnNvcmVkIFNlbmQgaGFzIGJlZW4gc2lnbmVkLlxuICAgICAqL1xuICAgIGlzU2lnbmVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldFNpZ25hdHVyZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTdGF0dXMgb2YgdGhlIFNwb25zb3JlZCBTZW5kLlxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIFN0YXR1cyBvZiB0aGUgU3BvbnNvcmVkIFNlbmRcbiAgICAgKi9cbiAgICBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLlBFTkRJTkc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5QRU5ESU5HO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuU0lHTkVEOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuU0lHTkVEO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuU1VCTUlUVEVEOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuU1VCTUlUVEVEO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuQ09NUExFVEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLkZBSUxFRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLkZBSUxFRDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgU3BvbnNvcmVkIFNlbmQgaXMgaW4gYSB0ZXJtaW5hbCBTdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIFNwb25zb3JlZCBTZW5kIGlzIGluIGEgdGVybWluYWwgU3RhdGVcbiAgICAgKi9cbiAgICBpc1Rlcm1pbmFsU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuZ2V0U3RhdHVzKCk7XG4gICAgICAgIGlmICghc3RhdHVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gW3R5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5DT01QTEVURSwgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLkZBSUxFRF0uaW5jbHVkZXMoc3RhdHVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhbnNhY3Rpb24gSGFzaCBvZiB0aGUgU3BvbnNvcmVkIFNlbmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVHJhbnNhY3Rpb24gSGFzaFxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwudHJhbnNhY3Rpb25faGFzaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGluayB0byB0aGUgU3BvbnNvcmVkIFNlbmQgb24gdGhlIGJsb2NrY2hhaW4gZXhwbG9yZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbGluayB0byB0aGUgU3BvbnNvcmVkIFNlbmQgb24gdGhlIGJsb2NrY2hhaW4gZXhwbG9yZXJcbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbkxpbmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnRyYW5zYWN0aW9uX2xpbms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFNwb25zb3JlZCBTZW5kLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFNwb25zb3JlZCBTZW5kXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgU3BvbnNvcmVkU2VuZCB7IHRyYW5zYWN0aW9uSGFzaDogJyR7dGhpcy5nZXRUcmFuc2FjdGlvbkhhc2goKX0nLCBzdGF0dXM6ICcke3RoaXMuZ2V0U3RhdHVzKCl9JywgdHlwZWREYXRhSGFzaDogJyR7dGhpcy5nZXRUeXBlZERhdGFIYXNoKCl9Jywgc2lnbmF0dXJlOiAke3RoaXMuZ2V0U2lnbmF0dXJlKCl9LCB0cmFuc2FjdGlvbkxpbms6ICR7dGhpcy5nZXRUcmFuc2FjdGlvbkxpbmsoKX0gfWA7XG4gICAgfVxufVxuZXhwb3J0cy5TcG9uc29yZWRTZW5kID0gU3BvbnNvcmVkU2VuZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/sponsored_send.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StakingBalance = void 0;\nconst balance_1 = __webpack_require__(/*! ./balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * A representation of the staking balance for a given asset on a specific date.\n */\nclass StakingBalance {\n    /**\n     * Creates the StakingBalance object.\n     *\n     * @param model - The underlying staking balance object.\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    /**\n     * Returns a list of StakingBalances for the provided network, asset, and address.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param addressId - The address ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @returns The staking balances.\n     */\n    static async list(networkId, assetId, addressId, startTime, endTime) {\n        const stakingBalances = [];\n        const queue = [\"\"];\n        while (queue.length > 0) {\n            const page = queue.shift();\n            const response = await coinbase_1.Coinbase.apiClients.stake.fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, 100, page?.length ? page : undefined);\n            response.data.data.forEach(stakingBalance => {\n                stakingBalances.push(new StakingBalance(stakingBalance));\n            });\n            if (response.data.has_more) {\n                if (response.data.next_page) {\n                    queue.push(response.data.next_page);\n                }\n            }\n        }\n        return stakingBalances;\n    }\n    /**\n     * Returns the bonded stake amount of the StakingBalance.\n     *\n     * @returns The Balance.\n     */\n    bondedStake() {\n        return balance_1.Balance.fromModel(this.model.bonded_stake);\n    }\n    /**\n     * Returns the unbonded stake amount of the StakingBalance.\n     *\n     * @returns The Balance.\n     */\n    unbondedBalance() {\n        return balance_1.Balance.fromModel(this.model.unbonded_balance);\n    }\n    /**\n     * Returns the participant type of the address.\n     *\n     * @returns The participant type.\n     */\n    participantType() {\n        return this.model.participant_type;\n    }\n    /**\n     * Returns the date of the StakingBalance.\n     *\n     * @returns The date.\n     */\n    date() {\n        return new Date(this.model.date);\n    }\n    /**\n     * Returns the onchain address of the StakingBalance.\n     *\n     * @returns The onchain address.\n     */\n    address() {\n        return this.model.address;\n    }\n    /**\n     * Print the Staking Balance as a string.\n     *\n     * @returns The string representation of the Staking Balance.\n     */\n    toString() {\n        return `StakingBalance { date: '${this.date().toISOString()}' address: '${this.address()}' bondedStake: '${this.bondedStake().amount} ${this.bondedStake().asset?.assetId?.toUpperCase()}' unbondedBalance: '${this.unbondedBalance().amount} ${this.unbondedBalance().asset?.assetId?.toUpperCase()}' participantType: '${this.participantType()}' }`;\n    }\n}\nexports.StakingBalance = StakingBalance;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3N0YWtpbmdfYmFsYW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsa0JBQWtCLG1CQUFPLENBQUMsdUZBQVc7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTLDBCQUEwQixjQUFjLGVBQWUsa0JBQWtCLDJCQUEyQixFQUFFLGlEQUFpRCxzQkFBc0IsK0JBQStCLEVBQUUscURBQXFELHNCQUFzQix1QkFBdUIsR0FBRztBQUM3VjtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2Uvc3Rha2luZ19iYWxhbmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdGFraW5nQmFsYW5jZSA9IHZvaWQgMDtcbmNvbnN0IGJhbGFuY2VfMSA9IHJlcXVpcmUoXCIuL2JhbGFuY2VcIik7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0YWtpbmcgYmFsYW5jZSBmb3IgYSBnaXZlbiBhc3NldCBvbiBhIHNwZWNpZmljIGRhdGUuXG4gKi9cbmNsYXNzIFN0YWtpbmdCYWxhbmNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBTdGFraW5nQmFsYW5jZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBzdGFraW5nIGJhbGFuY2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgU3Rha2luZ0JhbGFuY2VzIGZvciB0aGUgcHJvdmlkZWQgbmV0d29yaywgYXNzZXQsIGFuZCBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCAtIFRoZSBuZXR3b3JrIElELlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEBwYXJhbSBhZGRyZXNzSWQgLSBUaGUgYWRkcmVzcyBJRC5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIC0gVGhlIHN0YXJ0IHRpbWUuXG4gICAgICogQHBhcmFtIGVuZFRpbWUgLSBUaGUgZW5kIHRpbWUuXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtpbmcgYmFsYW5jZXMuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGxpc3QobmV0d29ya0lkLCBhc3NldElkLCBhZGRyZXNzSWQsIHN0YXJ0VGltZSwgZW5kVGltZSkge1xuICAgICAgICBjb25zdCBzdGFraW5nQmFsYW5jZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcXVldWUgPSBbXCJcIl07XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwYWdlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnN0YWtlLmZldGNoSGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcyhuZXR3b3JrSWQsIGFzc2V0SWQsIGFkZHJlc3NJZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCAxMDAsIHBhZ2U/Lmxlbmd0aCA/IHBhZ2UgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmVzcG9uc2UuZGF0YS5kYXRhLmZvckVhY2goc3Rha2luZ0JhbGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgIHN0YWtpbmdCYWxhbmNlcy5wdXNoKG5ldyBTdGFraW5nQmFsYW5jZShzdGFraW5nQmFsYW5jZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5oYXNfbW9yZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWtpbmdCYWxhbmNlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYm9uZGVkIHN0YWtlIGFtb3VudCBvZiB0aGUgU3Rha2luZ0JhbGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQmFsYW5jZS5cbiAgICAgKi9cbiAgICBib25kZWRTdGFrZSgpIHtcbiAgICAgICAgcmV0dXJuIGJhbGFuY2VfMS5CYWxhbmNlLmZyb21Nb2RlbCh0aGlzLm1vZGVsLmJvbmRlZF9zdGFrZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVuYm9uZGVkIHN0YWtlIGFtb3VudCBvZiB0aGUgU3Rha2luZ0JhbGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQmFsYW5jZS5cbiAgICAgKi9cbiAgICB1bmJvbmRlZEJhbGFuY2UoKSB7XG4gICAgICAgIHJldHVybiBiYWxhbmNlXzEuQmFsYW5jZS5mcm9tTW9kZWwodGhpcy5tb2RlbC51bmJvbmRlZF9iYWxhbmNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFydGljaXBhbnQgdHlwZSBvZiB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJ0aWNpcGFudCB0eXBlLlxuICAgICAqL1xuICAgIHBhcnRpY2lwYW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwucGFydGljaXBhbnRfdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0ZSBvZiB0aGUgU3Rha2luZ0JhbGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0ZS5cbiAgICAgKi9cbiAgICBkYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5tb2RlbC5kYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBTdGFraW5nQmFsYW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBvbmNoYWluIGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuYWRkcmVzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpbnQgdGhlIFN0YWtpbmcgQmFsYW5jZSBhcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFN0YWtpbmcgQmFsYW5jZS5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBTdGFraW5nQmFsYW5jZSB7IGRhdGU6ICcke3RoaXMuZGF0ZSgpLnRvSVNPU3RyaW5nKCl9JyBhZGRyZXNzOiAnJHt0aGlzLmFkZHJlc3MoKX0nIGJvbmRlZFN0YWtlOiAnJHt0aGlzLmJvbmRlZFN0YWtlKCkuYW1vdW50fSAke3RoaXMuYm9uZGVkU3Rha2UoKS5hc3NldD8uYXNzZXRJZD8udG9VcHBlckNhc2UoKX0nIHVuYm9uZGVkQmFsYW5jZTogJyR7dGhpcy51bmJvbmRlZEJhbGFuY2UoKS5hbW91bnR9ICR7dGhpcy51bmJvbmRlZEJhbGFuY2UoKS5hc3NldD8uYXNzZXRJZD8udG9VcHBlckNhc2UoKX0nIHBhcnRpY2lwYW50VHlwZTogJyR7dGhpcy5wYXJ0aWNpcGFudFR5cGUoKX0nIH1gO1xuICAgIH1cbn1cbmV4cG9ydHMuU3Rha2luZ0JhbGFuY2UgPSBTdGFraW5nQmFsYW5jZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StakingOperation = void 0;\nconst api_1 = __webpack_require__(/*! ../client/api */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\n/**\n * A representation of a staking operation (stake, unstake, claim stake, etc.). It\n * may have multiple steps with some being transactions to sign, and others to wait.\n */\nclass StakingOperation {\n    /**\n     * Creates a StakingOperation object.\n     *\n     * @class\n     * @param model - The staking operation response from the API call.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n        this.transactions = [];\n        this.loadTransactionsFromModel();\n    }\n    /**\n     * Get the staking operation for the given ID.\n     *\n     * @param networkId - The network ID.\n     * @param addressId - The address ID.\n     * @param id - The staking operation ID.\n     * @param walletId - The wallet ID of the staking operation.\n     * @throws {Error} If the wallet id is defined but empty.\n     *\n     * @returns The staking operation object.\n     */\n    static async fetch(networkId, addressId, id, walletId) {\n        if (walletId === undefined) {\n            const result = await coinbase_1.Coinbase.apiClients.stake.getExternalStakingOperation(networkId, addressId, id);\n            return new StakingOperation(result.data);\n        }\n        else if (walletId != undefined && walletId != \"\") {\n            const result = await coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation(walletId, addressId, id);\n            return new StakingOperation(result.data);\n        }\n        else {\n            throw new Error(\"Invalid wallet ID\");\n        }\n    }\n    /**\n     * Returns the Staking Operation ID.\n     *\n     * @returns The Staking Operation ID.\n     */\n    getID() {\n        return this.model.id;\n    }\n    /**\n     * Get the status of the staking operation.\n     *\n     * @returns The status of the staking operation.\n     */\n    getStatus() {\n        return this.model.status;\n    }\n    /**\n     * Returns the Wallet ID if it exists.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletID() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the Address ID.\n     *\n     * @returns The Address ID.\n     */\n    getAddressID() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the Network ID.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkID() {\n        return this.model.network_id;\n    }\n    /**\n     * Return a human-readable string representation of the StakingOperation object.\n     *\n     * @returns The string representation of the StakingOperation object.\n     */\n    toString() {\n        return `StakingOperation { id: ${this.getID()} status: ${this.getStatus()} network_id: ${this.getNetworkID()} address_id: ${this.getAddressID()} }`;\n    }\n    /**\n     * Returns whether the Staking operation is in a terminal State.\n     *\n     * @returns Whether the Staking operation is in a terminal State\n     */\n    isTerminalState() {\n        return this.isCompleteState() || this.isFailedState();\n    }\n    /**\n     * Returns whether the Staking operation is in a failed state.\n     *\n     * @returns Whether the Staking operation is in a failed state.\n     */\n    isFailedState() {\n        return this.getStatus() === api_1.StakingOperationStatusEnum.Failed;\n    }\n    /**\n     * Returns whether the Staking operation is in a complete state.\n     *\n     * @returns Whether the Staking operation is in a complete state.\n     */\n    isCompleteState() {\n        return this.getStatus() === api_1.StakingOperationStatusEnum.Complete;\n    }\n    /**\n     * Get the transactions associated with this staking operation.\n     *\n     * @returns The array of transactions.\n     */\n    getTransactions() {\n        return this.transactions;\n    }\n    /**\n     * Get signed voluntary exit messages for native eth unstaking\n     *\n     * @returns The signed voluntary exit messages for a native eth unstaking operation.\n     */\n    getSignedVoluntaryExitMessages() {\n        const signedVoluntaryExitMessages = [];\n        if (this.model.metadata) {\n            this.model.metadata.forEach(metadata => {\n                const decodedSignedVoluntaryExitMessage = atob(metadata.signed_voluntary_exit);\n                signedVoluntaryExitMessages.push(decodedSignedVoluntaryExitMessage);\n            });\n        }\n        return signedVoluntaryExitMessages;\n    }\n    /**\n     * Reloads the StakingOperation model with the latest data from the server.\n     * If the StakingOperation object was created by an ExternalAddress then it will\n     * not have a wallet ID.\n     *\n     * @throws {APIError} if the API request to get the StakingOperation fails.\n     * @throws {Error} if this function is called on a StakingOperation without a wallet ID.\n     */\n    async reload() {\n        if (this.getWalletID() === undefined) {\n            const result = await coinbase_1.Coinbase.apiClients.stake.getExternalStakingOperation(this.getNetworkID(), this.getAddressID(), this.getID());\n            this.model = result.data;\n        }\n        else if (this.getWalletID() != undefined && this.getWalletID() != \"\") {\n            const result = await coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation(this.getWalletID(), this.getAddressID(), this.getID());\n            this.model = result.data;\n        }\n        this.loadTransactionsFromModel();\n    }\n    /**\n     * Waits until the Staking Operation is completed or failed by polling its status at the given interval.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval at which to poll, in seconds\n     * @param options.timeoutSeconds - The maximum amount of time to wait for the StakingOperation to complete, in seconds\n     * @throws {Error} If the StakingOperation takes longer than the given timeout.\n     * @returns The completed StakingOperation object.\n     */\n    async wait({ intervalSeconds = 5, timeoutSeconds = 3600, } = {}) {\n        if (this.getWalletID() != undefined) {\n            throw new Error(\"cannot wait on staking operation for wallet address.\");\n        }\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            if (this.isTerminalState()) {\n                return this.model;\n            }\n            if (Date.now() - startTime > timeoutSeconds * 1000) {\n                throw new Error(\"Staking operation timed out\");\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new Error(\"Staking operation timed out\");\n    }\n    /**\n     * Sign the transactions in the StakingOperation object.\n     *\n     * @param key - The key used to sign the transactions.\n     */\n    async sign(key) {\n        for (const tx of this.transactions) {\n            if (!tx.isSigned()) {\n                await tx.sign(key);\n            }\n        }\n    }\n    /**\n     * loadTransactionsFromModel loads new unsigned transactions from the model into the transactions array.\n     * Note: For External Address model since tx signing and broadcast status happens by the end user and not our backend\n     * we need to be careful to not overwrite the transactions array with the response from the API. Ex: End user could have used\n     * stakingOperation.sign() method to sign the transactions, and we should not overwrite them with the response from the API.\n     * This however is ok to do so for the Wallet Address model since the transactions states are maintained by our backend.\n     * This method attempts to be safe for both address models, and only adds newly created unsigned transactions that are not\n     *  already in the transactions array.\n     */\n    loadTransactionsFromModel() {\n        // Only overwrite the transactions if the response is populated.\n        if (this.model.transactions && this.model.transactions.length > 0) {\n            // Create a set of existing unsigned payloads to avoid duplicates.\n            const existingUnsignedPayloads = new Set(this.transactions.map(tx => tx.getUnsignedPayload()));\n            // Add transactions that are not already in the transactions array.\n            this.model.transactions.forEach(transaction => {\n                if (!existingUnsignedPayloads.has(transaction.unsigned_payload)) {\n                    this.transactions.push(new transaction_1.Transaction(transaction));\n                }\n            });\n        }\n    }\n}\nexports.StakingOperation = StakingOperation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3N0YWtpbmdfb3BlcmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixjQUFjLG1CQUFPLENBQUMscUZBQWU7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWU7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTSxjQUFjLFVBQVUsa0JBQWtCLGNBQWMscUJBQXFCLGNBQWMsc0JBQXNCO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxpQkFBaUIsOENBQThDLElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9zdGFraW5nX29wZXJhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3Rha2luZ09wZXJhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIi4uL2NsaWVudC9hcGlcIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBzdGFraW5nIG9wZXJhdGlvbiAoc3Rha2UsIHVuc3Rha2UsIGNsYWltIHN0YWtlLCBldGMuKS4gSXRcbiAqIG1heSBoYXZlIG11bHRpcGxlIHN0ZXBzIHdpdGggc29tZSBiZWluZyB0cmFuc2FjdGlvbnMgdG8gc2lnbiwgYW5kIG90aGVycyB0byB3YWl0LlxuICovXG5jbGFzcyBTdGFraW5nT3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgU3Rha2luZ09wZXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgc3Rha2luZyBvcGVyYXRpb24gcmVzcG9uc2UgZnJvbSB0aGUgQVBJIGNhbGwuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlbCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5sb2FkVHJhbnNhY3Rpb25zRnJvbU1vZGVsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3Rha2luZyBvcGVyYXRpb24gZm9yIHRoZSBnaXZlbiBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgLSBUaGUgbmV0d29yayBJRC5cbiAgICAgKiBAcGFyYW0gYWRkcmVzc0lkIC0gVGhlIGFkZHJlc3MgSUQuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIHN0YWtpbmcgb3BlcmF0aW9uIElELlxuICAgICAqIEBwYXJhbSB3YWxsZXRJZCAtIFRoZSB3YWxsZXQgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgd2FsbGV0IGlkIGlzIGRlZmluZWQgYnV0IGVtcHR5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtpbmcgb3BlcmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZmV0Y2gobmV0d29ya0lkLCBhZGRyZXNzSWQsIGlkLCB3YWxsZXRJZCkge1xuICAgICAgICBpZiAod2FsbGV0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnN0YWtlLmdldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgaWQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFraW5nT3BlcmF0aW9uKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3YWxsZXRJZCAhPSB1bmRlZmluZWQgJiYgd2FsbGV0SWQgIT0gXCJcIikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndhbGxldFN0YWtlLmdldFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgaWQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFraW5nT3BlcmF0aW9uKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2FsbGV0IElEXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFN0YWtpbmcgT3BlcmF0aW9uIElELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFN0YWtpbmcgT3BlcmF0aW9uIElELlxuICAgICAqL1xuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGF0dXMgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0YXR1cyBvZiB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICovXG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zdGF0dXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFdhbGxldCBJRCBpZiBpdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgV2FsbGV0IElELlxuICAgICAqL1xuICAgIGdldFdhbGxldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC53YWxsZXRfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEFkZHJlc3MgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQWRkcmVzcyBJRC5cbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzSUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFkZHJlc3NfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5ldHdvcmsgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgTmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm5ldHdvcmtfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgU3Rha2luZ09wZXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTdGFraW5nT3BlcmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBTdGFraW5nT3BlcmF0aW9uIHsgaWQ6ICR7dGhpcy5nZXRJRCgpfSBzdGF0dXM6ICR7dGhpcy5nZXRTdGF0dXMoKX0gbmV0d29ya19pZDogJHt0aGlzLmdldE5ldHdvcmtJRCgpfSBhZGRyZXNzX2lkOiAke3RoaXMuZ2V0QWRkcmVzc0lEKCl9IH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFN0YWtpbmcgb3BlcmF0aW9uIGlzIGluIGEgdGVybWluYWwgU3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBTdGFraW5nIG9wZXJhdGlvbiBpcyBpbiBhIHRlcm1pbmFsIFN0YXRlXG4gICAgICovXG4gICAgaXNUZXJtaW5hbFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NvbXBsZXRlU3RhdGUoKSB8fCB0aGlzLmlzRmFpbGVkU3RhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBTdGFraW5nIG9wZXJhdGlvbiBpcyBpbiBhIGZhaWxlZCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIFN0YWtpbmcgb3BlcmF0aW9uIGlzIGluIGEgZmFpbGVkIHN0YXRlLlxuICAgICAqL1xuICAgIGlzRmFpbGVkU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXR1cygpID09PSBhcGlfMS5TdGFraW5nT3BlcmF0aW9uU3RhdHVzRW51bS5GYWlsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgU3Rha2luZyBvcGVyYXRpb24gaXMgaW4gYSBjb21wbGV0ZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIFN0YWtpbmcgb3BlcmF0aW9uIGlzIGluIGEgY29tcGxldGUgc3RhdGUuXG4gICAgICovXG4gICAgaXNDb21wbGV0ZVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0dXMoKSA9PT0gYXBpXzEuU3Rha2luZ09wZXJhdGlvblN0YXR1c0VudW0uQ29tcGxldGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHJhbnNhY3Rpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGFycmF5IG9mIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNpZ25lZCB2b2x1bnRhcnkgZXhpdCBtZXNzYWdlcyBmb3IgbmF0aXZlIGV0aCB1bnN0YWtpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduZWQgdm9sdW50YXJ5IGV4aXQgbWVzc2FnZXMgZm9yIGEgbmF0aXZlIGV0aCB1bnN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGdldFNpZ25lZFZvbHVudGFyeUV4aXRNZXNzYWdlcygpIHtcbiAgICAgICAgY29uc3Qgc2lnbmVkVm9sdW50YXJ5RXhpdE1lc3NhZ2VzID0gW107XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLm1ldGFkYXRhLmZvckVhY2gobWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZWRTaWduZWRWb2x1bnRhcnlFeGl0TWVzc2FnZSA9IGF0b2IobWV0YWRhdGEuc2lnbmVkX3ZvbHVudGFyeV9leGl0KTtcbiAgICAgICAgICAgICAgICBzaWduZWRWb2x1bnRhcnlFeGl0TWVzc2FnZXMucHVzaChkZWNvZGVkU2lnbmVkVm9sdW50YXJ5RXhpdE1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25lZFZvbHVudGFyeUV4aXRNZXNzYWdlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsb2FkcyB0aGUgU3Rha2luZ09wZXJhdGlvbiBtb2RlbCB3aXRoIHRoZSBsYXRlc3QgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogSWYgdGhlIFN0YWtpbmdPcGVyYXRpb24gb2JqZWN0IHdhcyBjcmVhdGVkIGJ5IGFuIEV4dGVybmFsQWRkcmVzcyB0aGVuIGl0IHdpbGxcbiAgICAgKiBub3QgaGF2ZSBhIHdhbGxldCBJRC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gZ2V0IHRoZSBTdGFraW5nT3BlcmF0aW9uIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhIFN0YWtpbmdPcGVyYXRpb24gd2l0aG91dCBhIHdhbGxldCBJRC5cbiAgICAgKi9cbiAgICBhc3luYyByZWxvYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFdhbGxldElEKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnN0YWtlLmdldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbih0aGlzLmdldE5ldHdvcmtJRCgpLCB0aGlzLmdldEFkZHJlc3NJRCgpLCB0aGlzLmdldElEKCkpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IHJlc3VsdC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZ2V0V2FsbGV0SUQoKSAhPSB1bmRlZmluZWQgJiYgdGhpcy5nZXRXYWxsZXRJRCgpICE9IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53YWxsZXRTdGFrZS5nZXRTdGFraW5nT3BlcmF0aW9uKHRoaXMuZ2V0V2FsbGV0SUQoKSwgdGhpcy5nZXRBZGRyZXNzSUQoKSwgdGhpcy5nZXRJRCgpKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRUcmFuc2FjdGlvbnNGcm9tTW9kZWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgdW50aWwgdGhlIFN0YWtpbmcgT3BlcmF0aW9uIGlzIGNvbXBsZXRlZCBvciBmYWlsZWQgYnkgcG9sbGluZyBpdHMgc3RhdHVzIGF0IHRoZSBnaXZlbiBpbnRlcnZhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSB3YWl0IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmludGVydmFsU2Vjb25kcyAtIFRoZSBpbnRlcnZhbCBhdCB3aGljaCB0byBwb2xsLCBpbiBzZWNvbmRzXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dFNlY29uZHMgLSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciB0aGUgU3Rha2luZ09wZXJhdGlvbiB0byBjb21wbGV0ZSwgaW4gc2Vjb25kc1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgU3Rha2luZ09wZXJhdGlvbiB0YWtlcyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcGxldGVkIFN0YWtpbmdPcGVyYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoeyBpbnRlcnZhbFNlY29uZHMgPSA1LCB0aW1lb3V0U2Vjb25kcyA9IDM2MDAsIH0gPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5nZXRXYWxsZXRJRCgpICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHdhaXQgb24gc3Rha2luZyBvcGVyYXRpb24gZm9yIHdhbGxldCBhZGRyZXNzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA8IHRpbWVvdXRTZWNvbmRzICogMTAwMCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVGVybWluYWxTdGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+IHRpbWVvdXRTZWNvbmRzICogMTAwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YWtpbmcgb3BlcmF0aW9uIHRpbWVkIG91dFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgwLCB1dGlsc18xLmRlbGF5KShpbnRlcnZhbFNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YWtpbmcgb3BlcmF0aW9uIHRpbWVkIG91dFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbiB0aGUgdHJhbnNhY3Rpb25zIGluIHRoZSBTdGFraW5nT3BlcmF0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHVzZWQgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ24oa2V5KSB7XG4gICAgICAgIGZvciAoY29uc3QgdHggb2YgdGhpcy50cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghdHguaXNTaWduZWQoKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHR4LnNpZ24oa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBsb2FkVHJhbnNhY3Rpb25zRnJvbU1vZGVsIGxvYWRzIG5ldyB1bnNpZ25lZCB0cmFuc2FjdGlvbnMgZnJvbSB0aGUgbW9kZWwgaW50byB0aGUgdHJhbnNhY3Rpb25zIGFycmF5LlxuICAgICAqIE5vdGU6IEZvciBFeHRlcm5hbCBBZGRyZXNzIG1vZGVsIHNpbmNlIHR4IHNpZ25pbmcgYW5kIGJyb2FkY2FzdCBzdGF0dXMgaGFwcGVucyBieSB0aGUgZW5kIHVzZXIgYW5kIG5vdCBvdXIgYmFja2VuZFxuICAgICAqIHdlIG5lZWQgdG8gYmUgY2FyZWZ1bCB0byBub3Qgb3ZlcndyaXRlIHRoZSB0cmFuc2FjdGlvbnMgYXJyYXkgd2l0aCB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLiBFeDogRW5kIHVzZXIgY291bGQgaGF2ZSB1c2VkXG4gICAgICogc3Rha2luZ09wZXJhdGlvbi5zaWduKCkgbWV0aG9kIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9ucywgYW5kIHdlIHNob3VsZCBub3Qgb3ZlcndyaXRlIHRoZW0gd2l0aCB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqIFRoaXMgaG93ZXZlciBpcyBvayB0byBkbyBzbyBmb3IgdGhlIFdhbGxldCBBZGRyZXNzIG1vZGVsIHNpbmNlIHRoZSB0cmFuc2FjdGlvbnMgc3RhdGVzIGFyZSBtYWludGFpbmVkIGJ5IG91ciBiYWNrZW5kLlxuICAgICAqIFRoaXMgbWV0aG9kIGF0dGVtcHRzIHRvIGJlIHNhZmUgZm9yIGJvdGggYWRkcmVzcyBtb2RlbHMsIGFuZCBvbmx5IGFkZHMgbmV3bHkgY3JlYXRlZCB1bnNpZ25lZCB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgbm90XG4gICAgICogIGFscmVhZHkgaW4gdGhlIHRyYW5zYWN0aW9ucyBhcnJheS5cbiAgICAgKi9cbiAgICBsb2FkVHJhbnNhY3Rpb25zRnJvbU1vZGVsKCkge1xuICAgICAgICAvLyBPbmx5IG92ZXJ3cml0ZSB0aGUgdHJhbnNhY3Rpb25zIGlmIHRoZSByZXNwb25zZSBpcyBwb3B1bGF0ZWQuXG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnRyYW5zYWN0aW9ucyAmJiB0aGlzLm1vZGVsLnRyYW5zYWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgZXhpc3RpbmcgdW5zaWduZWQgcGF5bG9hZHMgdG8gYXZvaWQgZHVwbGljYXRlcy5cbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVW5zaWduZWRQYXlsb2FkcyA9IG5ldyBTZXQodGhpcy50cmFuc2FjdGlvbnMubWFwKHR4ID0+IHR4LmdldFVuc2lnbmVkUGF5bG9hZCgpKSk7XG4gICAgICAgICAgICAvLyBBZGQgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIG5vdCBhbHJlYWR5IGluIHRoZSB0cmFuc2FjdGlvbnMgYXJyYXkuXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnRyYW5zYWN0aW9ucy5mb3JFYWNoKHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nVW5zaWduZWRQYXlsb2Fkcy5oYXModHJhbnNhY3Rpb24udW5zaWduZWRfcGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMucHVzaChuZXcgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdGFraW5nT3BlcmF0aW9uID0gU3Rha2luZ09wZXJhdGlvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StakingReward = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\n/**\n * A representation of a staking reward earned on a network for a given asset.\n */\nclass StakingReward {\n    /**\n     * Creates the StakingReward object.\n     *\n     * @param model - The underlying staking reward object.\n     * @param asset - The asset for the staking reward.\n     * @param format - The format to return the rewards in. (usd, native). Defaults to usd.\n     */\n    constructor(model, asset, format) {\n        this.model = model;\n        this.asset = asset;\n        this.format = format;\n    }\n    /**\n     * Returns a list of StakingRewards for the provided network, asset, and addresses.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param addressIds - The address ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @param format - The format to return the rewards in. (usd, native). Defaults to usd.\n     * @returns The staking rewards.\n     */\n    static async list(networkId, assetId, addressIds, startTime, endTime, format = types_1.StakingRewardFormat.USD) {\n        const stakingRewards = [];\n        const queue = [\"\"];\n        while (queue.length > 0) {\n            const page = queue.shift();\n            const request = {\n                network_id: coinbase_1.Coinbase.normalizeNetwork(networkId),\n                asset_id: assetId,\n                address_ids: addressIds,\n                start_time: startTime,\n                end_time: endTime,\n                format: format,\n            };\n            const response = await coinbase_1.Coinbase.apiClients.stake.fetchStakingRewards(request, 100, page?.length ? page : undefined);\n            const asset = await asset_1.Asset.fetch(networkId, assetId);\n            response.data.data.forEach(stakingReward => {\n                stakingRewards.push(new StakingReward(stakingReward, asset, format));\n            });\n            if (response.data.has_more) {\n                if (response.data.next_page) {\n                    queue.push(response.data.next_page);\n                }\n            }\n        }\n        return stakingRewards;\n    }\n    /**\n     * Returns the amount of the StakingReward.\n     *\n     * @returns The amount.\n     */\n    amount() {\n        if (this.model.amount == \"\")\n            return 0;\n        if (this.format == types_1.StakingRewardFormat.USD) {\n            return new decimal_js_1.default(this.model.amount).div(new decimal_js_1.default(\"100\"));\n        }\n        return this.asset.fromAtomicAmount(new decimal_js_1.default(this.model.amount)).toNumber();\n    }\n    /**\n     * Returns the date of the StakingReward.\n     *\n     * @returns The date.\n     */\n    date() {\n        return new Date(this.model.date);\n    }\n    /**\n     * Returns the onchain address of the StakingReward.\n     *\n     * @returns The onchain address.\n     */\n    addressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the USD value of the StakingReward.\n     *\n     * @returns The USD value.\n     */\n    usdValue() {\n        return new decimal_js_1.default(this.model.usd_value.amount).div(new decimal_js_1.default(\"100\"));\n    }\n    /**\n     * Returns the conversion price of the StakingReward in USD.\n     *\n     * @returns The conversion price.\n     */\n    conversionPrice() {\n        return new decimal_js_1.default(this.model.usd_value.conversion_price);\n    }\n    /**\n     * Returns the time of calculating the conversion price.\n     *\n     * @returns The conversion time.\n     */\n    conversionTime() {\n        return new Date(this.model.usd_value.conversion_time);\n    }\n    /**\n     * Print the Staking Reward as a string.\n     *\n     * @returns The string representation of the Staking Reward.\n     */\n    toString() {\n        return `StakingReward { date: '${this.date().toISOString()}' address: '${this.addressId()}' amount: '${this.amount().toString()}' usd_value: '${this.usdValue().toString()}' conversion_price: '${this.conversionPrice().toString()}' conversion_time: '${this.conversionTime().toISOString()}' }`;\n    }\n}\nexports.StakingReward = StakingReward;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3N0YWtpbmdfcmV3YXJkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLHFDQUFxQyxtQkFBTyxDQUFDLDhEQUFZO0FBQ3pELG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUywwQkFBMEIsY0FBYyxpQkFBaUIsYUFBYSx5QkFBeUIsZ0JBQWdCLDJCQUEyQix1QkFBdUIsa0NBQWtDLHNCQUFzQixvQ0FBb0MsR0FBRztBQUN6UztBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2Uvc3Rha2luZ19yZXdhcmQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YWtpbmdSZXdhcmQgPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlY2ltYWwuanNcIikpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuY29uc3QgYXNzZXRfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0XCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc3Rha2luZyByZXdhcmQgZWFybmVkIG9uIGEgbmV0d29yayBmb3IgYSBnaXZlbiBhc3NldC5cbiAqL1xuY2xhc3MgU3Rha2luZ1Jld2FyZCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgU3Rha2luZ1Jld2FyZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBzdGFraW5nIHJld2FyZCBvYmplY3QuXG4gICAgICogQHBhcmFtIGFzc2V0IC0gVGhlIGFzc2V0IGZvciB0aGUgc3Rha2luZyByZXdhcmQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgdG8gcmV0dXJuIHRoZSByZXdhcmRzIGluLiAodXNkLCBuYXRpdmUpLiBEZWZhdWx0cyB0byB1c2QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwsIGFzc2V0LCBmb3JtYXQpIHtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLmFzc2V0ID0gYXNzZXQ7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBTdGFraW5nUmV3YXJkcyBmb3IgdGhlIHByb3ZpZGVkIG5ldHdvcmssIGFzc2V0LCBhbmQgYWRkcmVzc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCAtIFRoZSBuZXR3b3JrIElELlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEBwYXJhbSBhZGRyZXNzSWRzIC0gVGhlIGFkZHJlc3MgSUQuXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZSAtIFRoZSBzdGFydCB0aW1lLlxuICAgICAqIEBwYXJhbSBlbmRUaW1lIC0gVGhlIGVuZCB0aW1lLlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHRvIHJldHVybiB0aGUgcmV3YXJkcyBpbi4gKHVzZCwgbmF0aXZlKS4gRGVmYXVsdHMgdG8gdXNkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIHJld2FyZHMuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGxpc3QobmV0d29ya0lkLCBhc3NldElkLCBhZGRyZXNzSWRzLCBzdGFydFRpbWUsIGVuZFRpbWUsIGZvcm1hdCA9IHR5cGVzXzEuU3Rha2luZ1Jld2FyZEZvcm1hdC5VU0QpIHtcbiAgICAgICAgY29uc3Qgc3Rha2luZ1Jld2FyZHMgPSBbXTtcbiAgICAgICAgY29uc3QgcXVldWUgPSBbXCJcIl07XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwYWdlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgbmV0d29ya19pZDogY29pbmJhc2VfMS5Db2luYmFzZS5ub3JtYWxpemVOZXR3b3JrKG5ldHdvcmtJZCksXG4gICAgICAgICAgICAgICAgYXNzZXRfaWQ6IGFzc2V0SWQsXG4gICAgICAgICAgICAgICAgYWRkcmVzc19pZHM6IGFkZHJlc3NJZHMsXG4gICAgICAgICAgICAgICAgc3RhcnRfdGltZTogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGVuZF90aW1lOiBlbmRUaW1lLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnN0YWtlLmZldGNoU3Rha2luZ1Jld2FyZHMocmVxdWVzdCwgMTAwLCBwYWdlPy5sZW5ndGggPyBwYWdlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0ID0gYXdhaXQgYXNzZXRfMS5Bc3NldC5mZXRjaChuZXR3b3JrSWQsIGFzc2V0SWQpO1xuICAgICAgICAgICAgcmVzcG9uc2UuZGF0YS5kYXRhLmZvckVhY2goc3Rha2luZ1Jld2FyZCA9PiB7XG4gICAgICAgICAgICAgICAgc3Rha2luZ1Jld2FyZHMucHVzaChuZXcgU3Rha2luZ1Jld2FyZChzdGFraW5nUmV3YXJkLCBhc3NldCwgZm9ybWF0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLmhhc19tb3JlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Rha2luZ1Jld2FyZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiB0aGUgU3Rha2luZ1Jld2FyZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhbW91bnQuXG4gICAgICovXG4gICAgYW1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5hbW91bnQgPT0gXCJcIilcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBpZiAodGhpcy5mb3JtYXQgPT0gdHlwZXNfMS5TdGFraW5nUmV3YXJkRm9ybWF0LlVTRCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdCh0aGlzLm1vZGVsLmFtb3VudCkuZGl2KG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdChcIjEwMFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXQuZnJvbUF0b21pY0Ftb3VudChuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQodGhpcy5tb2RlbC5hbW91bnQpKS50b051bWJlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRlIG9mIHRoZSBTdGFraW5nUmV3YXJkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGRhdGUuXG4gICAgICovXG4gICAgZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMubW9kZWwuZGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgU3Rha2luZ1Jld2FyZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBvbmNoYWluIGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5hZGRyZXNzX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBVU0QgdmFsdWUgb2YgdGhlIFN0YWtpbmdSZXdhcmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVVNEIHZhbHVlLlxuICAgICAqL1xuICAgIHVzZFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gbmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KHRoaXMubW9kZWwudXNkX3ZhbHVlLmFtb3VudCkuZGl2KG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdChcIjEwMFwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnZlcnNpb24gcHJpY2Ugb2YgdGhlIFN0YWtpbmdSZXdhcmQgaW4gVVNELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNvbnZlcnNpb24gcHJpY2UuXG4gICAgICovXG4gICAgY29udmVyc2lvblByaWNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KHRoaXMubW9kZWwudXNkX3ZhbHVlLmNvbnZlcnNpb25fcHJpY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0aW1lIG9mIGNhbGN1bGF0aW5nIHRoZSBjb252ZXJzaW9uIHByaWNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNvbnZlcnNpb24gdGltZS5cbiAgICAgKi9cbiAgICBjb252ZXJzaW9uVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMubW9kZWwudXNkX3ZhbHVlLmNvbnZlcnNpb25fdGltZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW50IHRoZSBTdGFraW5nIFJld2FyZCBhcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFN0YWtpbmcgUmV3YXJkLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFN0YWtpbmdSZXdhcmQgeyBkYXRlOiAnJHt0aGlzLmRhdGUoKS50b0lTT1N0cmluZygpfScgYWRkcmVzczogJyR7dGhpcy5hZGRyZXNzSWQoKX0nIGFtb3VudDogJyR7dGhpcy5hbW91bnQoKS50b1N0cmluZygpfScgdXNkX3ZhbHVlOiAnJHt0aGlzLnVzZFZhbHVlKCkudG9TdHJpbmcoKX0nIGNvbnZlcnNpb25fcHJpY2U6ICcke3RoaXMuY29udmVyc2lvblByaWNlKCkudG9TdHJpbmcoKX0nIGNvbnZlcnNpb25fdGltZTogJyR7dGhpcy5jb252ZXJzaW9uVGltZSgpLnRvSVNPU3RyaW5nKCl9JyB9YDtcbiAgICB9XG59XG5leHBvcnRzLlN0YWtpbmdSZXdhcmQgPSBTdGFraW5nUmV3YXJkO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js":
/*!********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Trade = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\n/**\n * A representation of a Trade, which trades an amount of an Asset to another Asset on a Network.\n * The fee is assumed to be paid in the native Asset of the Network.\n */\nclass Trade {\n    /**\n     * Trades should be created through Wallet.trade or Address.trade.\n     *\n     * @class\n     * @param model - The underlying Trade object.\n     * @throws {Error} - If the Trade model is empty.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Trade model cannot be empty\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the Trade ID.\n     *\n     * @returns The Trade ID.\n     */\n    getId() {\n        return this.model.trade_id;\n    }\n    /**\n     * Returns the Network ID of the Trade.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the Wallet ID of the Trade.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the Address ID of the Trade.\n     *\n     * @returns The Address ID.\n     */\n    getAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the From Asset ID of the Trade.\n     *\n     * @returns The From Asset ID.\n     */\n    getFromAssetId() {\n        return this.model.from_asset.asset_id;\n    }\n    /**\n     * Returns the amount of the from asset for the Trade.\n     *\n     * @returns The amount of the from asset.\n     */\n    getFromAmount() {\n        const amount = new decimal_js_1.Decimal(this.model.from_amount);\n        return amount.div(decimal_js_1.Decimal.pow(10, this.model.from_asset.decimals));\n    }\n    /**\n     * Returns the To Asset ID of the Trade.\n     *\n     * @returns The To Asset ID.\n     */\n    getToAssetId() {\n        return this.model.to_asset.asset_id;\n    }\n    /**\n     * Returns the amount of the to asset for the Trade.\n     *\n     * @returns The amount of the to asset.\n     */\n    getToAmount() {\n        const amount = new decimal_js_1.Decimal(this.model.to_amount);\n        return amount.div(decimal_js_1.Decimal.pow(10, this.model.to_asset.decimals));\n    }\n    /**\n     * Returns the Trade transaction.\n     *\n     * @returns The Trade transaction.\n     */\n    getTransaction() {\n        this.transaction = new transaction_1.Transaction(this.model.transaction);\n        return this.transaction;\n    }\n    /**\n     * Returns the approve transaction if it exists.\n     *\n     * @returns The approve transaction.\n     */\n    getApproveTransaction() {\n        if (!this.approveTransaction && this.model.approve_transaction) {\n            this.approveTransaction = new transaction_1.Transaction(this.model.approve_transaction);\n        }\n        return this.approveTransaction;\n    }\n    /**\n     * Signs the Trade with the provided key.\n     * This signs the transfer transaction and will sign the approval transaction if present.\n     *\n     * @param key - The key to sign the Transfer with\n     */\n    async sign(key) {\n        if (this.getApproveTransaction()) {\n            await this.getApproveTransaction().sign(key);\n        }\n        await this.getTransaction().sign(key);\n    }\n    /**\n     * Broadcasts the Trade to the Network.\n     *\n     * @returns The Trade object\n     * @throws {APIError} if the API request to broadcast a Trade fails.\n     */\n    async broadcast() {\n        const tx = this.getTransaction();\n        const approveTx = this.getApproveTransaction();\n        if (!tx.isSigned()) {\n            throw new errors_1.NotSignedError(\"Cannot broadcast Trade with unsigned transaction\");\n        }\n        if (approveTx && !approveTx.isSigned()) {\n            throw new errors_1.NotSignedError(\"Cannot broadcast Trade with unsigned approve transaction\");\n        }\n        const response = await coinbase_1.Coinbase.apiClients.trade.broadcastTrade(this.getWalletId(), tx.fromAddressId(), this.getId(), {\n            signed_payload: tx.getSignature(),\n            approve_transaction_signed_payload: approveTx ? approveTx.getSignature() : undefined,\n        });\n        this.resetModel(response.data);\n        return this;\n    }\n    /**\n     * Returns the status of the Trade.\n     *\n     * @returns The status.\n     */\n    getStatus() {\n        return this.getTransaction()?.getStatus();\n    }\n    /**\n     * Waits until the Trade is completed or failed by polling the Network at the given interval.\n     * Raises an error if the Trade takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval at which to poll the Network, in seconds\n     * @param options.timeoutSeconds - The maximum amount of time to wait for the Trade to complete, in seconds\n     * @throws {Error} If the Trade takes longer than the given timeout.\n     * @throws {APIError} If the request fails.\n     * @returns The completed Trade object.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10 } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            if (this.getTransaction().isTerminalState()) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"Trade timed out\");\n    }\n    /**\n     * Reloads the Trade model with the latest version from the server side.\n     *\n     * @returns The most recent version of Trade from the server.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.trade.getTrade(this.getWalletId(), this.getAddressId(), this.getId());\n        return this.resetModel(result?.data);\n    }\n    /**\n     * Returns a String representation of the Trade.\n     *\n     * @returns A String representation of the Trade.\n     */\n    toString() {\n        return (`Trade { transfer_id: '${this.getId()}', network_id: '${this.getNetworkId()}', ` +\n            `address_id: '${this.getAddressId()}', from_asset_id: '${this.getFromAssetId()}', ` +\n            `to_asset_id: '${this.getToAssetId()}', from_amount: '${this.getFromAmount()}', ` +\n            `to_amount: '${this.getToAmount()}', status: '${this.getStatus()}' }`);\n    }\n    /**\n     * Resets the trade model with the specified data from the server.\n     *\n     * @param model - The Trade model\n     * @returns The updated Trade object\n     */\n    resetModel(model) {\n        this.model = model;\n        this.transaction = new transaction_1.Transaction(this.model.transaction);\n        this.approveTransaction = this.model.approve_transaction\n            ? new transaction_1.Transaction(this.model.approve_transaction)\n            : undefined;\n        return this;\n    }\n}\nexports.Trade = Trade;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3RyYWRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixxQkFBcUIsbUJBQU8sQ0FBQyw4REFBWTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQywrRkFBZTtBQUM3QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBNkMsSUFBSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0IsYUFBYSxrQkFBa0Isb0JBQW9CO0FBQzVGLDRCQUE0QixvQkFBb0IscUJBQXFCLHNCQUFzQjtBQUMzRiw2QkFBNkIsb0JBQW9CLG1CQUFtQixxQkFBcUI7QUFDekYsMkJBQTJCLG1CQUFtQixjQUFjLGlCQUFpQixHQUFHO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3RyYWRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFkZSA9IHZvaWQgMDtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBUcmFkZSwgd2hpY2ggdHJhZGVzIGFuIGFtb3VudCBvZiBhbiBBc3NldCB0byBhbm90aGVyIEFzc2V0IG9uIGEgTmV0d29yay5cbiAqIFRoZSBmZWUgaXMgYXNzdW1lZCB0byBiZSBwYWlkIGluIHRoZSBuYXRpdmUgQXNzZXQgb2YgdGhlIE5ldHdvcmsuXG4gKi9cbmNsYXNzIFRyYWRlIHtcbiAgICAvKipcbiAgICAgKiBUcmFkZXMgc2hvdWxkIGJlIGNyZWF0ZWQgdGhyb3VnaCBXYWxsZXQudHJhZGUgb3IgQWRkcmVzcy50cmFkZS5cbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSB1bmRlcmx5aW5nIFRyYWRlIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUgVHJhZGUgbW9kZWwgaXMgZW1wdHkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhZGUgbW9kZWwgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhZGUgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVHJhZGUgSUQuXG4gICAgICovXG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnRyYWRlX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBOZXR3b3JrIElEIG9mIHRoZSBUcmFkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBOZXR3b3JrIElELlxuICAgICAqL1xuICAgIGdldE5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwubmV0d29ya19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgV2FsbGV0IElEIG9mIHRoZSBUcmFkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBXYWxsZXQgSUQuXG4gICAgICovXG4gICAgZ2V0V2FsbGV0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLndhbGxldF9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQWRkcmVzcyBJRCBvZiB0aGUgVHJhZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQWRkcmVzcyBJRC5cbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFkZHJlc3NfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEZyb20gQXNzZXQgSUQgb2YgdGhlIFRyYWRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEZyb20gQXNzZXQgSUQuXG4gICAgICovXG4gICAgZ2V0RnJvbUFzc2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmZyb21fYXNzZXQuYXNzZXRfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiB0aGUgZnJvbSBhc3NldCBmb3IgdGhlIFRyYWRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGFtb3VudCBvZiB0aGUgZnJvbSBhc3NldC5cbiAgICAgKi9cbiAgICBnZXRGcm9tQW1vdW50KCkge1xuICAgICAgICBjb25zdCBhbW91bnQgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwodGhpcy5tb2RlbC5mcm9tX2Ftb3VudCk7XG4gICAgICAgIHJldHVybiBhbW91bnQuZGl2KGRlY2ltYWxfanNfMS5EZWNpbWFsLnBvdygxMCwgdGhpcy5tb2RlbC5mcm9tX2Fzc2V0LmRlY2ltYWxzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRvIEFzc2V0IElEIG9mIHRoZSBUcmFkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBUbyBBc3NldCBJRC5cbiAgICAgKi9cbiAgICBnZXRUb0Fzc2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnRvX2Fzc2V0LmFzc2V0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2YgdGhlIHRvIGFzc2V0IGZvciB0aGUgVHJhZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYW1vdW50IG9mIHRoZSB0byBhc3NldC5cbiAgICAgKi9cbiAgICBnZXRUb0Ftb3VudCgpIHtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKHRoaXMubW9kZWwudG9fYW1vdW50KTtcbiAgICAgICAgcmV0dXJuIGFtb3VudC5kaXYoZGVjaW1hbF9qc18xLkRlY2ltYWwucG93KDEwLCB0aGlzLm1vZGVsLnRvX2Fzc2V0LmRlY2ltYWxzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRyYWRlIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYWRlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uID0gbmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odGhpcy5tb2RlbC50cmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcHByb3ZlIHRyYW5zYWN0aW9uIGlmIGl0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhcHByb3ZlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldEFwcHJvdmVUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFwcHJvdmVUcmFuc2FjdGlvbiAmJiB0aGlzLm1vZGVsLmFwcHJvdmVfdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYXBwcm92ZVRyYW5zYWN0aW9uID0gbmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odGhpcy5tb2RlbC5hcHByb3ZlX3RyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcHByb3ZlVHJhbnNhY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIHRoZSBUcmFkZSB3aXRoIHRoZSBwcm92aWRlZCBrZXkuXG4gICAgICogVGhpcyBzaWducyB0aGUgdHJhbnNmZXIgdHJhbnNhY3Rpb24gYW5kIHdpbGwgc2lnbiB0aGUgYXBwcm92YWwgdHJhbnNhY3Rpb24gaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHNpZ24gdGhlIFRyYW5zZmVyIHdpdGhcbiAgICAgKi9cbiAgICBhc3luYyBzaWduKGtleSkge1xuICAgICAgICBpZiAodGhpcy5nZXRBcHByb3ZlVHJhbnNhY3Rpb24oKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRBcHByb3ZlVHJhbnNhY3Rpb24oKS5zaWduKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvbigpLnNpZ24oa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0cyB0aGUgVHJhZGUgdG8gdGhlIE5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVHJhZGUgb2JqZWN0XG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBicm9hZGNhc3QgYSBUcmFkZSBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBicm9hZGNhc3QoKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy5nZXRUcmFuc2FjdGlvbigpO1xuICAgICAgICBjb25zdCBhcHByb3ZlVHggPSB0aGlzLmdldEFwcHJvdmVUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAoIXR4LmlzU2lnbmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RTaWduZWRFcnJvcihcIkNhbm5vdCBicm9hZGNhc3QgVHJhZGUgd2l0aCB1bnNpZ25lZCB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXBwcm92ZVR4ICYmICFhcHByb3ZlVHguaXNTaWduZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdFNpZ25lZEVycm9yKFwiQ2Fubm90IGJyb2FkY2FzdCBUcmFkZSB3aXRoIHVuc2lnbmVkIGFwcHJvdmUgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMudHJhZGUuYnJvYWRjYXN0VHJhZGUodGhpcy5nZXRXYWxsZXRJZCgpLCB0eC5mcm9tQWRkcmVzc0lkKCksIHRoaXMuZ2V0SWQoKSwge1xuICAgICAgICAgICAgc2lnbmVkX3BheWxvYWQ6IHR4LmdldFNpZ25hdHVyZSgpLFxuICAgICAgICAgICAgYXBwcm92ZV90cmFuc2FjdGlvbl9zaWduZWRfcGF5bG9hZDogYXBwcm92ZVR4ID8gYXBwcm92ZVR4LmdldFNpZ25hdHVyZSgpIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXNldE1vZGVsKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdHVzIG9mIHRoZSBUcmFkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGF0dXMuXG4gICAgICovXG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvbigpPy5nZXRTdGF0dXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgdW50aWwgdGhlIFRyYWRlIGlzIGNvbXBsZXRlZCBvciBmYWlsZWQgYnkgcG9sbGluZyB0aGUgTmV0d29yayBhdCB0aGUgZ2l2ZW4gaW50ZXJ2YWwuXG4gICAgICogUmFpc2VzIGFuIGVycm9yIGlmIHRoZSBUcmFkZSB0YWtlcyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSB3YWl0IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmludGVydmFsU2Vjb25kcyAtIFRoZSBpbnRlcnZhbCBhdCB3aGljaCB0byBwb2xsIHRoZSBOZXR3b3JrLCBpbiBzZWNvbmRzXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dFNlY29uZHMgLSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciB0aGUgVHJhZGUgdG8gY29tcGxldGUsIGluIHNlY29uZHNcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIFRyYWRlIHRha2VzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiB0aW1lb3V0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcGxldGVkIFRyYWRlIG9iamVjdC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KHsgaW50ZXJ2YWxTZWNvbmRzID0gMC4yLCB0aW1lb3V0U2Vjb25kcyA9IDEwIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA8IHRpbWVvdXRTZWNvbmRzICogMTAwMCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldFRyYW5zYWN0aW9uKCkuaXNUZXJtaW5hbFN0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgwLCB1dGlsc18xLmRlbGF5KShpbnRlcnZhbFNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5UaW1lb3V0RXJyb3IoXCJUcmFkZSB0aW1lZCBvdXRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIFRyYWRlIG1vZGVsIHdpdGggdGhlIGxhdGVzdCB2ZXJzaW9uIGZyb20gdGhlIHNlcnZlciBzaWRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG1vc3QgcmVjZW50IHZlcnNpb24gb2YgVHJhZGUgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbG9hZCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnRyYWRlLmdldFRyYWRlKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRBZGRyZXNzSWQoKSwgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzZXRNb2RlbChyZXN1bHQ/LmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUcmFkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUcmFkZS5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChgVHJhZGUgeyB0cmFuc2Zlcl9pZDogJyR7dGhpcy5nZXRJZCgpfScsIG5ldHdvcmtfaWQ6ICcke3RoaXMuZ2V0TmV0d29ya0lkKCl9JywgYCArXG4gICAgICAgICAgICBgYWRkcmVzc19pZDogJyR7dGhpcy5nZXRBZGRyZXNzSWQoKX0nLCBmcm9tX2Fzc2V0X2lkOiAnJHt0aGlzLmdldEZyb21Bc3NldElkKCl9JywgYCArXG4gICAgICAgICAgICBgdG9fYXNzZXRfaWQ6ICcke3RoaXMuZ2V0VG9Bc3NldElkKCl9JywgZnJvbV9hbW91bnQ6ICcke3RoaXMuZ2V0RnJvbUFtb3VudCgpfScsIGAgK1xuICAgICAgICAgICAgYHRvX2Ftb3VudDogJyR7dGhpcy5nZXRUb0Ftb3VudCgpfScsIHN0YXR1czogJyR7dGhpcy5nZXRTdGF0dXMoKX0nIH1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSB0cmFkZSBtb2RlbCB3aXRoIHRoZSBzcGVjaWZpZWQgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgVHJhZGUgbW9kZWxcbiAgICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBUcmFkZSBvYmplY3RcbiAgICAgKi9cbiAgICByZXNldE1vZGVsKG1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IG5ldyB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKHRoaXMubW9kZWwudHJhbnNhY3Rpb24pO1xuICAgICAgICB0aGlzLmFwcHJvdmVUcmFuc2FjdGlvbiA9IHRoaXMubW9kZWwuYXBwcm92ZV90cmFuc2FjdGlvblxuICAgICAgICAgICAgPyBuZXcgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbih0aGlzLm1vZGVsLmFwcHJvdmVfdHJhbnNhY3Rpb24pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFkZSA9IFRyYWRlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transaction = void 0;\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.commonjs/index.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\n/**\n * A representation of an onchain Transaction.\n */\nclass Transaction {\n    /**\n     * Transactions should be constructed via higher level abstractions like Trade or Transfer.\n     *\n     * @class\n     * @param model - The underlying Transaction object.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the Unsigned Payload of the Transaction.\n     *\n     * @returns The Unsigned Payload\n     */\n    getUnsignedPayload() {\n        return this.model.unsigned_payload;\n    }\n    /**\n     * Returns the Signed Payload of the Transaction.\n     *\n     * @returns The Signed Payload\n     */\n    getSignedPayload() {\n        return this.model.signed_payload;\n    }\n    /**\n     * Returns the Transaction Hash of the Transaction.\n     *\n     * @returns The Transaction Hash\n     */\n    getTransactionHash() {\n        return this.model.transaction_hash;\n    }\n    /**\n     * Returns the Status of the Transaction.\n     *\n     * @returns The Status\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case types_1.TransactionStatus.PENDING:\n                return types_1.TransactionStatus.PENDING;\n            case types_1.TransactionStatus.BROADCAST:\n                return types_1.TransactionStatus.BROADCAST;\n            case types_1.TransactionStatus.SIGNED:\n                return types_1.TransactionStatus.SIGNED;\n            case types_1.TransactionStatus.COMPLETE:\n                return types_1.TransactionStatus.COMPLETE;\n            case types_1.TransactionStatus.FAILED:\n                return types_1.TransactionStatus.FAILED;\n            default:\n                return types_1.TransactionStatus.UNSPECIFIED;\n        }\n    }\n    /**\n     * Returns whether the Transaction is in a terminal State.\n     *\n     * @returns Whether the Transaction is in a terminal State\n     */\n    isTerminalState() {\n        const status = this.getStatus();\n        return [types_1.TransactionStatus.COMPLETE, types_1.TransactionStatus.FAILED].includes(status);\n    }\n    /**\n     * Returns the From Address ID for the Transaction.\n     *\n     * @returns The From Address ID\n     */\n    fromAddressId() {\n        return this.model.from_address_id;\n    }\n    /**\n     * Returns the To Address ID for the Transaction if it's available.\n     *\n     * @returns The To Address ID\n     */\n    toAddressId() {\n        return this.model.to_address_id;\n    }\n    /**\n     * Returns the Block Height where the Transaction is recorded.\n     *\n     * @returns The Block Height\n     */\n    blockHeight() {\n        return this.model.block_height;\n    }\n    /**\n     * Returns the Block Hash where the Transaction is recorded.\n     *\n     * @returns The Block Hash\n     */\n    blockHash() {\n        return this.model.block_hash;\n    }\n    /**\n     * Returns the Content of the Transaction.\n     *\n     * @returns The transaction content\n     */\n    content() {\n        return this.model.content;\n    }\n    /**\n     * Returns the link to the Transaction on the blockchain explorer.\n     *\n     * @returns The link to the Transaction on the blockchain explorer\n     */\n    getTransactionLink() {\n        return this.model.transaction_link;\n    }\n    /**\n     * Returns the Network ID of the Transaction.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the underlying raw transaction.\n     *\n     * @throws {InvalidUnsignedPayload} If the Unsigned Payload is invalid.\n     * @returns The ethers.js Transaction object\n     */\n    rawTransaction() {\n        if (this.raw) {\n            return this.raw;\n        }\n        const parsedPayload = (0, utils_1.parseUnsignedPayload)(this.getUnsignedPayload());\n        const transaction = new ethers_1.ethers.Transaction();\n        transaction.chainId = BigInt(parsedPayload.chainId);\n        transaction.nonce = BigInt(parsedPayload.nonce);\n        transaction.maxPriorityFeePerGas = BigInt(parsedPayload.maxPriorityFeePerGas);\n        transaction.maxFeePerGas = BigInt(parsedPayload.maxFeePerGas);\n        // TODO: Handle multiple currencies.\n        transaction.gasLimit = BigInt(parsedPayload.gas);\n        transaction.to = parsedPayload.to;\n        transaction.value = BigInt(parsedPayload.value);\n        transaction.data = parsedPayload.input;\n        this.raw = transaction;\n        return this.raw;\n    }\n    /**\n     * Signs the Transaction with the provided key and returns the hex signing payload.\n     *\n     * @param key - The key to sign the transaction with\n     * @returns The hex-encoded signed payload\n     */\n    async sign(key) {\n        const signedPayload = await key.signTransaction(this.rawTransaction());\n        this.model.signed_payload = signedPayload;\n        // Removes the '0x' prefix as required by the API.\n        return signedPayload.slice(2);\n    }\n    /**\n     * Returns the Signed Payload of the Transaction.\n     *\n     * @returns The Signed Payload\n     */\n    getSignature() {\n        return this.getSignedPayload()?.slice(2);\n    }\n    /**\n     * Returns whether the transaction has been signed.\n     *\n     * @returns if the transaction has been signed.\n     */\n    isSigned() {\n        return !!this.getSignature();\n    }\n    /**\n     * Returns a string representation of the Transaction.\n     *\n     * @returns A string representation of the Transaction.\n     */\n    toString() {\n        return `Transaction { transactionHash: '${this.getTransactionHash()}', status: '${this.getStatus()}', unsignedPayload: '${this.getUnsignedPayload()}', signedPayload: ${this.getSignedPayload()}, transactionLink: ${this.getTransactionLink()} }`;\n    }\n}\nexports.Transaction = Transaction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBUTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0IsMEJBQTBCLGNBQWMsaUJBQWlCLHVCQUF1QiwwQkFBMEIsb0JBQW9CLHdCQUF3QixxQkFBcUIsNEJBQTRCO0FBQ3pQO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS90cmFuc2FjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNhY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBldGhlcnNfMSA9IHJlcXVpcmUoXCJldGhlcnNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYW4gb25jaGFpbiBUcmFuc2FjdGlvbi5cbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRyYW5zYWN0aW9ucyBzaG91bGQgYmUgY29uc3RydWN0ZWQgdmlhIGhpZ2hlciBsZXZlbCBhYnN0cmFjdGlvbnMgbGlrZSBUcmFkZSBvciBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSB1bmRlcmx5aW5nIFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1vZGVsIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBVbnNpZ25lZCBQYXlsb2FkIG9mIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBVbnNpZ25lZCBQYXlsb2FkXG4gICAgICovXG4gICAgZ2V0VW5zaWduZWRQYXlsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC51bnNpZ25lZF9wYXlsb2FkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTaWduZWQgUGF5bG9hZCBvZiB0aGUgVHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgU2lnbmVkIFBheWxvYWRcbiAgICAgKi9cbiAgICBnZXRTaWduZWRQYXlsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zaWduZWRfcGF5bG9hZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhbnNhY3Rpb24gSGFzaCBvZiB0aGUgVHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVHJhbnNhY3Rpb24gSGFzaFxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwudHJhbnNhY3Rpb25faGFzaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU3RhdHVzIG9mIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTdGF0dXNcbiAgICAgKi9cbiAgICBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5QRU5ESU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLlBFTkRJTkc7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuQlJPQURDQVNUOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkJST0FEQ0FTVDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5TSUdORUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuU0lHTkVEO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkZBSUxFRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5GQUlMRUQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLlVOU1BFQ0lGSUVEO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgVHJhbnNhY3Rpb24gaXMgaW4gYSB0ZXJtaW5hbCBTdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIFRyYW5zYWN0aW9uIGlzIGluIGEgdGVybWluYWwgU3RhdGVcbiAgICAgKi9cbiAgICBpc1Rlcm1pbmFsU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuZ2V0U3RhdHVzKCk7XG4gICAgICAgIHJldHVybiBbdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURSwgdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5GQUlMRURdLmluY2x1ZGVzKHN0YXR1cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEZyb20gQWRkcmVzcyBJRCBmb3IgdGhlIFRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEZyb20gQWRkcmVzcyBJRFxuICAgICAqL1xuICAgIGZyb21BZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmZyb21fYWRkcmVzc19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVG8gQWRkcmVzcyBJRCBmb3IgdGhlIFRyYW5zYWN0aW9uIGlmIGl0J3MgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRvIEFkZHJlc3MgSURcbiAgICAgKi9cbiAgICB0b0FkZHJlc3NJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwudG9fYWRkcmVzc19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQmxvY2sgSGVpZ2h0IHdoZXJlIHRoZSBUcmFuc2FjdGlvbiBpcyByZWNvcmRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBCbG9jayBIZWlnaHRcbiAgICAgKi9cbiAgICBibG9ja0hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuYmxvY2tfaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBCbG9jayBIYXNoIHdoZXJlIHRoZSBUcmFuc2FjdGlvbiBpcyByZWNvcmRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBCbG9jayBIYXNoXG4gICAgICovXG4gICAgYmxvY2tIYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5ibG9ja19oYXNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBDb250ZW50IG9mIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiBjb250ZW50XG4gICAgICovXG4gICAgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY29udGVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGluayB0byB0aGUgVHJhbnNhY3Rpb24gb24gdGhlIGJsb2NrY2hhaW4gZXhwbG9yZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbGluayB0byB0aGUgVHJhbnNhY3Rpb24gb24gdGhlIGJsb2NrY2hhaW4gZXhwbG9yZXJcbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbkxpbmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnRyYW5zYWN0aW9uX2xpbms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5ldHdvcmsgSUQgb2YgdGhlIFRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIE5ldHdvcmsgSUQuXG4gICAgICovXG4gICAgZ2V0TmV0d29ya0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5uZXR3b3JrX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHJhdyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRVbnNpZ25lZFBheWxvYWR9IElmIHRoZSBVbnNpZ25lZCBQYXlsb2FkIGlzIGludmFsaWQuXG4gICAgICogQHJldHVybnMgVGhlIGV0aGVycy5qcyBUcmFuc2FjdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICByYXdUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucmF3KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYXc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkUGF5bG9hZCA9ICgwLCB1dGlsc18xLnBhcnNlVW5zaWduZWRQYXlsb2FkKSh0aGlzLmdldFVuc2lnbmVkUGF5bG9hZCgpKTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgZXRoZXJzXzEuZXRoZXJzLlRyYW5zYWN0aW9uKCk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmNoYWluSWQgPSBCaWdJbnQocGFyc2VkUGF5bG9hZC5jaGFpbklkKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ubm9uY2UgPSBCaWdJbnQocGFyc2VkUGF5bG9hZC5ub25jZSk7XG4gICAgICAgIHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnSW50KHBhcnNlZFBheWxvYWQubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMgPSBCaWdJbnQocGFyc2VkUGF5bG9hZC5tYXhGZWVQZXJHYXMpO1xuICAgICAgICAvLyBUT0RPOiBIYW5kbGUgbXVsdGlwbGUgY3VycmVuY2llcy5cbiAgICAgICAgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPSBCaWdJbnQocGFyc2VkUGF5bG9hZC5nYXMpO1xuICAgICAgICB0cmFuc2FjdGlvbi50byA9IHBhcnNlZFBheWxvYWQudG87XG4gICAgICAgIHRyYW5zYWN0aW9uLnZhbHVlID0gQmlnSW50KHBhcnNlZFBheWxvYWQudmFsdWUpO1xuICAgICAgICB0cmFuc2FjdGlvbi5kYXRhID0gcGFyc2VkUGF5bG9hZC5pbnB1dDtcbiAgICAgICAgdGhpcy5yYXcgPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyB0aGUgVHJhbnNhY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQga2V5IGFuZCByZXR1cm5zIHRoZSBoZXggc2lnbmluZyBwYXlsb2FkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb24gd2l0aFxuICAgICAqIEByZXR1cm5zIFRoZSBoZXgtZW5jb2RlZCBzaWduZWQgcGF5bG9hZFxuICAgICAqL1xuICAgIGFzeW5jIHNpZ24oa2V5KSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZFBheWxvYWQgPSBhd2FpdCBrZXkuc2lnblRyYW5zYWN0aW9uKHRoaXMucmF3VHJhbnNhY3Rpb24oKSk7XG4gICAgICAgIHRoaXMubW9kZWwuc2lnbmVkX3BheWxvYWQgPSBzaWduZWRQYXlsb2FkO1xuICAgICAgICAvLyBSZW1vdmVzIHRoZSAnMHgnIHByZWZpeCBhcyByZXF1aXJlZCBieSB0aGUgQVBJLlxuICAgICAgICByZXR1cm4gc2lnbmVkUGF5bG9hZC5zbGljZSgyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU2lnbmVkIFBheWxvYWQgb2YgdGhlIFRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFNpZ25lZCBQYXlsb2FkXG4gICAgICovXG4gICAgZ2V0U2lnbmF0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTaWduZWRQYXlsb2FkKCk/LnNsaWNlKDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIHNpZ25lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBzaWduZWQuXG4gICAgICovXG4gICAgaXNTaWduZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0U2lnbmF0dXJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFRyYW5zYWN0aW9uIHsgdHJhbnNhY3Rpb25IYXNoOiAnJHt0aGlzLmdldFRyYW5zYWN0aW9uSGFzaCgpfScsIHN0YXR1czogJyR7dGhpcy5nZXRTdGF0dXMoKX0nLCB1bnNpZ25lZFBheWxvYWQ6ICcke3RoaXMuZ2V0VW5zaWduZWRQYXlsb2FkKCl9Jywgc2lnbmVkUGF5bG9hZDogJHt0aGlzLmdldFNpZ25lZFBheWxvYWQoKX0sIHRyYW5zYWN0aW9uTGluazogJHt0aGlzLmdldFRyYW5zYWN0aW9uTGluaygpfSB9YDtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transfer = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst sponsored_send_1 = __webpack_require__(/*! ./sponsored_send */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/sponsored_send.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/**\n * A representation of a Transfer, which moves an Amount of an Asset from\n * a user-controlled Wallet to another Address. The fee is assumed to be paid\n * in the native Asset of the Network.\n */\nclass Transfer {\n    /**\n     * Private constructor to prevent direct instantiation outside of the factory methods.\n     *\n     * @ignore\n     * @param transferModel - The Transfer model.\n     * @hideconstructor\n     */\n    constructor(transferModel) {\n        if (!transferModel) {\n            throw new Error(\"Transfer model cannot be empty\");\n        }\n        this.model = transferModel;\n    }\n    /**\n     * Converts a TransferModel into a Transfer object.\n     *\n     * @param transferModel - The Transfer model object.\n     * @returns The Transfer object.\n     */\n    static fromModel(transferModel) {\n        return new Transfer(transferModel);\n    }\n    /**\n     * Returns the ID of the Transfer.\n     *\n     * @returns The Transfer ID.\n     */\n    getId() {\n        return this.model.transfer_id;\n    }\n    /**\n     * Returns the Network ID of the Transfer.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the Wallet ID of the Transfer.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the From Address ID of the Transfer.\n     *\n     * @returns The From Address ID.\n     */\n    getFromAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the Destination Address ID of the Transfer.\n     *\n     * @returns The Destination Address ID.\n     */\n    getDestinationAddressId() {\n        return this.model.destination;\n    }\n    /**\n     * Returns the Asset ID of the Transfer.\n     *\n     * @returns The Asset ID.\n     */\n    getAssetId() {\n        return this.model.asset_id;\n    }\n    /**\n     * Returns the Amount of the Transfer.\n     *\n     * @returns The Amount of the Asset.\n     */\n    getAmount() {\n        const amount = new decimal_js_1.Decimal(this.model.amount);\n        return amount.dividedBy(new decimal_js_1.Decimal(10).pow(this.model.asset.decimals));\n    }\n    /**\n     * Returns the Transaction Hash of the Transfer.\n     *\n     * @returns The Transaction Hash as a Hex string, or undefined if not yet available.\n     */\n    getTransactionHash() {\n        return this.getSendTransactionDelegate()?.getTransactionHash();\n    }\n    /**\n     * Returns the Transaction of the Transfer.\n     *\n     * @returns The ethers.js Transaction object.\n     * @throws (InvalidUnsignedPayload) If the Unsigned Payload is invalid.\n     */\n    getRawTransaction() {\n        if (!this.getTransaction())\n            return undefined;\n        return this.getTransaction().rawTransaction();\n    }\n    /**\n     * Signs the Transfer with the provided key and returns the hex signature\n     * required for broadcasting the Transfer.\n     *\n     * @param key - The key to sign the Transfer with\n     * @returns The hex-encoded signed payload\n     */\n    async sign(key) {\n        return this.getSendTransactionDelegate().sign(key);\n    }\n    /**\n     * Returns the Status of the Transfer.\n     *\n     * @returns The Status of the Transfer.\n     */\n    getStatus() {\n        switch (this.getSendTransactionDelegate().getStatus()) {\n            case types_1.TransactionStatus.PENDING:\n                return types_1.TransferStatus.PENDING;\n            case types_1.SponsoredSendStatus.PENDING:\n                return types_1.TransferStatus.PENDING;\n            case types_1.SponsoredSendStatus.SIGNED:\n                return types_1.TransferStatus.PENDING;\n            case types_1.TransactionStatus.BROADCAST:\n                return types_1.TransferStatus.BROADCAST;\n            case types_1.SponsoredSendStatus.SUBMITTED:\n                return types_1.TransferStatus.BROADCAST;\n            case types_1.TransactionStatus.COMPLETE:\n                return types_1.TransferStatus.COMPLETE;\n            case types_1.SponsoredSendStatus.COMPLETE:\n                return types_1.TransferStatus.COMPLETE;\n            case types_1.TransactionStatus.FAILED:\n                return types_1.TransferStatus.FAILED;\n            case types_1.SponsoredSendStatus.FAILED:\n                return types_1.TransferStatus.FAILED;\n            default:\n                return undefined;\n        }\n    }\n    /**\n     * Returns the Transaction of the Transfer.\n     *\n     * @returns The Transaction\n     */\n    getTransaction() {\n        if (!this.model.transaction)\n            return undefined;\n        return new transaction_1.Transaction(this.model.transaction);\n    }\n    /**\n     * Returns the Sponsored Send of the Transfer.\n     *\n     * @returns The Sponsored Send\n     */\n    getSponsoredSend() {\n        if (!this.model.sponsored_send)\n            return undefined;\n        return new sponsored_send_1.SponsoredSend(this.model.sponsored_send);\n    }\n    /**\n     * Returns the Send Transaction Delegate of the Transfer.\n     *\n     * @returns Either the Transaction or the Sponsored Send\n     */\n    getSendTransactionDelegate() {\n        return !this.getTransaction() ? this.getSponsoredSend() : this.getTransaction();\n    }\n    /**\n     * Returns the link to the Transaction on the blockchain explorer.\n     *\n     * @returns The link to the Transaction on the blockchain explorer.\n     */\n    getTransactionLink() {\n        return this.getSendTransactionDelegate()?.getTransactionLink();\n    }\n    /**\n     * Broadcasts the Transfer to the Network.\n     *\n     * @returns The Transfer object\n     * @throws {APIError} if the API request to broadcast a Transfer fails.\n     */\n    async broadcast() {\n        if (!this.getSendTransactionDelegate()?.isSigned())\n            throw new Error(\"Cannot broadcast unsigned Transfer\");\n        const broadcastTransferRequest = {\n            signed_payload: this.getSendTransactionDelegate().getSignature(),\n        };\n        const response = await coinbase_1.Coinbase.apiClients.transfer.broadcastTransfer(this.getWalletId(), this.getFromAddressId(), this.getId(), broadcastTransferRequest);\n        return Transfer.fromModel(response.data);\n    }\n    /**\n     * Waits for the Transfer to be confirmed on the Network or fail on chain.\n     * Waits until the Transfer is completed or failed on-chain by polling at the given interval.\n     * Raises an error if the Trade takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the Transfer.\n     * @param options.timeoutSeconds - The maximum time to wait for the Transfer to be confirmed.\n     *\n     * @returns The Transfer object in a terminal state.\n     * @throws {Error} if the Transfer times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10 } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the Transfer is in a terminal state, return the Transfer.\n            const status = this.getStatus();\n            if (status === types_1.TransferStatus.COMPLETE || status === types_1.TransferStatus.FAILED) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"Transfer timed out\");\n    }\n    /**\n     * Reloads the Transfer model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a Transfer fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.transfer.getTransfer(this.getWalletId(), this.getFromAddressId(), this.getId());\n        this.model = result?.data;\n    }\n    /**\n     * Returns a string representation of the Transfer.\n     *\n     * @returns The string representation of the Transfer.\n     */\n    toString() {\n        return (`Transfer{transferId: '${this.getId()}', networkId: '${this.getNetworkId()}', ` +\n            `fromAddressId: '${this.getFromAddressId()}', destinationAddressId: '${this.getDestinationAddressId()}', ` +\n            `assetId: '${this.getAssetId()}', amount: '${this.getAmount()}', transactionHash: '${this.getTransactionHash()}', ` +\n            `transactionLink: '${this.getTransactionLink()}', status: '${this.getStatus()}'}`);\n    }\n}\nexports.Transfer = Transfer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3RyYW5zZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixxQkFBcUIsbUJBQU8sQ0FBQyw4REFBWTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxzQkFBc0IsbUJBQU8sQ0FBQywrRkFBZTtBQUM3Qyx5QkFBeUIsbUJBQU8sQ0FBQyxxR0FBa0I7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsaUJBQWlCLDZDQUE2QyxJQUFJO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxhQUFhLGlCQUFpQixvQkFBb0I7QUFDM0YsK0JBQStCLHdCQUF3Qiw0QkFBNEIsK0JBQStCO0FBQ2xILHlCQUF5QixrQkFBa0IsY0FBYyxpQkFBaUIsdUJBQXVCLDBCQUEwQjtBQUMzSCxpQ0FBaUMsMEJBQTBCLGNBQWMsaUJBQWlCLEVBQUU7QUFDNUY7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3RyYW5zZmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFuc2ZlciA9IHZvaWQgMDtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuY29uc3Qgc3BvbnNvcmVkX3NlbmRfMSA9IHJlcXVpcmUoXCIuL3Nwb25zb3JlZF9zZW5kXCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBUcmFuc2Zlciwgd2hpY2ggbW92ZXMgYW4gQW1vdW50IG9mIGFuIEFzc2V0IGZyb21cbiAqIGEgdXNlci1jb250cm9sbGVkIFdhbGxldCB0byBhbm90aGVyIEFkZHJlc3MuIFRoZSBmZWUgaXMgYXNzdW1lZCB0byBiZSBwYWlkXG4gKiBpbiB0aGUgbmF0aXZlIEFzc2V0IG9mIHRoZSBOZXR3b3JrLlxuICovXG5jbGFzcyBUcmFuc2ZlciB7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IGRpcmVjdCBpbnN0YW50aWF0aW9uIG91dHNpZGUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJNb2RlbCAtIFRoZSBUcmFuc2ZlciBtb2RlbC5cbiAgICAgKiBAaGlkZWNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHJhbnNmZXJNb2RlbCkge1xuICAgICAgICBpZiAoIXRyYW5zZmVyTW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zZmVyIG1vZGVsIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsID0gdHJhbnNmZXJNb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBUcmFuc2Zlck1vZGVsIGludG8gYSBUcmFuc2ZlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJNb2RlbCAtIFRoZSBUcmFuc2ZlciBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zZmVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU1vZGVsKHRyYW5zZmVyTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zlcih0cmFuc2Zlck1vZGVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zZmVyIElELlxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50cmFuc2Zlcl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTmV0d29yayBJRCBvZiB0aGUgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgTmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm5ldHdvcmtfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFdhbGxldCBJRCBvZiB0aGUgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgV2FsbGV0IElELlxuICAgICAqL1xuICAgIGdldFdhbGxldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC53YWxsZXRfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEZyb20gQWRkcmVzcyBJRCBvZiB0aGUgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgRnJvbSBBZGRyZXNzIElELlxuICAgICAqL1xuICAgIGdldEZyb21BZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFkZHJlc3NfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERlc3RpbmF0aW9uIEFkZHJlc3MgSUQgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIERlc3RpbmF0aW9uIEFkZHJlc3MgSUQuXG4gICAgICovXG4gICAgZ2V0RGVzdGluYXRpb25BZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBBc3NldCBJRCBvZiB0aGUgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQXNzZXQgSUQuXG4gICAgICovXG4gICAgZ2V0QXNzZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuYXNzZXRfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEFtb3VudCBvZiB0aGUgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQW1vdW50IG9mIHRoZSBBc3NldC5cbiAgICAgKi9cbiAgICBnZXRBbW91bnQoKSB7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCh0aGlzLm1vZGVsLmFtb3VudCk7XG4gICAgICAgIHJldHVybiBhbW91bnQuZGl2aWRlZEJ5KG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCgxMCkucG93KHRoaXMubW9kZWwuYXNzZXQuZGVjaW1hbHMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhbnNhY3Rpb24gSGFzaCBvZiB0aGUgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVHJhbnNhY3Rpb24gSGFzaCBhcyBhIEhleCBzdHJpbmcsIG9yIHVuZGVmaW5lZCBpZiBub3QgeWV0IGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbkhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlbmRUcmFuc2FjdGlvbkRlbGVnYXRlKCk/LmdldFRyYW5zYWN0aW9uSGFzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUcmFuc2FjdGlvbiBvZiB0aGUgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZXRoZXJzLmpzIFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIChJbnZhbGlkVW5zaWduZWRQYXlsb2FkKSBJZiB0aGUgVW5zaWduZWQgUGF5bG9hZCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIGdldFJhd1RyYW5zYWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0VHJhbnNhY3Rpb24oKSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRyYW5zYWN0aW9uKCkucmF3VHJhbnNhY3Rpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgdGhlIFRyYW5zZmVyIHdpdGggdGhlIHByb3ZpZGVkIGtleSBhbmQgcmV0dXJucyB0aGUgaGV4IHNpZ25hdHVyZVxuICAgICAqIHJlcXVpcmVkIGZvciBicm9hZGNhc3RpbmcgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gc2lnbiB0aGUgVHJhbnNmZXIgd2l0aFxuICAgICAqIEByZXR1cm5zIFRoZSBoZXgtZW5jb2RlZCBzaWduZWQgcGF5bG9hZFxuICAgICAqL1xuICAgIGFzeW5jIHNpZ24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlbmRUcmFuc2FjdGlvbkRlbGVnYXRlKCkuc2lnbihrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTdGF0dXMgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFN0YXR1cyBvZiB0aGUgVHJhbnNmZXIuXG4gICAgICovXG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0U2VuZFRyYW5zYWN0aW9uRGVsZWdhdGUoKS5nZXRTdGF0dXMoKSkge1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLlBFTkRJTkc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVHJhbnNmZXJTdGF0dXMuUEVORElORztcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLlBFTkRJTkc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVHJhbnNmZXJTdGF0dXMuUEVORElORztcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLlNJR05FRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2ZlclN0YXR1cy5QRU5ESU5HO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkJST0FEQ0FTVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2ZlclN0YXR1cy5CUk9BRENBU1Q7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5TVUJNSVRURUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVHJhbnNmZXJTdGF0dXMuQlJPQURDQVNUO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zZmVyU3RhdHVzLkNPTVBMRVRFO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuQ09NUExFVEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVHJhbnNmZXJTdGF0dXMuQ09NUExFVEU7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuRkFJTEVEOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zZmVyU3RhdHVzLkZBSUxFRDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLkZBSUxFRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2ZlclN0YXR1cy5GQUlMRUQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhbnNhY3Rpb24gb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC50cmFuc2FjdGlvbilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBuZXcgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbih0aGlzLm1vZGVsLnRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU3BvbnNvcmVkIFNlbmQgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFNwb25zb3JlZCBTZW5kXG4gICAgICovXG4gICAgZ2V0U3BvbnNvcmVkU2VuZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsLnNwb25zb3JlZF9zZW5kKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG5ldyBzcG9uc29yZWRfc2VuZF8xLlNwb25zb3JlZFNlbmQodGhpcy5tb2RlbC5zcG9uc29yZWRfc2VuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFNlbmQgVHJhbnNhY3Rpb24gRGVsZWdhdGUgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgRWl0aGVyIHRoZSBUcmFuc2FjdGlvbiBvciB0aGUgU3BvbnNvcmVkIFNlbmRcbiAgICAgKi9cbiAgICBnZXRTZW5kVHJhbnNhY3Rpb25EZWxlZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmdldFRyYW5zYWN0aW9uKCkgPyB0aGlzLmdldFNwb25zb3JlZFNlbmQoKSA6IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGluayB0byB0aGUgVHJhbnNhY3Rpb24gb24gdGhlIGJsb2NrY2hhaW4gZXhwbG9yZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbGluayB0byB0aGUgVHJhbnNhY3Rpb24gb24gdGhlIGJsb2NrY2hhaW4gZXhwbG9yZXIuXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25MaW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZW5kVHJhbnNhY3Rpb25EZWxlZ2F0ZSgpPy5nZXRUcmFuc2FjdGlvbkxpbmsoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0cyB0aGUgVHJhbnNmZXIgdG8gdGhlIE5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVHJhbnNmZXIgb2JqZWN0XG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBicm9hZGNhc3QgYSBUcmFuc2ZlciBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBicm9hZGNhc3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRTZW5kVHJhbnNhY3Rpb25EZWxlZ2F0ZSgpPy5pc1NpZ25lZCgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGJyb2FkY2FzdCB1bnNpZ25lZCBUcmFuc2ZlclwiKTtcbiAgICAgICAgY29uc3QgYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgc2lnbmVkX3BheWxvYWQ6IHRoaXMuZ2V0U2VuZFRyYW5zYWN0aW9uRGVsZWdhdGUoKS5nZXRTaWduYXR1cmUoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMudHJhbnNmZXIuYnJvYWRjYXN0VHJhbnNmZXIodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldEZyb21BZGRyZXNzSWQoKSwgdGhpcy5nZXRJZCgpLCBicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gVHJhbnNmZXIuZnJvbU1vZGVsKHJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgdGhlIFRyYW5zZmVyIHRvIGJlIGNvbmZpcm1lZCBvbiB0aGUgTmV0d29yayBvciBmYWlsIG9uIGNoYWluLlxuICAgICAqIFdhaXRzIHVudGlsIHRoZSBUcmFuc2ZlciBpcyBjb21wbGV0ZWQgb3IgZmFpbGVkIG9uLWNoYWluIGJ5IHBvbGxpbmcgYXQgdGhlIGdpdmVuIGludGVydmFsLlxuICAgICAqIFJhaXNlcyBhbiBlcnJvciBpZiB0aGUgVHJhZGUgdGFrZXMgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgd2FpdCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbFNlY29uZHMgLSBUaGUgaW50ZXJ2YWwgdG8gY2hlY2sgdGhlIHN0YXR1cyBvZiB0aGUgVHJhbnNmZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dFNlY29uZHMgLSBUaGUgbWF4aW11bSB0aW1lIHRvIHdhaXQgZm9yIHRoZSBUcmFuc2ZlciB0byBiZSBjb25maXJtZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVHJhbnNmZXIgb2JqZWN0IGluIGEgdGVybWluYWwgc3RhdGUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBUcmFuc2ZlciB0aW1lcyBvdXQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdCh7IGludGVydmFsU2Vjb25kcyA9IDAuMiwgdGltZW91dFNlY29uZHMgPSAxMCB9ID0ge30pIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgVHJhbnNmZXIgaXMgaW4gYSB0ZXJtaW5hbCBzdGF0ZSwgcmV0dXJuIHRoZSBUcmFuc2Zlci5cbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuZ2V0U3RhdHVzKCk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSB0eXBlc18xLlRyYW5zZmVyU3RhdHVzLkNPTVBMRVRFIHx8IHN0YXR1cyA9PT0gdHlwZXNfMS5UcmFuc2ZlclN0YXR1cy5GQUlMRUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgwLCB1dGlsc18xLmRlbGF5KShpbnRlcnZhbFNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5UaW1lb3V0RXJyb3IoXCJUcmFuc2ZlciB0aW1lZCBvdXRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIFRyYW5zZmVyIG1vZGVsIHdpdGggdGhlIGxhdGVzdCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gZ2V0IGEgVHJhbnNmZXIgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgcmVsb2FkKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMudHJhbnNmZXIuZ2V0VHJhbnNmZXIodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldEZyb21BZGRyZXNzSWQoKSwgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IHJlc3VsdD8uZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChgVHJhbnNmZXJ7dHJhbnNmZXJJZDogJyR7dGhpcy5nZXRJZCgpfScsIG5ldHdvcmtJZDogJyR7dGhpcy5nZXROZXR3b3JrSWQoKX0nLCBgICtcbiAgICAgICAgICAgIGBmcm9tQWRkcmVzc0lkOiAnJHt0aGlzLmdldEZyb21BZGRyZXNzSWQoKX0nLCBkZXN0aW5hdGlvbkFkZHJlc3NJZDogJyR7dGhpcy5nZXREZXN0aW5hdGlvbkFkZHJlc3NJZCgpfScsIGAgK1xuICAgICAgICAgICAgYGFzc2V0SWQ6ICcke3RoaXMuZ2V0QXNzZXRJZCgpfScsIGFtb3VudDogJyR7dGhpcy5nZXRBbW91bnQoKX0nLCB0cmFuc2FjdGlvbkhhc2g6ICcke3RoaXMuZ2V0VHJhbnNhY3Rpb25IYXNoKCl9JywgYCArXG4gICAgICAgICAgICBgdHJhbnNhY3Rpb25MaW5rOiAnJHt0aGlzLmdldFRyYW5zYWN0aW9uTGluaygpfScsIHN0YXR1czogJyR7dGhpcy5nZXRTdGF0dXMoKX0nfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhbnNmZXIgPSBUcmFuc2ZlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SmartContractType = exports.StakeOptionsMode = exports.ServerSignerStatus = exports.isMnemonicSeedPhrase = exports.isWalletData = exports.FundOperationStatus = exports.PayloadSignatureStatus = exports.StakingRewardFormat = exports.ValidatorStatus = exports.SponsoredSendStatus = exports.TransactionStatus = exports.TransferStatus = void 0;\n/**\n * Transfer status type definition.\n */\nvar TransferStatus;\n(function (TransferStatus) {\n    TransferStatus[\"PENDING\"] = \"pending\";\n    TransferStatus[\"BROADCAST\"] = \"broadcast\";\n    TransferStatus[\"COMPLETE\"] = \"complete\";\n    TransferStatus[\"FAILED\"] = \"failed\";\n})(TransferStatus || (exports.TransferStatus = TransferStatus = {}));\n/**\n * Transaction status type definition.\n */\nvar TransactionStatus;\n(function (TransactionStatus) {\n    TransactionStatus[\"PENDING\"] = \"pending\";\n    TransactionStatus[\"SIGNED\"] = \"signed\";\n    TransactionStatus[\"BROADCAST\"] = \"broadcast\";\n    TransactionStatus[\"COMPLETE\"] = \"complete\";\n    TransactionStatus[\"FAILED\"] = \"failed\";\n    TransactionStatus[\"UNSPECIFIED\"] = \"unspecified\";\n})(TransactionStatus || (exports.TransactionStatus = TransactionStatus = {}));\n/**\n * Sponsored Send status type definition.\n */\nvar SponsoredSendStatus;\n(function (SponsoredSendStatus) {\n    SponsoredSendStatus[\"PENDING\"] = \"pending\";\n    SponsoredSendStatus[\"SIGNED\"] = \"signed\";\n    SponsoredSendStatus[\"SUBMITTED\"] = \"submitted\";\n    SponsoredSendStatus[\"COMPLETE\"] = \"complete\";\n    SponsoredSendStatus[\"FAILED\"] = \"failed\";\n})(SponsoredSendStatus || (exports.SponsoredSendStatus = SponsoredSendStatus = {}));\n/**\n * Validator status type definition.\n * Represents the various states a validator can be in.\n */\nvar ValidatorStatus;\n(function (ValidatorStatus) {\n    ValidatorStatus[\"UNKNOWN\"] = \"unknown\";\n    ValidatorStatus[\"PROVISIONING\"] = \"provisioning\";\n    ValidatorStatus[\"PROVISIONED\"] = \"provisioned\";\n    ValidatorStatus[\"DEPOSITED\"] = \"deposited\";\n    ValidatorStatus[\"PENDING_ACTIVATION\"] = \"pending_activation\";\n    ValidatorStatus[\"ACTIVE\"] = \"active\";\n    ValidatorStatus[\"EXITING\"] = \"exiting\";\n    ValidatorStatus[\"EXITED\"] = \"exited\";\n    ValidatorStatus[\"WITHDRAWAL_AVAILABLE\"] = \"withdrawal_available\";\n    ValidatorStatus[\"WITHDRAWAL_COMPLETE\"] = \"withdrawal_complete\";\n    ValidatorStatus[\"ACTIVE_SLASHED\"] = \"active_slashed\";\n    ValidatorStatus[\"EXITED_SLASHED\"] = \"exited_slashed\";\n    ValidatorStatus[\"REAPED\"] = \"reaped\";\n})(ValidatorStatus || (exports.ValidatorStatus = ValidatorStatus = {}));\n/**\n * Staking reward format type definition.\n * Represents the format in which staking rewards can be queried.\n */\nvar StakingRewardFormat;\n(function (StakingRewardFormat) {\n    StakingRewardFormat[\"USD\"] = \"usd\";\n    StakingRewardFormat[\"NATIVE\"] = \"native\";\n})(StakingRewardFormat || (exports.StakingRewardFormat = StakingRewardFormat = {}));\n/**\n * Payload Signature status type definition.\n */\nvar PayloadSignatureStatus;\n(function (PayloadSignatureStatus) {\n    PayloadSignatureStatus[\"PENDING\"] = \"pending\";\n    PayloadSignatureStatus[\"SIGNED\"] = \"signed\";\n    PayloadSignatureStatus[\"FAILED\"] = \"failed\";\n})(PayloadSignatureStatus || (exports.PayloadSignatureStatus = PayloadSignatureStatus = {}));\n/**\n * Fund Operation status type definition.\n */\nvar FundOperationStatus;\n(function (FundOperationStatus) {\n    FundOperationStatus[\"PENDING\"] = \"pending\";\n    FundOperationStatus[\"COMPLETE\"] = \"complete\";\n    FundOperationStatus[\"FAILED\"] = \"failed\";\n})(FundOperationStatus || (exports.FundOperationStatus = FundOperationStatus = {}));\n/**\n * Type guard to check if data matches the appropriate WalletData format.\n * WalletData must have:\n * - exactly one of (walletId or wallet_id)\n * - at most one of (networkId or network_id)\n * - a seed\n *\n * @param data - The data to check\n * @returns True if data matches the appropriate WalletData format\n */\nfunction isWalletData(data) {\n    if (typeof data !== \"object\" || data === null) {\n        return false;\n    }\n    const { walletId, wallet_id, networkId, network_id, seed } = data;\n    // Check that exactly one of walletId or wallet_id is present (but not both)\n    const hasWalletId = typeof walletId === \"string\";\n    const hasWalletSnakeId = typeof wallet_id === \"string\";\n    if (!(hasWalletId !== hasWalletSnakeId)) {\n        return false;\n    }\n    // Check that at most one of networkId or network_id is present (but not both)\n    const hasNetworkId = typeof networkId === \"string\";\n    const hasNetworkSnakeId = typeof network_id === \"string\";\n    if (hasNetworkId && hasNetworkSnakeId) {\n        return false;\n    }\n    // Check that seed is present and is a string\n    return typeof seed === \"string\";\n}\nexports.isWalletData = isWalletData;\n/**\n * Type guard to check if data matches the MnemonicSeedPhrase format.\n *\n * @param data - The data to check\n * @returns True if data matches the MnemonicSeedPhrase format\n */\nfunction isMnemonicSeedPhrase(data) {\n    if (typeof data !== \"object\" || data === null) {\n        return false;\n    }\n    const { mnemonicPhrase } = data;\n    return typeof mnemonicPhrase === \"string\";\n}\nexports.isMnemonicSeedPhrase = isMnemonicSeedPhrase;\n/**\n * ServerSigner status type definition.\n */\nvar ServerSignerStatus;\n(function (ServerSignerStatus) {\n    ServerSignerStatus[\"PENDING\"] = \"pending_seed_creation\";\n    ServerSignerStatus[\"ACTIVE\"] = \"active_seed\";\n})(ServerSignerStatus || (exports.ServerSignerStatus = ServerSignerStatus = {}));\n/**\n * StakeOptionsMode type definition.\n */\nvar StakeOptionsMode;\n(function (StakeOptionsMode) {\n    /**\n     * Defaults to the mode specific to the asset.\n     */\n    StakeOptionsMode[\"DEFAULT\"] = \"default\";\n    /**\n     * Partial represents Partial Ethereum Staking mode.\n     */\n    StakeOptionsMode[\"PARTIAL\"] = \"partial\";\n    /**\n     * Native represents Native Ethereum Staking mode.\n     */\n    StakeOptionsMode[\"NATIVE\"] = \"native\";\n})(StakeOptionsMode || (exports.StakeOptionsMode = StakeOptionsMode = {}));\n/**\n * Smart Contract Type\n */\nvar SmartContractType;\n(function (SmartContractType) {\n    SmartContractType[\"ERC20\"] = \"erc20\";\n    SmartContractType[\"ERC721\"] = \"erc721\";\n    SmartContractType[\"ERC1155\"] = \"erc1155\";\n    SmartContractType[\"CUSTOM\"] = \"custom\";\n})(SmartContractType || (exports.SmartContractType = SmartContractType = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHdCQUF3QixHQUFHLDBCQUEwQixHQUFHLDRCQUE0QixHQUFHLG9CQUFvQixHQUFHLDJCQUEyQixHQUFHLDhCQUE4QixHQUFHLDJCQUEyQixHQUFHLHVCQUF1QixHQUFHLDJCQUEyQixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQjtBQUNqVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQixzQkFBc0Isc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3Qix5QkFBeUIseUJBQXlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEIsMkJBQTJCLDJCQUEyQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCLHVCQUF1Qix1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCLDJCQUEyQiwyQkFBMkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCLDhCQUE4Qiw4QkFBOEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCLDJCQUEyQiwyQkFBMkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQW1EO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHlCQUF5QiwwQkFBMEIsMEJBQTBCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1Qix3QkFBd0Isd0JBQXdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLHlCQUF5Qix5QkFBeUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS90eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU21hcnRDb250cmFjdFR5cGUgPSBleHBvcnRzLlN0YWtlT3B0aW9uc01vZGUgPSBleHBvcnRzLlNlcnZlclNpZ25lclN0YXR1cyA9IGV4cG9ydHMuaXNNbmVtb25pY1NlZWRQaHJhc2UgPSBleHBvcnRzLmlzV2FsbGV0RGF0YSA9IGV4cG9ydHMuRnVuZE9wZXJhdGlvblN0YXR1cyA9IGV4cG9ydHMuUGF5bG9hZFNpZ25hdHVyZVN0YXR1cyA9IGV4cG9ydHMuU3Rha2luZ1Jld2FyZEZvcm1hdCA9IGV4cG9ydHMuVmFsaWRhdG9yU3RhdHVzID0gZXhwb3J0cy5TcG9uc29yZWRTZW5kU3RhdHVzID0gZXhwb3J0cy5UcmFuc2FjdGlvblN0YXR1cyA9IGV4cG9ydHMuVHJhbnNmZXJTdGF0dXMgPSB2b2lkIDA7XG4vKipcbiAqIFRyYW5zZmVyIHN0YXR1cyB0eXBlIGRlZmluaXRpb24uXG4gKi9cbnZhciBUcmFuc2ZlclN0YXR1cztcbihmdW5jdGlvbiAoVHJhbnNmZXJTdGF0dXMpIHtcbiAgICBUcmFuc2ZlclN0YXR1c1tcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgICBUcmFuc2ZlclN0YXR1c1tcIkJST0FEQ0FTVFwiXSA9IFwiYnJvYWRjYXN0XCI7XG4gICAgVHJhbnNmZXJTdGF0dXNbXCJDT01QTEVURVwiXSA9IFwiY29tcGxldGVcIjtcbiAgICBUcmFuc2ZlclN0YXR1c1tcIkZBSUxFRFwiXSA9IFwiZmFpbGVkXCI7XG59KShUcmFuc2ZlclN0YXR1cyB8fCAoZXhwb3J0cy5UcmFuc2ZlclN0YXR1cyA9IFRyYW5zZmVyU3RhdHVzID0ge30pKTtcbi8qKlxuICogVHJhbnNhY3Rpb24gc3RhdHVzIHR5cGUgZGVmaW5pdGlvbi5cbiAqL1xudmFyIFRyYW5zYWN0aW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChUcmFuc2FjdGlvblN0YXR1cykge1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wiUEVORElOR1wiXSA9IFwicGVuZGluZ1wiO1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wiU0lHTkVEXCJdID0gXCJzaWduZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcIkJST0FEQ0FTVFwiXSA9IFwiYnJvYWRjYXN0XCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJDT01QTEVURVwiXSA9IFwiY29tcGxldGVcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcIkZBSUxFRFwiXSA9IFwiZmFpbGVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJVTlNQRUNJRklFRFwiXSA9IFwidW5zcGVjaWZpZWRcIjtcbn0pKFRyYW5zYWN0aW9uU3RhdHVzIHx8IChleHBvcnRzLlRyYW5zYWN0aW9uU3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMgPSB7fSkpO1xuLyoqXG4gKiBTcG9uc29yZWQgU2VuZCBzdGF0dXMgdHlwZSBkZWZpbml0aW9uLlxuICovXG52YXIgU3BvbnNvcmVkU2VuZFN0YXR1cztcbihmdW5jdGlvbiAoU3BvbnNvcmVkU2VuZFN0YXR1cykge1xuICAgIFNwb25zb3JlZFNlbmRTdGF0dXNbXCJQRU5ESU5HXCJdID0gXCJwZW5kaW5nXCI7XG4gICAgU3BvbnNvcmVkU2VuZFN0YXR1c1tcIlNJR05FRFwiXSA9IFwic2lnbmVkXCI7XG4gICAgU3BvbnNvcmVkU2VuZFN0YXR1c1tcIlNVQk1JVFRFRFwiXSA9IFwic3VibWl0dGVkXCI7XG4gICAgU3BvbnNvcmVkU2VuZFN0YXR1c1tcIkNPTVBMRVRFXCJdID0gXCJjb21wbGV0ZVwiO1xuICAgIFNwb25zb3JlZFNlbmRTdGF0dXNbXCJGQUlMRURcIl0gPSBcImZhaWxlZFwiO1xufSkoU3BvbnNvcmVkU2VuZFN0YXR1cyB8fCAoZXhwb3J0cy5TcG9uc29yZWRTZW5kU3RhdHVzID0gU3BvbnNvcmVkU2VuZFN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIFZhbGlkYXRvciBzdGF0dXMgdHlwZSBkZWZpbml0aW9uLlxuICogUmVwcmVzZW50cyB0aGUgdmFyaW91cyBzdGF0ZXMgYSB2YWxpZGF0b3IgY2FuIGJlIGluLlxuICovXG52YXIgVmFsaWRhdG9yU3RhdHVzO1xuKGZ1bmN0aW9uIChWYWxpZGF0b3JTdGF0dXMpIHtcbiAgICBWYWxpZGF0b3JTdGF0dXNbXCJVTktOT1dOXCJdID0gXCJ1bmtub3duXCI7XG4gICAgVmFsaWRhdG9yU3RhdHVzW1wiUFJPVklTSU9OSU5HXCJdID0gXCJwcm92aXNpb25pbmdcIjtcbiAgICBWYWxpZGF0b3JTdGF0dXNbXCJQUk9WSVNJT05FRFwiXSA9IFwicHJvdmlzaW9uZWRcIjtcbiAgICBWYWxpZGF0b3JTdGF0dXNbXCJERVBPU0lURURcIl0gPSBcImRlcG9zaXRlZFwiO1xuICAgIFZhbGlkYXRvclN0YXR1c1tcIlBFTkRJTkdfQUNUSVZBVElPTlwiXSA9IFwicGVuZGluZ19hY3RpdmF0aW9uXCI7XG4gICAgVmFsaWRhdG9yU3RhdHVzW1wiQUNUSVZFXCJdID0gXCJhY3RpdmVcIjtcbiAgICBWYWxpZGF0b3JTdGF0dXNbXCJFWElUSU5HXCJdID0gXCJleGl0aW5nXCI7XG4gICAgVmFsaWRhdG9yU3RhdHVzW1wiRVhJVEVEXCJdID0gXCJleGl0ZWRcIjtcbiAgICBWYWxpZGF0b3JTdGF0dXNbXCJXSVRIRFJBV0FMX0FWQUlMQUJMRVwiXSA9IFwid2l0aGRyYXdhbF9hdmFpbGFibGVcIjtcbiAgICBWYWxpZGF0b3JTdGF0dXNbXCJXSVRIRFJBV0FMX0NPTVBMRVRFXCJdID0gXCJ3aXRoZHJhd2FsX2NvbXBsZXRlXCI7XG4gICAgVmFsaWRhdG9yU3RhdHVzW1wiQUNUSVZFX1NMQVNIRURcIl0gPSBcImFjdGl2ZV9zbGFzaGVkXCI7XG4gICAgVmFsaWRhdG9yU3RhdHVzW1wiRVhJVEVEX1NMQVNIRURcIl0gPSBcImV4aXRlZF9zbGFzaGVkXCI7XG4gICAgVmFsaWRhdG9yU3RhdHVzW1wiUkVBUEVEXCJdID0gXCJyZWFwZWRcIjtcbn0pKFZhbGlkYXRvclN0YXR1cyB8fCAoZXhwb3J0cy5WYWxpZGF0b3JTdGF0dXMgPSBWYWxpZGF0b3JTdGF0dXMgPSB7fSkpO1xuLyoqXG4gKiBTdGFraW5nIHJld2FyZCBmb3JtYXQgdHlwZSBkZWZpbml0aW9uLlxuICogUmVwcmVzZW50cyB0aGUgZm9ybWF0IGluIHdoaWNoIHN0YWtpbmcgcmV3YXJkcyBjYW4gYmUgcXVlcmllZC5cbiAqL1xudmFyIFN0YWtpbmdSZXdhcmRGb3JtYXQ7XG4oZnVuY3Rpb24gKFN0YWtpbmdSZXdhcmRGb3JtYXQpIHtcbiAgICBTdGFraW5nUmV3YXJkRm9ybWF0W1wiVVNEXCJdID0gXCJ1c2RcIjtcbiAgICBTdGFraW5nUmV3YXJkRm9ybWF0W1wiTkFUSVZFXCJdID0gXCJuYXRpdmVcIjtcbn0pKFN0YWtpbmdSZXdhcmRGb3JtYXQgfHwgKGV4cG9ydHMuU3Rha2luZ1Jld2FyZEZvcm1hdCA9IFN0YWtpbmdSZXdhcmRGb3JtYXQgPSB7fSkpO1xuLyoqXG4gKiBQYXlsb2FkIFNpZ25hdHVyZSBzdGF0dXMgdHlwZSBkZWZpbml0aW9uLlxuICovXG52YXIgUGF5bG9hZFNpZ25hdHVyZVN0YXR1cztcbihmdW5jdGlvbiAoUGF5bG9hZFNpZ25hdHVyZVN0YXR1cykge1xuICAgIFBheWxvYWRTaWduYXR1cmVTdGF0dXNbXCJQRU5ESU5HXCJdID0gXCJwZW5kaW5nXCI7XG4gICAgUGF5bG9hZFNpZ25hdHVyZVN0YXR1c1tcIlNJR05FRFwiXSA9IFwic2lnbmVkXCI7XG4gICAgUGF5bG9hZFNpZ25hdHVyZVN0YXR1c1tcIkZBSUxFRFwiXSA9IFwiZmFpbGVkXCI7XG59KShQYXlsb2FkU2lnbmF0dXJlU3RhdHVzIHx8IChleHBvcnRzLlBheWxvYWRTaWduYXR1cmVTdGF0dXMgPSBQYXlsb2FkU2lnbmF0dXJlU3RhdHVzID0ge30pKTtcbi8qKlxuICogRnVuZCBPcGVyYXRpb24gc3RhdHVzIHR5cGUgZGVmaW5pdGlvbi5cbiAqL1xudmFyIEZ1bmRPcGVyYXRpb25TdGF0dXM7XG4oZnVuY3Rpb24gKEZ1bmRPcGVyYXRpb25TdGF0dXMpIHtcbiAgICBGdW5kT3BlcmF0aW9uU3RhdHVzW1wiUEVORElOR1wiXSA9IFwicGVuZGluZ1wiO1xuICAgIEZ1bmRPcGVyYXRpb25TdGF0dXNbXCJDT01QTEVURVwiXSA9IFwiY29tcGxldGVcIjtcbiAgICBGdW5kT3BlcmF0aW9uU3RhdHVzW1wiRkFJTEVEXCJdID0gXCJmYWlsZWRcIjtcbn0pKEZ1bmRPcGVyYXRpb25TdGF0dXMgfHwgKGV4cG9ydHMuRnVuZE9wZXJhdGlvblN0YXR1cyA9IEZ1bmRPcGVyYXRpb25TdGF0dXMgPSB7fSkpO1xuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGRhdGEgbWF0Y2hlcyB0aGUgYXBwcm9wcmlhdGUgV2FsbGV0RGF0YSBmb3JtYXQuXG4gKiBXYWxsZXREYXRhIG11c3QgaGF2ZTpcbiAqIC0gZXhhY3RseSBvbmUgb2YgKHdhbGxldElkIG9yIHdhbGxldF9pZClcbiAqIC0gYXQgbW9zdCBvbmUgb2YgKG5ldHdvcmtJZCBvciBuZXR3b3JrX2lkKVxuICogLSBhIHNlZWRcbiAqXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBUcnVlIGlmIGRhdGEgbWF0Y2hlcyB0aGUgYXBwcm9wcmlhdGUgV2FsbGV0RGF0YSBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gaXNXYWxsZXREYXRhKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgd2FsbGV0SWQsIHdhbGxldF9pZCwgbmV0d29ya0lkLCBuZXR3b3JrX2lkLCBzZWVkIH0gPSBkYXRhO1xuICAgIC8vIENoZWNrIHRoYXQgZXhhY3RseSBvbmUgb2Ygd2FsbGV0SWQgb3Igd2FsbGV0X2lkIGlzIHByZXNlbnQgKGJ1dCBub3QgYm90aClcbiAgICBjb25zdCBoYXNXYWxsZXRJZCA9IHR5cGVvZiB3YWxsZXRJZCA9PT0gXCJzdHJpbmdcIjtcbiAgICBjb25zdCBoYXNXYWxsZXRTbmFrZUlkID0gdHlwZW9mIHdhbGxldF9pZCA9PT0gXCJzdHJpbmdcIjtcbiAgICBpZiAoIShoYXNXYWxsZXRJZCAhPT0gaGFzV2FsbGV0U25ha2VJZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaGVjayB0aGF0IGF0IG1vc3Qgb25lIG9mIG5ldHdvcmtJZCBvciBuZXR3b3JrX2lkIGlzIHByZXNlbnQgKGJ1dCBub3QgYm90aClcbiAgICBjb25zdCBoYXNOZXR3b3JrSWQgPSB0eXBlb2YgbmV0d29ya0lkID09PSBcInN0cmluZ1wiO1xuICAgIGNvbnN0IGhhc05ldHdvcmtTbmFrZUlkID0gdHlwZW9mIG5ldHdvcmtfaWQgPT09IFwic3RyaW5nXCI7XG4gICAgaWYgKGhhc05ldHdvcmtJZCAmJiBoYXNOZXR3b3JrU25ha2VJZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIENoZWNrIHRoYXQgc2VlZCBpcyBwcmVzZW50IGFuZCBpcyBhIHN0cmluZ1xuICAgIHJldHVybiB0eXBlb2Ygc2VlZCA9PT0gXCJzdHJpbmdcIjtcbn1cbmV4cG9ydHMuaXNXYWxsZXREYXRhID0gaXNXYWxsZXREYXRhO1xuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGRhdGEgbWF0Y2hlcyB0aGUgTW5lbW9uaWNTZWVkUGhyYXNlIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBUcnVlIGlmIGRhdGEgbWF0Y2hlcyB0aGUgTW5lbW9uaWNTZWVkUGhyYXNlIGZvcm1hdFxuICovXG5mdW5jdGlvbiBpc01uZW1vbmljU2VlZFBocmFzZShkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiIHx8IGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IG1uZW1vbmljUGhyYXNlIH0gPSBkYXRhO1xuICAgIHJldHVybiB0eXBlb2YgbW5lbW9uaWNQaHJhc2UgPT09IFwic3RyaW5nXCI7XG59XG5leHBvcnRzLmlzTW5lbW9uaWNTZWVkUGhyYXNlID0gaXNNbmVtb25pY1NlZWRQaHJhc2U7XG4vKipcbiAqIFNlcnZlclNpZ25lciBzdGF0dXMgdHlwZSBkZWZpbml0aW9uLlxuICovXG52YXIgU2VydmVyU2lnbmVyU3RhdHVzO1xuKGZ1bmN0aW9uIChTZXJ2ZXJTaWduZXJTdGF0dXMpIHtcbiAgICBTZXJ2ZXJTaWduZXJTdGF0dXNbXCJQRU5ESU5HXCJdID0gXCJwZW5kaW5nX3NlZWRfY3JlYXRpb25cIjtcbiAgICBTZXJ2ZXJTaWduZXJTdGF0dXNbXCJBQ1RJVkVcIl0gPSBcImFjdGl2ZV9zZWVkXCI7XG59KShTZXJ2ZXJTaWduZXJTdGF0dXMgfHwgKGV4cG9ydHMuU2VydmVyU2lnbmVyU3RhdHVzID0gU2VydmVyU2lnbmVyU3RhdHVzID0ge30pKTtcbi8qKlxuICogU3Rha2VPcHRpb25zTW9kZSB0eXBlIGRlZmluaXRpb24uXG4gKi9cbnZhciBTdGFrZU9wdGlvbnNNb2RlO1xuKGZ1bmN0aW9uIChTdGFrZU9wdGlvbnNNb2RlKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdHMgdG8gdGhlIG1vZGUgc3BlY2lmaWMgdG8gdGhlIGFzc2V0LlxuICAgICAqL1xuICAgIFN0YWtlT3B0aW9uc01vZGVbXCJERUZBVUxUXCJdID0gXCJkZWZhdWx0XCI7XG4gICAgLyoqXG4gICAgICogUGFydGlhbCByZXByZXNlbnRzIFBhcnRpYWwgRXRoZXJldW0gU3Rha2luZyBtb2RlLlxuICAgICAqL1xuICAgIFN0YWtlT3B0aW9uc01vZGVbXCJQQVJUSUFMXCJdID0gXCJwYXJ0aWFsXCI7XG4gICAgLyoqXG4gICAgICogTmF0aXZlIHJlcHJlc2VudHMgTmF0aXZlIEV0aGVyZXVtIFN0YWtpbmcgbW9kZS5cbiAgICAgKi9cbiAgICBTdGFrZU9wdGlvbnNNb2RlW1wiTkFUSVZFXCJdID0gXCJuYXRpdmVcIjtcbn0pKFN0YWtlT3B0aW9uc01vZGUgfHwgKGV4cG9ydHMuU3Rha2VPcHRpb25zTW9kZSA9IFN0YWtlT3B0aW9uc01vZGUgPSB7fSkpO1xuLyoqXG4gKiBTbWFydCBDb250cmFjdCBUeXBlXG4gKi9cbnZhciBTbWFydENvbnRyYWN0VHlwZTtcbihmdW5jdGlvbiAoU21hcnRDb250cmFjdFR5cGUpIHtcbiAgICBTbWFydENvbnRyYWN0VHlwZVtcIkVSQzIwXCJdID0gXCJlcmMyMFwiO1xuICAgIFNtYXJ0Q29udHJhY3RUeXBlW1wiRVJDNzIxXCJdID0gXCJlcmM3MjFcIjtcbiAgICBTbWFydENvbnRyYWN0VHlwZVtcIkVSQzExNTVcIl0gPSBcImVyYzExNTVcIjtcbiAgICBTbWFydENvbnRyYWN0VHlwZVtcIkNVU1RPTVwiXSA9IFwiY3VzdG9tXCI7XG59KShTbWFydENvbnRyYWN0VHlwZSB8fCAoZXhwb3J0cy5TbWFydENvbnRyYWN0VHlwZSA9IFNtYXJ0Q29udHJhY3RUeXBlID0ge30pKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js":
/*!********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getWeekBackDate = exports.formatDate = exports.parseUnsignedPayload = exports.delay = exports.convertStringToHex = exports.registerAxiosInterceptors = exports.logApiResponse = void 0;\nconst api_error_1 = __webpack_require__(/*! ./api_error */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/**\n * Prints Axios response to the console for debugging purposes.\n *\n * @param response - The Axios response object.\n * @param debugging - Flag to enable or disable logging.\n * @returns The Axios response object.\n */\nconst logApiResponse = (response, debugging = false) => {\n    if (debugging) {\n        let output = typeof response.data === \"string\" ? response.data : \"\";\n        if (typeof response.data === \"object\") {\n            output = JSON.stringify(response.data, null, 4);\n        }\n        console.log(`API RESPONSE: \n      Status: ${response.status} \n      URL: ${response.config.url} \n      Data: ${output}`);\n    }\n    return response;\n};\nexports.logApiResponse = logApiResponse;\n/**\n * Registers request and response interceptors to an Axios instance.\n *\n * @param axiosInstance - The Axios instance to register the interceptors.\n * @param requestFn - The request interceptor function.\n * @param responseFn - The response interceptor function.\n */\nconst registerAxiosInterceptors = (axiosInstance, requestFn, responseFn) => {\n    axiosInstance.interceptors.request.use(requestFn);\n    axiosInstance.interceptors.response.use(responseFn, error => {\n        return Promise.reject(api_error_1.APIError.fromError(error));\n    });\n};\nexports.registerAxiosInterceptors = registerAxiosInterceptors;\n/**\n * Converts a Uint8Array to a hex string.\n *\n * @param key - The key to convert.\n * @returns The converted hex string.\n */\nconst convertStringToHex = (key) => {\n    return Buffer.from(key).toString(\"hex\");\n};\nexports.convertStringToHex = convertStringToHex;\n/**\n * Delays the execution of the function by the specified number of seconds.\n *\n * @param seconds - The number of seconds to delay the execution.\n * @returns A promise that resolves after the specified number of seconds.\n */\nasync function delay(seconds) {\n    return new Promise(resolve => setTimeout(resolve, seconds * 1000));\n}\nexports.delay = delay;\n/**\n * Parses an Unsigned Payload and returns the JSON object.\n *\n * @throws {InvalidUnsignedPayload} If the Unsigned Payload is invalid.\n * @param payload - The Unsigned Payload.\n * @returns The parsed JSON object.\n */\nfunction parseUnsignedPayload(payload) {\n    const rawPayload = payload.match(/../g)?.map(byte => parseInt(byte, 16));\n    if (!rawPayload) {\n        throw new errors_1.InvalidUnsignedPayloadError(\"Unable to parse unsigned payload\");\n    }\n    let parsedPayload;\n    try {\n        const rawPayloadBytes = new Uint8Array(rawPayload);\n        const decoder = new TextDecoder();\n        parsedPayload = JSON.parse(decoder.decode(rawPayloadBytes));\n    }\n    catch (error) {\n        throw new errors_1.InvalidUnsignedPayloadError(\"Unable to decode unsigned payload JSON\");\n    }\n    return parsedPayload;\n}\nexports.parseUnsignedPayload = parseUnsignedPayload;\n/**\n * Formats the input date to 'YYYY-MM-DD'\n *\n * @param date - The date to format.\n *\n * @returns a formated date of 'YYYY-MM-DD'\n */\nfunction formatDate(date) {\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, \"0\"); // Months are zero-based, so add 1\n    const day = String(date.getDate()).padStart(2, \"0\");\n    return `${year}-${month}-${day}T00:00:00Z`;\n}\nexports.formatDate = formatDate;\n/**\n *\n * Takes a date and subtracts a week from it. (7 days)\n *\n * @param date - The date to be formatted.\n *\n * @returns a formatted date that is one week ago.\n */\nfunction getWeekBackDate(date) {\n    date.setDate(date.getDate() - 7);\n    return formatDate(date);\n}\nexports.getWeekBackDate = getWeekBackDate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLDRCQUE0QixHQUFHLGFBQWEsR0FBRywwQkFBMEIsR0FBRyxpQ0FBaUMsR0FBRyxzQkFBc0I7QUFDckwsb0JBQW9CLG1CQUFPLENBQUMsMkZBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsY0FBYyxLQUFLLEdBQUcsTUFBTSxHQUFHLElBQUk7QUFDbkM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFdlZWtCYWNrRGF0ZSA9IGV4cG9ydHMuZm9ybWF0RGF0ZSA9IGV4cG9ydHMucGFyc2VVbnNpZ25lZFBheWxvYWQgPSBleHBvcnRzLmRlbGF5ID0gZXhwb3J0cy5jb252ZXJ0U3RyaW5nVG9IZXggPSBleHBvcnRzLnJlZ2lzdGVyQXhpb3NJbnRlcmNlcHRvcnMgPSBleHBvcnRzLmxvZ0FwaVJlc3BvbnNlID0gdm9pZCAwO1xuY29uc3QgYXBpX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9hcGlfZXJyb3JcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8qKlxuICogUHJpbnRzIEF4aW9zIHJlc3BvbnNlIHRvIHRoZSBjb25zb2xlIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIEF4aW9zIHJlc3BvbnNlIG9iamVjdC5cbiAqIEBwYXJhbSBkZWJ1Z2dpbmcgLSBGbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIGxvZ2dpbmcuXG4gKiBAcmV0dXJucyBUaGUgQXhpb3MgcmVzcG9uc2Ugb2JqZWN0LlxuICovXG5jb25zdCBsb2dBcGlSZXNwb25zZSA9IChyZXNwb25zZSwgZGVidWdnaW5nID0gZmFsc2UpID0+IHtcbiAgICBpZiAoZGVidWdnaW5nKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSB0eXBlb2YgcmVzcG9uc2UuZGF0YSA9PT0gXCJzdHJpbmdcIiA/IHJlc3BvbnNlLmRhdGEgOiBcIlwiO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmRhdGEsIG51bGwsIDQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGBBUEkgUkVTUE9OU0U6IFxuICAgICAgU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c30gXG4gICAgICBVUkw6ICR7cmVzcG9uc2UuY29uZmlnLnVybH0gXG4gICAgICBEYXRhOiAke291dHB1dH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbmV4cG9ydHMubG9nQXBpUmVzcG9uc2UgPSBsb2dBcGlSZXNwb25zZTtcbi8qKlxuICogUmVnaXN0ZXJzIHJlcXVlc3QgYW5kIHJlc3BvbnNlIGludGVyY2VwdG9ycyB0byBhbiBBeGlvcyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gYXhpb3NJbnN0YW5jZSAtIFRoZSBBeGlvcyBpbnN0YW5jZSB0byByZWdpc3RlciB0aGUgaW50ZXJjZXB0b3JzLlxuICogQHBhcmFtIHJlcXVlc3RGbiAtIFRoZSByZXF1ZXN0IGludGVyY2VwdG9yIGZ1bmN0aW9uLlxuICogQHBhcmFtIHJlc3BvbnNlRm4gLSBUaGUgcmVzcG9uc2UgaW50ZXJjZXB0b3IgZnVuY3Rpb24uXG4gKi9cbmNvbnN0IHJlZ2lzdGVyQXhpb3NJbnRlcmNlcHRvcnMgPSAoYXhpb3NJbnN0YW5jZSwgcmVxdWVzdEZuLCByZXNwb25zZUZuKSA9PiB7XG4gICAgYXhpb3NJbnN0YW5jZS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UocmVxdWVzdEZuKTtcbiAgICBheGlvc0luc3RhbmNlLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UocmVzcG9uc2VGbiwgZXJyb3IgPT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYXBpX2Vycm9yXzEuQVBJRXJyb3IuZnJvbUVycm9yKGVycm9yKSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5yZWdpc3RlckF4aW9zSW50ZXJjZXB0b3JzID0gcmVnaXN0ZXJBeGlvc0ludGVyY2VwdG9ycztcbi8qKlxuICogQ29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBoZXggc3RyaW5nLlxuICovXG5jb25zdCBjb252ZXJ0U3RyaW5nVG9IZXggPSAoa2V5KSA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGtleSkudG9TdHJpbmcoXCJoZXhcIik7XG59O1xuZXhwb3J0cy5jb252ZXJ0U3RyaW5nVG9IZXggPSBjb252ZXJ0U3RyaW5nVG9IZXg7XG4vKipcbiAqIERlbGF5cyB0aGUgZXhlY3V0aW9uIG9mIHRoZSBmdW5jdGlvbiBieSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSBzZWNvbmRzIC0gVGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIGRlbGF5IHRoZSBleGVjdXRpb24uXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzZWNvbmRzLlxuICovXG5hc3luYyBmdW5jdGlvbiBkZWxheShzZWNvbmRzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBzZWNvbmRzICogMTAwMCkpO1xufVxuZXhwb3J0cy5kZWxheSA9IGRlbGF5O1xuLyoqXG4gKiBQYXJzZXMgYW4gVW5zaWduZWQgUGF5bG9hZCBhbmQgcmV0dXJucyB0aGUgSlNPTiBvYmplY3QuXG4gKlxuICogQHRocm93cyB7SW52YWxpZFVuc2lnbmVkUGF5bG9hZH0gSWYgdGhlIFVuc2lnbmVkIFBheWxvYWQgaXMgaW52YWxpZC5cbiAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIFVuc2lnbmVkIFBheWxvYWQuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIEpTT04gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBwYXJzZVVuc2lnbmVkUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgY29uc3QgcmF3UGF5bG9hZCA9IHBheWxvYWQubWF0Y2goLy4uL2cpPy5tYXAoYnl0ZSA9PiBwYXJzZUludChieXRlLCAxNikpO1xuICAgIGlmICghcmF3UGF5bG9hZCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yKFwiVW5hYmxlIHRvIHBhcnNlIHVuc2lnbmVkIHBheWxvYWRcIik7XG4gICAgfVxuICAgIGxldCBwYXJzZWRQYXlsb2FkO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJhd1BheWxvYWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHJhd1BheWxvYWQpO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIHBhcnNlZFBheWxvYWQgPSBKU09OLnBhcnNlKGRlY29kZXIuZGVjb2RlKHJhd1BheWxvYWRCeXRlcykpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRVbnNpZ25lZFBheWxvYWRFcnJvcihcIlVuYWJsZSB0byBkZWNvZGUgdW5zaWduZWQgcGF5bG9hZCBKU09OXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkUGF5bG9hZDtcbn1cbmV4cG9ydHMucGFyc2VVbnNpZ25lZFBheWxvYWQgPSBwYXJzZVVuc2lnbmVkUGF5bG9hZDtcbi8qKlxuICogRm9ybWF0cyB0aGUgaW5wdXQgZGF0ZSB0byAnWVlZWS1NTS1ERCdcbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGZvcm1hdC5cbiAqXG4gKiBAcmV0dXJucyBhIGZvcm1hdGVkIGRhdGUgb2YgJ1lZWVktTU0tREQnXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICAgIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgY29uc3QgbW9udGggPSBTdHJpbmcoZGF0ZS5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgXCIwXCIpOyAvLyBNb250aHMgYXJlIHplcm8tYmFzZWQsIHNvIGFkZCAxXG4gICAgY29uc3QgZGF5ID0gU3RyaW5nKGRhdGUuZ2V0RGF0ZSgpKS5wYWRTdGFydCgyLCBcIjBcIik7XG4gICAgcmV0dXJuIGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fVQwMDowMDowMFpgO1xufVxuZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcbi8qKlxuICpcbiAqIFRha2VzIGEgZGF0ZSBhbmQgc3VidHJhY3RzIGEgd2VlayBmcm9tIGl0LiAoNyBkYXlzKVxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgZm9ybWF0dGVkLlxuICpcbiAqIEByZXR1cm5zIGEgZm9ybWF0dGVkIGRhdGUgdGhhdCBpcyBvbmUgd2VlayBhZ28uXG4gKi9cbmZ1bmN0aW9uIGdldFdlZWtCYWNrRGF0ZShkYXRlKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gNyk7XG4gICAgcmV0dXJuIGZvcm1hdERhdGUoZGF0ZSk7XG59XG5leHBvcnRzLmdldFdlZWtCYWNrRGF0ZSA9IGdldFdlZWtCYWNrRGF0ZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/validator.js":
/*!************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/validator.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Validator = void 0;\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst api_1 = __webpack_require__(/*! ../client/api */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\n/**\n * A representation of a validator onchain.\n */\nclass Validator {\n    /**\n     * Creates a Validator object.\n     *\n     * @class\n     * @param model - The underlying Validator object.\n     * @throws {Error} - If the Validator model is empty.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the list of Validators.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param status - The status to filter by.\n     * @returns The list of Validators.\n     */\n    static async list(networkId, assetId, status) {\n        const validators = [];\n        const response = await coinbase_1.Coinbase.apiClients.stake.listValidators(networkId, assetId, Validator.getAPIValidatorStatus(status));\n        response.data.data.forEach(validator => {\n            validators.push(new Validator(validator));\n        });\n        return validators;\n    }\n    /**\n     *\n     * Returns the details of a specific validator.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param id - The unique publicly identifiable id of the validator for which to fetch the data.\n     * @returns The requested validator details.\n     */\n    static async fetch(networkId, assetId, id) {\n        const response = await coinbase_1.Coinbase.apiClients.stake.getValidator(networkId, assetId, id);\n        return new Validator(response.data);\n    }\n    /**\n     * Returns the Validator status.\n     *\n     * @param status - The API Validator status.\n     * @returns The Validator status.\n     */\n    static getAPIValidatorStatus(status) {\n        /* istanbul ignore next */\n        switch (status) {\n            case types_1.ValidatorStatus.UNKNOWN:\n                return api_1.ValidatorStatus.Unknown;\n            case types_1.ValidatorStatus.PROVISIONING:\n                return api_1.ValidatorStatus.Provisioning;\n            case types_1.ValidatorStatus.PROVISIONED:\n                return api_1.ValidatorStatus.Provisioned;\n            case types_1.ValidatorStatus.DEPOSITED:\n                return api_1.ValidatorStatus.Deposited;\n            case types_1.ValidatorStatus.PENDING_ACTIVATION:\n                return api_1.ValidatorStatus.PendingActivation;\n            case types_1.ValidatorStatus.ACTIVE:\n                return api_1.ValidatorStatus.Active;\n            case types_1.ValidatorStatus.EXITING:\n                return api_1.ValidatorStatus.Exiting;\n            case types_1.ValidatorStatus.EXITED:\n                return api_1.ValidatorStatus.Exited;\n            case types_1.ValidatorStatus.WITHDRAWAL_AVAILABLE:\n                return api_1.ValidatorStatus.WithdrawalAvailable;\n            case types_1.ValidatorStatus.WITHDRAWAL_COMPLETE:\n                return api_1.ValidatorStatus.WithdrawalComplete;\n            case types_1.ValidatorStatus.ACTIVE_SLASHED:\n                return api_1.ValidatorStatus.ActiveSlashed;\n            case types_1.ValidatorStatus.EXITED_SLASHED:\n                return api_1.ValidatorStatus.ExitedSlashed;\n            case types_1.ValidatorStatus.REAPED:\n                return api_1.ValidatorStatus.Reaped;\n            default:\n                return api_1.ValidatorStatus.Unknown;\n        }\n    }\n    /**\n     * Returns the Validator ID.\n     *\n     * @returns The Validator ID.\n     */\n    getValidatorId() {\n        return this.model.validator_id;\n    }\n    /**\n     * Returns the Validator status.\n     *\n     * @returns The Validator status.\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case api_1.ValidatorStatus.Unknown:\n                return types_1.ValidatorStatus.UNKNOWN;\n            case api_1.ValidatorStatus.Provisioning:\n                return types_1.ValidatorStatus.PROVISIONING;\n            case api_1.ValidatorStatus.Provisioned:\n                return types_1.ValidatorStatus.PROVISIONED;\n            case api_1.ValidatorStatus.Deposited:\n                return types_1.ValidatorStatus.DEPOSITED;\n            case api_1.ValidatorStatus.PendingActivation:\n                return types_1.ValidatorStatus.PENDING_ACTIVATION;\n            case api_1.ValidatorStatus.Active:\n                return types_1.ValidatorStatus.ACTIVE;\n            case api_1.ValidatorStatus.Exiting:\n                return types_1.ValidatorStatus.EXITING;\n            case api_1.ValidatorStatus.Exited:\n                return types_1.ValidatorStatus.EXITED;\n            case api_1.ValidatorStatus.WithdrawalAvailable:\n                return types_1.ValidatorStatus.WITHDRAWAL_AVAILABLE;\n            case api_1.ValidatorStatus.WithdrawalComplete:\n                return types_1.ValidatorStatus.WITHDRAWAL_COMPLETE;\n            case api_1.ValidatorStatus.ActiveSlashed:\n                return types_1.ValidatorStatus.ACTIVE_SLASHED;\n            case api_1.ValidatorStatus.ExitedSlashed:\n                return types_1.ValidatorStatus.EXITED_SLASHED;\n            case api_1.ValidatorStatus.Reaped:\n                return types_1.ValidatorStatus.REAPED;\n            default:\n                return types_1.ValidatorStatus.UNKNOWN;\n        }\n    }\n    /**\n     * Returns the network ID.\n     *\n     * @returns The network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the asset ID.\n     *\n     * @returns The asset ID.\n     */\n    getAssetId() {\n        return this.model.asset_id;\n    }\n    /**\n     * Returns the activation epoch of the validator.\n     *\n     * @returns The activation epoch as a string.\n     */\n    getActivationEpoch() {\n        return this.model.details?.activationEpoch || \"\";\n    }\n    /**\n     * Returns the balance of the validator.\n     *\n     * @returns The balance object.\n     */\n    getBalance() {\n        return this.model.details?.balance;\n    }\n    /**\n     * Returns the effective balance of the validator.\n     *\n     * @returns The effective balance object.\n     */\n    getEffectiveBalance() {\n        return this.model.details?.effective_balance;\n    }\n    /**\n     * Returns the exit epoch of the validator.\n     *\n     * @returns The exit epoch as a string.\n     */\n    getExitEpoch() {\n        return this.model.details?.exitEpoch || \"\";\n    }\n    /**\n     * Returns the index of the validator.\n     *\n     * @returns The validator index as a string.\n     */\n    getIndex() {\n        return this.model.details?.index || \"\";\n    }\n    /**\n     * Returns the public key of the validator.\n     *\n     * @returns The validator's public key as a string.\n     */\n    getPublicKey() {\n        return this.model.details?.public_key || \"\";\n    }\n    /**\n     * Returns whether the validator has been slashed.\n     *\n     * @returns True if the validator has been slashed, false otherwise.\n     */\n    isSlashed() {\n        return this.model.details?.slashed || false;\n    }\n    /**\n     * Returns the withdrawable epoch of the validator.\n     *\n     * @returns The withdrawable epoch as a string.\n     */\n    getWithdrawableEpoch() {\n        return this.model.details?.withdrawableEpoch || \"\";\n    }\n    /**\n     * Returns the withdrawal address of the validator.\n     *\n     * @returns The withdrawal address as a string.\n     */\n    getWithdrawalAddress() {\n        return this.model.details?.withdrawal_address || \"\";\n    }\n    /**\n     * Returns the string representation of the Validator.\n     *\n     * @returns The string representation of the Validator.\n     */\n    toString() {\n        return `Id: ${this.getValidatorId()} Status: ${this.getStatus()}`;\n    }\n    /**\n     * Returns the JSON representation of the Validator.\n     *\n     * @returns The JSON representation of the Validator.\n     */\n    toJSON() {\n        return JSON.stringify(this.model);\n    }\n}\nexports.Validator = Validator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3ZhbGlkYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLHFGQUFlO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCLFVBQVUsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvdmFsaWRhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWxpZGF0b3IgPSB2b2lkIDA7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCIuLi9jbGllbnQvYXBpXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgdmFsaWRhdG9yIG9uY2hhaW4uXG4gKi9cbmNsYXNzIFZhbGlkYXRvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFZhbGlkYXRvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBWYWxpZGF0b3Igb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIHRoZSBWYWxpZGF0b3IgbW9kZWwgaXMgZW1wdHkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlbCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBWYWxpZGF0b3JzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCAtIFRoZSBuZXR3b3JrIElELlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEBwYXJhbSBzdGF0dXMgLSBUaGUgc3RhdHVzIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbGlzdCBvZiBWYWxpZGF0b3JzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBsaXN0KG5ldHdvcmtJZCwgYXNzZXRJZCwgc3RhdHVzKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc3Rha2UubGlzdFZhbGlkYXRvcnMobmV0d29ya0lkLCBhc3NldElkLCBWYWxpZGF0b3IuZ2V0QVBJVmFsaWRhdG9yU3RhdHVzKHN0YXR1cykpO1xuICAgICAgICByZXNwb25zZS5kYXRhLmRhdGEuZm9yRWFjaCh2YWxpZGF0b3IgPT4ge1xuICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKG5ldyBWYWxpZGF0b3IodmFsaWRhdG9yKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9ycztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBkZXRhaWxzIG9mIGEgc3BlY2lmaWMgdmFsaWRhdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCAtIFRoZSBuZXR3b3JrIElELlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSB1bmlxdWUgcHVibGljbHkgaWRlbnRpZmlhYmxlIGlkIG9mIHRoZSB2YWxpZGF0b3IgZm9yIHdoaWNoIHRvIGZldGNoIHRoZSBkYXRhLlxuICAgICAqIEByZXR1cm5zIFRoZSByZXF1ZXN0ZWQgdmFsaWRhdG9yIGRldGFpbHMuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZldGNoKG5ldHdvcmtJZCwgYXNzZXRJZCwgaWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc3Rha2UuZ2V0VmFsaWRhdG9yKG5ldHdvcmtJZCwgYXNzZXRJZCwgaWQpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbGlkYXRvcihyZXNwb25zZS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVmFsaWRhdG9yIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXMgLSBUaGUgQVBJIFZhbGlkYXRvciBzdGF0dXMuXG4gICAgICogQHJldHVybnMgVGhlIFZhbGlkYXRvciBzdGF0dXMuXG4gICAgICovXG4gICAgc3RhdGljIGdldEFQSVZhbGlkYXRvclN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuVU5LTk9XTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuVmFsaWRhdG9yU3RhdHVzLlVua25vd247XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLlBST1ZJU0lPTklORzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuVmFsaWRhdG9yU3RhdHVzLlByb3Zpc2lvbmluZztcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuUFJPVklTSU9ORUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5Qcm92aXNpb25lZDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuREVQT1NJVEVEOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuRGVwb3NpdGVkO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5QRU5ESU5HX0FDVElWQVRJT046XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5QZW5kaW5nQWN0aXZhdGlvbjtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuQUNUSVZFOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuQWN0aXZlO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5FWElUSU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuRXhpdGluZztcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuRVhJVEVEOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuRXhpdGVkO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5XSVRIRFJBV0FMX0FWQUlMQUJMRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuVmFsaWRhdG9yU3RhdHVzLldpdGhkcmF3YWxBdmFpbGFibGU7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLldJVEhEUkFXQUxfQ09NUExFVEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5XaXRoZHJhd2FsQ29tcGxldGU7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLkFDVElWRV9TTEFTSEVEOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuQWN0aXZlU2xhc2hlZDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuRVhJVEVEX1NMQVNIRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5FeGl0ZWRTbGFzaGVkO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5SRUFQRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5SZWFwZWQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuVW5rbm93bjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBWYWxpZGF0b3IgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVmFsaWRhdG9yIElELlxuICAgICAqL1xuICAgIGdldFZhbGlkYXRvcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC52YWxpZGF0b3JfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFZhbGlkYXRvciBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVmFsaWRhdG9yIHN0YXR1cy5cbiAgICAgKi9cbiAgICBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLlVua25vd246XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLlVOS05PV047XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5Qcm92aXNpb25pbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLlBST1ZJU0lPTklORztcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLlByb3Zpc2lvbmVkOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5QUk9WSVNJT05FRDtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLkRlcG9zaXRlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuREVQT1NJVEVEO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuUGVuZGluZ0FjdGl2YXRpb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLlBFTkRJTkdfQUNUSVZBVElPTjtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLkFjdGl2ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuQUNUSVZFO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuRXhpdGluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuRVhJVElORztcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLkV4aXRlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuRVhJVEVEO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuV2l0aGRyYXdhbEF2YWlsYWJsZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuV0lUSERSQVdBTF9BVkFJTEFCTEU7XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5XaXRoZHJhd2FsQ29tcGxldGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLldJVEhEUkFXQUxfQ09NUExFVEU7XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5BY3RpdmVTbGFzaGVkOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5BQ1RJVkVfU0xBU0hFRDtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLkV4aXRlZFNsYXNoZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLkVYSVRFRF9TTEFTSEVEO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuUmVhcGVkOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5SRUFQRUQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5VTktOT1dOO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5ldHdvcmsgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm5ldHdvcmtfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFzc2V0IElELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGFzc2V0IElELlxuICAgICAqL1xuICAgIGdldEFzc2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFzc2V0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3RpdmF0aW9uIGVwb2NoIG9mIHRoZSB2YWxpZGF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYWN0aXZhdGlvbiBlcG9jaCBhcyBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBnZXRBY3RpdmF0aW9uRXBvY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmRldGFpbHM/LmFjdGl2YXRpb25FcG9jaCB8fCBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiYWxhbmNlIG9mIHRoZSB2YWxpZGF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYmFsYW5jZSBvYmplY3QuXG4gICAgICovXG4gICAgZ2V0QmFsYW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZGV0YWlscz8uYmFsYW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIGJhbGFuY2Ugb2YgdGhlIHZhbGlkYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBlZmZlY3RpdmUgYmFsYW5jZSBvYmplY3QuXG4gICAgICovXG4gICAgZ2V0RWZmZWN0aXZlQmFsYW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZGV0YWlscz8uZWZmZWN0aXZlX2JhbGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV4aXQgZXBvY2ggb2YgdGhlIHZhbGlkYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBleGl0IGVwb2NoIGFzIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGdldEV4aXRFcG9jaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZGV0YWlscz8uZXhpdEVwb2NoIHx8IFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSB2YWxpZGF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsaWRhdG9yIGluZGV4IGFzIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGdldEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5kZXRhaWxzPy5pbmRleCB8fCBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwdWJsaWMga2V5IG9mIHRoZSB2YWxpZGF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsaWRhdG9yJ3MgcHVibGljIGtleSBhcyBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBnZXRQdWJsaWNLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmRldGFpbHM/LnB1YmxpY19rZXkgfHwgXCJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSB2YWxpZGF0b3IgaGFzIGJlZW4gc2xhc2hlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbGlkYXRvciBoYXMgYmVlbiBzbGFzaGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNTbGFzaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5kZXRhaWxzPy5zbGFzaGVkIHx8IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aXRoZHJhd2FibGUgZXBvY2ggb2YgdGhlIHZhbGlkYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB3aXRoZHJhd2FibGUgZXBvY2ggYXMgYSBzdHJpbmcuXG4gICAgICovXG4gICAgZ2V0V2l0aGRyYXdhYmxlRXBvY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmRldGFpbHM/LndpdGhkcmF3YWJsZUVwb2NoIHx8IFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpdGhkcmF3YWwgYWRkcmVzcyBvZiB0aGUgdmFsaWRhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHdpdGhkcmF3YWwgYWRkcmVzcyBhcyBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBnZXRXaXRoZHJhd2FsQWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZGV0YWlscz8ud2l0aGRyYXdhbF9hZGRyZXNzIHx8IFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsaWRhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsaWRhdG9yLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYElkOiAke3RoaXMuZ2V0VmFsaWRhdG9ySWQoKX0gU3RhdHVzOiAke3RoaXMuZ2V0U3RhdHVzKCl9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsaWRhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhbGlkYXRvci5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLm1vZGVsKTtcbiAgICB9XG59XG5leHBvcnRzLlZhbGlkYXRvciA9IFZhbGlkYXRvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/validator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Wallet = void 0;\nconst bip32_1 = __webpack_require__(/*! @scure/bip32 */ \"(ssr)/./node_modules/@scure/bip32/lib/index.js\");\nconst bip39_1 = __webpack_require__(/*! @scure/bip39 */ \"(ssr)/./node_modules/@scure/bip39/index.js\");\nconst english_1 = __webpack_require__(/*! @scure/bip39/wordlists/english */ \"(ssr)/./node_modules/@scure/bip39/wordlists/english.js\");\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.commonjs/index.js\");\nconst crypto = __importStar(__webpack_require__(/*! crypto */ \"crypto\"));\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst ethers_2 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.commonjs/index.js\");\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst secp256k1 = __importStar(__webpack_require__(/*! secp256k1 */ \"(ssr)/./node_modules/secp256k1/index.js\"));\nconst wallet_address_1 = __webpack_require__(/*! ./address/wallet_address */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js\");\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst balance_1 = __webpack_require__(/*! ./balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\");\nconst balance_map_1 = __webpack_require__(/*! ./balance_map */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst webhook_1 = __webpack_require__(/*! ./webhook */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js\");\n/**\n * A representation of a Wallet. Wallets come with a single default Address, but can expand to have a set of Addresses,\n * each of which can hold a balance of one or more Assets. Wallets can create new Addresses, list their addresses,\n * list their balances, and transfer Assets to other Addresses. Wallets should be created through User.createWallet or User.importWallet.\n * Wallets should be created using `Wallet.create`, imported using `Wallet.import`, or fetched using `Wallet.fetch`.\n * Existing wallets can be imported with a seed using `Wallet.import`.\n * Wallets backed by a Server Signer can be fetched with `Wallet.fetch` and used for signing operations immediately.\n */\nclass Wallet {\n    /**\n     * Private constructor to prevent direct instantiation outside of factory method. Use Wallet.init instead.\n     *\n     * @ignore\n     * @param model - The wallet model object.\n     * @param master - The HD master key.\n     * @param seed - The seed to use for the Wallet. Expects a 32-byte hexadecimal with no 0x prefix.\n     * @hideconstructor\n     */\n    constructor(model, master, seed) {\n        this.addresses = [];\n        this.addressPathPrefix = \"m/44'/60'/0'/0\";\n        this.model = model;\n        this.master = master;\n        this.seed = seed;\n    }\n    /**\n     * Lists the Wallets belonging to the CDP Project.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Wallets to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Wallets. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Wallets.\n     */\n    static async listWallets({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.wallet.listWallets(limit, page);\n        const wallets = response.data.data;\n        for (const wallet of wallets) {\n            data.push(Wallet.init(wallet, \"\"));\n        }\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Fetches a Wallet by its ID. The returned wallet can be immediately used for signing operations if backed by a server signer.\n     * If the wallet is not backed by a server signer, the wallet's seed will need to be set before it can be used for signing operations.\n     *\n     * @param wallet_id - The ID of the Wallet to fetch\n     * @returns The fetched Wallet\n     */\n    static async fetch(wallet_id) {\n        const response = await coinbase_1.Coinbase.apiClients.wallet.getWallet(wallet_id);\n        return Wallet.init(response.data, \"\");\n    }\n    /**\n     * Loads an existing CDP Wallet using a wallet data object or mnemonic seed phrase.\n     *\n     * @param data - The data used to import the wallet:\n     *   - If WalletData: Must contain walletId (or wallet_id) and seed.\n     *     Allows for the loading of an existing CDP wallet into CDP.\n     *   - If MnemonicSeedPhrase: Must contain a valid BIP-39 mnemonic phrase (12, 15, 18, 21, or 24 words).\n     *     Allows for the import of an external wallet into CDP as a 1-of-1 wallet.\n     * @param networkId - the ID of the blockchain network. Defaults to 'base-sepolia'.\n     * @returns A Promise that resolves to the loaded Wallet instance\n     * @throws {ArgumentError} If the data format is invalid.\n     * @throws {ArgumentError} If the seed is not provided.\n     * @throws {ArgumentError} If the mnemonic seed phrase is invalid.\n     */\n    static async import(data, networkId = coinbase_1.Coinbase.networks.BaseSepolia) {\n        // Check if data is a mnemonic seed phrase object\n        if ((0, types_1.isMnemonicSeedPhrase)(data)) {\n            // Handle mnemonic seed phrase object import\n            if (!data.mnemonicPhrase) {\n                throw new errors_1.ArgumentError(\"BIP-39 mnemonic seed phrase must be provided\");\n            }\n            if (!(0, bip39_1.validateMnemonic)(data.mnemonicPhrase, english_1.wordlist)) {\n                throw new errors_1.ArgumentError(\"Invalid BIP-39 mnemonic seed phrase\");\n            }\n            // Convert mnemonic phrase to seed\n            const seedBuffer = (0, bip39_1.mnemonicToSeedSync)(data.mnemonicPhrase);\n            const seed = (0, ethers_1.hexlify)(seedBuffer).slice(2); // remove 0x prefix\n            // Create wallet using the provided seed\n            const wallet = await Wallet.createWithSeed({\n                seed: seed,\n                networkId,\n            });\n            // Ensure the wallet is created\n            await wallet.listAddresses();\n            return wallet;\n        }\n        else if ((0, types_1.isWalletData)(data)) {\n            // Handle WalletData object import\n            const walletId = data.walletId || data.wallet_id;\n            if (!walletId) {\n                throw new errors_1.ArgumentError(\"Wallet ID must be provided\");\n            }\n            if (!data.seed) {\n                throw new errors_1.ArgumentError(\"Seed must be provided\");\n            }\n            const walletModel = await coinbase_1.Coinbase.apiClients.wallet.getWallet(walletId);\n            const wallet = Wallet.init(walletModel.data, data.seed);\n            await wallet.listAddresses();\n            return wallet;\n        }\n        else {\n            throw new errors_1.ArgumentError(\"Invalid import data format\");\n        }\n    }\n    /**\n     * Creates a new Wallet with a random seed.\n     *\n     * @constructs Wallet\n     * @param options - The options to create the Wallet.\n     * @param options.networkId - the ID of the blockchain network. Defaults to 'base-sepolia'.\n     * @param options.intervalSeconds - The interval at which to poll the backend, in seconds.\n     * @param options.timeoutSeconds - The maximum amount of time to wait for the ServerSigner to create a seed, in seconds.\n     * @throws {ArgumentError} If the model or client is not provided.\n     * @throws {Error} - If address derivation or caching fails.\n     * @throws {APIError} - If the request fails.\n     * @returns A promise that resolves with the new Wallet object.\n     */\n    static async create({ networkId = coinbase_1.Coinbase.networks.BaseSepolia, timeoutSeconds = 20, intervalSeconds = 0.2, } = {}) {\n        return Wallet.createWithSeed({\n            networkId,\n            timeoutSeconds,\n            intervalSeconds,\n        });\n    }\n    /**\n     * Creates a new Wallet with the given seed.\n     *\n     * @param options - The options to create the Wallet.\n     * @param options.seed - The seed to use for the Wallet. If undefined, a random seed will be generated.\n     * @param options.networkId - the ID of the blockchain network. Defaults to 'base-sepolia'.\n     * @param options.intervalSeconds - The interval at which to poll the backend, in seconds.\n     * @param options.timeoutSeconds - The maximum amount of time to wait for the ServerSigner to create a seed, in seconds.\n     * @throws {ArgumentError} If the model or client is not provided.\n     * @throws {Error} - If address derivation or caching fails.\n     * @throws {APIError} - If the request fails.\n     * @returns A promise that resolves with the new Wallet object.\n     */\n    static async createWithSeed({ seed = undefined, networkId = coinbase_1.Coinbase.networks.BaseSepolia, timeoutSeconds = 20, intervalSeconds = 0.2, } = {}) {\n        const result = await coinbase_1.Coinbase.apiClients.wallet.createWallet({\n            wallet: {\n                network_id: networkId,\n                use_server_signer: coinbase_1.Coinbase.useServerSigner,\n            },\n        });\n        const wallet = Wallet.init(result.data, seed);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            await wallet.waitForSigner(wallet.getId(), intervalSeconds, timeoutSeconds);\n        }\n        await wallet.createAddress();\n        return wallet;\n    }\n    /**\n     * Returns a new Wallet object. Do not use this method directly. Instead, use one of:\n     * - Wallet.create (Create a new Wallet),\n     * - Wallet.import (Import a Wallet with seed),\n     * - Wallet.fetch (fetch a Wallet by ID w/o seed, useful for server signer wallets).\n     *\n     * @constructs Wallet\n     * @param model - The underlying Wallet model object\n     * @param seed - The seed to use for the Wallet. Expects a 32-byte hexadecimal with no 0x prefix. If null or undefined, a new seed will be generated.\n     * If the empty string, no seed is generated, and the Wallet will be instantiated without a seed and its corresponding private keys.\n     * @throws {ArgumentError} If the model or client is not provided.\n     * @throws {Error} - If address derivation or caching fails.\n     * @throws {APIError} - If the request fails.\n     * @returns A promise that resolves with the new Wallet object.\n     */\n    static init(model, seed) {\n        const wallet = new Wallet(model, undefined, seed);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return wallet;\n        }\n        wallet.setMasterNode(seed);\n        return wallet;\n    }\n    /**\n     * Exports the Wallet's data to a WalletData object.\n     *\n     * @returns The Wallet's data.\n     * @throws {APIError} - If the request fails.\n     */\n    export() {\n        if (!this.seed) {\n            throw new Error(\"Cannot export Wallet without loaded seed\");\n        }\n        return {\n            walletId: this.getId(),\n            seed: this.seed,\n            networkId: this.getNetworkId(),\n        };\n    }\n    /**\n     * Creates a new Address in the Wallet.\n     *\n     * @returns The new Address.\n     * @throws {APIError} - If the address creation fails.\n     */\n    async createAddress() {\n        let payload, key;\n        if (!coinbase_1.Coinbase.useServerSigner) {\n            // TODO: Coordinate this value with concurrent calls to createAddress.\n            const addressIndex = this.addresses.length;\n            const hdKey = this.deriveKey(addressIndex);\n            const attestation = this.createAttestation(hdKey);\n            const publicKey = (0, utils_1.convertStringToHex)(hdKey.publicKey);\n            key = new ethers_2.ethers.Wallet((0, utils_1.convertStringToHex)(hdKey.privateKey));\n            payload = {\n                public_key: publicKey,\n                attestation: attestation,\n                address_index: addressIndex,\n            };\n        }\n        const response = await coinbase_1.Coinbase.apiClients.address.createAddress(this.model.id, payload);\n        if (!this.addresses.length || !coinbase_1.Coinbase.useServerSigner) {\n            await this.reload();\n        }\n        const address = new wallet_address_1.WalletAddress(response.data, key);\n        this.addresses.push(address);\n        return address;\n    }\n    /**\n     * Set the seed for the Wallet.\n     *\n     * @param seed - The seed to use for the Wallet. Expects a 32-byte hexadecimal with no 0x prefix.\n     * @throws {ArgumentError} If the seed is empty.\n     * @throws {Error} If the seed is already set.\n     */\n    setSeed(seed) {\n        if (seed === undefined || seed === \"\") {\n            throw new errors_1.ArgumentError(\"Seed must not be empty\");\n        }\n        if (this.master) {\n            throw new Error(\"Seed is already set\");\n        }\n        this.setMasterNode(seed);\n        if (this.addresses.length < 1) {\n            return;\n        }\n        this.addresses.forEach((address, index) => {\n            const derivedKey = this.deriveKey(index);\n            const etherWallet = new ethers_2.ethers.Wallet((0, utils_1.convertStringToHex)(derivedKey.privateKey));\n            if (etherWallet.address != address.getId()) {\n                throw new Error(`Seed does not match wallet; cannot find address ${etherWallet.address}`);\n            }\n            address.setKey(etherWallet);\n        });\n    }\n    /**\n     * Returns the WalletAddress with the given ID.\n     *\n     * @param addressId - The ID of the WalletAddress to retrieve.\n     * @returns The WalletAddress.\n     */\n    async getAddress(addressId) {\n        if (this.addresses.length < 1) {\n            this.addresses = await this.listAddresses();\n        }\n        return this.addresses.find(address => {\n            return address.getId() === addressId;\n        });\n    }\n    /**\n     * Returns the list of Addresses in the Wallet.\n     *\n     * @returns The list of Addresses.\n     */\n    async listAddresses() {\n        const response = await coinbase_1.Coinbase.apiClients.address.listAddresses(this.getId(), Wallet.MAX_ADDRESSES);\n        const addresses = response.data.data.map((address, index) => {\n            return this.buildWalletAddress(address, index);\n        });\n        this.addresses = addresses;\n        return addresses;\n    }\n    /**\n     *  Trades the given amount of the given Asset for another Asset.\n     *  Currently only the default address is used to source the Trade.\n     *\n     * @param options - The options to create the Trade.\n     * @param options.amount - The amount of the Asset to send.\n     * @param options.fromAssetId - The ID of the Asset to trade from.\n     * @param options.toAssetId - The ID of the Asset to trade to.\n     * @throws {Error} If the default address is not found.\n     * @throws {Error} If the private key is not loaded, or if the asset IDs are unsupported, or if there are insufficient funds.\n     * @returns The created Trade object.\n     */\n    async createTrade(options) {\n        return (await this.getDefaultAddress()).createTrade(options);\n    }\n    /**\n     * Get the stakeable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check the stakeable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the stakeable balance.\n     * @throws {Error} if the default address is not found.\n     * @returns The stakeable balance.\n     */\n    async stakeableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        return (await this.getDefaultAddress()).stakeableBalance(asset_id, mode, options);\n    }\n    /**\n     * Get the unstakeable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check the unstakeable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the unstakeable balance.\n     * @throws {Error} if the default address is not found.\n     * @returns The unstakeable balance.\n     */\n    async unstakeableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        return (await this.getDefaultAddress()).unstakeableBalance(asset_id, mode, options);\n    }\n    /**\n     * Get the claimable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check claimable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the claimable balance.\n     * @throws {Error} if the default address is not found.\n     * @returns The claimable balance.\n     */\n    async claimableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        return (await this.getDefaultAddress()).claimableBalance(asset_id, mode, options);\n    }\n    /**\n     * Lists the staking rewards for the address.\n     *\n     * @param assetId - The asset ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @param format - The format to return the rewards in. (usd, native). Defaults to usd.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking rewards.\n     */\n    async stakingRewards(assetId, startTime = (0, utils_1.getWeekBackDate)(new Date()), endTime = (0, utils_1.formatDate)(new Date()), format = types_1.StakingRewardFormat.USD) {\n        return (await this.getDefaultAddress()).stakingRewards(assetId, startTime, endTime, format);\n    }\n    /**\n     * Lists the historical staking balances for the address.\n     *\n     * @param assetId - The asset ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking balances.\n     */\n    async historicalStakingBalances(assetId, startTime = (0, utils_1.getWeekBackDate)(new Date()), endTime = (0, utils_1.formatDate)(new Date())) {\n        return (await this.getDefaultAddress()).historicalStakingBalances(assetId, startTime, endTime);\n    }\n    /**\n     * Lists the historical balances for a given asset belonging to the default address of the wallet.\n     *\n     * @param assetId - The asset ID.\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Historical Balances to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Historical Balances. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Historical Balances for the given Asset ID.\n     */\n    async listHistoricalBalances(assetId, { limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined } = {}) {\n        return (await this.getDefaultAddress()).listHistoricalBalances(assetId, { limit, page });\n    }\n    /**\n     * Creates a staking operation to stake, signs it, and broadcasts it on the blockchain.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking operation after it's completed fully.\n     */\n    async createStake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 60, intervalSeconds = 0.2) {\n        return (await this.getDefaultAddress()).createStake(amount, assetId, mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a staking operation to unstake, signs it, and broadcasts it on the blockchain.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking operation after it's completed successfully.\n     */\n    async createUnstake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 60, intervalSeconds = 0.2) {\n        return (await this.getDefaultAddress()).createUnstake(amount, assetId, mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a staking operation to claim stake, signs it, and broadcasts it on the blockchain.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking operation after it's completed fully.\n     */\n    async createClaimStake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 60, intervalSeconds = 0.2) {\n        return (await this.getDefaultAddress()).createClaimStake(amount, assetId, mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Returns the list of balances of this Wallet. Balances are aggregated across all Addresses in the Wallet.\n     *\n     * @returns The list of balances. The key is the Asset ID, and the value is the balance.\n     */\n    async listBalances() {\n        const response = await coinbase_1.Coinbase.apiClients.wallet.listWalletBalances(this.model.id);\n        return balance_map_1.BalanceMap.fromBalances(response.data.data);\n    }\n    /**\n     * Returns the balance of the provided Asset. Balances are aggregated across all Addresses in the Wallet.\n     *\n     * @param assetId - The ID of the Asset to retrieve the balance for.\n     * @returns The balance of the Asset.\n     */\n    async getBalance(assetId) {\n        const response = await coinbase_1.Coinbase.apiClients.wallet.getWalletBalance(this.model.id, asset_1.Asset.primaryDenomination(assetId));\n        if (!response.data.amount) {\n            return new decimal_js_1.default(0);\n        }\n        const balance = balance_1.Balance.fromModelAndAssetId(response.data, assetId);\n        return balance.amount;\n    }\n    /**\n     * Returns the Network ID of the Wallet.\n     *\n     * @returns The network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the ServerSigner Status of the Wallet.\n     *\n     * @returns the ServerSigner Status.\n     */\n    getServerSignerStatus() {\n        const status = {\n            pending_seed_creation: types_1.ServerSignerStatus.PENDING,\n            active_seed: types_1.ServerSignerStatus.ACTIVE,\n        };\n        return this.model.server_signer_status ? status[this.model.server_signer_status] : undefined;\n    }\n    /**\n     * Returns the wallet ID.\n     *\n     * @returns The wallet ID.\n     */\n    getId() {\n        return this.model.id;\n    }\n    /**\n     * Saves the seed of the Wallet to the given file.\n     *\n     * @deprecated Use saveSeedToFile() instead\n     * @param filePath - The path of the file to save the seed to\n     * @param encrypt - Whether the seed information persisted to the local file system should be\n     * encrypted or not. Data is unencrypted by default.\n     * @returns A string indicating the success of the operation\n     * @throws {Error} If the Wallet does not have a seed\n     */\n    saveSeed(filePath, encrypt = false) {\n        return this.saveSeedToFile(filePath, encrypt);\n    }\n    /**\n     * Saves the seed of the Wallet to the given file. Wallets whose seeds are saved this way can be\n     * rehydrated using load_seed. A single file can be used for multiple Wallet seeds.\n     * This is an insecure method of storing Wallet seeds and should only be used for development purposes.\n     *\n     * @param filePath - The path of the file to save the seed to\n     * @param encrypt - Whether the seed information persisted to the local file system should be\n     * encrypted or not. Data is unencrypted by default.\n     * @returns A string indicating the success of the operation\n     * @throws {Error} If the Wallet does not have a seed\n     */\n    saveSeedToFile(filePath, encrypt = false) {\n        if (!this.master) {\n            throw new Error(\"Cannot save Wallet without loaded seed\");\n        }\n        const existingSeedsInStore = this.getExistingSeeds(filePath);\n        const data = this.export();\n        let seedToStore = data.seed;\n        let authTag = \"\";\n        let iv = \"\";\n        if (encrypt) {\n            const ivBytes = crypto.randomBytes(12);\n            const sharedSecret = this.getEncryptionKey();\n            const cipher = crypto.createCipheriv(\"aes-256-gcm\", crypto.createHash(\"sha256\").update(sharedSecret).digest(), ivBytes);\n            const encryptedData = Buffer.concat([cipher.update(data.seed, \"utf8\"), cipher.final()]);\n            authTag = cipher.getAuthTag().toString(\"hex\");\n            seedToStore = encryptedData.toString(\"hex\");\n            iv = ivBytes.toString(\"hex\");\n        }\n        existingSeedsInStore[data.walletId] = {\n            seed: seedToStore,\n            encrypted: encrypt,\n            authTag: authTag,\n            iv: iv,\n            networkId: data.networkId,\n        };\n        fs.writeFileSync(filePath, JSON.stringify(existingSeedsInStore, null, 2), \"utf8\");\n        return `Successfully saved seed for ${data.walletId} to ${filePath}.`;\n    }\n    /**\n     * Loads the seed of the Wallet from the given file.\n     *\n     * @deprecated Use loadSeedFromFile() instead\n     * @param filePath - The path of the file to load the seed from\n     * @returns A string indicating the success of the operation\n     */\n    async loadSeed(filePath) {\n        return this.loadSeedFromFile(filePath);\n    }\n    /**\n     * Loads the seed of the Wallet from the given file.\n     *\n     * @param filePath - The path of the file to load the seed from\n     * @returns A string indicating the success of the operation\n     */\n    async loadSeedFromFile(filePath) {\n        const existingSeedsInStore = this.getExistingSeeds(filePath);\n        if (Object.keys(existingSeedsInStore).length === 0) {\n            throw new errors_1.ArgumentError(`File ${filePath} does not contain any seed data`);\n        }\n        if (existingSeedsInStore[this.getId()] === undefined) {\n            throw new errors_1.ArgumentError(`File ${filePath} does not contain seed data for wallet ${this.getId()}`);\n        }\n        const seedData = existingSeedsInStore[this.getId()];\n        let seed = seedData.seed;\n        if (!seed) {\n            /* istanbul ignore next */\n            throw new errors_1.ArgumentError(\"Seed data is malformed\");\n        }\n        if (seedData.encrypted) {\n            const sharedSecret = this.getEncryptionKey();\n            if (!seedData.iv || !seedData.authTag) {\n                /* istanbul ignore next */\n                throw new errors_1.ArgumentError(\"Encrypted seed data is malformed\");\n            }\n            const decipher = crypto.createDecipheriv(\"aes-256-gcm\", crypto.createHash(\"sha256\").update(sharedSecret).digest(), Buffer.from(seedData.iv, \"hex\"));\n            decipher.setAuthTag(Buffer.from(seedData.authTag, \"hex\"));\n            const decryptedData = Buffer.concat([\n                decipher.update(Buffer.from(seed, \"hex\")),\n                decipher.final(),\n            ]);\n            seed = decryptedData.toString(\"utf8\");\n        }\n        this.setSeed(seed);\n        await this.listAddresses();\n        return `Successfully loaded seed for wallet ${this.getId()} from ${filePath}.`;\n    }\n    /**\n     * Returns the default address of the Wallet.\n     *\n     * @returns The default address\n     */\n    async getDefaultAddress() {\n        if (this.model.default_address === undefined) {\n            throw new Error(\"WalletModel default address not set\");\n        }\n        const defaultAddress = await this.getAddress(this.model.default_address.address_id);\n        if (!defaultAddress) {\n            throw new Error(\"Default address not found\");\n        }\n        return defaultAddress;\n    }\n    /**\n     * Returns whether the Wallet has a seed with which to derive keys and sign transactions.\n     *\n     * @returns Whether the Wallet has a seed with which to derive keys and sign transactions.\n     */\n    canSign() {\n        return this.master?.publicKey !== undefined;\n    }\n    /**\n     * Requests funds from the faucet for the Wallet's default address and returns the faucet transaction.\n     * This is only supported on testnet networks.\n     *\n     * @param assetId - The ID of the Asset to request from the faucet.\n     * @throws {Error} If the default address is not found.\n     * @throws {APIError} If the request fails.\n     * @returns The successful faucet transaction\n     */\n    async faucet(assetId) {\n        if (!this.model.default_address) {\n            throw new Error(\"Default address not found\");\n        }\n        const transaction = (await this.getDefaultAddress()).faucet(assetId);\n        return transaction;\n    }\n    /**\n     * Transfers the given amount of the given Asset to the given address. Only same-Network Transfers are supported.\n     * Currently only the default_address is used to source the Transfer.\n     *\n     * @param options - The options to create the Transfer.\n     * @param options.amount - The amount of the Asset to send.\n     * @param options.assetId - The ID of the Asset to send.\n     * @param options.destination - The destination of the transfer. If a Wallet, sends to the Wallet's default address. If a String, interprets it as the address ID.\n     * @param options.gasless - Whether the Transfer should be gasless. Defaults to false.\n     * @param options.skipBatching - When true, the Transfer will be submitted immediately. Otherwise, the Transfer will be batched. Defaults to false. Note: requires gasless option to be set to true.\n     * @returns The created Transfer object.\n     * @throws {APIError} if the API request to create a Transfer fails.\n     * @throws {APIError} if the API request to broadcast a Transfer fails.\n     */\n    async createTransfer(options) {\n        return (await this.getDefaultAddress()).createTransfer(options);\n    }\n    /**\n     * Creates a Payload Signature.\n     *\n     * @param unsignedPayload - The Unsigned Payload to sign.\n     * @returns A promise that resolves to the Payload Signature object.\n     * @throws {APIError} if the API request to create a Payload Signature fails.\n     * @throws {Error} if the default address is not found.\n     */\n    async createPayloadSignature(unsignedPayload) {\n        return (await this.getDefaultAddress()).createPayloadSignature(unsignedPayload);\n    }\n    /**\n     * Creates a Webhook for a wallet, monitors all wallet addresses for onchain events.\n     *\n     * @param notificationUri - The URI to which the webhook notifications will be sent.\n     *\n     * @returns The newly created webhook instance.\n     */\n    async createWebhook(notificationUri) {\n        const result = await coinbase_1.Coinbase.apiClients.webhook.createWalletWebhook(this.getId(), {\n            notification_uri: notificationUri,\n        });\n        return webhook_1.Webhook.init(result.data);\n    }\n    /**\n     * Invokes a contract with the given data.\n     *\n     * @param options - The options to invoke the contract\n     * @param options.contractAddress - The address of the contract the method will be invoked on.\n     * @param options.method - The method to invoke on the contract.\n     * @param options.abi - The ABI of the contract.\n     * @param options.args - The arguments to pass to the contract method invocation.\n     *   The keys should be the argument names and the values should be the argument values.\n     * @param options.amount - The amount of the asset to send to a payable contract method.\n     * @param options.assetId - The ID of the asset to send to a payable contract method.\n     *   The asset must be a denomination of the native asset. (Ex. \"wei\", \"gwei\", or \"eth\").\n     * @returns The ContractInvocation object.\n     * @throws {APIError} if the API request to create a contract invocation fails.\n     */\n    async invokeContract(options) {\n        return (await this.getDefaultAddress()).invokeContract(options);\n    }\n    /**\n     * Deploys an ERC20 token contract.\n     *\n     * @param options - The options for creating the ERC20 token.\n     * @param options.name - The name of the ERC20 token.\n     * @param options.symbol - The symbol of the ERC20 token.\n     * @param options.totalSupply - The total supply of the ERC20 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {Error} If the private key is not loaded when not using server signer.\n     */\n    async deployToken(options) {\n        return (await this.getDefaultAddress()).deployToken(options);\n    }\n    /**\n     * Deploys an ERC721 token contract.\n     *\n     * @param options - The options for creating the ERC721 token.\n     * @param options.name - The name of the ERC721 token.\n     * @param options.symbol - The symbol of the ERC721 token.\n     * @param options.baseURI - The base URI of the ERC721 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {Error} If the private key is not loaded when not using server signer.\n     */\n    async deployNFT(options) {\n        return (await this.getDefaultAddress()).deployNFT(options);\n    }\n    /**\n     * Deploys an ERC1155 token contract.\n     *\n     * @param options - The options for creating the ERC1155 token.\n     * @param options.name - The name of the ERC1155 token.\n     * @param options.symbol - The symbol of the ERC1155 token.\n     * @param options.baseURI - The base URI of the ERC1155 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {Error} If the private key is not loaded when not using server signer.\n     */\n    async deployMultiToken(options) {\n        return (await this.getDefaultAddress()).deployMultiToken(options);\n    }\n    /**\n     * Deploys a custom contract.\n     *\n     * @param options - The options for creating the custom contract.\n     * @param options.solidityVersion - The version of the solidity compiler, must be 0.8.+, such as \"0.8.28+commit.7893614a\". See https://binaries.soliditylang.org/bin/list.json\n     * @param options.solidityInputJson - The input json for the solidity compiler. See https://docs.soliditylang.org/en/latest/using-the-compiler.html#input-description for more details.\n     * @param options.contractName - The name of the contract class to be deployed.\n     * @param options.constructorArgs - The arguments for the constructor.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {Error} If the private key is not loaded when not using server signer.\n     */\n    async deployContract(options) {\n        return (await this.getDefaultAddress()).deployContract(options);\n    }\n    /**\n     * Fund the wallet from your account on the Coinbase Platform.\n     *\n     * @param options - The options to create the fund operation\n     * @param options.amount - The amount of the Asset to fund the wallet with\n     * @param options.assetId - The ID of the Asset to fund with. For Ether, eth, gwei, and wei are supported.\n     * @returns The created fund operation object\n     * @throws {Error} If the default address does not exist\n     */\n    async fund(options) {\n        const defaultAddress = await this.getDefaultAddress();\n        if (!defaultAddress) {\n            throw new Error(\"Default address does not exist\");\n        }\n        return defaultAddress.fund(options);\n    }\n    /**\n     * Get a quote for funding the wallet from your Coinbase platform account.\n     *\n     * @param options - The options to create the fund quote\n     * @param options.amount - The amount to fund\n     * @param options.assetId - The ID of the Asset to fund with. For Ether, eth, gwei, and wei are supported.\n     * @returns The fund quote object\n     * @throws {Error} If the default address does not exist\n     */\n    async quoteFund(options) {\n        const defaultAddress = await this.getDefaultAddress();\n        if (!defaultAddress) {\n            throw new Error(\"Default address does not exist\");\n        }\n        return defaultAddress.quoteFund(options);\n    }\n    /**\n     * Returns all the fund operations associated with the wallet's default address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of fund operations to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of fund operations. Don't include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     * @returns The paginated list response of fund operations.\n     * @throws {Error} If the default address does not exist\n     */\n    async listFundOperations({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const defaultAddress = await this.getDefaultAddress();\n        if (!defaultAddress) {\n            throw new Error(\"Default address does not exist\");\n        }\n        return defaultAddress.listFundOperations({ limit, page });\n    }\n    /**\n     * Returns a String representation of the Wallet.\n     *\n     * @returns a String representation of the Wallet\n     */\n    toString() {\n        return `Wallet{id: '${this.model.id}', networkId: '${this.model.network_id}'}`;\n    }\n    /**\n     * Validates the seed and address models passed to the constructor.\n     *\n     * @param seed - The seed to use for the Wallet\n     */\n    validateSeed(seed) {\n        if (seed && seed.length !== 64 && seed.length !== 128) {\n            throw new errors_1.ArgumentError(\"Seed must be 32 or 64 bytes\");\n        }\n    }\n    /**\n     * Loads the seed data from the given file.\n     *\n     * @param filePath - The path of the file to load the seed data from\n     * @returns The seed data\n     */\n    getExistingSeeds(filePath) {\n        try {\n            const data = fs.readFileSync(filePath, \"utf8\");\n            if (!data) {\n                return {};\n            }\n            const seedData = JSON.parse(data);\n            if (!Object.entries(seedData).every(([key, value]) => typeof key === \"string\" &&\n                /* eslint-disable @typescript-eslint/no-explicit-any */\n                typeof value.authTag === \"string\" &&\n                typeof value.encrypted === \"boolean\" &&\n                typeof value.iv === \"string\" &&\n                typeof value.seed === \"string\")) {\n                throw new errors_1.ArgumentError(\"Malformed backup data\");\n            }\n            return seedData;\n        }\n        catch (error) {\n            /* eslint-enable @typescript-eslint/no-explicit-any */\n            if (error.code === \"ENOENT\") {\n                return {};\n            }\n            throw new errors_1.ArgumentError(\"Malformed backup data\");\n        }\n    }\n    /**\n     * Gets the key for encrypting seed data.\n     *\n     * @returns The encryption key.\n     */\n    getEncryptionKey() {\n        const privateKey = crypto.createPrivateKey(coinbase_1.Coinbase.apiKeyPrivateKey);\n        const publicKey = crypto.createPublicKey(coinbase_1.Coinbase.apiKeyPrivateKey);\n        const encryptionKey = crypto.diffieHellman({\n            privateKey,\n            publicKey,\n        });\n        return encryptionKey;\n    }\n    /**\n     * Returns a WalletAddress object for the given AddressModel.\n     *\n     * @param addressModel - The AddressModel to build the WalletAddress from.\n     * @param index - The index of the AddressModel.\n     * @returns The WalletAddress object.\n     */\n    buildWalletAddress(addressModel, index) {\n        if (!this.master) {\n            return new wallet_address_1.WalletAddress(addressModel);\n        }\n        const key = this.deriveKey(index);\n        const ethWallet = new ethers_2.ethers.Wallet((0, utils_1.convertStringToHex)(key.privateKey));\n        if (ethWallet.address != addressModel.address_id) {\n            throw new Error(`Seed does not match wallet`);\n        }\n        return new wallet_address_1.WalletAddress(addressModel, ethWallet);\n    }\n    /**\n     * Waits until the ServerSigner has created a seed for the Wallet.\n     *\n     * @param walletId - The ID of the Wallet that is awaiting seed creation.\n     * @param intervalSeconds - The interval at which to poll the CDPService, in seconds.\n     * @param timeoutSeconds - The maximum amount of time to wait for the ServerSigner to create a seed, in seconds.\n     * @throws {APIError} if the API request to get a Wallet fails.\n     * @throws {Error} if the ServerSigner times out.\n     */\n    async waitForSigner(walletId, intervalSeconds = 0.2, timeoutSeconds = 20) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            const response = await coinbase_1.Coinbase.apiClients.wallet.getWallet(walletId);\n            if (response?.data.server_signer_status === types_1.ServerSignerStatus.ACTIVE) {\n                return;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new Error(\"Wallet creation timed out. Check status of your Server-Signer\");\n    }\n    /**\n     * Sets the master node for the given seed, if valid. If the seed is undefined it will set the master node using a random seed.\n     *\n     * @param seed - The seed to use for the Wallet.\n     * @returns The master node for the given seed.\n     */\n    setMasterNode(seed) {\n        if (seed === \"\") {\n            return undefined;\n        }\n        if (seed === undefined) {\n            seed = ethers_2.ethers.Wallet.createRandom().privateKey.slice(2);\n        }\n        this.validateSeed(seed);\n        this.seed = seed;\n        this.master = bip32_1.HDKey.fromMasterSeed(Buffer.from(seed, \"hex\"));\n    }\n    /**\n     * Derives a key for an already registered Address in the Wallet.\n     *\n     * @param index - The index of the Address to derive.\n     * @throws {Error} - If the key derivation fails.\n     * @returns The derived key.\n     */\n    deriveKey(index) {\n        if (!this.master) {\n            throw new Error(\"Cannot derive key for Wallet without seed loaded\");\n        }\n        const derivedKey = this.master?.derive(this.addressPathPrefix + `/${index}`);\n        if (!derivedKey?.privateKey) {\n            throw new Error(\"Failed to derive key\");\n        }\n        return derivedKey;\n    }\n    /**\n     * Creates an attestation for the Address currently being created.\n     *\n     * @param key - The key of the Wallet.\n     * @returns The attestation.\n     */\n    createAttestation(key) {\n        if (!key.publicKey || !key.privateKey) {\n            /* istanbul ignore next */\n            throw Error;\n        }\n        const publicKey = (0, utils_1.convertStringToHex)(key.publicKey);\n        const payload = JSON.stringify({\n            wallet_id: this.model.id,\n            public_key: publicKey,\n        });\n        const hashedPayload = crypto.createHash(\"sha256\").update(payload).digest();\n        const signature = secp256k1.ecdsaSign(hashedPayload, key.privateKey);\n        const r = signature.signature.slice(0, 32);\n        const s = signature.signature.slice(32, 64);\n        const v = signature.recid + 27 + 4;\n        const newSignatureBuffer = Buffer.concat([Buffer.from([v]), r, s]);\n        const newSignatureHex = newSignatureBuffer.toString(\"hex\");\n        return newSignatureHex;\n    }\n    /**\n     * Reloads the Wallet model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a Wallet fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.wallet.getWallet(this.model.id);\n        this.model = result?.data;\n    }\n}\nexports.Wallet = Wallet;\nWallet.MAX_ADDRESSES = 20;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3dhbGxldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQWM7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsZ0VBQWM7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsOEZBQWdDO0FBQzFELGlCQUFpQixtQkFBTyxDQUFDLGlFQUFRO0FBQ2pDLDRCQUE0QixtQkFBTyxDQUFDLHNCQUFRO0FBQzVDLHFDQUFxQyxtQkFBTyxDQUFDLDhEQUFZO0FBQ3pELGlCQUFpQixtQkFBTyxDQUFDLGlFQUFRO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLGNBQUk7QUFDcEMsK0JBQStCLG1CQUFPLENBQUMsMERBQVc7QUFDbEQseUJBQXlCLG1CQUFPLENBQUMscUhBQTBCO0FBQzNELGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFXO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLCtGQUFlO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFVO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0VBQWtFLElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCLG9HQUFvRyxJQUFJO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQSxrQ0FBa0Msc0hBQXNILElBQUk7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxzQkFBc0Isb0JBQW9CO0FBQ3ZHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpRUFBaUUsSUFBSTtBQUNqSCxrRkFBa0YsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxlQUFlLEtBQUssU0FBUztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBLHFEQUFxRCxVQUFVLHdDQUF3QyxhQUFhO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsY0FBYyxPQUFPLFNBQVM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsK0JBQStCLGtFQUFrRSxJQUFJO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTyxjQUFjLGlCQUFpQixzQkFBc0IsRUFBRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsTUFBTTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3dhbGxldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XYWxsZXQgPSB2b2lkIDA7XG5jb25zdCBiaXAzMl8xID0gcmVxdWlyZShcIkBzY3VyZS9iaXAzMlwiKTtcbmNvbnN0IGJpcDM5XzEgPSByZXF1aXJlKFwiQHNjdXJlL2JpcDM5XCIpO1xuY29uc3QgZW5nbGlzaF8xID0gcmVxdWlyZShcIkBzY3VyZS9iaXAzOS93b3JkbGlzdHMvZW5nbGlzaFwiKTtcbmNvbnN0IGV0aGVyc18xID0gcmVxdWlyZShcImV0aGVyc1wiKTtcbmNvbnN0IGNyeXB0byA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVjaW1hbC5qc1wiKSk7XG5jb25zdCBldGhlcnNfMiA9IHJlcXVpcmUoXCJldGhlcnNcIik7XG5jb25zdCBmcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZnNcIikpO1xuY29uc3Qgc2VjcDI1NmsxID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzZWNwMjU2azFcIikpO1xuY29uc3Qgd2FsbGV0X2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3Mvd2FsbGV0X2FkZHJlc3NcIik7XG5jb25zdCBhc3NldF8xID0gcmVxdWlyZShcIi4vYXNzZXRcIik7XG5jb25zdCBiYWxhbmNlXzEgPSByZXF1aXJlKFwiLi9iYWxhbmNlXCIpO1xuY29uc3QgYmFsYW5jZV9tYXBfMSA9IHJlcXVpcmUoXCIuL2JhbGFuY2VfbWFwXCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCB3ZWJob29rXzEgPSByZXF1aXJlKFwiLi93ZWJob29rXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgV2FsbGV0LiBXYWxsZXRzIGNvbWUgd2l0aCBhIHNpbmdsZSBkZWZhdWx0IEFkZHJlc3MsIGJ1dCBjYW4gZXhwYW5kIHRvIGhhdmUgYSBzZXQgb2YgQWRkcmVzc2VzLFxuICogZWFjaCBvZiB3aGljaCBjYW4gaG9sZCBhIGJhbGFuY2Ugb2Ygb25lIG9yIG1vcmUgQXNzZXRzLiBXYWxsZXRzIGNhbiBjcmVhdGUgbmV3IEFkZHJlc3NlcywgbGlzdCB0aGVpciBhZGRyZXNzZXMsXG4gKiBsaXN0IHRoZWlyIGJhbGFuY2VzLCBhbmQgdHJhbnNmZXIgQXNzZXRzIHRvIG90aGVyIEFkZHJlc3Nlcy4gV2FsbGV0cyBzaG91bGQgYmUgY3JlYXRlZCB0aHJvdWdoIFVzZXIuY3JlYXRlV2FsbGV0IG9yIFVzZXIuaW1wb3J0V2FsbGV0LlxuICogV2FsbGV0cyBzaG91bGQgYmUgY3JlYXRlZCB1c2luZyBgV2FsbGV0LmNyZWF0ZWAsIGltcG9ydGVkIHVzaW5nIGBXYWxsZXQuaW1wb3J0YCwgb3IgZmV0Y2hlZCB1c2luZyBgV2FsbGV0LmZldGNoYC5cbiAqIEV4aXN0aW5nIHdhbGxldHMgY2FuIGJlIGltcG9ydGVkIHdpdGggYSBzZWVkIHVzaW5nIGBXYWxsZXQuaW1wb3J0YC5cbiAqIFdhbGxldHMgYmFja2VkIGJ5IGEgU2VydmVyIFNpZ25lciBjYW4gYmUgZmV0Y2hlZCB3aXRoIGBXYWxsZXQuZmV0Y2hgIGFuZCB1c2VkIGZvciBzaWduaW5nIG9wZXJhdGlvbnMgaW1tZWRpYXRlbHkuXG4gKi9cbmNsYXNzIFdhbGxldCB7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IGRpcmVjdCBpbnN0YW50aWF0aW9uIG91dHNpZGUgb2YgZmFjdG9yeSBtZXRob2QuIFVzZSBXYWxsZXQuaW5pdCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSB3YWxsZXQgbW9kZWwgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBtYXN0ZXIgLSBUaGUgSEQgbWFzdGVyIGtleS5cbiAgICAgKiBAcGFyYW0gc2VlZCAtIFRoZSBzZWVkIHRvIHVzZSBmb3IgdGhlIFdhbGxldC4gRXhwZWN0cyBhIDMyLWJ5dGUgaGV4YWRlY2ltYWwgd2l0aCBubyAweCBwcmVmaXguXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsLCBtYXN0ZXIsIHNlZWQpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRyZXNzUGF0aFByZWZpeCA9IFwibS80NCcvNjAnLzAnLzBcIjtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLm1hc3RlciA9IG1hc3RlcjtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIFdhbGxldHMgYmVsb25naW5nIHRvIHRoZSBDRFAgUHJvamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBXYWxsZXRzIHRvIHJldHVybi4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhZ2UgLSBUaGUgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiBXYWxsZXRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHQgcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhZ2luYXRlZCBsaXN0IHJlc3BvbnNlIG9mIFdhbGxldHMuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGxpc3RXYWxsZXRzKHsgbGltaXQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLmRlZmF1bHRQYWdlTGltaXQsIHBhZ2UgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGxldCBuZXh0UGFnZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0Lmxpc3RXYWxsZXRzKGxpbWl0LCBwYWdlKTtcbiAgICAgICAgY29uc3Qgd2FsbGV0cyA9IHJlc3BvbnNlLmRhdGEuZGF0YTtcbiAgICAgICAgZm9yIChjb25zdCB3YWxsZXQgb2Ygd2FsbGV0cykge1xuICAgICAgICAgICAgZGF0YS5wdXNoKFdhbGxldC5pbml0KHdhbGxldCwgXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc01vcmUgPSByZXNwb25zZS5kYXRhLmhhc19tb3JlO1xuICAgICAgICBpZiAoaGFzTW9yZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBhZ2UgPSByZXNwb25zZS5kYXRhLm5leHRfcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGhhc01vcmUsXG4gICAgICAgICAgICBuZXh0UGFnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIFdhbGxldCBieSBpdHMgSUQuIFRoZSByZXR1cm5lZCB3YWxsZXQgY2FuIGJlIGltbWVkaWF0ZWx5IHVzZWQgZm9yIHNpZ25pbmcgb3BlcmF0aW9ucyBpZiBiYWNrZWQgYnkgYSBzZXJ2ZXIgc2lnbmVyLlxuICAgICAqIElmIHRoZSB3YWxsZXQgaXMgbm90IGJhY2tlZCBieSBhIHNlcnZlciBzaWduZXIsIHRoZSB3YWxsZXQncyBzZWVkIHdpbGwgbmVlZCB0byBiZSBzZXQgYmVmb3JlIGl0IGNhbiBiZSB1c2VkIGZvciBzaWduaW5nIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0X2lkIC0gVGhlIElEIG9mIHRoZSBXYWxsZXQgdG8gZmV0Y2hcbiAgICAgKiBAcmV0dXJucyBUaGUgZmV0Y2hlZCBXYWxsZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZmV0Y2god2FsbGV0X2lkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndhbGxldC5nZXRXYWxsZXQod2FsbGV0X2lkKTtcbiAgICAgICAgcmV0dXJuIFdhbGxldC5pbml0KHJlc3BvbnNlLmRhdGEsIFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbiBleGlzdGluZyBDRFAgV2FsbGV0IHVzaW5nIGEgd2FsbGV0IGRhdGEgb2JqZWN0IG9yIG1uZW1vbmljIHNlZWQgcGhyYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB1c2VkIHRvIGltcG9ydCB0aGUgd2FsbGV0OlxuICAgICAqICAgLSBJZiBXYWxsZXREYXRhOiBNdXN0IGNvbnRhaW4gd2FsbGV0SWQgKG9yIHdhbGxldF9pZCkgYW5kIHNlZWQuXG4gICAgICogICAgIEFsbG93cyBmb3IgdGhlIGxvYWRpbmcgb2YgYW4gZXhpc3RpbmcgQ0RQIHdhbGxldCBpbnRvIENEUC5cbiAgICAgKiAgIC0gSWYgTW5lbW9uaWNTZWVkUGhyYXNlOiBNdXN0IGNvbnRhaW4gYSB2YWxpZCBCSVAtMzkgbW5lbW9uaWMgcGhyYXNlICgxMiwgMTUsIDE4LCAyMSwgb3IgMjQgd29yZHMpLlxuICAgICAqICAgICBBbGxvd3MgZm9yIHRoZSBpbXBvcnQgb2YgYW4gZXh0ZXJuYWwgd2FsbGV0IGludG8gQ0RQIGFzIGEgMS1vZi0xIHdhbGxldC5cbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIC0gdGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuIERlZmF1bHRzIHRvICdiYXNlLXNlcG9saWEnLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBsb2FkZWQgV2FsbGV0IGluc3RhbmNlXG4gICAgICogQHRocm93cyB7QXJndW1lbnRFcnJvcn0gSWYgdGhlIGRhdGEgZm9ybWF0IGlzIGludmFsaWQuXG4gICAgICogQHRocm93cyB7QXJndW1lbnRFcnJvcn0gSWYgdGhlIHNlZWQgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEB0aHJvd3Mge0FyZ3VtZW50RXJyb3J9IElmIHRoZSBtbmVtb25pYyBzZWVkIHBocmFzZSBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBpbXBvcnQoZGF0YSwgbmV0d29ya0lkID0gY29pbmJhc2VfMS5Db2luYmFzZS5uZXR3b3Jrcy5CYXNlU2Vwb2xpYSkge1xuICAgICAgICAvLyBDaGVjayBpZiBkYXRhIGlzIGEgbW5lbW9uaWMgc2VlZCBwaHJhc2Ugb2JqZWN0XG4gICAgICAgIGlmICgoMCwgdHlwZXNfMS5pc01uZW1vbmljU2VlZFBocmFzZSkoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtbmVtb25pYyBzZWVkIHBocmFzZSBvYmplY3QgaW1wb3J0XG4gICAgICAgICAgICBpZiAoIWRhdGEubW5lbW9uaWNQaHJhc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcIkJJUC0zOSBtbmVtb25pYyBzZWVkIHBocmFzZSBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoMCwgYmlwMzlfMS52YWxpZGF0ZU1uZW1vbmljKShkYXRhLm1uZW1vbmljUGhyYXNlLCBlbmdsaXNoXzEud29yZGxpc3QpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoXCJJbnZhbGlkIEJJUC0zOSBtbmVtb25pYyBzZWVkIHBocmFzZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbnZlcnQgbW5lbW9uaWMgcGhyYXNlIHRvIHNlZWRcbiAgICAgICAgICAgIGNvbnN0IHNlZWRCdWZmZXIgPSAoMCwgYmlwMzlfMS5tbmVtb25pY1RvU2VlZFN5bmMpKGRhdGEubW5lbW9uaWNQaHJhc2UpO1xuICAgICAgICAgICAgY29uc3Qgc2VlZCA9ICgwLCBldGhlcnNfMS5oZXhsaWZ5KShzZWVkQnVmZmVyKS5zbGljZSgyKTsgLy8gcmVtb3ZlIDB4IHByZWZpeFxuICAgICAgICAgICAgLy8gQ3JlYXRlIHdhbGxldCB1c2luZyB0aGUgcHJvdmlkZWQgc2VlZFxuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgV2FsbGV0LmNyZWF0ZVdpdGhTZWVkKHtcbiAgICAgICAgICAgICAgICBzZWVkOiBzZWVkLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSB3YWxsZXQgaXMgY3JlYXRlZFxuICAgICAgICAgICAgYXdhaXQgd2FsbGV0Lmxpc3RBZGRyZXNzZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIHR5cGVzXzEuaXNXYWxsZXREYXRhKShkYXRhKSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIFdhbGxldERhdGEgb2JqZWN0IGltcG9ydFxuICAgICAgICAgICAgY29uc3Qgd2FsbGV0SWQgPSBkYXRhLndhbGxldElkIHx8IGRhdGEud2FsbGV0X2lkO1xuICAgICAgICAgICAgaWYgKCF3YWxsZXRJZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwiV2FsbGV0IElEIG11c3QgYmUgcHJvdmlkZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGEuc2VlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwiU2VlZCBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2FsbGV0TW9kZWwgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0LmdldFdhbGxldCh3YWxsZXRJZCk7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXQgPSBXYWxsZXQuaW5pdCh3YWxsZXRNb2RlbC5kYXRhLCBkYXRhLnNlZWQpO1xuICAgICAgICAgICAgYXdhaXQgd2FsbGV0Lmxpc3RBZGRyZXNzZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcIkludmFsaWQgaW1wb3J0IGRhdGEgZm9ybWF0XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgV2FsbGV0IHdpdGggYSByYW5kb20gc2VlZC5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RzIFdhbGxldFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBXYWxsZXQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmV0d29ya0lkIC0gdGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuIERlZmF1bHRzIHRvICdiYXNlLXNlcG9saWEnLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmludGVydmFsU2Vjb25kcyAtIFRoZSBpbnRlcnZhbCBhdCB3aGljaCB0byBwb2xsIHRoZSBiYWNrZW5kLCBpbiBzZWNvbmRzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgdGhlIFNlcnZlclNpZ25lciB0byBjcmVhdGUgYSBzZWVkLCBpbiBzZWNvbmRzLlxuICAgICAqIEB0aHJvd3Mge0FyZ3VtZW50RXJyb3J9IElmIHRoZSBtb2RlbCBvciBjbGllbnQgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIGFkZHJlc3MgZGVyaXZhdGlvbiBvciBjYWNoaW5nIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSAtIElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG5ldyBXYWxsZXQgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUoeyBuZXR3b3JrSWQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLm5ldHdvcmtzLkJhc2VTZXBvbGlhLCB0aW1lb3V0U2Vjb25kcyA9IDIwLCBpbnRlcnZhbFNlY29uZHMgPSAwLjIsIH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gV2FsbGV0LmNyZWF0ZVdpdGhTZWVkKHtcbiAgICAgICAgICAgIG5ldHdvcmtJZCxcbiAgICAgICAgICAgIHRpbWVvdXRTZWNvbmRzLFxuICAgICAgICAgICAgaW50ZXJ2YWxTZWNvbmRzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBXYWxsZXQgd2l0aCB0aGUgZ2l2ZW4gc2VlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBXYWxsZXQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc2VlZCAtIFRoZSBzZWVkIHRvIHVzZSBmb3IgdGhlIFdhbGxldC4gSWYgdW5kZWZpbmVkLCBhIHJhbmRvbSBzZWVkIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5ldHdvcmtJZCAtIHRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLiBEZWZhdWx0cyB0byAnYmFzZS1zZXBvbGlhJy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbFNlY29uZHMgLSBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggdG8gcG9sbCB0aGUgYmFja2VuZCwgaW4gc2Vjb25kcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0U2Vjb25kcyAtIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgZm9yIHRoZSBTZXJ2ZXJTaWduZXIgdG8gY3JlYXRlIGEgc2VlZCwgaW4gc2Vjb25kcy5cbiAgICAgKiBAdGhyb3dzIHtBcmd1bWVudEVycm9yfSBJZiB0aGUgbW9kZWwgb3IgY2xpZW50IGlzIG5vdCBwcm92aWRlZC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiBhZGRyZXNzIGRlcml2YXRpb24gb3IgY2FjaGluZyBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gLSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBuZXcgV2FsbGV0IG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlV2l0aFNlZWQoeyBzZWVkID0gdW5kZWZpbmVkLCBuZXR3b3JrSWQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLm5ldHdvcmtzLkJhc2VTZXBvbGlhLCB0aW1lb3V0U2Vjb25kcyA9IDIwLCBpbnRlcnZhbFNlY29uZHMgPSAwLjIsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0LmNyZWF0ZVdhbGxldCh7XG4gICAgICAgICAgICB3YWxsZXQ6IHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrX2lkOiBuZXR3b3JrSWQsXG4gICAgICAgICAgICAgICAgdXNlX3NlcnZlcl9zaWduZXI6IGNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IFdhbGxldC5pbml0KHJlc3VsdC5kYXRhLCBzZWVkKTtcbiAgICAgICAgaWYgKGNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyKSB7XG4gICAgICAgICAgICBhd2FpdCB3YWxsZXQud2FpdEZvclNpZ25lcih3YWxsZXQuZ2V0SWQoKSwgaW50ZXJ2YWxTZWNvbmRzLCB0aW1lb3V0U2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgd2FsbGV0LmNyZWF0ZUFkZHJlc3MoKTtcbiAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBXYWxsZXQgb2JqZWN0LiBEbyBub3QgdXNlIHRoaXMgbWV0aG9kIGRpcmVjdGx5LiBJbnN0ZWFkLCB1c2Ugb25lIG9mOlxuICAgICAqIC0gV2FsbGV0LmNyZWF0ZSAoQ3JlYXRlIGEgbmV3IFdhbGxldCksXG4gICAgICogLSBXYWxsZXQuaW1wb3J0IChJbXBvcnQgYSBXYWxsZXQgd2l0aCBzZWVkKSxcbiAgICAgKiAtIFdhbGxldC5mZXRjaCAoZmV0Y2ggYSBXYWxsZXQgYnkgSUQgdy9vIHNlZWQsIHVzZWZ1bCBmb3Igc2VydmVyIHNpZ25lciB3YWxsZXRzKS5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RzIFdhbGxldFxuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSB1bmRlcmx5aW5nIFdhbGxldCBtb2RlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0gc2VlZCAtIFRoZSBzZWVkIHRvIHVzZSBmb3IgdGhlIFdhbGxldC4gRXhwZWN0cyBhIDMyLWJ5dGUgaGV4YWRlY2ltYWwgd2l0aCBubyAweCBwcmVmaXguIElmIG51bGwgb3IgdW5kZWZpbmVkLCBhIG5ldyBzZWVkIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICAgICAqIElmIHRoZSBlbXB0eSBzdHJpbmcsIG5vIHNlZWQgaXMgZ2VuZXJhdGVkLCBhbmQgdGhlIFdhbGxldCB3aWxsIGJlIGluc3RhbnRpYXRlZCB3aXRob3V0IGEgc2VlZCBhbmQgaXRzIGNvcnJlc3BvbmRpbmcgcHJpdmF0ZSBrZXlzLlxuICAgICAqIEB0aHJvd3Mge0FyZ3VtZW50RXJyb3J9IElmIHRoZSBtb2RlbCBvciBjbGllbnQgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIGFkZHJlc3MgZGVyaXZhdGlvbiBvciBjYWNoaW5nIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSAtIElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG5ldyBXYWxsZXQgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBpbml0KG1vZGVsLCBzZWVkKSB7XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXQobW9kZWwsIHVuZGVmaW5lZCwgc2VlZCk7XG4gICAgICAgIGlmIChjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICAgICAgfVxuICAgICAgICB3YWxsZXQuc2V0TWFzdGVyTm9kZShzZWVkKTtcbiAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgV2FsbGV0J3MgZGF0YSB0byBhIFdhbGxldERhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFdhbGxldCdzIGRhdGEuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IC0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgZXhwb3J0KCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGV4cG9ydCBXYWxsZXQgd2l0aG91dCBsb2FkZWQgc2VlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2FsbGV0SWQ6IHRoaXMuZ2V0SWQoKSxcbiAgICAgICAgICAgIHNlZWQ6IHRoaXMuc2VlZCxcbiAgICAgICAgICAgIG5ldHdvcmtJZDogdGhpcy5nZXROZXR3b3JrSWQoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBBZGRyZXNzIGluIHRoZSBXYWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IEFkZHJlc3MuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IC0gSWYgdGhlIGFkZHJlc3MgY3JlYXRpb24gZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQWRkcmVzcygpIHtcbiAgICAgICAgbGV0IHBheWxvYWQsIGtleTtcbiAgICAgICAgaWYgKCFjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgLy8gVE9ETzogQ29vcmRpbmF0ZSB0aGlzIHZhbHVlIHdpdGggY29uY3VycmVudCBjYWxscyB0byBjcmVhdGVBZGRyZXNzLlxuICAgICAgICAgICAgY29uc3QgYWRkcmVzc0luZGV4ID0gdGhpcy5hZGRyZXNzZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGRLZXkgPSB0aGlzLmRlcml2ZUtleShhZGRyZXNzSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgYXR0ZXN0YXRpb24gPSB0aGlzLmNyZWF0ZUF0dGVzdGF0aW9uKGhkS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9ICgwLCB1dGlsc18xLmNvbnZlcnRTdHJpbmdUb0hleCkoaGRLZXkucHVibGljS2V5KTtcbiAgICAgICAgICAgIGtleSA9IG5ldyBldGhlcnNfMi5ldGhlcnMuV2FsbGV0KCgwLCB1dGlsc18xLmNvbnZlcnRTdHJpbmdUb0hleCkoaGRLZXkucHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBwdWJsaWNfa2V5OiBwdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgYXR0ZXN0YXRpb246IGF0dGVzdGF0aW9uLFxuICAgICAgICAgICAgICAgIGFkZHJlc3NfaW5kZXg6IGFkZHJlc3NJbmRleCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuYWRkcmVzcy5jcmVhdGVBZGRyZXNzKHRoaXMubW9kZWwuaWQsIHBheWxvYWQpO1xuICAgICAgICBpZiAoIXRoaXMuYWRkcmVzc2VzLmxlbmd0aCB8fCAhY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IG5ldyB3YWxsZXRfYWRkcmVzc18xLldhbGxldEFkZHJlc3MocmVzcG9uc2UuZGF0YSwga2V5KTtcbiAgICAgICAgdGhpcy5hZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2VlZCBmb3IgdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWVkIC0gVGhlIHNlZWQgdG8gdXNlIGZvciB0aGUgV2FsbGV0LiBFeHBlY3RzIGEgMzItYnl0ZSBoZXhhZGVjaW1hbCB3aXRoIG5vIDB4IHByZWZpeC5cbiAgICAgKiBAdGhyb3dzIHtBcmd1bWVudEVycm9yfSBJZiB0aGUgc2VlZCBpcyBlbXB0eS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNlZWQgaXMgYWxyZWFkeSBzZXQuXG4gICAgICovXG4gICAgc2V0U2VlZChzZWVkKSB7XG4gICAgICAgIGlmIChzZWVkID09PSB1bmRlZmluZWQgfHwgc2VlZCA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoXCJTZWVkIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hc3Rlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VlZCBpcyBhbHJlYWR5IHNldFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE1hc3Rlck5vZGUoc2VlZCk7XG4gICAgICAgIGlmICh0aGlzLmFkZHJlc3Nlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRyZXNzZXMuZm9yRWFjaCgoYWRkcmVzcywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSB0aGlzLmRlcml2ZUtleShpbmRleCk7XG4gICAgICAgICAgICBjb25zdCBldGhlcldhbGxldCA9IG5ldyBldGhlcnNfMi5ldGhlcnMuV2FsbGV0KCgwLCB1dGlsc18xLmNvbnZlcnRTdHJpbmdUb0hleCkoZGVyaXZlZEtleS5wcml2YXRlS2V5KSk7XG4gICAgICAgICAgICBpZiAoZXRoZXJXYWxsZXQuYWRkcmVzcyAhPSBhZGRyZXNzLmdldElkKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlZWQgZG9lcyBub3QgbWF0Y2ggd2FsbGV0OyBjYW5ub3QgZmluZCBhZGRyZXNzICR7ZXRoZXJXYWxsZXQuYWRkcmVzc31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHJlc3Muc2V0S2V5KGV0aGVyV2FsbGV0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFdhbGxldEFkZHJlc3Mgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzc0lkIC0gVGhlIElEIG9mIHRoZSBXYWxsZXRBZGRyZXNzIHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIFRoZSBXYWxsZXRBZGRyZXNzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoYWRkcmVzc0lkKSB7XG4gICAgICAgIGlmICh0aGlzLmFkZHJlc3Nlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IGF3YWl0IHRoaXMubGlzdEFkZHJlc3NlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3Nlcy5maW5kKGFkZHJlc3MgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3MuZ2V0SWQoKSA9PT0gYWRkcmVzc0lkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBBZGRyZXNzZXMgaW4gdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIEFkZHJlc3Nlcy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0QWRkcmVzc2VzKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5hZGRyZXNzLmxpc3RBZGRyZXNzZXModGhpcy5nZXRJZCgpLCBXYWxsZXQuTUFYX0FERFJFU1NFUyk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IHJlc3BvbnNlLmRhdGEuZGF0YS5tYXAoKGFkZHJlc3MsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFdhbGxldEFkZHJlc3MoYWRkcmVzcywgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRyZXNzZXMgPSBhZGRyZXNzZXM7XG4gICAgICAgIHJldHVybiBhZGRyZXNzZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUcmFkZXMgdGhlIGdpdmVuIGFtb3VudCBvZiB0aGUgZ2l2ZW4gQXNzZXQgZm9yIGFub3RoZXIgQXNzZXQuXG4gICAgICogIEN1cnJlbnRseSBvbmx5IHRoZSBkZWZhdWx0IGFkZHJlc3MgaXMgdXNlZCB0byBzb3VyY2UgdGhlIFRyYWRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjcmVhdGUgdGhlIFRyYWRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIEFzc2V0IHRvIHNlbmQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZnJvbUFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIHRyYWRlIGZyb20uXG4gICAgICogQHBhcmFtIG9wdGlvbnMudG9Bc3NldElkIC0gVGhlIElEIG9mIHRoZSBBc3NldCB0byB0cmFkZSB0by5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBpcyBub3QgZm91bmQuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcml2YXRlIGtleSBpcyBub3QgbG9hZGVkLCBvciBpZiB0aGUgYXNzZXQgSURzIGFyZSB1bnN1cHBvcnRlZCwgb3IgaWYgdGhlcmUgYXJlIGluc3VmZmljaWVudCBmdW5kcy5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBUcmFkZSBvYmplY3QuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVHJhZGUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuY3JlYXRlVHJhZGUob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3Rha2VhYmxlIGJhbGFuY2UgZm9yIHRoZSBzdXBwbGllZCBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldF9pZCAtIFRoZSBhc3NldCB0byBjaGVjayB0aGUgc3Rha2VhYmxlIGJhbGFuY2UgZm9yLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgZ2V0dGluZyB0aGUgc3Rha2VhYmxlIGJhbGFuY2UuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBkZWZhdWx0IGFkZHJlc3MgaXMgbm90IGZvdW5kLlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFrZWFibGUgYmFsYW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyBzdGFrZWFibGVCYWxhbmNlKGFzc2V0X2lkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuc3Rha2VhYmxlQmFsYW5jZShhc3NldF9pZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdW5zdGFrZWFibGUgYmFsYW5jZSBmb3IgdGhlIHN1cHBsaWVkIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0X2lkIC0gVGhlIGFzc2V0IHRvIGNoZWNrIHRoZSB1bnN0YWtlYWJsZSBiYWxhbmNlIGZvci5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGdldHRpbmcgdGhlIHVuc3Rha2VhYmxlIGJhbGFuY2UuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBkZWZhdWx0IGFkZHJlc3MgaXMgbm90IGZvdW5kLlxuICAgICAqIEByZXR1cm5zIFRoZSB1bnN0YWtlYWJsZSBiYWxhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIHVuc3Rha2VhYmxlQmFsYW5jZShhc3NldF9pZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLnVuc3Rha2VhYmxlQmFsYW5jZShhc3NldF9pZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2xhaW1hYmxlIGJhbGFuY2UgZm9yIHRoZSBzdXBwbGllZCBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldF9pZCAtIFRoZSBhc3NldCB0byBjaGVjayBjbGFpbWFibGUgYmFsYW5jZSBmb3IuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBnZXR0aW5nIHRoZSBjbGFpbWFibGUgYmFsYW5jZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBpcyBub3QgZm91bmQuXG4gICAgICogQHJldHVybnMgVGhlIGNsYWltYWJsZSBiYWxhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIGNsYWltYWJsZUJhbGFuY2UoYXNzZXRfaWQsIG1vZGUgPSB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5jbGFpbWFibGVCYWxhbmNlKGFzc2V0X2lkLCBtb2RlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIHN0YWtpbmcgcmV3YXJkcyBmb3IgdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIC0gVGhlIHN0YXJ0IHRpbWUuXG4gICAgICogQHBhcmFtIGVuZFRpbWUgLSBUaGUgZW5kIHRpbWUuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgdG8gcmV0dXJuIHRoZSByZXdhcmRzIGluLiAodXNkLCBuYXRpdmUpLiBEZWZhdWx0cyB0byB1c2QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBkZWZhdWx0IGFkZHJlc3MgaXMgbm90IGZvdW5kLlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIHJld2FyZHMuXG4gICAgICovXG4gICAgYXN5bmMgc3Rha2luZ1Jld2FyZHMoYXNzZXRJZCwgc3RhcnRUaW1lID0gKDAsIHV0aWxzXzEuZ2V0V2Vla0JhY2tEYXRlKShuZXcgRGF0ZSgpKSwgZW5kVGltZSA9ICgwLCB1dGlsc18xLmZvcm1hdERhdGUpKG5ldyBEYXRlKCkpLCBmb3JtYXQgPSB0eXBlc18xLlN0YWtpbmdSZXdhcmRGb3JtYXQuVVNEKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5zdGFraW5nUmV3YXJkcyhhc3NldElkLCBzdGFydFRpbWUsIGVuZFRpbWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIHRoZSBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXMgZm9yIHRoZSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgSUQuXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZSAtIFRoZSBzdGFydCB0aW1lLlxuICAgICAqIEBwYXJhbSBlbmRUaW1lIC0gVGhlIGVuZCB0aW1lLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgZGVmYXVsdCBhZGRyZXNzIGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyBiYWxhbmNlcy5cbiAgICAgKi9cbiAgICBhc3luYyBoaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzKGFzc2V0SWQsIHN0YXJ0VGltZSA9ICgwLCB1dGlsc18xLmdldFdlZWtCYWNrRGF0ZSkobmV3IERhdGUoKSksIGVuZFRpbWUgPSAoMCwgdXRpbHNfMS5mb3JtYXREYXRlKShuZXcgRGF0ZSgpKSkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuaGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcyhhc3NldElkLCBzdGFydFRpbWUsIGVuZFRpbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0aGUgaGlzdG9yaWNhbCBiYWxhbmNlcyBmb3IgYSBnaXZlbiBhc3NldCBiZWxvbmdpbmcgdG8gdGhlIGRlZmF1bHQgYWRkcmVzcyBvZiB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgSUQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcGFnaW5hdGlvbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIEhpc3RvcmljYWwgQmFsYW5jZXMgdG8gcmV0dXJuLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFnZSAtIFRoZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIEhpc3RvcmljYWwgQmFsYW5jZXMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dCBwYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFnaW5hdGVkIGxpc3QgcmVzcG9uc2Ugb2YgSGlzdG9yaWNhbCBCYWxhbmNlcyBmb3IgdGhlIGdpdmVuIEFzc2V0IElELlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RIaXN0b3JpY2FsQmFsYW5jZXMoYXNzZXRJZCwgeyBsaW1pdCA9IGNvaW5iYXNlXzEuQ29pbmJhc2UuZGVmYXVsdFBhZ2VMaW1pdCwgcGFnZSA9IHVuZGVmaW5lZCB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLmxpc3RIaXN0b3JpY2FsQmFsYW5jZXMoYXNzZXRJZCwgeyBsaW1pdCwgcGFnZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YWtpbmcgb3BlcmF0aW9uIHRvIHN0YWtlLCBzaWducyBpdCwgYW5kIGJyb2FkY2FzdHMgaXQgb24gdGhlIGJsb2NrY2hhaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBmb3IgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IGZvciB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIHN1Y2ggYXMgc2V0dGluZyB0aGUgbW9kZSBmb3IgdGhlIHN0YWtpbmcgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB0aW1lb3V0U2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gd2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGNvbXBsZXRlIHdoZW4gYnJvYWRjYXN0ZWQuXG4gICAgICogQHBhcmFtIGludGVydmFsU2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gY2hlY2sgZWFjaCB0aW1lIGZvciBhIHN1Y2Nlc3NmdWwgYnJvYWRjYXN0LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgZGVmYXVsdCBhZGRyZXNzIGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyBvcGVyYXRpb24gYWZ0ZXIgaXQncyBjb21wbGV0ZWQgZnVsbHkuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSwgdGltZW91dFNlY29uZHMgPSA2MCwgaW50ZXJ2YWxTZWNvbmRzID0gMC4yKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5jcmVhdGVTdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMsIHRpbWVvdXRTZWNvbmRzLCBpbnRlcnZhbFNlY29uZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3Rha2luZyBvcGVyYXRpb24gdG8gdW5zdGFrZSwgc2lnbnMgaXQsIGFuZCBicm9hZGNhc3RzIGl0IG9uIHRoZSBibG9ja2NoYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBmb3IgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBzdWNoIGFzIHNldHRpbmcgdGhlIG1vZGUgZm9yIHRoZSBzdGFraW5nIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gdGltZW91dFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIHdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBjb21wbGV0ZSB3aGVuIGJyb2FkY2FzdGVkLlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIGNoZWNrIGVhY2ggdGltZSBmb3IgYSBzdWNjZXNzZnVsIGJyb2FkY2FzdC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBpcyBub3QgZm91bmQuXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtpbmcgb3BlcmF0aW9uIGFmdGVyIGl0J3MgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVVbnN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30sIHRpbWVvdXRTZWNvbmRzID0gNjAsIGludGVydmFsU2Vjb25kcyA9IDAuMikge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuY3JlYXRlVW5zdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMsIHRpbWVvdXRTZWNvbmRzLCBpbnRlcnZhbFNlY29uZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3Rha2luZyBvcGVyYXRpb24gdG8gY2xhaW0gc3Rha2UsIHNpZ25zIGl0LCBhbmQgYnJvYWRjYXN0cyBpdCBvbiB0aGUgYmxvY2tjaGFpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IGZvciB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgc3VjaCBhcyBzZXR0aW5nIHRoZSBtb2RlIGZvciB0aGUgc3Rha2luZyBhY3Rpb24uXG4gICAgICogQHBhcmFtIHRpbWVvdXRTZWNvbmRzIC0gVGhlIGFtb3VudCB0byB3YWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gY29tcGxldGUgd2hlbiBicm9hZGNhc3RlZC5cbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWxTZWNvbmRzIC0gVGhlIGFtb3VudCB0byBjaGVjayBlYWNoIHRpbWUgZm9yIGEgc3VjY2Vzc2Z1bCBicm9hZGNhc3QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBkZWZhdWx0IGFkZHJlc3MgaXMgbm90IGZvdW5kLlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIG9wZXJhdGlvbiBhZnRlciBpdCdzIGNvbXBsZXRlZCBmdWxseS5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVDbGFpbVN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30sIHRpbWVvdXRTZWNvbmRzID0gNjAsIGludGVydmFsU2Vjb25kcyA9IDAuMikge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuY3JlYXRlQ2xhaW1TdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMsIHRpbWVvdXRTZWNvbmRzLCBpbnRlcnZhbFNlY29uZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGJhbGFuY2VzIG9mIHRoaXMgV2FsbGV0LiBCYWxhbmNlcyBhcmUgYWdncmVnYXRlZCBhY3Jvc3MgYWxsIEFkZHJlc3NlcyBpbiB0aGUgV2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxpc3Qgb2YgYmFsYW5jZXMuIFRoZSBrZXkgaXMgdGhlIEFzc2V0IElELCBhbmQgdGhlIHZhbHVlIGlzIHRoZSBiYWxhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RCYWxhbmNlcygpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0Lmxpc3RXYWxsZXRCYWxhbmNlcyh0aGlzLm1vZGVsLmlkKTtcbiAgICAgICAgcmV0dXJuIGJhbGFuY2VfbWFwXzEuQmFsYW5jZU1hcC5mcm9tQmFsYW5jZXMocmVzcG9uc2UuZGF0YS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmFsYW5jZSBvZiB0aGUgcHJvdmlkZWQgQXNzZXQuIEJhbGFuY2VzIGFyZSBhZ2dyZWdhdGVkIGFjcm9zcyBhbGwgQWRkcmVzc2VzIGluIHRoZSBXYWxsZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBJRCBvZiB0aGUgQXNzZXQgdG8gcmV0cmlldmUgdGhlIGJhbGFuY2UgZm9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBiYWxhbmNlIG9mIHRoZSBBc3NldC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCYWxhbmNlKGFzc2V0SWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0LmdldFdhbGxldEJhbGFuY2UodGhpcy5tb2RlbC5pZCwgYXNzZXRfMS5Bc3NldC5wcmltYXJ5RGVub21pbmF0aW9uKGFzc2V0SWQpKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5kYXRhLmFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdCgwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYWxhbmNlID0gYmFsYW5jZV8xLkJhbGFuY2UuZnJvbU1vZGVsQW5kQXNzZXRJZChyZXNwb25zZS5kYXRhLCBhc3NldElkKTtcbiAgICAgICAgcmV0dXJuIGJhbGFuY2UuYW1vdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBOZXR3b3JrIElEIG9mIHRoZSBXYWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm5ldHdvcmtfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFNlcnZlclNpZ25lciBTdGF0dXMgb2YgdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBTZXJ2ZXJTaWduZXIgU3RhdHVzLlxuICAgICAqL1xuICAgIGdldFNlcnZlclNpZ25lclN0YXR1cygpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0ge1xuICAgICAgICAgICAgcGVuZGluZ19zZWVkX2NyZWF0aW9uOiB0eXBlc18xLlNlcnZlclNpZ25lclN0YXR1cy5QRU5ESU5HLFxuICAgICAgICAgICAgYWN0aXZlX3NlZWQ6IHR5cGVzXzEuU2VydmVyU2lnbmVyU3RhdHVzLkFDVElWRSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuc2VydmVyX3NpZ25lcl9zdGF0dXMgPyBzdGF0dXNbdGhpcy5tb2RlbC5zZXJ2ZXJfc2lnbmVyX3N0YXR1c10gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdhbGxldCBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB3YWxsZXQgSUQuXG4gICAgICovXG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYXZlcyB0aGUgc2VlZCBvZiB0aGUgV2FsbGV0IHRvIHRoZSBnaXZlbiBmaWxlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHNhdmVTZWVkVG9GaWxlKCkgaW5zdGVhZFxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCAtIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHRvIHNhdmUgdGhlIHNlZWQgdG9cbiAgICAgKiBAcGFyYW0gZW5jcnlwdCAtIFdoZXRoZXIgdGhlIHNlZWQgaW5mb3JtYXRpb24gcGVyc2lzdGVkIHRvIHRoZSBsb2NhbCBmaWxlIHN5c3RlbSBzaG91bGQgYmVcbiAgICAgKiBlbmNyeXB0ZWQgb3Igbm90LiBEYXRhIGlzIHVuZW5jcnlwdGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgc3VjY2VzcyBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBXYWxsZXQgZG9lcyBub3QgaGF2ZSBhIHNlZWRcbiAgICAgKi9cbiAgICBzYXZlU2VlZChmaWxlUGF0aCwgZW5jcnlwdCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhdmVTZWVkVG9GaWxlKGZpbGVQYXRoLCBlbmNyeXB0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2F2ZXMgdGhlIHNlZWQgb2YgdGhlIFdhbGxldCB0byB0aGUgZ2l2ZW4gZmlsZS4gV2FsbGV0cyB3aG9zZSBzZWVkcyBhcmUgc2F2ZWQgdGhpcyB3YXkgY2FuIGJlXG4gICAgICogcmVoeWRyYXRlZCB1c2luZyBsb2FkX3NlZWQuIEEgc2luZ2xlIGZpbGUgY2FuIGJlIHVzZWQgZm9yIG11bHRpcGxlIFdhbGxldCBzZWVkcy5cbiAgICAgKiBUaGlzIGlzIGFuIGluc2VjdXJlIG1ldGhvZCBvZiBzdG9yaW5nIFdhbGxldCBzZWVkcyBhbmQgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgZGV2ZWxvcG1lbnQgcHVycG9zZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggLSBUaGUgcGF0aCBvZiB0aGUgZmlsZSB0byBzYXZlIHRoZSBzZWVkIHRvXG4gICAgICogQHBhcmFtIGVuY3J5cHQgLSBXaGV0aGVyIHRoZSBzZWVkIGluZm9ybWF0aW9uIHBlcnNpc3RlZCB0byB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0gc2hvdWxkIGJlXG4gICAgICogZW5jcnlwdGVkIG9yIG5vdC4gRGF0YSBpcyB1bmVuY3J5cHRlZCBieSBkZWZhdWx0LlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHN1Y2Nlc3Mgb2YgdGhlIG9wZXJhdGlvblxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgV2FsbGV0IGRvZXMgbm90IGhhdmUgYSBzZWVkXG4gICAgICovXG4gICAgc2F2ZVNlZWRUb0ZpbGUoZmlsZVBhdGgsIGVuY3J5cHQgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMubWFzdGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2F2ZSBXYWxsZXQgd2l0aG91dCBsb2FkZWQgc2VlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGlzdGluZ1NlZWRzSW5TdG9yZSA9IHRoaXMuZ2V0RXhpc3RpbmdTZWVkcyhmaWxlUGF0aCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmV4cG9ydCgpO1xuICAgICAgICBsZXQgc2VlZFRvU3RvcmUgPSBkYXRhLnNlZWQ7XG4gICAgICAgIGxldCBhdXRoVGFnID0gXCJcIjtcbiAgICAgICAgbGV0IGl2ID0gXCJcIjtcbiAgICAgICAgaWYgKGVuY3J5cHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl2Qnl0ZXMgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTIpO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0gdGhpcy5nZXRFbmNyeXB0aW9uS2V5KCk7XG4gICAgICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoXCJhZXMtMjU2LWdjbVwiLCBjcnlwdG8uY3JlYXRlSGFzaChcInNoYTI1NlwiKS51cGRhdGUoc2hhcmVkU2VjcmV0KS5kaWdlc3QoKSwgaXZCeXRlcyk7XG4gICAgICAgICAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gQnVmZmVyLmNvbmNhdChbY2lwaGVyLnVwZGF0ZShkYXRhLnNlZWQsIFwidXRmOFwiKSwgY2lwaGVyLmZpbmFsKCldKTtcbiAgICAgICAgICAgIGF1dGhUYWcgPSBjaXBoZXIuZ2V0QXV0aFRhZygpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICAgICAgc2VlZFRvU3RvcmUgPSBlbmNyeXB0ZWREYXRhLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICAgICAgaXYgPSBpdkJ5dGVzLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGV4aXN0aW5nU2VlZHNJblN0b3JlW2RhdGEud2FsbGV0SWRdID0ge1xuICAgICAgICAgICAgc2VlZDogc2VlZFRvU3RvcmUsXG4gICAgICAgICAgICBlbmNyeXB0ZWQ6IGVuY3J5cHQsXG4gICAgICAgICAgICBhdXRoVGFnOiBhdXRoVGFnLFxuICAgICAgICAgICAgaXY6IGl2LFxuICAgICAgICAgICAgbmV0d29ya0lkOiBkYXRhLm5ldHdvcmtJZCxcbiAgICAgICAgfTtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdTZWVkc0luU3RvcmUsIG51bGwsIDIpLCBcInV0ZjhcIik7XG4gICAgICAgIHJldHVybiBgU3VjY2Vzc2Z1bGx5IHNhdmVkIHNlZWQgZm9yICR7ZGF0YS53YWxsZXRJZH0gdG8gJHtmaWxlUGF0aH0uYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIHNlZWQgb2YgdGhlIFdhbGxldCBmcm9tIHRoZSBnaXZlbiBmaWxlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGxvYWRTZWVkRnJvbUZpbGUoKSBpbnN0ZWFkXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIC0gVGhlIHBhdGggb2YgdGhlIGZpbGUgdG8gbG9hZCB0aGUgc2VlZCBmcm9tXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgc3VjY2VzcyBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgbG9hZFNlZWQoZmlsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFNlZWRGcm9tRmlsZShmaWxlUGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBzZWVkIG9mIHRoZSBXYWxsZXQgZnJvbSB0aGUgZ2l2ZW4gZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCAtIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHRvIGxvYWQgdGhlIHNlZWQgZnJvbVxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHN1Y2Nlc3Mgb2YgdGhlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGxvYWRTZWVkRnJvbUZpbGUoZmlsZVBhdGgpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdTZWVkc0luU3RvcmUgPSB0aGlzLmdldEV4aXN0aW5nU2VlZHMoZmlsZVBhdGgpO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZXhpc3RpbmdTZWVkc0luU3RvcmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoYEZpbGUgJHtmaWxlUGF0aH0gZG9lcyBub3QgY29udGFpbiBhbnkgc2VlZCBkYXRhYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4aXN0aW5nU2VlZHNJblN0b3JlW3RoaXMuZ2V0SWQoKV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoYEZpbGUgJHtmaWxlUGF0aH0gZG9lcyBub3QgY29udGFpbiBzZWVkIGRhdGEgZm9yIHdhbGxldCAke3RoaXMuZ2V0SWQoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkRGF0YSA9IGV4aXN0aW5nU2VlZHNJblN0b3JlW3RoaXMuZ2V0SWQoKV07XG4gICAgICAgIGxldCBzZWVkID0gc2VlZERhdGEuc2VlZDtcbiAgICAgICAgaWYgKCFzZWVkKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoXCJTZWVkIGRhdGEgaXMgbWFsZm9ybWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWVkRGF0YS5lbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFNlY3JldCA9IHRoaXMuZ2V0RW5jcnlwdGlvbktleSgpO1xuICAgICAgICAgICAgaWYgKCFzZWVkRGF0YS5pdiB8fCAhc2VlZERhdGEuYXV0aFRhZykge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoXCJFbmNyeXB0ZWQgc2VlZCBkYXRhIGlzIG1hbGZvcm1lZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoXCJhZXMtMjU2LWdjbVwiLCBjcnlwdG8uY3JlYXRlSGFzaChcInNoYTI1NlwiKS51cGRhdGUoc2hhcmVkU2VjcmV0KS5kaWdlc3QoKSwgQnVmZmVyLmZyb20oc2VlZERhdGEuaXYsIFwiaGV4XCIpKTtcbiAgICAgICAgICAgIGRlY2lwaGVyLnNldEF1dGhUYWcoQnVmZmVyLmZyb20oc2VlZERhdGEuYXV0aFRhZywgXCJoZXhcIikpO1xuICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkRGF0YSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgICAgIGRlY2lwaGVyLnVwZGF0ZShCdWZmZXIuZnJvbShzZWVkLCBcImhleFwiKSksXG4gICAgICAgICAgICAgICAgZGVjaXBoZXIuZmluYWwoKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgc2VlZCA9IGRlY3J5cHRlZERhdGEudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U2VlZChzZWVkKTtcbiAgICAgICAgYXdhaXQgdGhpcy5saXN0QWRkcmVzc2VzKCk7XG4gICAgICAgIHJldHVybiBgU3VjY2Vzc2Z1bGx5IGxvYWRlZCBzZWVkIGZvciB3YWxsZXQgJHt0aGlzLmdldElkKCl9IGZyb20gJHtmaWxlUGF0aH0uYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBhZGRyZXNzIG9mIHRoZSBXYWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZGVmYXVsdCBhZGRyZXNzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVmYXVsdEFkZHJlc3MoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmRlZmF1bHRfYWRkcmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXRNb2RlbCBkZWZhdWx0IGFkZHJlc3Mgbm90IHNldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0QWRkcmVzcyA9IGF3YWl0IHRoaXMuZ2V0QWRkcmVzcyh0aGlzLm1vZGVsLmRlZmF1bHRfYWRkcmVzcy5hZGRyZXNzX2lkKTtcbiAgICAgICAgaWYgKCFkZWZhdWx0QWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmYXVsdCBhZGRyZXNzIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdEFkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgV2FsbGV0IGhhcyBhIHNlZWQgd2l0aCB3aGljaCB0byBkZXJpdmUga2V5cyBhbmQgc2lnbiB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBXYWxsZXQgaGFzIGEgc2VlZCB3aXRoIHdoaWNoIHRvIGRlcml2ZSBrZXlzIGFuZCBzaWduIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBjYW5TaWduKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXN0ZXI/LnB1YmxpY0tleSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBmdW5kcyBmcm9tIHRoZSBmYXVjZXQgZm9yIHRoZSBXYWxsZXQncyBkZWZhdWx0IGFkZHJlc3MgYW5kIHJldHVybnMgdGhlIGZhdWNldCB0cmFuc2FjdGlvbi5cbiAgICAgKiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIG9uIHRlc3RuZXQgbmV0d29ya3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBJRCBvZiB0aGUgQXNzZXQgdG8gcmVxdWVzdCBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZWZhdWx0IGFkZHJlc3MgaXMgbm90IGZvdW5kLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3VjY2Vzc2Z1bCBmYXVjZXQgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICBhc3luYyBmYXVjZXQoYXNzZXRJZCkge1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwuZGVmYXVsdF9hZGRyZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZhdWx0IGFkZHJlc3Mgbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuZmF1Y2V0KGFzc2V0SWQpO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVycyB0aGUgZ2l2ZW4gYW1vdW50IG9mIHRoZSBnaXZlbiBBc3NldCB0byB0aGUgZ2l2ZW4gYWRkcmVzcy4gT25seSBzYW1lLU5ldHdvcmsgVHJhbnNmZXJzIGFyZSBzdXBwb3J0ZWQuXG4gICAgICogQ3VycmVudGx5IG9ubHkgdGhlIGRlZmF1bHRfYWRkcmVzcyBpcyB1c2VkIHRvIHNvdXJjZSB0aGUgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNyZWF0ZSB0aGUgVHJhbnNmZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgQXNzZXQgdG8gc2VuZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hc3NldElkIC0gVGhlIElEIG9mIHRoZSBBc3NldCB0byBzZW5kLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlc3RpbmF0aW9uIC0gVGhlIGRlc3RpbmF0aW9uIG9mIHRoZSB0cmFuc2Zlci4gSWYgYSBXYWxsZXQsIHNlbmRzIHRvIHRoZSBXYWxsZXQncyBkZWZhdWx0IGFkZHJlc3MuIElmIGEgU3RyaW5nLCBpbnRlcnByZXRzIGl0IGFzIHRoZSBhZGRyZXNzIElELlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdhc2xlc3MgLSBXaGV0aGVyIHRoZSBUcmFuc2ZlciBzaG91bGQgYmUgZ2FzbGVzcy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc2tpcEJhdGNoaW5nIC0gV2hlbiB0cnVlLCB0aGUgVHJhbnNmZXIgd2lsbCBiZSBzdWJtaXR0ZWQgaW1tZWRpYXRlbHkuIE90aGVyd2lzZSwgdGhlIFRyYW5zZmVyIHdpbGwgYmUgYmF0Y2hlZC4gRGVmYXVsdHMgdG8gZmFsc2UuIE5vdGU6IHJlcXVpcmVzIGdhc2xlc3Mgb3B0aW9uIHRvIGJlIHNldCB0byB0cnVlLlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIFRyYW5zZmVyIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIFRyYW5zZmVyIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gYnJvYWRjYXN0IGEgVHJhbnNmZXIgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVHJhbnNmZXIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuY3JlYXRlVHJhbnNmZXIob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1bnNpZ25lZFBheWxvYWQgLSBUaGUgVW5zaWduZWQgUGF5bG9hZCB0byBzaWduLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBQYXlsb2FkIFNpZ25hdHVyZSBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBQYXlsb2FkIFNpZ25hdHVyZSBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBpcyBub3QgZm91bmQuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZSh1bnNpZ25lZFBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLmNyZWF0ZVBheWxvYWRTaWduYXR1cmUodW5zaWduZWRQYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFdlYmhvb2sgZm9yIGEgd2FsbGV0LCBtb25pdG9ycyBhbGwgd2FsbGV0IGFkZHJlc3NlcyBmb3Igb25jaGFpbiBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm90aWZpY2F0aW9uVXJpIC0gVGhlIFVSSSB0byB3aGljaCB0aGUgd2ViaG9vayBub3RpZmljYXRpb25zIHdpbGwgYmUgc2VudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIHdlYmhvb2sgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlV2ViaG9vayhub3RpZmljYXRpb25VcmkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndlYmhvb2suY3JlYXRlV2FsbGV0V2ViaG9vayh0aGlzLmdldElkKCksIHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbl91cmk6IG5vdGlmaWNhdGlvblVyaSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3ZWJob29rXzEuV2ViaG9vay5pbml0KHJlc3VsdC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyBhIGNvbnRyYWN0IHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGludm9rZSB0aGUgY29udHJhY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb250cmFjdEFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgdGhlIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWV0aG9kIC0gVGhlIG1ldGhvZCB0byBpbnZva2Ugb24gdGhlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFiaSAtIFRoZSBBQkkgb2YgdGhlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGNvbnRyYWN0IG1ldGhvZCBpbnZvY2F0aW9uLlxuICAgICAqICAgVGhlIGtleXMgc2hvdWxkIGJlIHRoZSBhcmd1bWVudCBuYW1lcyBhbmQgdGhlIHZhbHVlcyBzaG91bGQgYmUgdGhlIGFyZ3VtZW50IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBhc3NldCB0byBzZW5kIHRvIGEgcGF5YWJsZSBjb250cmFjdCBtZXRob2QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXNzZXRJZCAtIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gc2VuZCB0byBhIHBheWFibGUgY29udHJhY3QgbWV0aG9kLlxuICAgICAqICAgVGhlIGFzc2V0IG11c3QgYmUgYSBkZW5vbWluYXRpb24gb2YgdGhlIG5hdGl2ZSBhc3NldC4gKEV4LiBcIndlaVwiLCBcImd3ZWlcIiwgb3IgXCJldGhcIikuXG4gICAgICogQHJldHVybnMgVGhlIENvbnRyYWN0SW52b2NhdGlvbiBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBjb250cmFjdCBpbnZvY2F0aW9uIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZUNvbnRyYWN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLmludm9rZUNvbnRyYWN0KG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBsb3lzIGFuIEVSQzIwIHRva2VuIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIEVSQzIwIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgRVJDMjAgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3ltYm9sIC0gVGhlIHN5bWJvbCBvZiB0aGUgRVJDMjAgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMudG90YWxTdXBwbHkgLSBUaGUgdG90YWwgc3VwcGx5IG9mIHRoZSBFUkMyMCB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVwbG95ZWQgU21hcnRDb250cmFjdCBvYmplY3QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcml2YXRlIGtleSBpcyBub3QgbG9hZGVkIHdoZW4gbm90IHVzaW5nIHNlcnZlciBzaWduZXIuXG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95VG9rZW4ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuZGVwbG95VG9rZW4ob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYW4gRVJDNzIxIHRva2VuIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIEVSQzcyMSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEVSQzcyMSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zeW1ib2wgLSBUaGUgc3ltYm9sIG9mIHRoZSBFUkM3MjEgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYmFzZVVSSSAtIFRoZSBiYXNlIFVSSSBvZiB0aGUgRVJDNzIxIHRva2VuLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXBsb3llZCBTbWFydENvbnRyYWN0IG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHByaXZhdGUga2V5IGlzIG5vdCBsb2FkZWQgd2hlbiBub3QgdXNpbmcgc2VydmVyIHNpZ25lci5cbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lORlQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuZGVwbG95TkZUKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBsb3lzIGFuIEVSQzExNTUgdG9rZW4gY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgRVJDMTE1NSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEVSQzExNTUgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3ltYm9sIC0gVGhlIHN5bWJvbCBvZiB0aGUgRVJDMTE1NSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5iYXNlVVJJIC0gVGhlIGJhc2UgVVJJIG9mIHRoZSBFUkMxMTU1IHRva2VuLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXBsb3llZCBTbWFydENvbnRyYWN0IG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHByaXZhdGUga2V5IGlzIG5vdCBsb2FkZWQgd2hlbiBub3QgdXNpbmcgc2VydmVyIHNpZ25lci5cbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lNdWx0aVRva2VuKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLmRlcGxveU11bHRpVG9rZW4ob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYSBjdXN0b20gY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgY3VzdG9tIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNvbGlkaXR5VmVyc2lvbiAtIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb2xpZGl0eSBjb21waWxlciwgbXVzdCBiZSAwLjguKywgc3VjaCBhcyBcIjAuOC4yOCtjb21taXQuNzg5MzYxNGFcIi4gU2VlIGh0dHBzOi8vYmluYXJpZXMuc29saWRpdHlsYW5nLm9yZy9iaW4vbGlzdC5qc29uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc29saWRpdHlJbnB1dEpzb24gLSBUaGUgaW5wdXQganNvbiBmb3IgdGhlIHNvbGlkaXR5IGNvbXBpbGVyLiBTZWUgaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L3VzaW5nLXRoZS1jb21waWxlci5odG1sI2lucHV0LWRlc2NyaXB0aW9uIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29udHJhY3ROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbnRyYWN0IGNsYXNzIHRvIGJlIGRlcGxveWVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbnN0cnVjdG9yQXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVwbG95ZWQgU21hcnRDb250cmFjdCBvYmplY3QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcml2YXRlIGtleSBpcyBub3QgbG9hZGVkIHdoZW4gbm90IHVzaW5nIHNlcnZlciBzaWduZXIuXG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95Q29udHJhY3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuZGVwbG95Q29udHJhY3Qob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bmQgdGhlIHdhbGxldCBmcm9tIHlvdXIgYWNjb3VudCBvbiB0aGUgQ29pbmJhc2UgUGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNyZWF0ZSB0aGUgZnVuZCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBBc3NldCB0byBmdW5kIHRoZSB3YWxsZXQgd2l0aFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIGZ1bmQgd2l0aC4gRm9yIEV0aGVyLCBldGgsIGd3ZWksIGFuZCB3ZWkgYXJlIHN1cHBvcnRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBmdW5kIG9wZXJhdGlvbiBvYmplY3RcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBkb2VzIG5vdCBleGlzdFxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmQob3B0aW9ucykge1xuICAgICAgICBjb25zdCBkZWZhdWx0QWRkcmVzcyA9IGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKTtcbiAgICAgICAgaWYgKCFkZWZhdWx0QWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmYXVsdCBhZGRyZXNzIGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0QWRkcmVzcy5mdW5kKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBxdW90ZSBmb3IgZnVuZGluZyB0aGUgd2FsbGV0IGZyb20geW91ciBDb2luYmFzZSBwbGF0Zm9ybSBhY2NvdW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjcmVhdGUgdGhlIGZ1bmQgcXVvdGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbW91bnQgLSBUaGUgYW1vdW50IHRvIGZ1bmRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hc3NldElkIC0gVGhlIElEIG9mIHRoZSBBc3NldCB0byBmdW5kIHdpdGguIEZvciBFdGhlciwgZXRoLCBnd2VpLCBhbmQgd2VpIGFyZSBzdXBwb3J0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGZ1bmQgcXVvdGUgb2JqZWN0XG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZWZhdWx0IGFkZHJlc3MgZG9lcyBub3QgZXhpc3RcbiAgICAgKi9cbiAgICBhc3luYyBxdW90ZUZ1bmQob3B0aW9ucykge1xuICAgICAgICBjb25zdCBkZWZhdWx0QWRkcmVzcyA9IGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKTtcbiAgICAgICAgaWYgKCFkZWZhdWx0QWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmYXVsdCBhZGRyZXNzIGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0QWRkcmVzcy5xdW90ZUZ1bmQob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHRoZSBmdW5kIG9wZXJhdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSB3YWxsZXQncyBkZWZhdWx0IGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYWdpbmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgZnVuZCBvcGVyYXRpb25zIHRvIHJldHVybi4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhZ2UgLSBUaGUgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiBmdW5kIG9wZXJhdGlvbnMuIERvbid0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dCBwYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHJldHVybnMgVGhlIHBhZ2luYXRlZCBsaXN0IHJlc3BvbnNlIG9mIGZ1bmQgb3BlcmF0aW9ucy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBkb2VzIG5vdCBleGlzdFxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RGdW5kT3BlcmF0aW9ucyh7IGxpbWl0ID0gY29pbmJhc2VfMS5Db2luYmFzZS5kZWZhdWx0UGFnZUxpbWl0LCBwYWdlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdEFkZHJlc3MgPSBhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCk7XG4gICAgICAgIGlmICghZGVmYXVsdEFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmF1bHQgYWRkcmVzcyBkb2VzIG5vdCBleGlzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdEFkZHJlc3MubGlzdEZ1bmRPcGVyYXRpb25zKHsgbGltaXQsIHBhZ2UgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBXYWxsZXRcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBXYWxsZXR7aWQ6ICcke3RoaXMubW9kZWwuaWR9JywgbmV0d29ya0lkOiAnJHt0aGlzLm1vZGVsLm5ldHdvcmtfaWR9J31gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIHNlZWQgYW5kIGFkZHJlc3MgbW9kZWxzIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VlZCAtIFRoZSBzZWVkIHRvIHVzZSBmb3IgdGhlIFdhbGxldFxuICAgICAqL1xuICAgIHZhbGlkYXRlU2VlZChzZWVkKSB7XG4gICAgICAgIGlmIChzZWVkICYmIHNlZWQubGVuZ3RoICE9PSA2NCAmJiBzZWVkLmxlbmd0aCAhPT0gMTI4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcIlNlZWQgbXVzdCBiZSAzMiBvciA2NCBieXRlc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgc2VlZCBkYXRhIGZyb20gdGhlIGdpdmVuIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggLSBUaGUgcGF0aCBvZiB0aGUgZmlsZSB0byBsb2FkIHRoZSBzZWVkIGRhdGEgZnJvbVxuICAgICAqIEByZXR1cm5zIFRoZSBzZWVkIGRhdGFcbiAgICAgKi9cbiAgICBnZXRFeGlzdGluZ1NlZWRzKGZpbGVQYXRoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCBcInV0ZjhcIik7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZWVkRGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5lbnRyaWVzKHNlZWREYXRhKS5ldmVyeSgoW2tleSwgdmFsdWVdKSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS5hdXRoVGFnID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLmVuY3J5cHRlZCA9PT0gXCJib29sZWFuXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUuaXYgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUuc2VlZCA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcIk1hbGZvcm1lZCBiYWNrdXAgZGF0YVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWVkRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcIk1hbGZvcm1lZCBiYWNrdXAgZGF0YVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBrZXkgZm9yIGVuY3J5cHRpbmcgc2VlZCBkYXRhLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGVuY3J5cHRpb24ga2V5LlxuICAgICAqL1xuICAgIGdldEVuY3J5cHRpb25LZXkoKSB7XG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBjcnlwdG8uY3JlYXRlUHJpdmF0ZUtleShjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUtleVByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBjcnlwdG8uY3JlYXRlUHVibGljS2V5KGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpS2V5UHJpdmF0ZUtleSk7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRpb25LZXkgPSBjcnlwdG8uZGlmZmllSGVsbG1hbih7XG4gICAgICAgICAgICBwcml2YXRlS2V5LFxuICAgICAgICAgICAgcHVibGljS2V5LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVuY3J5cHRpb25LZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBXYWxsZXRBZGRyZXNzIG9iamVjdCBmb3IgdGhlIGdpdmVuIEFkZHJlc3NNb2RlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzTW9kZWwgLSBUaGUgQWRkcmVzc01vZGVsIHRvIGJ1aWxkIHRoZSBXYWxsZXRBZGRyZXNzIGZyb20uXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBBZGRyZXNzTW9kZWwuXG4gICAgICogQHJldHVybnMgVGhlIFdhbGxldEFkZHJlc3Mgb2JqZWN0LlxuICAgICAqL1xuICAgIGJ1aWxkV2FsbGV0QWRkcmVzcyhhZGRyZXNzTW9kZWwsIGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5tYXN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgd2FsbGV0X2FkZHJlc3NfMS5XYWxsZXRBZGRyZXNzKGFkZHJlc3NNb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5kZXJpdmVLZXkoaW5kZXgpO1xuICAgICAgICBjb25zdCBldGhXYWxsZXQgPSBuZXcgZXRoZXJzXzIuZXRoZXJzLldhbGxldCgoMCwgdXRpbHNfMS5jb252ZXJ0U3RyaW5nVG9IZXgpKGtleS5wcml2YXRlS2V5KSk7XG4gICAgICAgIGlmIChldGhXYWxsZXQuYWRkcmVzcyAhPSBhZGRyZXNzTW9kZWwuYWRkcmVzc19pZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZWVkIGRvZXMgbm90IG1hdGNoIHdhbGxldGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgd2FsbGV0X2FkZHJlc3NfMS5XYWxsZXRBZGRyZXNzKGFkZHJlc3NNb2RlbCwgZXRoV2FsbGV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgdW50aWwgdGhlIFNlcnZlclNpZ25lciBoYXMgY3JlYXRlZCBhIHNlZWQgZm9yIHRoZSBXYWxsZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0SWQgLSBUaGUgSUQgb2YgdGhlIFdhbGxldCB0aGF0IGlzIGF3YWl0aW5nIHNlZWQgY3JlYXRpb24uXG4gICAgICogQHBhcmFtIGludGVydmFsU2Vjb25kcyAtIFRoZSBpbnRlcnZhbCBhdCB3aGljaCB0byBwb2xsIHRoZSBDRFBTZXJ2aWNlLCBpbiBzZWNvbmRzLlxuICAgICAqIEBwYXJhbSB0aW1lb3V0U2Vjb25kcyAtIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgZm9yIHRoZSBTZXJ2ZXJTaWduZXIgdG8gY3JlYXRlIGEgc2VlZCwgaW4gc2Vjb25kcy5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGdldCBhIFdhbGxldCBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIFNlcnZlclNpZ25lciB0aW1lcyBvdXQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdEZvclNpZ25lcih3YWxsZXRJZCwgaW50ZXJ2YWxTZWNvbmRzID0gMC4yLCB0aW1lb3V0U2Vjb25kcyA9IDIwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dFNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53YWxsZXQuZ2V0V2FsbGV0KHdhbGxldElkKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZT8uZGF0YS5zZXJ2ZXJfc2lnbmVyX3N0YXR1cyA9PT0gdHlwZXNfMS5TZXJ2ZXJTaWduZXJTdGF0dXMuQUNUSVZFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgKDAsIHV0aWxzXzEuZGVsYXkpKGludGVydmFsU2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IGNyZWF0aW9uIHRpbWVkIG91dC4gQ2hlY2sgc3RhdHVzIG9mIHlvdXIgU2VydmVyLVNpZ25lclwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFzdGVyIG5vZGUgZm9yIHRoZSBnaXZlbiBzZWVkLCBpZiB2YWxpZC4gSWYgdGhlIHNlZWQgaXMgdW5kZWZpbmVkIGl0IHdpbGwgc2V0IHRoZSBtYXN0ZXIgbm9kZSB1c2luZyBhIHJhbmRvbSBzZWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlZWQgLSBUaGUgc2VlZCB0byB1c2UgZm9yIHRoZSBXYWxsZXQuXG4gICAgICogQHJldHVybnMgVGhlIG1hc3RlciBub2RlIGZvciB0aGUgZ2l2ZW4gc2VlZC5cbiAgICAgKi9cbiAgICBzZXRNYXN0ZXJOb2RlKHNlZWQpIHtcbiAgICAgICAgaWYgKHNlZWQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VlZCA9IGV0aGVyc18yLmV0aGVycy5XYWxsZXQuY3JlYXRlUmFuZG9tKCkucHJpdmF0ZUtleS5zbGljZSgyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbGlkYXRlU2VlZChzZWVkKTtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICAgICAgdGhpcy5tYXN0ZXIgPSBiaXAzMl8xLkhES2V5LmZyb21NYXN0ZXJTZWVkKEJ1ZmZlci5mcm9tKHNlZWQsIFwiaGV4XCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVyaXZlcyBhIGtleSBmb3IgYW4gYWxyZWFkeSByZWdpc3RlcmVkIEFkZHJlc3MgaW4gdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgQWRkcmVzcyB0byBkZXJpdmUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIGtleSBkZXJpdmF0aW9uIGZhaWxzLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZXJpdmVkIGtleS5cbiAgICAgKi9cbiAgICBkZXJpdmVLZXkoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hc3Rlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRlcml2ZSBrZXkgZm9yIFdhbGxldCB3aXRob3V0IHNlZWQgbG9hZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSB0aGlzLm1hc3Rlcj8uZGVyaXZlKHRoaXMuYWRkcmVzc1BhdGhQcmVmaXggKyBgLyR7aW5kZXh9YCk7XG4gICAgICAgIGlmICghZGVyaXZlZEtleT8ucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlcml2ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXR0ZXN0YXRpb24gZm9yIHRoZSBBZGRyZXNzIGN1cnJlbnRseSBiZWluZyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIFdhbGxldC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYXR0ZXN0YXRpb24uXG4gICAgICovXG4gICAgY3JlYXRlQXR0ZXN0YXRpb24oa2V5KSB7XG4gICAgICAgIGlmICgha2V5LnB1YmxpY0tleSB8fCAha2V5LnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICB0aHJvdyBFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSAoMCwgdXRpbHNfMS5jb252ZXJ0U3RyaW5nVG9IZXgpKGtleS5wdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgd2FsbGV0X2lkOiB0aGlzLm1vZGVsLmlkLFxuICAgICAgICAgICAgcHVibGljX2tleTogcHVibGljS2V5LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFzaGVkUGF5bG9hZCA9IGNyeXB0by5jcmVhdGVIYXNoKFwic2hhMjU2XCIpLnVwZGF0ZShwYXlsb2FkKS5kaWdlc3QoKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2VjcDI1NmsxLmVjZHNhU2lnbihoYXNoZWRQYXlsb2FkLCBrZXkucHJpdmF0ZUtleSk7XG4gICAgICAgIGNvbnN0IHIgPSBzaWduYXR1cmUuc2lnbmF0dXJlLnNsaWNlKDAsIDMyKTtcbiAgICAgICAgY29uc3QgcyA9IHNpZ25hdHVyZS5zaWduYXR1cmUuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgY29uc3QgdiA9IHNpZ25hdHVyZS5yZWNpZCArIDI3ICsgNDtcbiAgICAgICAgY29uc3QgbmV3U2lnbmF0dXJlQnVmZmVyID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oW3ZdKSwgciwgc10pO1xuICAgICAgICBjb25zdCBuZXdTaWduYXR1cmVIZXggPSBuZXdTaWduYXR1cmVCdWZmZXIudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICAgIHJldHVybiBuZXdTaWduYXR1cmVIZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIFdhbGxldCBtb2RlbCB3aXRoIHRoZSBsYXRlc3QgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGdldCBhIFdhbGxldCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyByZWxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53YWxsZXQuZ2V0V2FsbGV0KHRoaXMubW9kZWwuaWQpO1xuICAgICAgICB0aGlzLm1vZGVsID0gcmVzdWx0Py5kYXRhO1xuICAgIH1cbn1cbmV4cG9ydHMuV2FsbGV0ID0gV2FsbGV0O1xuV2FsbGV0Lk1BWF9BRERSRVNTRVMgPSAyMDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Webhook = void 0;\nconst api_1 = __webpack_require__(/*! ../client/api */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * A representation of a Webhook,\n * which provides methods to create, list, update, and delete webhooks that are used to receive notifications of specific events.\n */\nclass Webhook {\n    /**\n     * Initializes a new Webhook object.\n     *\n     * @param model - The underlying Webhook object.\n     * @throws {Error} If the model is not provided.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Webhook model cannot be empty\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns a new Webhook object. Do not use this method directly. Instead, Webhook.create(...)\n     *\n     * @constructs Webhook\n     * @param model - The underlying Webhook model object\n     * @returns A Webhook object.\n     */\n    static init(model) {\n        return new Webhook(model);\n    }\n    /**\n     * Creates a new webhook for a specified network.\n     *\n     * @param options - The options to create webhook.\n     * @param options.networkId - The network ID for which the webhook is created.\n     * @param options.notificationUri - The URI where notifications should be sent.\n     * @param options.eventType - The type of event for the webhook.\n     * @param options.eventTypeFilter - Filter for wallet or smart contract activity event types.\n     * @param options.eventFilters - Filters applied to the events that determine which specific events trigger the webhook.\n     * @returns A promise that resolves to a new instance of Webhook.\n     */\n    static async create({ networkId, notificationUri, eventType, eventTypeFilter, eventFilters = [], }) {\n        const result = await coinbase_1.Coinbase.apiClients.webhook.createWebhook({\n            network_id: networkId,\n            notification_uri: notificationUri,\n            event_type: eventType,\n            event_type_filter: eventTypeFilter,\n            event_filters: eventFilters,\n        });\n        return new Webhook(result.data);\n    }\n    /**\n     * Lists the Webhooks belonging to the CDP Project.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Webhooks to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Webhooks. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Webhooks.\n     */\n    static async list({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.webhook.listWebhooks(limit, page);\n        const webhooks = response.data.data;\n        for (const w of webhooks) {\n            data.push(new Webhook(w));\n        }\n        const hasMore = response.data.has_more ? response.data.has_more : false;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Returns the ID of the webhook.\n     *\n     * @returns The ID of the webhook, or undefined if the model is null.\n     */\n    getId() {\n        return this.model?.id;\n    }\n    /**\n     * Returns the network ID associated with the webhook.\n     *\n     * @returns The network ID of the webhook, or undefined if the model is null.\n     */\n    getNetworkId() {\n        return this.model?.network_id;\n    }\n    /**\n     * Returns the notification URI of the webhook.\n     *\n     * @returns The URI where notifications are sent, or undefined if the model is null.\n     */\n    getNotificationURI() {\n        return this.model?.notification_uri;\n    }\n    /**\n     * Returns the event type of the webhook.\n     *\n     * @returns The type of event the webhook listens for, or undefined if the model is null.\n     */\n    getEventType() {\n        return this.model?.event_type;\n    }\n    /**\n     * Returns the event type filter of the webhook.\n     *\n     * @returns The filter which will be used to filter for events of a certain event type\n     */\n    getEventTypeFilter() {\n        return this.model?.event_type_filter;\n    }\n    /**\n     * Returns the event filters applied to the webhook.\n     *\n     * @returns An array of event filters used by the webhook, or undefined if the model is null.\n     */\n    getEventFilters() {\n        return this.model?.event_filters;\n    }\n    /**\n     * Returns the signature header of the webhook.\n     *\n     * @returns The signature header which will be set on the callback requests, or undefined if the model is null.\n     */\n    getSignatureHeader() {\n        return this.model?.signature_header;\n    }\n    /**\n     * Updates the webhook with a new notification URI, and optionally a new list of addresses to monitor.\n     *\n     * @param options - The options to update webhook.\n     * @param options.notificationUri - The new URI for webhook notifications.\n     * @param options.eventTypeFilter - The new eventTypeFilter that contains a new list (replacement) of addresses to monitor for the webhook.\n     * @returns A promise that resolves to the updated Webhook object.\n     */\n    async update({ notificationUri, eventTypeFilter, }) {\n        const finalNotificationUri = notificationUri ?? this.getNotificationURI();\n        const finalEventTypeFilter = eventTypeFilter ?? this.getEventTypeFilter();\n        // wallet ID is required for wallet activity event type filter, but we do not support updating it just yet, this will be added in the future\n        if (this.getEventType() === api_1.WebhookEventType.WalletActivity) {\n            finalEventTypeFilter.wallet_id = (this.getEventTypeFilter()?.wallet_id);\n        }\n        const result = await coinbase_1.Coinbase.apiClients.webhook.updateWebhook(this.getId(), {\n            notification_uri: finalNotificationUri,\n            event_filters: this.getEventFilters(),\n            event_type_filter: finalEventTypeFilter,\n        });\n        this.model = result.data;\n        return this;\n    }\n    /**\n     * Deletes the webhook.\n     *\n     * @returns A promise that resolves when the webhook is deleted and its attributes are set to null.\n     */\n    async delete() {\n        await coinbase_1.Coinbase.apiClients.webhook.deleteWebhook(this.getId());\n        this.model = null;\n    }\n    /**\n     * Returns a String representation of the Webhook.\n     *\n     * @returns A String representation of the Webhook.\n     */\n    toString() {\n        return (`Webhook { id: '${this.getId()}', networkId: '${this.getNetworkId()}', ` +\n            `eventType: '${this.getEventType()}', eventFilter: ${JSON.stringify(this.getEventFilters())}, ` +\n            `eventTypeFilter: ${JSON.stringify(this.getEventTypeFilter())}, ` +\n            `notificationUri: '${this.getNotificationURI()}', signatureHeader: '${this.getSignatureHeader()}' }`);\n    }\n}\nexports.Webhook = Webhook;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3dlYmhvb2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGNBQWMsbUJBQU8sQ0FBQyxxRkFBZTtBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0RUFBNEU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrRUFBa0UsSUFBSTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxhQUFhLGlCQUFpQixvQkFBb0I7QUFDcEYsMkJBQTJCLG9CQUFvQixrQkFBa0IsdUNBQXVDO0FBQ3hHLGdDQUFnQywwQ0FBMEM7QUFDMUUsaUNBQWlDLDBCQUEwQix1QkFBdUIsMEJBQTBCLEdBQUc7QUFDL0c7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS93ZWJob29rLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWJob29rID0gdm9pZCAwO1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiLi4vY2xpZW50L2FwaVwiKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIFdlYmhvb2ssXG4gKiB3aGljaCBwcm92aWRlcyBtZXRob2RzIHRvIGNyZWF0ZSwgbGlzdCwgdXBkYXRlLCBhbmQgZGVsZXRlIHdlYmhvb2tzIHRoYXQgYXJlIHVzZWQgdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHNwZWNpZmljIGV2ZW50cy5cbiAqL1xuY2xhc3MgV2ViaG9vayB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgV2ViaG9vayBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBXZWJob29rIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1vZGVsIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJob29rIG1vZGVsIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgV2ViaG9vayBvYmplY3QuIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkuIEluc3RlYWQsIFdlYmhvb2suY3JlYXRlKC4uLilcbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RzIFdlYmhvb2tcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBXZWJob29rIG1vZGVsIG9iamVjdFxuICAgICAqIEByZXR1cm5zIEEgV2ViaG9vayBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGluaXQobW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJob29rKG1vZGVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB3ZWJob29rIGZvciBhIHNwZWNpZmllZCBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjcmVhdGUgd2ViaG9vay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uZXR3b3JrSWQgLSBUaGUgbmV0d29yayBJRCBmb3Igd2hpY2ggdGhlIHdlYmhvb2sgaXMgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5ub3RpZmljYXRpb25VcmkgLSBUaGUgVVJJIHdoZXJlIG5vdGlmaWNhdGlvbnMgc2hvdWxkIGJlIHNlbnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZXZlbnRUeXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQgZm9yIHRoZSB3ZWJob29rLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmV2ZW50VHlwZUZpbHRlciAtIEZpbHRlciBmb3Igd2FsbGV0IG9yIHNtYXJ0IGNvbnRyYWN0IGFjdGl2aXR5IGV2ZW50IHR5cGVzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmV2ZW50RmlsdGVycyAtIEZpbHRlcnMgYXBwbGllZCB0byB0aGUgZXZlbnRzIHRoYXQgZGV0ZXJtaW5lIHdoaWNoIHNwZWNpZmljIGV2ZW50cyB0cmlnZ2VyIHRoZSB3ZWJob29rLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbmV3IGluc3RhbmNlIG9mIFdlYmhvb2suXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZSh7IG5ldHdvcmtJZCwgbm90aWZpY2F0aW9uVXJpLCBldmVudFR5cGUsIGV2ZW50VHlwZUZpbHRlciwgZXZlbnRGaWx0ZXJzID0gW10sIH0pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndlYmhvb2suY3JlYXRlV2ViaG9vayh7XG4gICAgICAgICAgICBuZXR3b3JrX2lkOiBuZXR3b3JrSWQsXG4gICAgICAgICAgICBub3RpZmljYXRpb25fdXJpOiBub3RpZmljYXRpb25VcmksXG4gICAgICAgICAgICBldmVudF90eXBlOiBldmVudFR5cGUsXG4gICAgICAgICAgICBldmVudF90eXBlX2ZpbHRlcjogZXZlbnRUeXBlRmlsdGVyLFxuICAgICAgICAgICAgZXZlbnRfZmlsdGVyczogZXZlbnRGaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJob29rKHJlc3VsdC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIFdlYmhvb2tzIGJlbG9uZ2luZyB0byB0aGUgQ0RQIFByb2plY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYWdpbmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgV2ViaG9va3MgdG8gcmV0dXJuLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFnZSAtIFRoZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIFdlYmhvb2tzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHQgcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhZ2luYXRlZCBsaXN0IHJlc3BvbnNlIG9mIFdlYmhvb2tzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBsaXN0KHsgbGltaXQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLmRlZmF1bHRQYWdlTGltaXQsIHBhZ2UgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGxldCBuZXh0UGFnZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2ViaG9vay5saXN0V2ViaG9va3MobGltaXQsIHBhZ2UpO1xuICAgICAgICBjb25zdCB3ZWJob29rcyA9IHJlc3BvbnNlLmRhdGEuZGF0YTtcbiAgICAgICAgZm9yIChjb25zdCB3IG9mIHdlYmhvb2tzKSB7XG4gICAgICAgICAgICBkYXRhLnB1c2gobmV3IFdlYmhvb2sodykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc01vcmUgPSByZXNwb25zZS5kYXRhLmhhc19tb3JlID8gcmVzcG9uc2UuZGF0YS5oYXNfbW9yZSA6IGZhbHNlO1xuICAgICAgICBpZiAoaGFzTW9yZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBhZ2UgPSByZXNwb25zZS5kYXRhLm5leHRfcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGhhc01vcmUsXG4gICAgICAgICAgICBuZXh0UGFnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIHdlYmhvb2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgSUQgb2YgdGhlIHdlYmhvb2ssIG9yIHVuZGVmaW5lZCBpZiB0aGUgbW9kZWwgaXMgbnVsbC5cbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWw/LmlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXR3b3JrIElEIGFzc29jaWF0ZWQgd2l0aCB0aGUgd2ViaG9vay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXR3b3JrIElEIG9mIHRoZSB3ZWJob29rLCBvciB1bmRlZmluZWQgaWYgdGhlIG1vZGVsIGlzIG51bGwuXG4gICAgICovXG4gICAgZ2V0TmV0d29ya0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbD8ubmV0d29ya19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbm90aWZpY2F0aW9uIFVSSSBvZiB0aGUgd2ViaG9vay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBVUkkgd2hlcmUgbm90aWZpY2F0aW9ucyBhcmUgc2VudCwgb3IgdW5kZWZpbmVkIGlmIHRoZSBtb2RlbCBpcyBudWxsLlxuICAgICAqL1xuICAgIGdldE5vdGlmaWNhdGlvblVSSSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWw/Lm5vdGlmaWNhdGlvbl91cmk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV2ZW50IHR5cGUgb2YgdGhlIHdlYmhvb2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdHlwZSBvZiBldmVudCB0aGUgd2ViaG9vayBsaXN0ZW5zIGZvciwgb3IgdW5kZWZpbmVkIGlmIHRoZSBtb2RlbCBpcyBudWxsLlxuICAgICAqL1xuICAgIGdldEV2ZW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWw/LmV2ZW50X3R5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV2ZW50IHR5cGUgZmlsdGVyIG9mIHRoZSB3ZWJob29rLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGZpbHRlciB3aGljaCB3aWxsIGJlIHVzZWQgdG8gZmlsdGVyIGZvciBldmVudHMgb2YgYSBjZXJ0YWluIGV2ZW50IHR5cGVcbiAgICAgKi9cbiAgICBnZXRFdmVudFR5cGVGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsPy5ldmVudF90eXBlX2ZpbHRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXZlbnQgZmlsdGVycyBhcHBsaWVkIHRvIHRoZSB3ZWJob29rLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgZXZlbnQgZmlsdGVycyB1c2VkIGJ5IHRoZSB3ZWJob29rLCBvciB1bmRlZmluZWQgaWYgdGhlIG1vZGVsIGlzIG51bGwuXG4gICAgICovXG4gICAgZ2V0RXZlbnRGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbD8uZXZlbnRfZmlsdGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2lnbmF0dXJlIGhlYWRlciBvZiB0aGUgd2ViaG9vay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduYXR1cmUgaGVhZGVyIHdoaWNoIHdpbGwgYmUgc2V0IG9uIHRoZSBjYWxsYmFjayByZXF1ZXN0cywgb3IgdW5kZWZpbmVkIGlmIHRoZSBtb2RlbCBpcyBudWxsLlxuICAgICAqL1xuICAgIGdldFNpZ25hdHVyZUhlYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWw/LnNpZ25hdHVyZV9oZWFkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHdlYmhvb2sgd2l0aCBhIG5ldyBub3RpZmljYXRpb24gVVJJLCBhbmQgb3B0aW9uYWxseSBhIG5ldyBsaXN0IG9mIGFkZHJlc3NlcyB0byBtb25pdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byB1cGRhdGUgd2ViaG9vay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5ub3RpZmljYXRpb25VcmkgLSBUaGUgbmV3IFVSSSBmb3Igd2ViaG9vayBub3RpZmljYXRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmV2ZW50VHlwZUZpbHRlciAtIFRoZSBuZXcgZXZlbnRUeXBlRmlsdGVyIHRoYXQgY29udGFpbnMgYSBuZXcgbGlzdCAocmVwbGFjZW1lbnQpIG9mIGFkZHJlc3NlcyB0byBtb25pdG9yIGZvciB0aGUgd2ViaG9vay5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdXBkYXRlZCBXZWJob29rIG9iamVjdC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUoeyBub3RpZmljYXRpb25VcmksIGV2ZW50VHlwZUZpbHRlciwgfSkge1xuICAgICAgICBjb25zdCBmaW5hbE5vdGlmaWNhdGlvblVyaSA9IG5vdGlmaWNhdGlvblVyaSA/PyB0aGlzLmdldE5vdGlmaWNhdGlvblVSSSgpO1xuICAgICAgICBjb25zdCBmaW5hbEV2ZW50VHlwZUZpbHRlciA9IGV2ZW50VHlwZUZpbHRlciA/PyB0aGlzLmdldEV2ZW50VHlwZUZpbHRlcigpO1xuICAgICAgICAvLyB3YWxsZXQgSUQgaXMgcmVxdWlyZWQgZm9yIHdhbGxldCBhY3Rpdml0eSBldmVudCB0eXBlIGZpbHRlciwgYnV0IHdlIGRvIG5vdCBzdXBwb3J0IHVwZGF0aW5nIGl0IGp1c3QgeWV0LCB0aGlzIHdpbGwgYmUgYWRkZWQgaW4gdGhlIGZ1dHVyZVxuICAgICAgICBpZiAodGhpcy5nZXRFdmVudFR5cGUoKSA9PT0gYXBpXzEuV2ViaG9va0V2ZW50VHlwZS5XYWxsZXRBY3Rpdml0eSkge1xuICAgICAgICAgICAgZmluYWxFdmVudFR5cGVGaWx0ZXIud2FsbGV0X2lkID0gKHRoaXMuZ2V0RXZlbnRUeXBlRmlsdGVyKCk/LndhbGxldF9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndlYmhvb2sudXBkYXRlV2ViaG9vayh0aGlzLmdldElkKCksIHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbl91cmk6IGZpbmFsTm90aWZpY2F0aW9uVXJpLFxuICAgICAgICAgICAgZXZlbnRfZmlsdGVyczogdGhpcy5nZXRFdmVudEZpbHRlcnMoKSxcbiAgICAgICAgICAgIGV2ZW50X3R5cGVfZmlsdGVyOiBmaW5hbEV2ZW50VHlwZUZpbHRlcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIHdlYmhvb2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSB3ZWJob29rIGlzIGRlbGV0ZWQgYW5kIGl0cyBhdHRyaWJ1dGVzIGFyZSBzZXQgdG8gbnVsbC5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUoKSB7XG4gICAgICAgIGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53ZWJob29rLmRlbGV0ZVdlYmhvb2sodGhpcy5nZXRJZCgpKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFdlYmhvb2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgV2ViaG9vay5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChgV2ViaG9vayB7IGlkOiAnJHt0aGlzLmdldElkKCl9JywgbmV0d29ya0lkOiAnJHt0aGlzLmdldE5ldHdvcmtJZCgpfScsIGAgK1xuICAgICAgICAgICAgYGV2ZW50VHlwZTogJyR7dGhpcy5nZXRFdmVudFR5cGUoKX0nLCBldmVudEZpbHRlcjogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmdldEV2ZW50RmlsdGVycygpKX0sIGAgK1xuICAgICAgICAgICAgYGV2ZW50VHlwZUZpbHRlcjogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmdldEV2ZW50VHlwZUZpbHRlcigpKX0sIGAgK1xuICAgICAgICAgICAgYG5vdGlmaWNhdGlvblVyaTogJyR7dGhpcy5nZXROb3RpZmljYXRpb25VUkkoKX0nLCBzaWduYXR1cmVIZWFkZXI6ICcke3RoaXMuZ2V0U2lnbmF0dXJlSGVhZGVyKCl9JyB9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJob29rID0gV2ViaG9vaztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./coinbase/address */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/address/external_address */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/external_address.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/address/wallet_address */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/api_error */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/authenticator */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/balance_map */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/constants */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/contract_event */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/contract_invocation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/faucet_transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/hash */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/hash.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/historical_balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/payload_signature */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/server_signer */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/server_signer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/smart_contract */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/staking_balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/staking_operation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/staking_reward */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/trade */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/transfer */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/validator */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/validator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/wallet */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/webhook */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/read_contract */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/read_contract.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/crypto_amount */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/crypto_amount.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/fiat_amount */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fiat_amount.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/fund_operation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_operation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/fund_quote */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_quote.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLGtJQUFxQztBQUMxRCxhQUFhLG1CQUFPLENBQUMsOEhBQW1DO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQyxvR0FBc0I7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLDRGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsNEdBQTBCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLHdHQUF3QjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsa0dBQXFCO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyxvR0FBc0I7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLDhHQUEyQjtBQUNoRCxhQUFhLG1CQUFPLENBQUMsd0hBQWdDO0FBQ3JELGFBQWEsbUJBQU8sQ0FBQyw4RkFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLHNIQUErQjtBQUNwRCxhQUFhLG1CQUFPLENBQUMsMEZBQWlCO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyxzSEFBK0I7QUFDcEQsYUFBYSxtQkFBTyxDQUFDLG9IQUE4QjtBQUNuRCxhQUFhLG1CQUFPLENBQUMsNEdBQTBCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyw4R0FBMkI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLGdIQUE0QjtBQUNqRCxhQUFhLG1CQUFPLENBQUMsb0hBQThCO0FBQ25ELGFBQWEsbUJBQU8sQ0FBQyw4R0FBMkI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLDRGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsd0dBQXdCO0FBQzdDLGFBQWEsbUJBQU8sQ0FBQyxrR0FBcUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLDRGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsb0dBQXNCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyw4RkFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGdHQUFvQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsNEdBQTBCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyw0R0FBMEI7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLHdHQUF3QjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsOEdBQTJCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQyxzR0FBdUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2FkZHJlc3NcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2FkZHJlc3MvZXh0ZXJuYWxfYWRkcmVzc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvYWRkcmVzcy93YWxsZXRfYWRkcmVzc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvYXBpX2Vycm9yXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9hc3NldFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvYXV0aGVudGljYXRvclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvYmFsYW5jZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvYmFsYW5jZV9tYXBcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2NvaW5iYXNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9jb25zdGFudHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2NvbnRyYWN0X2V2ZW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9jb250cmFjdF9pbnZvY2F0aW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9lcnJvcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2ZhdWNldF90cmFuc2FjdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvaGFzaFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvaGlzdG9yaWNhbF9iYWxhbmNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9wYXlsb2FkX3NpZ25hdHVyZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2Uvc2VydmVyX3NpZ25lclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2Uvc21hcnRfY29udHJhY3RcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3N0YWtpbmdfYmFsYW5jZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2Uvc3Rha2luZ19vcGVyYXRpb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3N0YWtpbmdfcmV3YXJkXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS90cmFkZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvdHJhbnNhY3Rpb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3RyYW5zZmVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS90eXBlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvdmFsaWRhdG9yXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS93YWxsZXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3dlYmhvb2tcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3JlYWRfY29udHJhY3RcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2NyeXB0b19hbW91bnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2ZpYXRfYW1vdW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9mdW5kX29wZXJhdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvZnVuZF9xdW90ZVwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/package.json":
/*!**********************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/package.json ***!
  \**********************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@coinbase/coinbase-sdk","author":"Coinbase Inc.","license":"ISC","description":"Coinbase Platform SDK","repository":"https://github.com/coinbase/coinbase-sdk-nodejs","version":"0.17.0","main":"dist/index.js","types":"dist/index.d.ts","scripts":{"lint":"eslint -c .eslintrc.json src/coinbase/**.ts","lint-fix":"eslint -c .eslintrc.json src/coinbase/*.ts --fix","format":"prettier -c .prettierrc --write \\"**/*.{ts,js,cjs,json,md}\\"","format-check":"prettier -c .prettierrc --check \\"**/*.{ts,js,cjs,json,md}\\"","check":"tsc --noEmit","test":"npx jest --no-cache  --testMatch=**/*_test.ts","test:dry-run":"npm install && npm ci && npm publish --dry-run","test:e2e":"npx jest --no-cache --testMatch=**/e2e.ts --coverageThreshold \'{}\'","test:e2e:stake":"npx jest --no-cache --testMatch=**/e2e.ts --coverageThreshold \'{}\' -t Stake","test:types":"tsd --files src/tests/types.test-d.ts","clean":"rm -rf dist/*","build":"tsc","prepack":"tsc","docs":"typedoc --entryPoints ./src --entryPointStrategy expand --exclude ./src/tests/**/*.ts"},"files":["dist"],"dependencies":{"@scure/bip32":"^1.4.0","abitype":"^1.0.6","axios":"^1.6.8","axios-mock-adapter":"^1.22.0","axios-retry":"^4.4.1","bip32":"^4.0.0","bip39":"^3.1.0","decimal.js":"^10.4.3","dotenv":"^16.4.5","ethers":"^6.12.1","node-jose":"^2.2.0","secp256k1":"^5.0.0","viem":"^2.21.26"},"devDependencies":{"@types/jest":"^29.5.12","@types/node":"^20.12.11","@types/node-jose":"^1.1.13","@types/secp256k1":"^4.0.6","@typescript-eslint/eslint-plugin":"^7.8.0","@typescript-eslint/parser":"^7.8.0","eslint":"^8.57.0","eslint-config-prettier":"^9.1.0","eslint-plugin-jsdoc":"^48.2.5","eslint-plugin-prettier":"^5.1.3","jest":"^29.7.0","mock-fs":"^5.2.0","prettier":"^3.2.5","ts-jest":"^29.1.2","ts-node":"^10.9.2","tsd":"^0.31.2","typedoc":"^0.25.13","typescript":"^5.4.5"}}');

/***/ })

};
;