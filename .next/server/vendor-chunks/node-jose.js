"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-jose";
exports.ids = ["vendor-chunks/node-jose"];
exports.modules = {

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/aes-cbc-hmac-sha2.js":
/*!********************************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/aes-cbc-hmac-sha2.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/aes-cbc-hmac-sha2.js - AES-CBC-HMAC-SHA2 Composited Encryption\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    HMAC = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js\"),\n    sha = __webpack_require__(/*! ./sha.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    DataBuffer = __webpack_require__(/*! ../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\nfunction checkIv(iv) {\n  if (16 !== iv.length) {\n    throw new Error(\"invalid iv\");\n  }\n}\n\nfunction commonCbcEncryptFN(size) {\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(encKey, pdata, iv) {\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var cipher = forge.cipher.createCipher(\"AES-CBC\", new DataBuffer(encKey));\n      cipher.start({\n        iv: new DataBuffer(iv)\n      });\n\n      // TODO: chunk data\n      cipher.update(new DataBuffer(pdata));\n      if (!cipher.finish()) {\n        return Promise.reject(new Error(\"encryption failed\"));\n      }\n\n      var cdata = Buffer.from(cipher.output.bytes(), \"binary\");\n      return cdata;\n    });\n\n    return promise;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(encKey, pdata, iv) {\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var alg = {\n        name: \"AES-CBC\"\n      };\n      return helpers.subtleCrypto.importKey(\"raw\", encKey, alg, true, [\"encrypt\"]);\n    });\n    promise = promise.then(function(key) {\n      var alg = {\n        name: \"AES-CBC\",\n        iv: iv\n      };\n      return helpers.subtleCrypto.encrypt(alg, key, pdata);\n    });\n    promise = promise.then(function(cdata) {\n      cdata = Buffer.from(cdata);\n      return cdata;\n    });\n\n    return promise;\n  };\n\n  // ### NodeJS implementation\n  var nodejs = function(encKey, pdata, iv) {\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve(pdata);\n\n    promise = promise.then(function(pdata) {\n      var name = \"AES-\" + size + \"-CBC\";\n      var cipher = helpers.nodeCrypto.createCipheriv(name, encKey, iv);\n      var cdata = Buffer.concat([\n        cipher.update(pdata),\n        cipher.final()\n      ]);\n      return cdata;\n    });\n\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction commonCbcDecryptFN(size) {\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(encKey, cdata, iv) {\n    // validate inputs\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var cipher = forge.cipher.createDecipher(\"AES-CBC\", new DataBuffer(encKey));\n      cipher.start({\n        iv: new DataBuffer(iv)\n      });\n\n      // TODO: chunk data\n      cipher.update(new DataBuffer(cdata));\n      if (!cipher.finish()) {\n        return Promise.reject(new Error(\"encryption failed\"));\n      }\n\n      var pdata = Buffer.from(cipher.output.bytes(), \"binary\");\n      return pdata;\n    });\n\n    return promise;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(encKey, cdata, iv) {\n    // validate inputs\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var alg = {\n        name: \"AES-CBC\"\n      };\n      return helpers.subtleCrypto.importKey(\"raw\", encKey, alg, true, [\"decrypt\"]);\n    });\n    promise = promise.then(function(key) {\n      var alg = {\n        name: \"AES-CBC\",\n        iv: iv\n      };\n      return helpers.subtleCrypto.decrypt(alg, key, cdata);\n    });\n    promise = promise.then(function(pdata) {\n      pdata = Buffer.from(pdata);\n      return pdata;\n    });\n\n    return promise;\n  };\n\n  // ### NodeJS implementation\n  var nodejs = function(encKey, cdata, iv) {\n    // validate inputs\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var name = \"AES-\" + size + \"-CBC\";\n      var cipher = helpers.nodeCrypto.createDecipheriv(name, encKey, iv);\n      var pdata = Buffer.concat([\n        cipher.update(cdata),\n        cipher.final()\n      ]);\n      return pdata;\n    });\n\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction checkKey(key, size) {\n  if ((size << 1) !== (key.length << 3)) {\n    throw new Error(\"invalid encryption key size\");\n  }\n}\n\nfunction cbcHmacEncryptFN(size) {\n  var commonEncrypt = commonCbcEncryptFN(size);\n  return function(key, pdata, props) {\n    // validate inputs\n    try {\n      checkKey(key, size);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var eKey = key.slice(size / 8),\n        iKey = key.slice(0, size / 8),\n        iv = props.iv || Buffer.alloc(0),\n        adata = props.aad || props.adata || Buffer.alloc(0);\n\n    // STEP 1 -- Encrypt\n    var promise = commonEncrypt(eKey, pdata, iv);\n\n    // STEP 2 -- MAC\n    promise = promise.then(function(cdata){\n      var mdata = Buffer.concat([\n        adata,\n        iv,\n        cdata,\n        helpers.int64ToBuffer(adata.length * 8)\n      ]);\n\n      var promise;\n      promise = HMAC[\"HS\" + (size * 2)].sign(iKey, mdata, {\n        length: size\n      });\n      promise = promise.then(function(result) {\n        // TODO: move slice to hmac.js\n        var tag = result.mac.slice(0, size / 8);\n        return {\n          data: cdata,\n          tag: tag\n        };\n      });\n      return promise;\n    });\n\n    return promise;\n  };\n}\n\nfunction cbcHmacDecryptFN(size) {\n  var commonDecrypt = commonCbcDecryptFN(size);\n\n  return function(key, cdata, props) {\n    // validate inputs\n    try {\n      checkKey(key, size);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var eKey = key.slice(size / 8),\n        iKey = key.slice(0, size / 8),\n        iv = props.iv || Buffer.alloc(0),\n        adata = props.aad || props.adata || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0);\n\n    var promise = Promise.resolve();\n\n    // STEP 1 -- MAC\n    promise = promise.then(function() {\n      var promise;\n      // construct MAC input\n      var mdata = Buffer.concat([\n        adata,\n        iv,\n        cdata,\n        helpers.int64ToBuffer(adata.length * 8)\n      ]);\n      promise = HMAC[\"HS\" + (size * 2)].verify(iKey, mdata, tag, {\n        length: size\n      });\n      promise = promise.then(function() {\n        return cdata;\n      }, function() {\n        // failure -- invalid tag error\n        throw new Error(\"mac check failed\");\n      });\n      return promise;\n    });\n\n    // STEP 2 -- Decrypt\n    promise = promise.then(function(){\n      return commonDecrypt(eKey, cdata, iv);\n    });\n\n    return promise;\n  };\n}\n\nvar EncryptionLabel = Buffer.from(\"Encryption\", \"utf8\");\nvar IntegrityLabel = Buffer.from(\"Integrity\", \"utf8\");\nvar DotLabel = Buffer.from(\".\", \"utf8\");\n\nfunction generateCek(masterKey, alg, epu, epv) {\n  var masterSize = masterKey.length * 8;\n  var cekSize = masterSize / 2;\n  var promise = Promise.resolve();\n\n  promise = promise.then(function(){\n    var input = Buffer.concat([\n      helpers.int32ToBuffer(1),\n      masterKey,\n      helpers.int32ToBuffer(cekSize),\n      Buffer.from(alg, \"utf8\"),\n      epu,\n      epv,\n      EncryptionLabel\n    ]);\n\n    return input;\n  });\n\n  promise = promise.then( function(input) {\n    return sha[\"SHA-\" + masterSize].digest(input).then(function(digest) {\n      return digest.slice(0, cekSize / 8);\n    });\n  });\n  promise = Promise.resolve(promise);\n\n  return promise;\n}\n\nfunction generateCik(masterKey, alg, epu, epv) {\n  var masterSize = masterKey.length * 8;\n  var cikSize = masterSize;\n  var promise = Promise.resolve();\n\n  promise = promise.then(function(){\n    var input = Buffer.concat([\n      helpers.int32ToBuffer(1),\n      masterKey,\n      helpers.int32ToBuffer(cikSize),\n      Buffer.from(alg, \"utf8\"),\n      epu,\n      epv,\n      IntegrityLabel\n    ]);\n\n    return input;\n  });\n\n  promise = promise.then( function(input) {\n    return sha[\"SHA-\" + masterSize].digest(input).then(function(digest) {\n      return digest.slice(0, cikSize / 8);\n    });\n  });\n  promise = Promise.resolve(promise);\n\n  return promise;\n}\n\nfunction concatKdfCbcHmacEncryptFN(size, alg) {\n  var commonEncrypt = commonCbcEncryptFN(size);\n\n  return function(key, pdata, props) {\n    var epu = props.epu || helpers.int32ToBuffer(0),\n        epv = props.epv || helpers.int32ToBuffer(0),\n        iv = props.iv || Buffer.alloc(0),\n        adata = props.aad || props.adata || Buffer.alloc(0),\n        kdata = props.kdata || Buffer.alloc(0);\n\n    // Pre Step 1 -- Generate Keys\n    var promises = [\n      generateCek(key, alg, epu, epv),\n      generateCik(key, alg, epu, epv)\n    ];\n\n    var cek,\n        cik;\n    var promise = Promise.all(promises).then(function(keys) {\n      cek = keys[0];\n      cik = keys[1];\n    });\n\n    // STEP 1 -- Encrypt\n    promise = promise.then(function(){\n      return commonEncrypt(cek, pdata, iv);\n    });\n\n    // STEP 2 -- Mac\n    promise = promise.then(function(cdata){\n      var mdata = Buffer.concat([\n        adata,\n        DotLabel,\n        Buffer.from(kdata),\n        DotLabel,\n        Buffer.from(util.base64url.encode(iv), \"utf8\"),\n        DotLabel,\n        Buffer.from(util.base64url.encode(cdata), \"utf8\")\n      ]);\n      return Promise.all([\n        Promise.resolve(cdata),\n        HMAC[\"HS\" + (size * 2)].sign(cik, mdata, { length: size })\n      ]);\n    });\n    promise = promise.then(function(result){\n      return {\n        data: result[0],\n        tag: result[1].mac\n      };\n    });\n\n    return promise;\n  };\n}\n\nfunction concatKdfCbcHmacDecryptFN(size, alg) {\n  var commonDecrypt = commonCbcDecryptFN(size);\n\n  return function(key, cdata, props) {\n    var epu = props.epu || helpers.int32ToBuffer(0),\n        epv = props.epv || helpers.int32ToBuffer(0),\n        iv = props.iv || Buffer.alloc(0),\n        adata = props.aad || props.adata || Buffer.alloc(0),\n        kdata = props.kdata || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0);\n\n    // Pre Step 1 -- Generate Keys\n    var promises = [\n      generateCek(key, alg, epu, epv),\n      generateCik(key, alg, epu, epv)\n    ];\n\n    var cek,\n        cik;\n    var promise = Promise.all(promises).then(function(keys){\n      cek = keys[0];\n      cik = keys[1];\n    });\n\n\n    // STEP 1 -- MAC\n    promise = promise.then(function() {\n      // construct MAC input\n      var mdata = Buffer.concat([\n        adata,\n        DotLabel,\n        Buffer.from(kdata),\n        DotLabel,\n        Buffer.from(util.base64url.encode(iv), \"utf8\"),\n        DotLabel,\n        Buffer.from(util.base64url.encode(cdata), \"utf8\")\n      ]);\n\n      try {\n        return HMAC[\"HS\" + (size * 2)].verify(cik, mdata, tag, {\n          loose: false\n        });\n      } catch (e) {\n        throw new Error(\"mac check failed\");\n      }\n    });\n\n    // STEP 2 -- Decrypt\n    promise = promise.then(function(){\n      return commonDecrypt(cek, cdata, iv);\n    });\n\n    return promise;\n  };\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar aesCbcHmacSha2 = {};\n[\n  \"A128CBC-HS256\",\n  \"A192CBC-HS384\",\n  \"A256CBC-HS512\"\n].forEach(function(alg) {\n  var size = parseInt(/A(\\d+)CBC-HS(\\d+)?/g.exec(alg)[1]);\n  aesCbcHmacSha2[alg] = {\n    encrypt: cbcHmacEncryptFN(size),\n    decrypt: cbcHmacDecryptFN(size)\n  };\n});\n\n[\n  \"A128CBC+HS256\",\n  \"A192CBC+HS384\",\n  \"A256CBC+HS512\"\n].forEach(function(alg) {\n  var size = parseInt(/A(\\d+)CBC\\+HS(\\d+)?/g.exec(alg)[1]);\n  aesCbcHmacSha2[alg] = {\n    encrypt: concatKdfCbcHmacEncryptFN(size, alg),\n    decrypt: concatKdfCbcHmacDecryptFN(size, alg)\n  };\n});\n\nmodule.exports = aesCbcHmacSha2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Flcy1jYmMtaG1hYy1zaGEyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsOEVBQWM7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLHdFQUFXO0FBQzlCLFVBQVUsbUJBQU8sQ0FBQyxzRUFBVTtBQUM1QixZQUFZLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3RDLGlCQUFpQixtQkFBTyxDQUFDLG9GQUF1QjtBQUNoRCxXQUFXLG1CQUFPLENBQUMsaUVBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvYWVzLWNiYy1obWFjLXNoYTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL2Flcy1jYmMtaG1hYy1zaGEyLmpzIC0gQUVTLUNCQy1ITUFDLVNIQTIgQ29tcG9zaXRlZCBFbmNyeXB0aW9uXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIiksXG4gICAgSE1BQyA9IHJlcXVpcmUoXCIuL2htYWMuanNcIiksXG4gICAgc2hhID0gcmVxdWlyZShcIi4vc2hhLmpzXCIpLFxuICAgIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2UuanNcIiksXG4gICAgRGF0YUJ1ZmZlciA9IHJlcXVpcmUoXCIuLi91dGlsL2RhdGFidWZmZXIuanNcIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBjaGVja0l2KGl2KSB7XG4gIGlmICgxNiAhPT0gaXYubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpdlwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21tb25DYmNFbmNyeXB0Rk4oc2l6ZSkge1xuICAvLyAjIyMgJ2ZhbGxiYWNrJyBpbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGVuY0tleSwgcGRhdGEsIGl2KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNoZWNrSXYoaXYpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcihcIkFFUy1DQkNcIiwgbmV3IERhdGFCdWZmZXIoZW5jS2V5KSk7XG4gICAgICBjaXBoZXIuc3RhcnQoe1xuICAgICAgICBpdjogbmV3IERhdGFCdWZmZXIoaXYpXG4gICAgICB9KTtcblxuICAgICAgLy8gVE9ETzogY2h1bmsgZGF0YVxuICAgICAgY2lwaGVyLnVwZGF0ZShuZXcgRGF0YUJ1ZmZlcihwZGF0YSkpO1xuICAgICAgaWYgKCFjaXBoZXIuZmluaXNoKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImVuY3J5cHRpb24gZmFpbGVkXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNkYXRhID0gQnVmZmVyLmZyb20oY2lwaGVyLm91dHB1dC5ieXRlcygpLCBcImJpbmFyeVwiKTtcbiAgICAgIHJldHVybiBjZGF0YTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgaW1wbGVtZW50YXRpb25cbiAgLy8gVE9ETzogY2FjaGUgQ3J5cHRvS2V5IHNvb25lclxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oZW5jS2V5LCBwZGF0YSwgaXYpIHtcbiAgICB0cnkge1xuICAgICAgY2hlY2tJdihpdik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhbGcgPSB7XG4gICAgICAgIG5hbWU6IFwiQUVTLUNCQ1wiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcInJhd1wiLCBlbmNLZXksIGFsZywgdHJ1ZSwgW1wiZW5jcnlwdFwiXSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBhbGcgPSB7XG4gICAgICAgIG5hbWU6IFwiQUVTLUNCQ1wiLFxuICAgICAgICBpdjogaXZcbiAgICAgIH07XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uZW5jcnlwdChhbGcsIGtleSwgcGRhdGEpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oY2RhdGEpIHtcbiAgICAgIGNkYXRhID0gQnVmZmVyLmZyb20oY2RhdGEpO1xuICAgICAgcmV0dXJuIGNkYXRhO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gIyMjIE5vZGVKUyBpbXBsZW1lbnRhdGlvblxuICB2YXIgbm9kZWpzID0gZnVuY3Rpb24oZW5jS2V5LCBwZGF0YSwgaXYpIHtcbiAgICB0cnkge1xuICAgICAgY2hlY2tJdihpdik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShwZGF0YSk7XG5cbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHBkYXRhKSB7XG4gICAgICB2YXIgbmFtZSA9IFwiQUVTLVwiICsgc2l6ZSArIFwiLUNCQ1wiO1xuICAgICAgdmFyIGNpcGhlciA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVDaXBoZXJpdihuYW1lLCBlbmNLZXksIGl2KTtcbiAgICAgIHZhciBjZGF0YSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICBjaXBoZXIudXBkYXRlKHBkYXRhKSxcbiAgICAgICAgY2lwaGVyLmZpbmFsKClcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIGNkYXRhO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBjb21tb25DYmNEZWNyeXB0Rk4oc2l6ZSkge1xuICAvLyAjIyMgJ2ZhbGxiYWNrJyBpbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGVuY0tleSwgY2RhdGEsIGl2KSB7XG4gICAgLy8gdmFsaWRhdGUgaW5wdXRzXG4gICAgdHJ5IHtcbiAgICAgIGNoZWNrSXYoaXYpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKFwiQUVTLUNCQ1wiLCBuZXcgRGF0YUJ1ZmZlcihlbmNLZXkpKTtcbiAgICAgIGNpcGhlci5zdGFydCh7XG4gICAgICAgIGl2OiBuZXcgRGF0YUJ1ZmZlcihpdilcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUT0RPOiBjaHVuayBkYXRhXG4gICAgICBjaXBoZXIudXBkYXRlKG5ldyBEYXRhQnVmZmVyKGNkYXRhKSk7XG4gICAgICBpZiAoIWNpcGhlci5maW5pc2goKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiZW5jcnlwdGlvbiBmYWlsZWRcIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGRhdGEgPSBCdWZmZXIuZnJvbShjaXBoZXIub3V0cHV0LmJ5dGVzKCksIFwiYmluYXJ5XCIpO1xuICAgICAgcmV0dXJuIHBkYXRhO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBpbXBsZW1lbnRhdGlvblxuICAvLyBUT0RPOiBjYWNoZSBDcnlwdG9LZXkgc29vbmVyXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihlbmNLZXksIGNkYXRhLCBpdikge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0c1xuICAgIHRyeSB7XG4gICAgICBjaGVja0l2KGl2KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFsZyA9IHtcbiAgICAgICAgbmFtZTogXCJBRVMtQ0JDXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwicmF3XCIsIGVuY0tleSwgYWxnLCB0cnVlLCBbXCJkZWNyeXB0XCJdKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGFsZyA9IHtcbiAgICAgICAgbmFtZTogXCJBRVMtQ0JDXCIsXG4gICAgICAgIGl2OiBpdlxuICAgICAgfTtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5kZWNyeXB0KGFsZywga2V5LCBjZGF0YSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihwZGF0YSkge1xuICAgICAgcGRhdGEgPSBCdWZmZXIuZnJvbShwZGF0YSk7XG4gICAgICByZXR1cm4gcGRhdGE7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyAjIyMgTm9kZUpTIGltcGxlbWVudGF0aW9uXG4gIHZhciBub2RlanMgPSBmdW5jdGlvbihlbmNLZXksIGNkYXRhLCBpdikge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0c1xuICAgIHRyeSB7XG4gICAgICBjaGVja0l2KGl2KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5hbWUgPSBcIkFFUy1cIiArIHNpemUgKyBcIi1DQkNcIjtcbiAgICAgIHZhciBjaXBoZXIgPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihuYW1lLCBlbmNLZXksIGl2KTtcbiAgICAgIHZhciBwZGF0YSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICBjaXBoZXIudXBkYXRlKGNkYXRhKSxcbiAgICAgICAgY2lwaGVyLmZpbmFsKClcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIHBkYXRhO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBjaGVja0tleShrZXksIHNpemUpIHtcbiAgaWYgKChzaXplIDw8IDEpICE9PSAoa2V5Lmxlbmd0aCA8PCAzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZW5jcnlwdGlvbiBrZXkgc2l6ZVwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYmNIbWFjRW5jcnlwdEZOKHNpemUpIHtcbiAgdmFyIGNvbW1vbkVuY3J5cHQgPSBjb21tb25DYmNFbmNyeXB0Rk4oc2l6ZSk7XG4gIHJldHVybiBmdW5jdGlvbihrZXksIHBkYXRhLCBwcm9wcykge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0c1xuICAgIHRyeSB7XG4gICAgICBjaGVja0tleShrZXksIHNpemUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIGVLZXkgPSBrZXkuc2xpY2Uoc2l6ZSAvIDgpLFxuICAgICAgICBpS2V5ID0ga2V5LnNsaWNlKDAsIHNpemUgLyA4KSxcbiAgICAgICAgaXYgPSBwcm9wcy5pdiB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIGFkYXRhID0gcHJvcHMuYWFkIHx8IHByb3BzLmFkYXRhIHx8IEJ1ZmZlci5hbGxvYygwKTtcblxuICAgIC8vIFNURVAgMSAtLSBFbmNyeXB0XG4gICAgdmFyIHByb21pc2UgPSBjb21tb25FbmNyeXB0KGVLZXksIHBkYXRhLCBpdik7XG5cbiAgICAvLyBTVEVQIDIgLS0gTUFDXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihjZGF0YSl7XG4gICAgICB2YXIgbWRhdGEgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgYWRhdGEsXG4gICAgICAgIGl2LFxuICAgICAgICBjZGF0YSxcbiAgICAgICAgaGVscGVycy5pbnQ2NFRvQnVmZmVyKGFkYXRhLmxlbmd0aCAqIDgpXG4gICAgICBdKTtcblxuICAgICAgdmFyIHByb21pc2U7XG4gICAgICBwcm9taXNlID0gSE1BQ1tcIkhTXCIgKyAoc2l6ZSAqIDIpXS5zaWduKGlLZXksIG1kYXRhLCB7XG4gICAgICAgIGxlbmd0aDogc2l6ZVxuICAgICAgfSk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAvLyBUT0RPOiBtb3ZlIHNsaWNlIHRvIGhtYWMuanNcbiAgICAgICAgdmFyIHRhZyA9IHJlc3VsdC5tYWMuc2xpY2UoMCwgc2l6ZSAvIDgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IGNkYXRhLFxuICAgICAgICAgIHRhZzogdGFnXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNiY0htYWNEZWNyeXB0Rk4oc2l6ZSkge1xuICB2YXIgY29tbW9uRGVjcnlwdCA9IGNvbW1vbkNiY0RlY3J5cHRGTihzaXplKTtcblxuICByZXR1cm4gZnVuY3Rpb24oa2V5LCBjZGF0YSwgcHJvcHMpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dHNcbiAgICB0cnkge1xuICAgICAgY2hlY2tLZXkoa2V5LCBzaXplKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBlS2V5ID0ga2V5LnNsaWNlKHNpemUgLyA4KSxcbiAgICAgICAgaUtleSA9IGtleS5zbGljZSgwLCBzaXplIC8gOCksXG4gICAgICAgIGl2ID0gcHJvcHMuaXYgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBhZGF0YSA9IHByb3BzLmFhZCB8fCBwcm9wcy5hZGF0YSB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIHRhZyA9IHByb3BzLnRhZyB8fCBwcm9wcy5tYWMgfHwgQnVmZmVyLmFsbG9jKDApO1xuXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgIC8vIFNURVAgMSAtLSBNQUNcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByb21pc2U7XG4gICAgICAvLyBjb25zdHJ1Y3QgTUFDIGlucHV0XG4gICAgICB2YXIgbWRhdGEgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgYWRhdGEsXG4gICAgICAgIGl2LFxuICAgICAgICBjZGF0YSxcbiAgICAgICAgaGVscGVycy5pbnQ2NFRvQnVmZmVyKGFkYXRhLmxlbmd0aCAqIDgpXG4gICAgICBdKTtcbiAgICAgIHByb21pc2UgPSBITUFDW1wiSFNcIiArIChzaXplICogMildLnZlcmlmeShpS2V5LCBtZGF0YSwgdGFnLCB7XG4gICAgICAgIGxlbmd0aDogc2l6ZVxuICAgICAgfSk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2RhdGE7XG4gICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gZmFpbHVyZSAtLSBpbnZhbGlkIHRhZyBlcnJvclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYWMgY2hlY2sgZmFpbGVkXCIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9KTtcblxuICAgIC8vIFNURVAgMiAtLSBEZWNyeXB0XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGNvbW1vbkRlY3J5cHQoZUtleSwgY2RhdGEsIGl2KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xufVxuXG52YXIgRW5jcnlwdGlvbkxhYmVsID0gQnVmZmVyLmZyb20oXCJFbmNyeXB0aW9uXCIsIFwidXRmOFwiKTtcbnZhciBJbnRlZ3JpdHlMYWJlbCA9IEJ1ZmZlci5mcm9tKFwiSW50ZWdyaXR5XCIsIFwidXRmOFwiKTtcbnZhciBEb3RMYWJlbCA9IEJ1ZmZlci5mcm9tKFwiLlwiLCBcInV0ZjhcIik7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ2VrKG1hc3RlcktleSwgYWxnLCBlcHUsIGVwdikge1xuICB2YXIgbWFzdGVyU2l6ZSA9IG1hc3RlcktleS5sZW5ndGggKiA4O1xuICB2YXIgY2VrU2l6ZSA9IG1hc3RlclNpemUgLyAyO1xuICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKXtcbiAgICB2YXIgaW5wdXQgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgIGhlbHBlcnMuaW50MzJUb0J1ZmZlcigxKSxcbiAgICAgIG1hc3RlcktleSxcbiAgICAgIGhlbHBlcnMuaW50MzJUb0J1ZmZlcihjZWtTaXplKSxcbiAgICAgIEJ1ZmZlci5mcm9tKGFsZywgXCJ1dGY4XCIpLFxuICAgICAgZXB1LFxuICAgICAgZXB2LFxuICAgICAgRW5jcnlwdGlvbkxhYmVsXG4gICAgXSk7XG5cbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0pO1xuXG4gIHByb21pc2UgPSBwcm9taXNlLnRoZW4oIGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgcmV0dXJuIHNoYVtcIlNIQS1cIiArIG1hc3RlclNpemVdLmRpZ2VzdChpbnB1dCkudGhlbihmdW5jdGlvbihkaWdlc3QpIHtcbiAgICAgIHJldHVybiBkaWdlc3Quc2xpY2UoMCwgY2VrU2l6ZSAvIDgpO1xuICAgIH0pO1xuICB9KTtcbiAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShwcm9taXNlKTtcblxuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVDaWsobWFzdGVyS2V5LCBhbGcsIGVwdSwgZXB2KSB7XG4gIHZhciBtYXN0ZXJTaXplID0gbWFzdGVyS2V5Lmxlbmd0aCAqIDg7XG4gIHZhciBjaWtTaXplID0gbWFzdGVyU2l6ZTtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGlucHV0ID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBoZWxwZXJzLmludDMyVG9CdWZmZXIoMSksXG4gICAgICBtYXN0ZXJLZXksXG4gICAgICBoZWxwZXJzLmludDMyVG9CdWZmZXIoY2lrU2l6ZSksXG4gICAgICBCdWZmZXIuZnJvbShhbGcsIFwidXRmOFwiKSxcbiAgICAgIGVwdSxcbiAgICAgIGVwdixcbiAgICAgIEludGVncml0eUxhYmVsXG4gICAgXSk7XG5cbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0pO1xuXG4gIHByb21pc2UgPSBwcm9taXNlLnRoZW4oIGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgcmV0dXJuIHNoYVtcIlNIQS1cIiArIG1hc3RlclNpemVdLmRpZ2VzdChpbnB1dCkudGhlbihmdW5jdGlvbihkaWdlc3QpIHtcbiAgICAgIHJldHVybiBkaWdlc3Quc2xpY2UoMCwgY2lrU2l6ZSAvIDgpO1xuICAgIH0pO1xuICB9KTtcbiAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShwcm9taXNlKTtcblxuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gY29uY2F0S2RmQ2JjSG1hY0VuY3J5cHRGTihzaXplLCBhbGcpIHtcbiAgdmFyIGNvbW1vbkVuY3J5cHQgPSBjb21tb25DYmNFbmNyeXB0Rk4oc2l6ZSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgcGRhdGEsIHByb3BzKSB7XG4gICAgdmFyIGVwdSA9IHByb3BzLmVwdSB8fCBoZWxwZXJzLmludDMyVG9CdWZmZXIoMCksXG4gICAgICAgIGVwdiA9IHByb3BzLmVwdiB8fCBoZWxwZXJzLmludDMyVG9CdWZmZXIoMCksXG4gICAgICAgIGl2ID0gcHJvcHMuaXYgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBhZGF0YSA9IHByb3BzLmFhZCB8fCBwcm9wcy5hZGF0YSB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIGtkYXRhID0gcHJvcHMua2RhdGEgfHwgQnVmZmVyLmFsbG9jKDApO1xuXG4gICAgLy8gUHJlIFN0ZXAgMSAtLSBHZW5lcmF0ZSBLZXlzXG4gICAgdmFyIHByb21pc2VzID0gW1xuICAgICAgZ2VuZXJhdGVDZWsoa2V5LCBhbGcsIGVwdSwgZXB2KSxcbiAgICAgIGdlbmVyYXRlQ2lrKGtleSwgYWxnLCBlcHUsIGVwdilcbiAgICBdO1xuXG4gICAgdmFyIGNlayxcbiAgICAgICAgY2lrO1xuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oa2V5cykge1xuICAgICAgY2VrID0ga2V5c1swXTtcbiAgICAgIGNpayA9IGtleXNbMV07XG4gICAgfSk7XG5cbiAgICAvLyBTVEVQIDEgLS0gRW5jcnlwdFxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBjb21tb25FbmNyeXB0KGNlaywgcGRhdGEsIGl2KTtcbiAgICB9KTtcblxuICAgIC8vIFNURVAgMiAtLSBNYWNcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNkYXRhKXtcbiAgICAgIHZhciBtZGF0YSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICBhZGF0YSxcbiAgICAgICAgRG90TGFiZWwsXG4gICAgICAgIEJ1ZmZlci5mcm9tKGtkYXRhKSxcbiAgICAgICAgRG90TGFiZWwsXG4gICAgICAgIEJ1ZmZlci5mcm9tKHV0aWwuYmFzZTY0dXJsLmVuY29kZShpdiksIFwidXRmOFwiKSxcbiAgICAgICAgRG90TGFiZWwsXG4gICAgICAgIEJ1ZmZlci5mcm9tKHV0aWwuYmFzZTY0dXJsLmVuY29kZShjZGF0YSksIFwidXRmOFwiKVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoY2RhdGEpLFxuICAgICAgICBITUFDW1wiSFNcIiArIChzaXplICogMildLnNpZ24oY2lrLCBtZGF0YSwgeyBsZW5ndGg6IHNpemUgfSlcbiAgICAgIF0pO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHJlc3VsdFswXSxcbiAgICAgICAgdGFnOiByZXN1bHRbMV0ubWFjXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbmNhdEtkZkNiY0htYWNEZWNyeXB0Rk4oc2l6ZSwgYWxnKSB7XG4gIHZhciBjb21tb25EZWNyeXB0ID0gY29tbW9uQ2JjRGVjcnlwdEZOKHNpemUpO1xuXG4gIHJldHVybiBmdW5jdGlvbihrZXksIGNkYXRhLCBwcm9wcykge1xuICAgIHZhciBlcHUgPSBwcm9wcy5lcHUgfHwgaGVscGVycy5pbnQzMlRvQnVmZmVyKDApLFxuICAgICAgICBlcHYgPSBwcm9wcy5lcHYgfHwgaGVscGVycy5pbnQzMlRvQnVmZmVyKDApLFxuICAgICAgICBpdiA9IHByb3BzLml2IHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgYWRhdGEgPSBwcm9wcy5hYWQgfHwgcHJvcHMuYWRhdGEgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBrZGF0YSA9IHByb3BzLmtkYXRhIHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgdGFnID0gcHJvcHMudGFnIHx8IHByb3BzLm1hYyB8fCBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICAvLyBQcmUgU3RlcCAxIC0tIEdlbmVyYXRlIEtleXNcbiAgICB2YXIgcHJvbWlzZXMgPSBbXG4gICAgICBnZW5lcmF0ZUNlayhrZXksIGFsZywgZXB1LCBlcHYpLFxuICAgICAgZ2VuZXJhdGVDaWsoa2V5LCBhbGcsIGVwdSwgZXB2KVxuICAgIF07XG5cbiAgICB2YXIgY2VrLFxuICAgICAgICBjaWs7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihrZXlzKXtcbiAgICAgIGNlayA9IGtleXNbMF07XG4gICAgICBjaWsgPSBrZXlzWzFdO1xuICAgIH0pO1xuXG5cbiAgICAvLyBTVEVQIDEgLS0gTUFDXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIC8vIGNvbnN0cnVjdCBNQUMgaW5wdXRcbiAgICAgIHZhciBtZGF0YSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICBhZGF0YSxcbiAgICAgICAgRG90TGFiZWwsXG4gICAgICAgIEJ1ZmZlci5mcm9tKGtkYXRhKSxcbiAgICAgICAgRG90TGFiZWwsXG4gICAgICAgIEJ1ZmZlci5mcm9tKHV0aWwuYmFzZTY0dXJsLmVuY29kZShpdiksIFwidXRmOFwiKSxcbiAgICAgICAgRG90TGFiZWwsXG4gICAgICAgIEJ1ZmZlci5mcm9tKHV0aWwuYmFzZTY0dXJsLmVuY29kZShjZGF0YSksIFwidXRmOFwiKVxuICAgICAgXSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBITUFDW1wiSFNcIiArIChzaXplICogMildLnZlcmlmeShjaWssIG1kYXRhLCB0YWcsIHtcbiAgICAgICAgICBsb29zZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hYyBjaGVjayBmYWlsZWRcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTVEVQIDIgLS0gRGVjcnlwdFxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBjb21tb25EZWNyeXB0KGNlaywgY2RhdGEsIGl2KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xufVxuXG4vLyAjIyMgUHVibGljIEFQSVxuLy8gKiBbbmFtZV0uZW5jcnlwdFxuLy8gKiBbbmFtZV0uZGVjcnlwdFxudmFyIGFlc0NiY0htYWNTaGEyID0ge307XG5bXG4gIFwiQTEyOENCQy1IUzI1NlwiLFxuICBcIkExOTJDQkMtSFMzODRcIixcbiAgXCJBMjU2Q0JDLUhTNTEyXCJcbl0uZm9yRWFjaChmdW5jdGlvbihhbGcpIHtcbiAgdmFyIHNpemUgPSBwYXJzZUludCgvQShcXGQrKUNCQy1IUyhcXGQrKT8vZy5leGVjKGFsZylbMV0pO1xuICBhZXNDYmNIbWFjU2hhMlthbGddID0ge1xuICAgIGVuY3J5cHQ6IGNiY0htYWNFbmNyeXB0Rk4oc2l6ZSksXG4gICAgZGVjcnlwdDogY2JjSG1hY0RlY3J5cHRGTihzaXplKVxuICB9O1xufSk7XG5cbltcbiAgXCJBMTI4Q0JDK0hTMjU2XCIsXG4gIFwiQTE5MkNCQytIUzM4NFwiLFxuICBcIkEyNTZDQkMrSFM1MTJcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKGFsZykge1xuICB2YXIgc2l6ZSA9IHBhcnNlSW50KC9BKFxcZCspQ0JDXFwrSFMoXFxkKyk/L2cuZXhlYyhhbGcpWzFdKTtcbiAgYWVzQ2JjSG1hY1NoYTJbYWxnXSA9IHtcbiAgICBlbmNyeXB0OiBjb25jYXRLZGZDYmNIbWFjRW5jcnlwdEZOKHNpemUsIGFsZyksXG4gICAgZGVjcnlwdDogY29uY2F0S2RmQ2JjSG1hY0RlY3J5cHRGTihzaXplLCBhbGcpXG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZXNDYmNIbWFjU2hhMjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/aes-cbc-hmac-sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/aes-gcm.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/aes-gcm.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/aes-gcm.js - AES-GCM Encryption and Key-Wrapping\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    GCM = __webpack_require__(/*! ../deps/ciphermodes/gcm */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/index.js\");\n\nfunction gcmEncryptFN(size, wrap) {\n  function commonChecks(key, iv) {\n    if (size !== (key.length << 3)) {\n       throw new Error(\"invalid key size\");\n    }\n    if (!iv && !wrap) {\n      throw new Error(\"invalid iv\");\n    }\n    if (iv && 12 !== iv.length) {\n      throw new Error(\"invalid iv\");\n    }\n  }\n\n  function prepareResults(results) {\n    if (wrap) {\n      var iv = util.base64url.encode(results.iv);\n      var tag = util.base64url.encode(results.tag);\n\n      results = {\n        data: results.data,\n        header: {\n          iv: iv,\n          tag: tag\n        }\n      };\n    }\n\n    return results;\n  }\n\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(key, pdata, props) {\n    var iv = props.iv,\n        adata = props.aad || props.adata || Buffer.alloc(0),\n        cipher,\n        cdata;\n\n    // validate inputs\n    try {\n      commonChecks(key, iv, adata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    iv = iv || util.randomBytes(12);\n\n    // setup cipher\n    cipher = GCM.createCipher({\n      key: key,\n      iv: iv,\n      additionalData: adata\n    });\n    // ciphertext is the same length as plaintext\n    cdata = Buffer.alloc(pdata.length);\n\n    var promise = new Promise(function(resolve, reject) {\n      var amt = CONSTANTS.CHUNK_SIZE,\n          clen = 0,\n          poff = 0;\n\n      (function doChunk() {\n        var plen = Math.min(amt, pdata.length - poff);\n        clen += cipher.update(pdata,\n                              poff,\n                              plen,\n                              cdata,\n                              clen);\n        poff += plen;\n        if (pdata.length > poff) {\n          setTimeout(doChunk, 0);\n          return;\n        }\n\n        // finish it\n        clen += cipher.finish(cdata, clen);\n        if (clen !== pdata.length) {\n          reject(new Error(\"encryption failed\"));\n          return;\n        }\n\n        // resolve with output\n        var tag = cipher.tag;\n        resolve(prepareResults({\n          data: cdata,\n          iv: iv,\n          tag: tag\n        }));\n      })();\n    });\n\n    return promise;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(key, pdata, props) {\n    var iv = props.iv,\n        adata = props.aad || props.adata || Buffer.alloc(0);\n\n    try {\n      commonChecks(key, iv, adata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    iv = iv || util.randomBytes(12);\n\n    var alg = {\n      name: \"AES-GCM\"\n    };\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"encrypt\"]);\n    promise = promise.then(function(key) {\n      alg.iv = iv;\n      alg.tagLength = 128;\n      if (adata.length) {\n        alg.additionalData = adata;\n      }\n\n      return helpers.subtleCrypto.encrypt(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      var tagStart = result.byteLength - 16;\n\n      var tag = result.slice(tagStart);\n      tag = Buffer.from(tag);\n\n      var cdata = result.slice(0, tagStart);\n      cdata = Buffer.from(cdata);\n\n      return prepareResults({\n        data: cdata,\n        iv: iv,\n        tag: tag\n      });\n    });\n\n    return promise;\n  };\n\n  // ### NodeJS implementation\n  var nodejs = function(key, pdata, props) {\n    var iv = props.iv,\n        adata = props.aad || props.adata || Buffer.alloc(0);\n\n    try {\n      commonChecks(key, iv, adata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    iv = iv || util.randomBytes(12);\n\n    var alg = \"aes-\" + (key.length * 8) + \"-gcm\";\n    var cipher;\n    try {\n      cipher = helpers.nodeCrypto.createCipheriv(alg, key, iv);\n    } catch (err) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n    if (\"function\" !== typeof cipher.setAAD) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n    if (adata.length) {\n      cipher.setAAD(adata);\n    }\n\n    var cdata = Buffer.concat([\n      cipher.update(pdata),\n      cipher.final()\n    ]);\n    var tag = cipher.getAuthTag();\n\n    return prepareResults({\n      data: cdata,\n      iv: iv,\n      tag: tag\n    });\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction gcmDecryptFN(size) {\n  function commonChecks(key, iv, tag) {\n    if (size !== (key.length << 3)) {\n      throw new Error(\"invalid key size\");\n    }\n    if (12 !== iv.length) {\n      throw new Error(\"invalid iv\");\n    }\n    if (16 !== tag.length) {\n      throw new Error(\"invalid tag length\");\n    }\n  }\n\n  // ### fallback implementation -- uses forge\n  var fallback = function(key, cdata, props) {\n    var adata = props.aad || props.adata || Buffer.alloc(0),\n        iv = props.iv || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0),\n        cipher,\n        pdata;\n\n    // validate inputs\n    try {\n      commonChecks(key, iv, tag);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // setup cipher\n    cipher = GCM.createDecipher({\n      key: key,\n      iv: iv,\n      additionalData: adata,\n      tag: tag\n    });\n    // plaintext is the same length as ciphertext\n    pdata = Buffer.alloc(cdata.length);\n\n    var promise = new Promise(function(resolve, reject) {\n      var amt = CONSTANTS.CHUNK_SIZE,\n          plen = 0,\n          coff = 0;\n\n      (function doChunk() {\n        var clen = Math.min(amt, cdata.length - coff);\n        plen += cipher.update(cdata,\n                              coff,\n                              clen,\n                              pdata,\n                              plen);\n        coff += clen;\n        if (cdata.length > coff) {\n          setTimeout(doChunk, 0);\n          return;\n        }\n\n        try {\n          plen += cipher.finish(pdata, plen);\n        } catch (err) {\n          reject(new Error(\"decryption failed\"));\n          return;\n        }\n\n        if (plen !== cdata.length) {\n          reject(new Error(\"decryption failed\"));\n          return;\n        }\n\n        // resolve with output\n        resolve(pdata);\n      })();\n    });\n\n    return promise;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(key, cdata, props) {\n    var adata = props.aad || props.adata || Buffer.alloc(0),\n        iv = props.iv || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0);\n\n    // validate inputs\n    try {\n      commonChecks(key, iv, tag);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = {\n      name: \"AES-GCM\"\n    };\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"decrypt\"]);\n    promise = promise.then(function(key) {\n      alg.iv = iv;\n      alg.tagLength = 128;\n      if (adata.length) {\n        alg.additionalData = adata;\n      }\n\n      // concatenate cdata and tag\n      cdata = Buffer.concat([cdata, tag], cdata.length + tag.length);\n\n      return helpers.subtleCrypto.decrypt(alg, key, cdata);\n    });\n    promise = promise.then(function(pdata) {\n      pdata = Buffer.from(pdata);\n      return pdata;\n    });\n\n    return promise;\n  };\n\n  var nodejs = function(key, cdata, props) {\n    var adata = props.aad || props.adata || Buffer.alloc(0),\n        iv = props.iv || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0);\n\n    // validate inputs\n    try {\n      commonChecks(key, iv, tag);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = \"aes-\" + (key.length * 8) + \"-gcm\";\n    var cipher;\n    try {\n      cipher = helpers.nodeCrypto.createDecipheriv(alg, key, iv);\n    } catch(err) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n    if (\"function\" !== typeof cipher.setAAD) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n    cipher.setAuthTag(tag);\n    if (adata.length) {\n      cipher.setAAD(adata);\n    }\n\n    try {\n      var pdata = Buffer.concat([\n        cipher.update(cdata),\n        cipher.final()\n      ]);\n\n      return pdata;\n    } catch (err) {\n      throw new Error(\"decryption failed\");\n    }\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar aesGcm = {};\n[\n  \"A128GCM\",\n  \"A192GCM\",\n  \"A256GCM\",\n  \"A128GCMKW\",\n  \"A192GCMKW\",\n  \"A256GCMKW\"\n].forEach(function(alg) {\n  var parts = /A(\\d+)GCM(KW)?/g.exec(alg);\n  var size = parseInt(parts[1]);\n  var wrap = (parts[2] === \"KW\");\n  aesGcm[alg] = {\n    encrypt: gcmEncryptFN(size, wrap),\n    decrypt: gcmDecryptFN(size, wrap)\n  };\n});\n\nmodule.exports = aesGcm;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Flcy1nY20uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyw4RUFBYztBQUNwQyxXQUFXLG1CQUFPLENBQUMsaUVBQVM7QUFDNUIsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQ3hDLFVBQVUsbUJBQU8sQ0FBQyxpR0FBeUI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Flcy1nY20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL2Flcy1nY20uanMgLSBBRVMtR0NNIEVuY3J5cHRpb24gYW5kIEtleS1XcmFwcGluZ1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKSxcbiAgICBDT05TVEFOVFMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIiksXG4gICAgR0NNID0gcmVxdWlyZShcIi4uL2RlcHMvY2lwaGVybW9kZXMvZ2NtXCIpO1xuXG5mdW5jdGlvbiBnY21FbmNyeXB0Rk4oc2l6ZSwgd3JhcCkge1xuICBmdW5jdGlvbiBjb21tb25DaGVja3Moa2V5LCBpdikge1xuICAgIGlmIChzaXplICE9PSAoa2V5Lmxlbmd0aCA8PCAzKSkge1xuICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQga2V5IHNpemVcIik7XG4gICAgfVxuICAgIGlmICghaXYgJiYgIXdyYXApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaXZcIik7XG4gICAgfVxuICAgIGlmIChpdiAmJiAxMiAhPT0gaXYubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGl2XCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICBpZiAod3JhcCkge1xuICAgICAgdmFyIGl2ID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKHJlc3VsdHMuaXYpO1xuICAgICAgdmFyIHRhZyA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZShyZXN1bHRzLnRhZyk7XG5cbiAgICAgIHJlc3VsdHMgPSB7XG4gICAgICAgIGRhdGE6IHJlc3VsdHMuZGF0YSxcbiAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgaXY6IGl2LFxuICAgICAgICAgIHRhZzogdGFnXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvLyAjIyMgJ2ZhbGxiYWNrJyBpbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIHByb3BzKSB7XG4gICAgdmFyIGl2ID0gcHJvcHMuaXYsXG4gICAgICAgIGFkYXRhID0gcHJvcHMuYWFkIHx8IHByb3BzLmFkYXRhIHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgY2lwaGVyLFxuICAgICAgICBjZGF0YTtcblxuICAgIC8vIHZhbGlkYXRlIGlucHV0c1xuICAgIHRyeSB7XG4gICAgICBjb21tb25DaGVja3Moa2V5LCBpdiwgYWRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgaXYgPSBpdiB8fCB1dGlsLnJhbmRvbUJ5dGVzKDEyKTtcblxuICAgIC8vIHNldHVwIGNpcGhlclxuICAgIGNpcGhlciA9IEdDTS5jcmVhdGVDaXBoZXIoe1xuICAgICAga2V5OiBrZXksXG4gICAgICBpdjogaXYsXG4gICAgICBhZGRpdGlvbmFsRGF0YTogYWRhdGFcbiAgICB9KTtcbiAgICAvLyBjaXBoZXJ0ZXh0IGlzIHRoZSBzYW1lIGxlbmd0aCBhcyBwbGFpbnRleHRcbiAgICBjZGF0YSA9IEJ1ZmZlci5hbGxvYyhwZGF0YS5sZW5ndGgpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBhbXQgPSBDT05TVEFOVFMuQ0hVTktfU0laRSxcbiAgICAgICAgICBjbGVuID0gMCxcbiAgICAgICAgICBwb2ZmID0gMDtcblxuICAgICAgKGZ1bmN0aW9uIGRvQ2h1bmsoKSB7XG4gICAgICAgIHZhciBwbGVuID0gTWF0aC5taW4oYW10LCBwZGF0YS5sZW5ndGggLSBwb2ZmKTtcbiAgICAgICAgY2xlbiArPSBjaXBoZXIudXBkYXRlKHBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9mZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZW4pO1xuICAgICAgICBwb2ZmICs9IHBsZW47XG4gICAgICAgIGlmIChwZGF0YS5sZW5ndGggPiBwb2ZmKSB7XG4gICAgICAgICAgc2V0VGltZW91dChkb0NodW5rLCAwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5pc2ggaXRcbiAgICAgICAgY2xlbiArPSBjaXBoZXIuZmluaXNoKGNkYXRhLCBjbGVuKTtcbiAgICAgICAgaWYgKGNsZW4gIT09IHBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJlbmNyeXB0aW9uIGZhaWxlZFwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzb2x2ZSB3aXRoIG91dHB1dFxuICAgICAgICB2YXIgdGFnID0gY2lwaGVyLnRhZztcbiAgICAgICAgcmVzb2x2ZShwcmVwYXJlUmVzdWx0cyh7XG4gICAgICAgICAgZGF0YTogY2RhdGEsXG4gICAgICAgICAgaXY6IGl2LFxuICAgICAgICAgIHRhZzogdGFnXG4gICAgICAgIH0pKTtcbiAgICAgIH0pKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIGltcGxlbWVudGF0aW9uXG4gIC8vIFRPRE86IGNhY2hlIENyeXB0b0tleSBzb29uZXJcbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIHByb3BzKSB7XG4gICAgdmFyIGl2ID0gcHJvcHMuaXYsXG4gICAgICAgIGFkYXRhID0gcHJvcHMuYWFkIHx8IHByb3BzLmFkYXRhIHx8IEJ1ZmZlci5hbGxvYygwKTtcblxuICAgIHRyeSB7XG4gICAgICBjb21tb25DaGVja3Moa2V5LCBpdiwgYWRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgaXYgPSBpdiB8fCB1dGlsLnJhbmRvbUJ5dGVzKDEyKTtcblxuICAgIHZhciBhbGcgPSB7XG4gICAgICBuYW1lOiBcIkFFUy1HQ01cIlxuICAgIH07XG4gICAgdmFyIHByb21pc2U7XG4gICAgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcInJhd1wiLCBrZXksIGFsZywgdHJ1ZSwgW1wiZW5jcnlwdFwiXSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgIGFsZy5pdiA9IGl2O1xuICAgICAgYWxnLnRhZ0xlbmd0aCA9IDEyODtcbiAgICAgIGlmIChhZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgYWxnLmFkZGl0aW9uYWxEYXRhID0gYWRhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5lbmNyeXB0KGFsZywga2V5LCBwZGF0YSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHZhciB0YWdTdGFydCA9IHJlc3VsdC5ieXRlTGVuZ3RoIC0gMTY7XG5cbiAgICAgIHZhciB0YWcgPSByZXN1bHQuc2xpY2UodGFnU3RhcnQpO1xuICAgICAgdGFnID0gQnVmZmVyLmZyb20odGFnKTtcblxuICAgICAgdmFyIGNkYXRhID0gcmVzdWx0LnNsaWNlKDAsIHRhZ1N0YXJ0KTtcbiAgICAgIGNkYXRhID0gQnVmZmVyLmZyb20oY2RhdGEpO1xuXG4gICAgICByZXR1cm4gcHJlcGFyZVJlc3VsdHMoe1xuICAgICAgICBkYXRhOiBjZGF0YSxcbiAgICAgICAgaXY6IGl2LFxuICAgICAgICB0YWc6IHRhZ1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyAjIyMgTm9kZUpTIGltcGxlbWVudGF0aW9uXG4gIHZhciBub2RlanMgPSBmdW5jdGlvbihrZXksIHBkYXRhLCBwcm9wcykge1xuICAgIHZhciBpdiA9IHByb3BzLml2LFxuICAgICAgICBhZGF0YSA9IHByb3BzLmFhZCB8fCBwcm9wcy5hZGF0YSB8fCBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICB0cnkge1xuICAgICAgY29tbW9uQ2hlY2tzKGtleSwgaXYsIGFkYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGl2ID0gaXYgfHwgdXRpbC5yYW5kb21CeXRlcygxMik7XG5cbiAgICB2YXIgYWxnID0gXCJhZXMtXCIgKyAoa2V5Lmxlbmd0aCAqIDgpICsgXCItZ2NtXCI7XG4gICAgdmFyIGNpcGhlcjtcbiAgICB0cnkge1xuICAgICAgY2lwaGVyID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZUNpcGhlcml2KGFsZywga2V5LCBpdik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IFwiICsgYWxnKTtcbiAgICB9XG4gICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNpcGhlci5zZXRBQUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogXCIgKyBhbGcpO1xuICAgIH1cbiAgICBpZiAoYWRhdGEubGVuZ3RoKSB7XG4gICAgICBjaXBoZXIuc2V0QUFEKGFkYXRhKTtcbiAgICB9XG5cbiAgICB2YXIgY2RhdGEgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgIGNpcGhlci51cGRhdGUocGRhdGEpLFxuICAgICAgY2lwaGVyLmZpbmFsKClcbiAgICBdKTtcbiAgICB2YXIgdGFnID0gY2lwaGVyLmdldEF1dGhUYWcoKTtcblxuICAgIHJldHVybiBwcmVwYXJlUmVzdWx0cyh7XG4gICAgICBkYXRhOiBjZGF0YSxcbiAgICAgIGl2OiBpdixcbiAgICAgIHRhZzogdGFnXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBnY21EZWNyeXB0Rk4oc2l6ZSkge1xuICBmdW5jdGlvbiBjb21tb25DaGVja3Moa2V5LCBpdiwgdGFnKSB7XG4gICAgaWYgKHNpemUgIT09IChrZXkubGVuZ3RoIDw8IDMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtleSBzaXplXCIpO1xuICAgIH1cbiAgICBpZiAoMTIgIT09IGl2Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpdlwiKTtcbiAgICB9XG4gICAgaWYgKDE2ICE9PSB0YWcubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHRhZyBsZW5ndGhcIik7XG4gICAgfVxuICB9XG5cbiAgLy8gIyMjIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBjZGF0YSwgcHJvcHMpIHtcbiAgICB2YXIgYWRhdGEgPSBwcm9wcy5hYWQgfHwgcHJvcHMuYWRhdGEgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBpdiA9IHByb3BzLml2IHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgdGFnID0gcHJvcHMudGFnIHx8IHByb3BzLm1hYyB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIGNpcGhlcixcbiAgICAgICAgcGRhdGE7XG5cbiAgICAvLyB2YWxpZGF0ZSBpbnB1dHNcbiAgICB0cnkge1xuICAgICAgY29tbW9uQ2hlY2tzKGtleSwgaXYsIHRhZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICAvLyBzZXR1cCBjaXBoZXJcbiAgICBjaXBoZXIgPSBHQ00uY3JlYXRlRGVjaXBoZXIoe1xuICAgICAga2V5OiBrZXksXG4gICAgICBpdjogaXYsXG4gICAgICBhZGRpdGlvbmFsRGF0YTogYWRhdGEsXG4gICAgICB0YWc6IHRhZ1xuICAgIH0pO1xuICAgIC8vIHBsYWludGV4dCBpcyB0aGUgc2FtZSBsZW5ndGggYXMgY2lwaGVydGV4dFxuICAgIHBkYXRhID0gQnVmZmVyLmFsbG9jKGNkYXRhLmxlbmd0aCk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGFtdCA9IENPTlNUQU5UUy5DSFVOS19TSVpFLFxuICAgICAgICAgIHBsZW4gPSAwLFxuICAgICAgICAgIGNvZmYgPSAwO1xuXG4gICAgICAoZnVuY3Rpb24gZG9DaHVuaygpIHtcbiAgICAgICAgdmFyIGNsZW4gPSBNYXRoLm1pbihhbXQsIGNkYXRhLmxlbmd0aCAtIGNvZmYpO1xuICAgICAgICBwbGVuICs9IGNpcGhlci51cGRhdGUoY2RhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2ZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxlbik7XG4gICAgICAgIGNvZmYgKz0gY2xlbjtcbiAgICAgICAgaWYgKGNkYXRhLmxlbmd0aCA+IGNvZmYpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGRvQ2h1bmssIDApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGxlbiArPSBjaXBoZXIuZmluaXNoKHBkYXRhLCBwbGVuKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcImRlY3J5cHRpb24gZmFpbGVkXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGxlbiAhPT0gY2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcImRlY3J5cHRpb24gZmFpbGVkXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNvbHZlIHdpdGggb3V0cHV0XG4gICAgICAgIHJlc29sdmUocGRhdGEpO1xuICAgICAgfSkoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgaW1wbGVtZW50YXRpb25cbiAgLy8gVE9ETzogY2FjaGUgQ3J5cHRvS2V5IHNvb25lclxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBjZGF0YSwgcHJvcHMpIHtcbiAgICB2YXIgYWRhdGEgPSBwcm9wcy5hYWQgfHwgcHJvcHMuYWRhdGEgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBpdiA9IHByb3BzLml2IHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgdGFnID0gcHJvcHMudGFnIHx8IHByb3BzLm1hYyB8fCBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICAvLyB2YWxpZGF0ZSBpbnB1dHNcbiAgICB0cnkge1xuICAgICAgY29tbW9uQ2hlY2tzKGtleSwgaXYsIHRhZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgYWxnID0ge1xuICAgICAgbmFtZTogXCJBRVMtR0NNXCJcbiAgICB9O1xuICAgIHZhciBwcm9taXNlO1xuICAgIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJyYXdcIiwga2V5LCBhbGcsIHRydWUsIFtcImRlY3J5cHRcIl0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICBhbGcuaXYgPSBpdjtcbiAgICAgIGFsZy50YWdMZW5ndGggPSAxMjg7XG4gICAgICBpZiAoYWRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGFsZy5hZGRpdGlvbmFsRGF0YSA9IGFkYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25jYXRlbmF0ZSBjZGF0YSBhbmQgdGFnXG4gICAgICBjZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2NkYXRhLCB0YWddLCBjZGF0YS5sZW5ndGggKyB0YWcubGVuZ3RoKTtcblxuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmRlY3J5cHQoYWxnLCBrZXksIGNkYXRhKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHBkYXRhKSB7XG4gICAgICBwZGF0YSA9IEJ1ZmZlci5mcm9tKHBkYXRhKTtcbiAgICAgIHJldHVybiBwZGF0YTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHZhciBub2RlanMgPSBmdW5jdGlvbihrZXksIGNkYXRhLCBwcm9wcykge1xuICAgIHZhciBhZGF0YSA9IHByb3BzLmFhZCB8fCBwcm9wcy5hZGF0YSB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIGl2ID0gcHJvcHMuaXYgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICB0YWcgPSBwcm9wcy50YWcgfHwgcHJvcHMubWFjIHx8IEJ1ZmZlci5hbGxvYygwKTtcblxuICAgIC8vIHZhbGlkYXRlIGlucHV0c1xuICAgIHRyeSB7XG4gICAgICBjb21tb25DaGVja3Moa2V5LCBpdiwgdGFnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBhbGcgPSBcImFlcy1cIiArIChrZXkubGVuZ3RoICogOCkgKyBcIi1nY21cIjtcbiAgICB2YXIgY2lwaGVyO1xuICAgIHRyeSB7XG4gICAgICBjaXBoZXIgPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihhbGcsIGtleSwgaXYpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IFwiICsgYWxnKTtcbiAgICB9XG4gICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNpcGhlci5zZXRBQUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogXCIgKyBhbGcpO1xuICAgIH1cbiAgICBjaXBoZXIuc2V0QXV0aFRhZyh0YWcpO1xuICAgIGlmIChhZGF0YS5sZW5ndGgpIHtcbiAgICAgIGNpcGhlci5zZXRBQUQoYWRhdGEpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgcGRhdGEgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgY2lwaGVyLnVwZGF0ZShjZGF0YSksXG4gICAgICAgIGNpcGhlci5maW5hbCgpXG4gICAgICBdKTtcblxuICAgICAgcmV0dXJuIHBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGVjcnlwdGlvbiBmYWlsZWRcIik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuLy8gIyMjIFB1YmxpYyBBUElcbi8vICogW25hbWVdLmVuY3J5cHRcbi8vICogW25hbWVdLmRlY3J5cHRcbnZhciBhZXNHY20gPSB7fTtcbltcbiAgXCJBMTI4R0NNXCIsXG4gIFwiQTE5MkdDTVwiLFxuICBcIkEyNTZHQ01cIixcbiAgXCJBMTI4R0NNS1dcIixcbiAgXCJBMTkyR0NNS1dcIixcbiAgXCJBMjU2R0NNS1dcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKGFsZykge1xuICB2YXIgcGFydHMgPSAvQShcXGQrKUdDTShLVyk/L2cuZXhlYyhhbGcpO1xuICB2YXIgc2l6ZSA9IHBhcnNlSW50KHBhcnRzWzFdKTtcbiAgdmFyIHdyYXAgPSAocGFydHNbMl0gPT09IFwiS1dcIik7XG4gIGFlc0djbVthbGddID0ge1xuICAgIGVuY3J5cHQ6IGdjbUVuY3J5cHRGTihzaXplLCB3cmFwKSxcbiAgICBkZWNyeXB0OiBnY21EZWNyeXB0Rk4oc2l6ZSwgd3JhcClcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFlc0djbTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/aes-gcm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/aes-kw.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/aes-kw.js - AES-KW Key-Wrapping\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    DataBuffer = __webpack_require__(/*! ../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\");\n\nvar A0 = Buffer.from(\"a6a6a6a6a6a6a6a6\", \"hex\");\n\n// ### helpers\nfunction xor(a, b) {\n  var len = Math.max(a.length, b.length);\n  var result = Buffer.alloc(len);\n  for (var idx = 0; len > idx; idx++) {\n    result[idx] = (a[idx] || 0) ^ (b[idx] || 0);\n  }\n  return result;\n}\n\nfunction split(input, size) {\n  var output = [];\n  for (var idx = 0; input.length > idx; idx += size) {\n    output.push(input.slice(idx, idx + size));\n  }\n  return output;\n}\n\nfunction longToBigEndian(input) {\n  var hi = Math.floor(input / 4294967296),\n      lo = input % 4294967296;\n  var output = Buffer.alloc(8);\n  output[0] = 0xff & (hi >>> 24);\n  output[1] = 0xff & (hi >>> 16);\n  output[2] = 0xff & (hi >>> 8);\n  output[3] = 0xff & (hi >>> 0);\n  output[4] = 0xff & (lo >>> 24);\n  output[5] = 0xff & (lo >>> 16);\n  output[6] = 0xff & (lo >>> 8);\n  output[7] = 0xff & (lo >>> 0);\n  return output;\n}\n\nfunction kwEncryptFN(size) {\n  function commonChecks(key, data) {\n    if (size !== (key.length << 3)) {\n      throw new Error(\"invalid key size\");\n    }\n    if (0 < data.length && 0 !== (data.length % 8)) {\n      throw new Error(\"invalid data length\");\n    }\n  }\n\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(key, pdata) {\n    try {\n      commonChecks(key, pdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // setup cipher\n    var cipher = forge.cipher.createCipher(\"AES\", new DataBuffer(key));\n\n    // split input into chunks\n    var R = split(pdata, 8);\n    var A,\n        B,\n        count;\n    A = A0;\n    for (var jdx = 0; 6 > jdx; jdx++) {\n      for (var idx = 0; R.length > idx; idx++) {\n        count = (R.length * jdx) + idx + 1;\n        B = Buffer.concat([A, R[idx]]);\n        cipher.start();\n        cipher.update(new DataBuffer(B));\n        cipher.finish();\n        B = Buffer.from(cipher.output.bytes(), \"binary\");\n\n        A = xor(B.slice(0, 8),\n                longToBigEndian(count));\n        R[idx] = B.slice(8, 16);\n      }\n    }\n    R = [A].concat(R);\n    var cdata = Buffer.concat(R);\n    return Promise.resolve({\n      data: cdata\n    });\n  };\n  // ### WebCryptoAPI implementation\n  var webcrypto = function(key, pdata) {\n    try {\n      commonChecks(key, pdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = {\n      name: \"AES-KW\"\n    };\n    var promise = [\n      helpers.subtleCrypto.importKey(\"raw\", pdata, { name: \"HMAC\", hash: \"SHA-256\" }, true, [\"sign\"]),\n      helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"wrapKey\"])\n    ];\n    promise = Promise.all(promise);\n    promise = promise.then(function(keys) {\n      return helpers.subtleCrypto.wrapKey(\"raw\",\n                                          keys[0], // key\n                                          keys[1], // wrappingKey\n                                          alg);\n    });\n    promise = promise.then(function(result) {\n      result = Buffer.from(result);\n\n      return {\n        data: result\n      };\n    });\n    return promise;\n  };\n  var node = function(key, pdata) {\n    try {\n      commonChecks(key, pdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // split input into chunks\n    var R = split(pdata, 8),\n        iv = Buffer.alloc(16);\n    var A,\n        B,\n        count;\n    A = A0;\n    for (var jdx = 0; 6 > jdx; jdx++) {\n      for (var idx = 0; R.length > idx; idx++) {\n        count = (R.length * jdx) + idx + 1;\n        B = Buffer.concat([A, R[idx]]);\n        var cipher = helpers.nodeCrypto.createCipheriv(\"AES\" + size, key, iv);\n        B = cipher.update(B);\n\n        A = xor(B.slice(0, 8),\n                longToBigEndian(count));\n        R[idx] = B.slice(8, 16);\n      }\n    }\n    R = [A].concat(R);\n    var cdata = Buffer.concat(R);\n    return Promise.resolve({\n      data: cdata\n    });\n  };\n\n  return helpers.setupFallback(node, webcrypto, fallback);\n}\nfunction kwDecryptFN(size) {\n  function commonChecks(key, data) {\n    if (size !== (key.length << 3)) {\n      throw new Error(\"invalid key size\");\n    }\n    if (0 < (data.length - 8) && 0 !== (data.length % 8)) {\n      throw new Error(\"invalid data length\");\n    }\n  }\n\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(key, cdata) {\n    try {\n      commonChecks(key, cdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // setup cipher\n    var cipher = forge.cipher.createDecipher(\"AES\", new DataBuffer(key));\n\n    // prepare inputs\n    var R = split(cdata, 8),\n        A,\n        B,\n        count;\n    A = R[0];\n    R = R.slice(1);\n    for (var jdx = 5; 0 <= jdx; --jdx) {\n      for (var idx = R.length - 1; 0 <= idx; --idx) {\n        count = (R.length * jdx) + idx + 1;\n        B = xor(A,\n                longToBigEndian(count));\n        B = Buffer.concat([B, R[idx]]);\n        cipher.start();\n        cipher.update(new DataBuffer(B));\n        cipher.finish();\n        B = Buffer.from(cipher.output.bytes(), \"binary\");\n\n        A = B.slice(0, 8);\n        R[idx] = B.slice(8, 16);\n      }\n    }\n    if (A.toString() !== A0.toString()) {\n      return Promise.reject(new Error(\"decryption failed\"));\n    }\n    var pdata = Buffer.concat(R);\n    return Promise.resolve(pdata);\n  };\n  // ### WebCryptoAPI implementation\n  var webcrypto = function(key, cdata) {\n    try {\n      commonChecks(key, cdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = {\n      name: \"AES-KW\"\n    };\n    var promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"unwrapKey\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.unwrapKey(\"raw\", cdata, key, alg, {name: \"HMAC\", hash: \"SHA-256\"}, true, [\"sign\"]);\n    });\n    promise = promise.then(function(result) {\n      // unwrapped CryptoKey -- extract raw\n      return helpers.subtleCrypto.exportKey(\"raw\", result);\n    });\n    promise = promise.then(function(result) {\n      result = Buffer.from(result);\n      return result;\n    });\n    return promise;\n  };\n  var node = function(key, cdata) {\n    try {\n      commonChecks(key, cdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // prepare inputs\n    var R = split(cdata, 8),\n        iv = Buffer.alloc(16),\n        A,\n        B,\n        count;\n    A = R[0];\n    R = R.slice(1);\n    for (var jdx = 5; 0 <= jdx; --jdx) {\n      for (var idx = R.length - 1; 0 <= idx; --idx) {\n        count = (R.length * jdx) + idx + 1;\n        B = xor(A,\n                longToBigEndian(count));\n        B = Buffer.concat([B, R[idx], iv]);\n        var cipher = helpers.nodeCrypto.createDecipheriv(\"AES\" + size, key, iv);\n        B = cipher.update(B);\n\n        A = B.slice(0, 8);\n        R[idx] = B.slice(8, 16);\n      }\n    }\n    if (A.toString() !== A0.toString()) {\n      return Promise.reject(new Error(\"decryption failed\"));\n    }\n    var pdata = Buffer.concat(R);\n    return Promise.resolve(pdata);\n  };\n\n  return helpers.setupFallback(node, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar aesKw = {};\n[\n  \"A128KW\",\n  \"A192KW\",\n  \"A256KW\"\n].forEach(function(alg) {\n  var size = parseInt(/A(\\d+)KW/g.exec(alg)[1]);\n  aesKw[alg] = {\n    encrypt: kwEncryptFN(size),\n    decrypt: kwDecryptFN(size)\n  };\n});\n\nmodule.exports = aesKw;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Flcy1rdy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLDhFQUFjO0FBQ3BDLFlBQVksbUJBQU8sQ0FBQywwRUFBa0I7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQXVCOztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELCtCQUErQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEMsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSw4QkFBOEI7QUFDbkcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQyxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Flcy1rdy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvYWVzLWt3LmpzIC0gQUVTLUtXIEtleS1XcmFwcGluZ1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpLFxuICAgIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2UuanNcIiksXG4gICAgRGF0YUJ1ZmZlciA9IHJlcXVpcmUoXCIuLi91dGlsL2RhdGFidWZmZXIuanNcIik7XG5cbnZhciBBMCA9IEJ1ZmZlci5mcm9tKFwiYTZhNmE2YTZhNmE2YTZhNlwiLCBcImhleFwiKTtcblxuLy8gIyMjIGhlbHBlcnNcbmZ1bmN0aW9uIHhvcihhLCBiKSB7XG4gIHZhciBsZW4gPSBNYXRoLm1heChhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKGxlbik7XG4gIGZvciAodmFyIGlkeCA9IDA7IGxlbiA+IGlkeDsgaWR4KyspIHtcbiAgICByZXN1bHRbaWR4XSA9IChhW2lkeF0gfHwgMCkgXiAoYltpZHhdIHx8IDApO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNwbGl0KGlucHV0LCBzaXplKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaWR4ID0gMDsgaW5wdXQubGVuZ3RoID4gaWR4OyBpZHggKz0gc2l6ZSkge1xuICAgIG91dHB1dC5wdXNoKGlucHV0LnNsaWNlKGlkeCwgaWR4ICsgc2l6ZSkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGxvbmdUb0JpZ0VuZGlhbihpbnB1dCkge1xuICB2YXIgaGkgPSBNYXRoLmZsb29yKGlucHV0IC8gNDI5NDk2NzI5NiksXG4gICAgICBsbyA9IGlucHV0ICUgNDI5NDk2NzI5NjtcbiAgdmFyIG91dHB1dCA9IEJ1ZmZlci5hbGxvYyg4KTtcbiAgb3V0cHV0WzBdID0gMHhmZiAmIChoaSA+Pj4gMjQpO1xuICBvdXRwdXRbMV0gPSAweGZmICYgKGhpID4+PiAxNik7XG4gIG91dHB1dFsyXSA9IDB4ZmYgJiAoaGkgPj4+IDgpO1xuICBvdXRwdXRbM10gPSAweGZmICYgKGhpID4+PiAwKTtcbiAgb3V0cHV0WzRdID0gMHhmZiAmIChsbyA+Pj4gMjQpO1xuICBvdXRwdXRbNV0gPSAweGZmICYgKGxvID4+PiAxNik7XG4gIG91dHB1dFs2XSA9IDB4ZmYgJiAobG8gPj4+IDgpO1xuICBvdXRwdXRbN10gPSAweGZmICYgKGxvID4+PiAwKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24ga3dFbmNyeXB0Rk4oc2l6ZSkge1xuICBmdW5jdGlvbiBjb21tb25DaGVja3Moa2V5LCBkYXRhKSB7XG4gICAgaWYgKHNpemUgIT09IChrZXkubGVuZ3RoIDw8IDMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtleSBzaXplXCIpO1xuICAgIH1cbiAgICBpZiAoMCA8IGRhdGEubGVuZ3RoICYmIDAgIT09IChkYXRhLmxlbmd0aCAlIDgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRhdGEgbGVuZ3RoXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vICMjIyAnZmFsbGJhY2snIGltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb21tb25DaGVja3Moa2V5LCBwZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICAvLyBzZXR1cCBjaXBoZXJcbiAgICB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcihcIkFFU1wiLCBuZXcgRGF0YUJ1ZmZlcihrZXkpKTtcblxuICAgIC8vIHNwbGl0IGlucHV0IGludG8gY2h1bmtzXG4gICAgdmFyIFIgPSBzcGxpdChwZGF0YSwgOCk7XG4gICAgdmFyIEEsXG4gICAgICAgIEIsXG4gICAgICAgIGNvdW50O1xuICAgIEEgPSBBMDtcbiAgICBmb3IgKHZhciBqZHggPSAwOyA2ID4gamR4OyBqZHgrKykge1xuICAgICAgZm9yICh2YXIgaWR4ID0gMDsgUi5sZW5ndGggPiBpZHg7IGlkeCsrKSB7XG4gICAgICAgIGNvdW50ID0gKFIubGVuZ3RoICogamR4KSArIGlkeCArIDE7XG4gICAgICAgIEIgPSBCdWZmZXIuY29uY2F0KFtBLCBSW2lkeF1dKTtcbiAgICAgICAgY2lwaGVyLnN0YXJ0KCk7XG4gICAgICAgIGNpcGhlci51cGRhdGUobmV3IERhdGFCdWZmZXIoQikpO1xuICAgICAgICBjaXBoZXIuZmluaXNoKCk7XG4gICAgICAgIEIgPSBCdWZmZXIuZnJvbShjaXBoZXIub3V0cHV0LmJ5dGVzKCksIFwiYmluYXJ5XCIpO1xuXG4gICAgICAgIEEgPSB4b3IoQi5zbGljZSgwLCA4KSxcbiAgICAgICAgICAgICAgICBsb25nVG9CaWdFbmRpYW4oY291bnQpKTtcbiAgICAgICAgUltpZHhdID0gQi5zbGljZSg4LCAxNik7XG4gICAgICB9XG4gICAgfVxuICAgIFIgPSBbQV0uY29uY2F0KFIpO1xuICAgIHZhciBjZGF0YSA9IEJ1ZmZlci5jb25jYXQoUik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBkYXRhOiBjZGF0YVxuICAgIH0pO1xuICB9O1xuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIGltcGxlbWVudGF0aW9uXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1vbkNoZWNrcyhrZXksIHBkYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBhbGcgPSB7XG4gICAgICBuYW1lOiBcIkFFUy1LV1wiXG4gICAgfTtcbiAgICB2YXIgcHJvbWlzZSA9IFtcbiAgICAgIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcInJhd1wiLCBwZGF0YSwgeyBuYW1lOiBcIkhNQUNcIiwgaGFzaDogXCJTSEEtMjU2XCIgfSwgdHJ1ZSwgW1wic2lnblwiXSksXG4gICAgICBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJyYXdcIiwga2V5LCBhbGcsIHRydWUsIFtcIndyYXBLZXlcIl0pXG4gICAgXTtcbiAgICBwcm9taXNlID0gUHJvbWlzZS5hbGwocHJvbWlzZSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXlzKSB7XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8ud3JhcEtleShcInJhd1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5c1swXSwgLy8ga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzWzFdLCAvLyB3cmFwcGluZ0tleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxnKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gQnVmZmVyLmZyb20ocmVzdWx0KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcmVzdWx0XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuICB2YXIgbm9kZSA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29tbW9uQ2hlY2tzKGtleSwgcGRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgLy8gc3BsaXQgaW5wdXQgaW50byBjaHVua3NcbiAgICB2YXIgUiA9IHNwbGl0KHBkYXRhLCA4KSxcbiAgICAgICAgaXYgPSBCdWZmZXIuYWxsb2MoMTYpO1xuICAgIHZhciBBLFxuICAgICAgICBCLFxuICAgICAgICBjb3VudDtcbiAgICBBID0gQTA7XG4gICAgZm9yICh2YXIgamR4ID0gMDsgNiA+IGpkeDsgamR4KyspIHtcbiAgICAgIGZvciAodmFyIGlkeCA9IDA7IFIubGVuZ3RoID4gaWR4OyBpZHgrKykge1xuICAgICAgICBjb3VudCA9IChSLmxlbmd0aCAqIGpkeCkgKyBpZHggKyAxO1xuICAgICAgICBCID0gQnVmZmVyLmNvbmNhdChbQSwgUltpZHhdXSk7XG4gICAgICAgIHZhciBjaXBoZXIgPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlQ2lwaGVyaXYoXCJBRVNcIiArIHNpemUsIGtleSwgaXYpO1xuICAgICAgICBCID0gY2lwaGVyLnVwZGF0ZShCKTtcblxuICAgICAgICBBID0geG9yKEIuc2xpY2UoMCwgOCksXG4gICAgICAgICAgICAgICAgbG9uZ1RvQmlnRW5kaWFuKGNvdW50KSk7XG4gICAgICAgIFJbaWR4XSA9IEIuc2xpY2UoOCwgMTYpO1xuICAgICAgfVxuICAgIH1cbiAgICBSID0gW0FdLmNvbmNhdChSKTtcbiAgICB2YXIgY2RhdGEgPSBCdWZmZXIuY29uY2F0KFIpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgZGF0YTogY2RhdGFcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGUsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuZnVuY3Rpb24ga3dEZWNyeXB0Rk4oc2l6ZSkge1xuICBmdW5jdGlvbiBjb21tb25DaGVja3Moa2V5LCBkYXRhKSB7XG4gICAgaWYgKHNpemUgIT09IChrZXkubGVuZ3RoIDw8IDMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtleSBzaXplXCIpO1xuICAgIH1cbiAgICBpZiAoMCA8IChkYXRhLmxlbmd0aCAtIDgpICYmIDAgIT09IChkYXRhLmxlbmd0aCAlIDgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRhdGEgbGVuZ3RoXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vICMjIyAnZmFsbGJhY2snIGltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBjZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb21tb25DaGVja3Moa2V5LCBjZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICAvLyBzZXR1cCBjaXBoZXJcbiAgICB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKFwiQUVTXCIsIG5ldyBEYXRhQnVmZmVyKGtleSkpO1xuXG4gICAgLy8gcHJlcGFyZSBpbnB1dHNcbiAgICB2YXIgUiA9IHNwbGl0KGNkYXRhLCA4KSxcbiAgICAgICAgQSxcbiAgICAgICAgQixcbiAgICAgICAgY291bnQ7XG4gICAgQSA9IFJbMF07XG4gICAgUiA9IFIuc2xpY2UoMSk7XG4gICAgZm9yICh2YXIgamR4ID0gNTsgMCA8PSBqZHg7IC0tamR4KSB7XG4gICAgICBmb3IgKHZhciBpZHggPSBSLmxlbmd0aCAtIDE7IDAgPD0gaWR4OyAtLWlkeCkge1xuICAgICAgICBjb3VudCA9IChSLmxlbmd0aCAqIGpkeCkgKyBpZHggKyAxO1xuICAgICAgICBCID0geG9yKEEsXG4gICAgICAgICAgICAgICAgbG9uZ1RvQmlnRW5kaWFuKGNvdW50KSk7XG4gICAgICAgIEIgPSBCdWZmZXIuY29uY2F0KFtCLCBSW2lkeF1dKTtcbiAgICAgICAgY2lwaGVyLnN0YXJ0KCk7XG4gICAgICAgIGNpcGhlci51cGRhdGUobmV3IERhdGFCdWZmZXIoQikpO1xuICAgICAgICBjaXBoZXIuZmluaXNoKCk7XG4gICAgICAgIEIgPSBCdWZmZXIuZnJvbShjaXBoZXIub3V0cHV0LmJ5dGVzKCksIFwiYmluYXJ5XCIpO1xuXG4gICAgICAgIEEgPSBCLnNsaWNlKDAsIDgpO1xuICAgICAgICBSW2lkeF0gPSBCLnNsaWNlKDgsIDE2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKEEudG9TdHJpbmcoKSAhPT0gQTAudG9TdHJpbmcoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImRlY3J5cHRpb24gZmFpbGVkXCIpKTtcbiAgICB9XG4gICAgdmFyIHBkYXRhID0gQnVmZmVyLmNvbmNhdChSKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBkYXRhKTtcbiAgfTtcbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBpbXBsZW1lbnRhdGlvblxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBjZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb21tb25DaGVja3Moa2V5LCBjZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgYWxnID0ge1xuICAgICAgbmFtZTogXCJBRVMtS1dcIlxuICAgIH07XG4gICAgdmFyIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJyYXdcIiwga2V5LCBhbGcsIHRydWUsIFtcInVud3JhcEtleVwiXSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by51bndyYXBLZXkoXCJyYXdcIiwgY2RhdGEsIGtleSwgYWxnLCB7bmFtZTogXCJITUFDXCIsIGhhc2g6IFwiU0hBLTI1NlwifSwgdHJ1ZSwgW1wic2lnblwiXSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIC8vIHVud3JhcHBlZCBDcnlwdG9LZXkgLS0gZXh0cmFjdCByYXdcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5leHBvcnRLZXkoXCJyYXdcIiwgcmVzdWx0KTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gQnVmZmVyLmZyb20ocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG4gIHZhciBub2RlID0gZnVuY3Rpb24oa2V5LCBjZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb21tb25DaGVja3Moa2V5LCBjZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICAvLyBwcmVwYXJlIGlucHV0c1xuICAgIHZhciBSID0gc3BsaXQoY2RhdGEsIDgpLFxuICAgICAgICBpdiA9IEJ1ZmZlci5hbGxvYygxNiksXG4gICAgICAgIEEsXG4gICAgICAgIEIsXG4gICAgICAgIGNvdW50O1xuICAgIEEgPSBSWzBdO1xuICAgIFIgPSBSLnNsaWNlKDEpO1xuICAgIGZvciAodmFyIGpkeCA9IDU7IDAgPD0gamR4OyAtLWpkeCkge1xuICAgICAgZm9yICh2YXIgaWR4ID0gUi5sZW5ndGggLSAxOyAwIDw9IGlkeDsgLS1pZHgpIHtcbiAgICAgICAgY291bnQgPSAoUi5sZW5ndGggKiBqZHgpICsgaWR4ICsgMTtcbiAgICAgICAgQiA9IHhvcihBLFxuICAgICAgICAgICAgICAgIGxvbmdUb0JpZ0VuZGlhbihjb3VudCkpO1xuICAgICAgICBCID0gQnVmZmVyLmNvbmNhdChbQiwgUltpZHhdLCBpdl0pO1xuICAgICAgICB2YXIgY2lwaGVyID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoXCJBRVNcIiArIHNpemUsIGtleSwgaXYpO1xuICAgICAgICBCID0gY2lwaGVyLnVwZGF0ZShCKTtcblxuICAgICAgICBBID0gQi5zbGljZSgwLCA4KTtcbiAgICAgICAgUltpZHhdID0gQi5zbGljZSg4LCAxNik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChBLnRvU3RyaW5nKCkgIT09IEEwLnRvU3RyaW5nKCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJkZWNyeXB0aW9uIGZhaWxlZFwiKSk7XG4gICAgfVxuICAgIHZhciBwZGF0YSA9IEJ1ZmZlci5jb25jYXQoUik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwZGF0YSk7XG4gIH07XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuLy8gIyMjIFB1YmxpYyBBUElcbi8vICogW25hbWVdLmVuY3J5cHRcbi8vICogW25hbWVdLmRlY3J5cHRcbnZhciBhZXNLdyA9IHt9O1xuW1xuICBcIkExMjhLV1wiLFxuICBcIkExOTJLV1wiLFxuICBcIkEyNTZLV1wiXG5dLmZvckVhY2goZnVuY3Rpb24oYWxnKSB7XG4gIHZhciBzaXplID0gcGFyc2VJbnQoL0EoXFxkKylLVy9nLmV4ZWMoYWxnKVsxXSk7XG4gIGFlc0t3W2FsZ10gPSB7XG4gICAgZW5jcnlwdDoga3dFbmNyeXB0Rk4oc2l6ZSksXG4gICAgZGVjcnlwdDoga3dEZWNyeXB0Rk4oc2l6ZSlcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFlc0t3O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/concat.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/concat.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/concat.js - Concat Key Derivation\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    sha = __webpack_require__(/*! ./sha.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\");\n\nfunction concatDeriveFn(name) {\n  name = name.replace(\"CONCAT-\", \"\");\n\n  // NOTE: no nodejs/webcrypto/fallback model, since ConcatKDF is\n  //       implemented using the SHA algorithms\n\n  var fn = function(key, props) {\n    props = props || {};\n\n    var keyLen = props.length,\n        hashLen = CONSTANTS.HASHLENGTH[name];\n    if (!keyLen) {\n      return Promise.reject(new Error(\"invalid key length\"));\n    }\n\n    // setup otherInfo\n    if (!props.otherInfo) {\n      return Promise.reject(new Error(\"invalid otherInfo\"));\n    }\n    var otherInfo = props.otherInfo;\n\n    var op = sha[name].digest;\n    var N = Math.ceil(keyLen / hashLen),\n        idx = 0,\n        okm = [];\n    function step() {\n      if (N === idx++) {\n        return Buffer.concat(okm).slice(0, keyLen);\n      }\n\n      var T = Buffer.alloc(4 + key.length + otherInfo.length);\n      T.writeUInt32BE(idx, 0);\n      key.copy(T, 4);\n      otherInfo.copy(T, 4 + key.length);\n      return op(T).then(function(result) {\n        okm.push(result);\n        return step();\n      });\n    }\n\n    return step();\n  };\n\n  return fn;\n}\n\n// Public API\n// * [name].derive\nvar concat = {};\n[\n  \"CONCAT-SHA-1\",\n  \"CONCAT-SHA-256\",\n  \"CONCAT-SHA-384\",\n  \"CONCAT-SHA-512\"\n].forEach(function(name) {\n  concat[name] = {\n    derive: concatDeriveFn(name)\n  };\n});\n\nmodule.exports = concat;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2NvbmNhdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQ3hDLFVBQVUsbUJBQU8sQ0FBQyxzRUFBVTs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9jb25jYXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL2NvbmNhdC5qcyAtIENvbmNhdCBLZXkgRGVyaXZhdGlvblxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIENPTlNUQU5UUyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKSxcbiAgICBzaGEgPSByZXF1aXJlKFwiLi9zaGEuanNcIik7XG5cbmZ1bmN0aW9uIGNvbmNhdERlcml2ZUZuKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUucmVwbGFjZShcIkNPTkNBVC1cIiwgXCJcIik7XG5cbiAgLy8gTk9URTogbm8gbm9kZWpzL3dlYmNyeXB0by9mYWxsYmFjayBtb2RlbCwgc2luY2UgQ29uY2F0S0RGIGlzXG4gIC8vICAgICAgIGltcGxlbWVudGVkIHVzaW5nIHRoZSBTSEEgYWxnb3JpdGhtc1xuXG4gIHZhciBmbiA9IGZ1bmN0aW9uKGtleSwgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgdmFyIGtleUxlbiA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgaGFzaExlbiA9IENPTlNUQU5UUy5IQVNITEVOR1RIW25hbWVdO1xuICAgIGlmICgha2V5TGVuKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBrZXkgbGVuZ3RoXCIpKTtcbiAgICB9XG5cbiAgICAvLyBzZXR1cCBvdGhlckluZm9cbiAgICBpZiAoIXByb3BzLm90aGVySW5mbykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgb3RoZXJJbmZvXCIpKTtcbiAgICB9XG4gICAgdmFyIG90aGVySW5mbyA9IHByb3BzLm90aGVySW5mbztcblxuICAgIHZhciBvcCA9IHNoYVtuYW1lXS5kaWdlc3Q7XG4gICAgdmFyIE4gPSBNYXRoLmNlaWwoa2V5TGVuIC8gaGFzaExlbiksXG4gICAgICAgIGlkeCA9IDAsXG4gICAgICAgIG9rbSA9IFtdO1xuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICBpZiAoTiA9PT0gaWR4KyspIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob2ttKS5zbGljZSgwLCBrZXlMZW4pO1xuICAgICAgfVxuXG4gICAgICB2YXIgVCA9IEJ1ZmZlci5hbGxvYyg0ICsga2V5Lmxlbmd0aCArIG90aGVySW5mby5sZW5ndGgpO1xuICAgICAgVC53cml0ZVVJbnQzMkJFKGlkeCwgMCk7XG4gICAgICBrZXkuY29weShULCA0KTtcbiAgICAgIG90aGVySW5mby5jb3B5KFQsIDQgKyBrZXkubGVuZ3RoKTtcbiAgICAgIHJldHVybiBvcChUKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBva20ucHVzaChyZXN1bHQpO1xuICAgICAgICByZXR1cm4gc3RlcCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ZXAoKTtcbiAgfTtcblxuICByZXR1cm4gZm47XG59XG5cbi8vIFB1YmxpYyBBUElcbi8vICogW25hbWVdLmRlcml2ZVxudmFyIGNvbmNhdCA9IHt9O1xuW1xuICBcIkNPTkNBVC1TSEEtMVwiLFxuICBcIkNPTkNBVC1TSEEtMjU2XCIsXG4gIFwiQ09OQ0FULVNIQS0zODRcIixcbiAgXCJDT05DQVQtU0hBLTUxMlwiXG5dLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICBjb25jYXRbbmFtZV0gPSB7XG4gICAgZGVyaXZlOiBjb25jYXREZXJpdmVGbihuYW1lKVxuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29uY2F0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/concat.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/constants.js ***!
  \************************************************************/
/***/ ((module) => {

eval("/*!\n * algorithms/constants.js - Constants used in Cryptographic Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n \n\nmodule.exports = {\n  CHUNK_SIZE: 1024,\n  HASHLENGTH: {\n    \"SHA-1\": 160,\n    \"SHA-256\": 256,\n    \"SHA-384\": 384,\n    \"SHA-512\": 512\n  },\n  ENCLENGTH: {\n    \"AES-128-CBC\": 128,\n    \"AES-192-CBC\": 192,\n    \"AES-256-CBC\": 256,\n    \"AES-128-KW\": 128,\n    \"AES-192-KW\": 192,\n    \"AES-256-KW\": 256\n  },\n  KEYLENGTH: {\n    \"A128CBC-HS256\": 256,\n    \"A192CBC-HS384\": 384,\n    \"A256CBC-HS512\": 512,\n    \"A128CBC+HS256\": 256,\n    \"A192CBC+HS384\": 384,\n    \"A256CBC+HS512\": 512,\n    \"A128GCM\": 128,\n    \"A192GCM\": 192,\n    \"A256GCM\": 256,\n    \"A128KW\": 128,\n    \"A192KW\": 192,\n    \"A256KW\": 256,\n    \"ECDH-ES+A128KW\": 128,\n    \"ECDH-ES+A192KW\": 192,\n    \"ECDH-ES+A256KW\": 256\n  },\n  NONCELENGTH: {\n    \"A128CBC-HS256\": 128,\n    \"A192CBC-HS384\": 128,\n    \"A256CBC-HS512\": 128,\n    \"A128CBC+HS256\": 128,\n    \"A192CBC+HS384\": 128,\n    \"A256CBC+HS512\": 128,\n    \"A128GCM\": 96,\n    \"A192GCM\": 96,\n    \"A256GCM\": 96\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL2NvbnN0YW50cy5qcyAtIENvbnN0YW50cyB1c2VkIGluIENyeXB0b2dyYXBoaWMgQWxnb3JpdGhtc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG4gXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDSFVOS19TSVpFOiAxMDI0LFxuICBIQVNITEVOR1RIOiB7XG4gICAgXCJTSEEtMVwiOiAxNjAsXG4gICAgXCJTSEEtMjU2XCI6IDI1NixcbiAgICBcIlNIQS0zODRcIjogMzg0LFxuICAgIFwiU0hBLTUxMlwiOiA1MTJcbiAgfSxcbiAgRU5DTEVOR1RIOiB7XG4gICAgXCJBRVMtMTI4LUNCQ1wiOiAxMjgsXG4gICAgXCJBRVMtMTkyLUNCQ1wiOiAxOTIsXG4gICAgXCJBRVMtMjU2LUNCQ1wiOiAyNTYsXG4gICAgXCJBRVMtMTI4LUtXXCI6IDEyOCxcbiAgICBcIkFFUy0xOTItS1dcIjogMTkyLFxuICAgIFwiQUVTLTI1Ni1LV1wiOiAyNTZcbiAgfSxcbiAgS0VZTEVOR1RIOiB7XG4gICAgXCJBMTI4Q0JDLUhTMjU2XCI6IDI1NixcbiAgICBcIkExOTJDQkMtSFMzODRcIjogMzg0LFxuICAgIFwiQTI1NkNCQy1IUzUxMlwiOiA1MTIsXG4gICAgXCJBMTI4Q0JDK0hTMjU2XCI6IDI1NixcbiAgICBcIkExOTJDQkMrSFMzODRcIjogMzg0LFxuICAgIFwiQTI1NkNCQytIUzUxMlwiOiA1MTIsXG4gICAgXCJBMTI4R0NNXCI6IDEyOCxcbiAgICBcIkExOTJHQ01cIjogMTkyLFxuICAgIFwiQTI1NkdDTVwiOiAyNTYsXG4gICAgXCJBMTI4S1dcIjogMTI4LFxuICAgIFwiQTE5MktXXCI6IDE5MixcbiAgICBcIkEyNTZLV1wiOiAyNTYsXG4gICAgXCJFQ0RILUVTK0ExMjhLV1wiOiAxMjgsXG4gICAgXCJFQ0RILUVTK0ExOTJLV1wiOiAxOTIsXG4gICAgXCJFQ0RILUVTK0EyNTZLV1wiOiAyNTZcbiAgfSxcbiAgTk9OQ0VMRU5HVEg6IHtcbiAgICBcIkExMjhDQkMtSFMyNTZcIjogMTI4LFxuICAgIFwiQTE5MkNCQy1IUzM4NFwiOiAxMjgsXG4gICAgXCJBMjU2Q0JDLUhTNTEyXCI6IDEyOCxcbiAgICBcIkExMjhDQkMrSFMyNTZcIjogMTI4LFxuICAgIFwiQTE5MkNCQytIUzM4NFwiOiAxMjgsXG4gICAgXCJBMjU2Q0JDK0hTNTEyXCI6IDEyOCxcbiAgICBcIkExMjhHQ01cIjogOTYsXG4gICAgXCJBMTkyR0NNXCI6IDk2LFxuICAgIFwiQTI1NkdDTVwiOiA5NlxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/dir.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/dir.js ***!
  \******************************************************/
/***/ ((module) => {

eval("/*!\n * algorithms/dir.js - Direct key mode\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nfunction dirEncryptFN(key) {\n  // NOTE: pdata unused\n  // NOTE: props unused\n  return Promise.resolve({\n    data: key,\n    once: true,\n    direct: true\n  });\n}\nfunction dirDecryptFN(key) {\n  // NOTE: pdata unused\n  // NOTE: props unused\n  return Promise.resolve(key);\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar direct = {\n  dir: {\n    encrypt: dirEncryptFN,\n    decrypt: dirDecryptFN\n  }\n};\n\nmodule.exports = direct;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Rpci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Rpci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvZGlyLmpzIC0gRGlyZWN0IGtleSBtb2RlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBkaXJFbmNyeXB0Rk4oa2V5KSB7XG4gIC8vIE5PVEU6IHBkYXRhIHVudXNlZFxuICAvLyBOT1RFOiBwcm9wcyB1bnVzZWRcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgZGF0YToga2V5LFxuICAgIG9uY2U6IHRydWUsXG4gICAgZGlyZWN0OiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gZGlyRGVjcnlwdEZOKGtleSkge1xuICAvLyBOT1RFOiBwZGF0YSB1bnVzZWRcbiAgLy8gTk9URTogcHJvcHMgdW51c2VkXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5KTtcbn1cblxuLy8gIyMjIFB1YmxpYyBBUElcbi8vICogW25hbWVdLmVuY3J5cHRcbi8vICogW25hbWVdLmRlY3J5cHRcbnZhciBkaXJlY3QgPSB7XG4gIGRpcjoge1xuICAgIGVuY3J5cHQ6IGRpckVuY3J5cHRGTixcbiAgICBkZWNyeXB0OiBkaXJEZWNyeXB0Rk5cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaXJlY3Q7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/dir.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/ec-util.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/ec-util.js - Elliptic Curve Utility Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    ecc = __webpack_require__(/*! ../deps/ecc */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/index.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\nvar EC_KEYSIZES = {\n  \"P-256\": 256,\n  \"P-384\": 384,\n  \"P-521\": 521\n};\n\nfunction convertToForge(key, isPublic) {\n  var parts = isPublic ?\n              [\"x\", \"y\"] :\n              [\"d\"];\n  parts = parts.map(function(f) {\n    return new forge.jsbn.BigInteger(key[f].toString(\"hex\"), 16);\n  });\n  // prefix with curve\n  parts = [key.crv].concat(parts);\n  var fn = isPublic ?\n           ecc.asPublicKey :\n           ecc.asPrivateKey;\n  return fn.apply(ecc, parts);\n}\n\nfunction convertToJWK(key, isPublic) {\n  var result = clone(key);\n  var parts = isPublic ?\n              [\"x\", \"y\"] :\n              [\"x\", \"y\", \"d\"];\n  parts.forEach(function(f) {\n    result[f] = util.base64url.encode(result[f]);\n  });\n\n  // remove potentially troublesome properties\n  delete result.key_ops;\n  delete result.use;\n  delete result.alg;\n\n  if (isPublic) {\n    delete result.d;\n  }\n\n  return result;\n}\n\nfunction convertToObj(key, isPublic) {\n  var result = clone(key);\n  var parts = isPublic ?\n              [\"x\", \"y\"] :\n              [\"d\"];\n  parts.forEach(function(f) {\n    // assume string if base64url-encoded\n    result[f] = util.asBuffer(result[f], \"base64url\");\n  });\n\n  return result;\n}\n\nvar UNCOMPRESSED = Buffer.from([0x04]);\nfunction convertToBuffer(key, isPublic) {\n  key = convertToObj(key, isPublic);\n  var result = isPublic ?\n               Buffer.concat([UNCOMPRESSED, key.x, key.y]) :\n               key.d;\n  return result;\n}\n\nfunction curveSize(crv) {\n  return EC_KEYSIZES[crv || \"\"] || NaN;\n}\n\nfunction curveNameToOid(crv) {\n  switch (crv) {\n    case \"P-256\":\n      return \"1.2.840.10045.3.1.7\";\n    case \"P-384\":\n      return \"1.3.132.0.34\";\n    case \"P-521\":\n      return \"1.3.132.0.35\";\n    default:\n      return null;\n  }\n}\n\nvar EC_OID = \"1.2.840.10045.2.1\";\nfunction convertToPEM(key, isPrivate) {\n  // curveName to OID\n  var oid = key.crv;\n  oid = curveNameToOid(oid);\n  oid = forge.asn1.oidToDer(oid);\n  // key as bytes\n  var type,\n      pub,\n      asn1;\n  if (isPrivate) {\n    type = \"EC PRIVATE KEY\";\n    pub = Buffer.concat([\n      Buffer.from([0x00, 0x04]),\n      key.x,\n      key.y\n    ]).toString(\"binary\");\n    key = key.d.toString(\"binary\");\n    asn1 = forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [\n      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.INTEGER, false, \"\\u0001\"),\n      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OCTETSTRING, false, key),\n      forge.asn1.create(forge.asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, oid.bytes())\n      ]),\n      forge.asn1.create(forge.asn1.Class.CONTEXT_SPECIFIC, 1, true, [\n        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.BITSTRING, false, pub)\n      ])\n    ]);\n  } else {\n    type = \"PUBLIC KEY\";\n    key = Buffer.concat([\n      Buffer.from([0x00, 0x04]),\n      key.x,\n      key.y\n    ]).toString(\"binary\");\n    asn1 = forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [\n      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [\n        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, forge.asn1.oidToDer(EC_OID).bytes()),\n        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, oid.bytes())\n      ]),\n      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.BITSTRING, false, key)\n    ]);\n  }\n  asn1 = forge.asn1.toDer(asn1).bytes();\n  var pem = forge.pem.encode({\n    type: type,\n    body: asn1\n  });\n  return pem;\n}\n\n// Inspired by teifip/node-webtokens/blob/master/lib/ecdsa.js\nvar ERR_MSG = \"Could not extract parameters from DER signature\";\nfunction derToConcat(signature, size) {\n  var offset = 0;\n  if (signature[offset++] !== 0x30) {\n    throw new Error(ERR_MSG);\n  }\n  var seqLength = signature[offset++];\n  if (seqLength === 0x81) {\n    seqLength = signature[offset++];\n  }\n  if (seqLength > signature.length - offset) {\n    throw new Error(ERR_MSG);\n  }\n  if (signature[offset++] !== 0x02) {\n    throw new Error(ERR_MSG);\n  }\n  var rLength = signature[offset++];\n  if (rLength > signature.length - offset - 2) {\n    throw new Error(ERR_MSG);\n  }\n  if (rLength > size + 1) {\n    throw new Error(ERR_MSG);\n  }\n  var rOffset = offset;\n  offset += rLength;\n  if (signature[offset++] !== 0x02) {\n    throw new Error(ERR_MSG);\n  }\n  var sLength = signature[offset++];\n  if (sLength !== signature.length - offset) {\n    throw new Error(ERR_MSG);\n  }\n  if (sLength > size + 1) {\n    throw new Error(ERR_MSG);\n  }\n  var sOffset = offset;\n  offset += sLength;\n  if (offset !== signature.length) {\n    throw new Error(ERR_MSG);\n  }\n  var rPadding = size - rLength;\n  var sPadding = size - sLength;\n  var dst = Buffer.alloc(rPadding + rLength + sPadding + sLength);\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0;\n  }\n  var rPad = Math.max(-rPadding, 0);\n  signature.copy(dst, offset, rOffset + rPad, rOffset + rLength);\n  offset = size;\n  for (var o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0;\n  }\n  var sPad = Math.max(-sPadding, 0);\n  signature.copy(dst, offset, sOffset + sPad, sOffset + sLength);\n  return dst;\n}\n\nfunction countPadding(buf, start, stop) {\n  var padding = 0;\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding;\n  }\n  var needsSign = buf[start + padding] >= 0x80;\n  if (needsSign) {\n    --padding;\n  }\n  return padding;\n}\n\nfunction concatToDer(signature, size) {\n  var rPadding = countPadding(signature, 0, size);\n  var sPadding = countPadding(signature, size, signature.length);\n  var rLength = size - rPadding;\n  var sLength = size - sPadding;\n  var rsBytes = rLength + sLength + 4;\n  var shortLength = rsBytes < 0x80;\n  var dst = Buffer.alloc((shortLength ? 2 : 3) + rsBytes);\n  var offset = 0;\n  dst[offset++] = 0x30;\n  if (shortLength) {\n    dst[offset++] = rsBytes;\n  } else {\n    dst[offset++] = 0x81;\n    dst[offset++] = rsBytes & 0xFF;\n  }\n  dst[offset++] = 0x02;\n  dst[offset++] = rLength;\n  if (rPadding < 0) {\n    dst[offset++] = 0;\n    offset += signature.copy(dst, offset, 0, size);\n  } else {\n    offset += signature.copy(dst, offset, rPadding, size);\n  }\n  dst[offset++] = 0x02;\n  dst[offset++] = sLength;\n  if (sPadding < 0) {\n    dst[offset++] = 0;\n    signature.copy(dst, offset, size);\n  } else {\n    signature.copy(dst, offset, size + sPadding);\n  }\n  return dst;\n}\n\nmodule.exports = {\n  convertToForge: convertToForge,\n  convertToJWK: convertToJWK,\n  convertToObj: convertToObj,\n  convertToBuffer: convertToBuffer,\n  curveSize: curveSize,\n  derToConcat: derToConcat,\n  concatToDer: concatToDer,\n  convertToPEM: convertToPEM,\n  EC_OID: EC_OID\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2VjLXV0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBYztBQUNsQyxVQUFVLG1CQUFPLENBQUMseUVBQWE7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QyxXQUFXLG1CQUFPLENBQUMsaUVBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvZWMtdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvZWMtdXRpbC5qcyAtIEVsbGlwdGljIEN1cnZlIFV0aWxpdHkgRnVuY3Rpb25zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2xvbmUgPSByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpLFxuICAgIGVjYyA9IHJlcXVpcmUoXCIuLi9kZXBzL2VjY1wiKSxcbiAgICBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlLmpzXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxudmFyIEVDX0tFWVNJWkVTID0ge1xuICBcIlAtMjU2XCI6IDI1NixcbiAgXCJQLTM4NFwiOiAzODQsXG4gIFwiUC01MjFcIjogNTIxXG59O1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9Gb3JnZShrZXksIGlzUHVibGljKSB7XG4gIHZhciBwYXJ0cyA9IGlzUHVibGljID9cbiAgICAgICAgICAgICAgW1wieFwiLCBcInlcIl0gOlxuICAgICAgICAgICAgICBbXCJkXCJdO1xuICBwYXJ0cyA9IHBhcnRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIG5ldyBmb3JnZS5qc2JuLkJpZ0ludGVnZXIoa2V5W2ZdLnRvU3RyaW5nKFwiaGV4XCIpLCAxNik7XG4gIH0pO1xuICAvLyBwcmVmaXggd2l0aCBjdXJ2ZVxuICBwYXJ0cyA9IFtrZXkuY3J2XS5jb25jYXQocGFydHMpO1xuICB2YXIgZm4gPSBpc1B1YmxpYyA/XG4gICAgICAgICAgIGVjYy5hc1B1YmxpY0tleSA6XG4gICAgICAgICAgIGVjYy5hc1ByaXZhdGVLZXk7XG4gIHJldHVybiBmbi5hcHBseShlY2MsIHBhcnRzKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRvSldLKGtleSwgaXNQdWJsaWMpIHtcbiAgdmFyIHJlc3VsdCA9IGNsb25lKGtleSk7XG4gIHZhciBwYXJ0cyA9IGlzUHVibGljID9cbiAgICAgICAgICAgICAgW1wieFwiLCBcInlcIl0gOlxuICAgICAgICAgICAgICBbXCJ4XCIsIFwieVwiLCBcImRcIl07XG4gIHBhcnRzLmZvckVhY2goZnVuY3Rpb24oZikge1xuICAgIHJlc3VsdFtmXSA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZShyZXN1bHRbZl0pO1xuICB9KTtcblxuICAvLyByZW1vdmUgcG90ZW50aWFsbHkgdHJvdWJsZXNvbWUgcHJvcGVydGllc1xuICBkZWxldGUgcmVzdWx0LmtleV9vcHM7XG4gIGRlbGV0ZSByZXN1bHQudXNlO1xuICBkZWxldGUgcmVzdWx0LmFsZztcblxuICBpZiAoaXNQdWJsaWMpIHtcbiAgICBkZWxldGUgcmVzdWx0LmQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9PYmooa2V5LCBpc1B1YmxpYykge1xuICB2YXIgcmVzdWx0ID0gY2xvbmUoa2V5KTtcbiAgdmFyIHBhcnRzID0gaXNQdWJsaWMgP1xuICAgICAgICAgICAgICBbXCJ4XCIsIFwieVwiXSA6XG4gICAgICAgICAgICAgIFtcImRcIl07XG4gIHBhcnRzLmZvckVhY2goZnVuY3Rpb24oZikge1xuICAgIC8vIGFzc3VtZSBzdHJpbmcgaWYgYmFzZTY0dXJsLWVuY29kZWRcbiAgICByZXN1bHRbZl0gPSB1dGlsLmFzQnVmZmVyKHJlc3VsdFtmXSwgXCJiYXNlNjR1cmxcIik7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBVTkNPTVBSRVNTRUQgPSBCdWZmZXIuZnJvbShbMHgwNF0pO1xuZnVuY3Rpb24gY29udmVydFRvQnVmZmVyKGtleSwgaXNQdWJsaWMpIHtcbiAga2V5ID0gY29udmVydFRvT2JqKGtleSwgaXNQdWJsaWMpO1xuICB2YXIgcmVzdWx0ID0gaXNQdWJsaWMgP1xuICAgICAgICAgICAgICAgQnVmZmVyLmNvbmNhdChbVU5DT01QUkVTU0VELCBrZXkueCwga2V5LnldKSA6XG4gICAgICAgICAgICAgICBrZXkuZDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY3VydmVTaXplKGNydikge1xuICByZXR1cm4gRUNfS0VZU0laRVNbY3J2IHx8IFwiXCJdIHx8IE5hTjtcbn1cblxuZnVuY3Rpb24gY3VydmVOYW1lVG9PaWQoY3J2KSB7XG4gIHN3aXRjaCAoY3J2KSB7XG4gICAgY2FzZSBcIlAtMjU2XCI6XG4gICAgICByZXR1cm4gXCIxLjIuODQwLjEwMDQ1LjMuMS43XCI7XG4gICAgY2FzZSBcIlAtMzg0XCI6XG4gICAgICByZXR1cm4gXCIxLjMuMTMyLjAuMzRcIjtcbiAgICBjYXNlIFwiUC01MjFcIjpcbiAgICAgIHJldHVybiBcIjEuMy4xMzIuMC4zNVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG52YXIgRUNfT0lEID0gXCIxLjIuODQwLjEwMDQ1LjIuMVwiO1xuZnVuY3Rpb24gY29udmVydFRvUEVNKGtleSwgaXNQcml2YXRlKSB7XG4gIC8vIGN1cnZlTmFtZSB0byBPSURcbiAgdmFyIG9pZCA9IGtleS5jcnY7XG4gIG9pZCA9IGN1cnZlTmFtZVRvT2lkKG9pZCk7XG4gIG9pZCA9IGZvcmdlLmFzbjEub2lkVG9EZXIob2lkKTtcbiAgLy8ga2V5IGFzIGJ5dGVzXG4gIHZhciB0eXBlLFxuICAgICAgcHViLFxuICAgICAgYXNuMTtcbiAgaWYgKGlzUHJpdmF0ZSkge1xuICAgIHR5cGUgPSBcIkVDIFBSSVZBVEUgS0VZXCI7XG4gICAgcHViID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBCdWZmZXIuZnJvbShbMHgwMCwgMHgwNF0pLFxuICAgICAga2V5LngsXG4gICAgICBrZXkueVxuICAgIF0pLnRvU3RyaW5nKFwiYmluYXJ5XCIpO1xuICAgIGtleSA9IGtleS5kLnRvU3RyaW5nKFwiYmluYXJ5XCIpO1xuICAgIGFzbjEgPSBmb3JnZS5hc24xLmNyZWF0ZShmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCwgZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBmb3JnZS5hc24xLmNyZWF0ZShmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCwgZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLCBcIlxcdTAwMDFcIiksXG4gICAgICBmb3JnZS5hc24xLmNyZWF0ZShmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCwgZm9yZ2UuYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwga2V5KSxcbiAgICAgIGZvcmdlLmFzbjEuY3JlYXRlKGZvcmdlLmFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICBmb3JnZS5hc24xLmNyZWF0ZShmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCwgZm9yZ2UuYXNuMS5UeXBlLk9JRCwgZmFsc2UsIG9pZC5ieXRlcygpKVxuICAgICAgXSksXG4gICAgICBmb3JnZS5hc24xLmNyZWF0ZShmb3JnZS5hc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDEsIHRydWUsIFtcbiAgICAgICAgZm9yZ2UuYXNuMS5jcmVhdGUoZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsIGZvcmdlLmFzbjEuVHlwZS5CSVRTVFJJTkcsIGZhbHNlLCBwdWIpXG4gICAgICBdKVxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBcIlBVQkxJQyBLRVlcIjtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgIEJ1ZmZlci5mcm9tKFsweDAwLCAweDA0XSksXG4gICAgICBrZXkueCxcbiAgICAgIGtleS55XG4gICAgXSkudG9TdHJpbmcoXCJiaW5hcnlcIik7XG4gICAgYXNuMSA9IGZvcmdlLmFzbjEuY3JlYXRlKGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIGZvcmdlLmFzbjEuY3JlYXRlKGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgZm9yZ2UuYXNuMS5jcmVhdGUoZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsIGZvcmdlLmFzbjEuVHlwZS5PSUQsIGZhbHNlLCBmb3JnZS5hc24xLm9pZFRvRGVyKEVDX09JRCkuYnl0ZXMoKSksXG4gICAgICAgIGZvcmdlLmFzbjEuY3JlYXRlKGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBmb3JnZS5hc24xLlR5cGUuT0lELCBmYWxzZSwgb2lkLmJ5dGVzKCkpXG4gICAgICBdKSxcbiAgICAgIGZvcmdlLmFzbjEuY3JlYXRlKGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBmb3JnZS5hc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSwga2V5KVxuICAgIF0pO1xuICB9XG4gIGFzbjEgPSBmb3JnZS5hc24xLnRvRGVyKGFzbjEpLmJ5dGVzKCk7XG4gIHZhciBwZW0gPSBmb3JnZS5wZW0uZW5jb2RlKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGJvZHk6IGFzbjFcbiAgfSk7XG4gIHJldHVybiBwZW07XG59XG5cbi8vIEluc3BpcmVkIGJ5IHRlaWZpcC9ub2RlLXdlYnRva2Vucy9ibG9iL21hc3Rlci9saWIvZWNkc2EuanNcbnZhciBFUlJfTVNHID0gXCJDb3VsZCBub3QgZXh0cmFjdCBwYXJhbWV0ZXJzIGZyb20gREVSIHNpZ25hdHVyZVwiO1xuZnVuY3Rpb24gZGVyVG9Db25jYXQoc2lnbmF0dXJlLCBzaXplKSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuICBpZiAoc2lnbmF0dXJlW29mZnNldCsrXSAhPT0gMHgzMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJfTVNHKTtcbiAgfVxuICB2YXIgc2VxTGVuZ3RoID0gc2lnbmF0dXJlW29mZnNldCsrXTtcbiAgaWYgKHNlcUxlbmd0aCA9PT0gMHg4MSkge1xuICAgIHNlcUxlbmd0aCA9IHNpZ25hdHVyZVtvZmZzZXQrK107XG4gIH1cbiAgaWYgKHNlcUxlbmd0aCA+IHNpZ25hdHVyZS5sZW5ndGggLSBvZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX01TRyk7XG4gIH1cbiAgaWYgKHNpZ25hdHVyZVtvZmZzZXQrK10gIT09IDB4MDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX01TRyk7XG4gIH1cbiAgdmFyIHJMZW5ndGggPSBzaWduYXR1cmVbb2Zmc2V0KytdO1xuICBpZiAockxlbmd0aCA+IHNpZ25hdHVyZS5sZW5ndGggLSBvZmZzZXQgLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUl9NU0cpO1xuICB9XG4gIGlmIChyTGVuZ3RoID4gc2l6ZSArIDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX01TRyk7XG4gIH1cbiAgdmFyIHJPZmZzZXQgPSBvZmZzZXQ7XG4gIG9mZnNldCArPSByTGVuZ3RoO1xuICBpZiAoc2lnbmF0dXJlW29mZnNldCsrXSAhPT0gMHgwMikge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJfTVNHKTtcbiAgfVxuICB2YXIgc0xlbmd0aCA9IHNpZ25hdHVyZVtvZmZzZXQrK107XG4gIGlmIChzTGVuZ3RoICE9PSBzaWduYXR1cmUubGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUl9NU0cpO1xuICB9XG4gIGlmIChzTGVuZ3RoID4gc2l6ZSArIDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX01TRyk7XG4gIH1cbiAgdmFyIHNPZmZzZXQgPSBvZmZzZXQ7XG4gIG9mZnNldCArPSBzTGVuZ3RoO1xuICBpZiAob2Zmc2V0ICE9PSBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUl9NU0cpO1xuICB9XG4gIHZhciByUGFkZGluZyA9IHNpemUgLSByTGVuZ3RoO1xuICB2YXIgc1BhZGRpbmcgPSBzaXplIC0gc0xlbmd0aDtcbiAgdmFyIGRzdCA9IEJ1ZmZlci5hbGxvYyhyUGFkZGluZyArIHJMZW5ndGggKyBzUGFkZGluZyArIHNMZW5ndGgpO1xuICBmb3IgKG9mZnNldCA9IDA7IG9mZnNldCA8IHJQYWRkaW5nOyArK29mZnNldCkge1xuICAgIGRzdFtvZmZzZXRdID0gMDtcbiAgfVxuICB2YXIgclBhZCA9IE1hdGgubWF4KC1yUGFkZGluZywgMCk7XG4gIHNpZ25hdHVyZS5jb3B5KGRzdCwgb2Zmc2V0LCByT2Zmc2V0ICsgclBhZCwgck9mZnNldCArIHJMZW5ndGgpO1xuICBvZmZzZXQgPSBzaXplO1xuICBmb3IgKHZhciBvID0gb2Zmc2V0OyBvZmZzZXQgPCBvICsgc1BhZGRpbmc7ICsrb2Zmc2V0KSB7XG4gICAgZHN0W29mZnNldF0gPSAwO1xuICB9XG4gIHZhciBzUGFkID0gTWF0aC5tYXgoLXNQYWRkaW5nLCAwKTtcbiAgc2lnbmF0dXJlLmNvcHkoZHN0LCBvZmZzZXQsIHNPZmZzZXQgKyBzUGFkLCBzT2Zmc2V0ICsgc0xlbmd0aCk7XG4gIHJldHVybiBkc3Q7XG59XG5cbmZ1bmN0aW9uIGNvdW50UGFkZGluZyhidWYsIHN0YXJ0LCBzdG9wKSB7XG4gIHZhciBwYWRkaW5nID0gMDtcbiAgd2hpbGUgKHN0YXJ0ICsgcGFkZGluZyA8IHN0b3AgJiYgYnVmW3N0YXJ0ICsgcGFkZGluZ10gPT09IDApIHtcbiAgICArK3BhZGRpbmc7XG4gIH1cbiAgdmFyIG5lZWRzU2lnbiA9IGJ1ZltzdGFydCArIHBhZGRpbmddID49IDB4ODA7XG4gIGlmIChuZWVkc1NpZ24pIHtcbiAgICAtLXBhZGRpbmc7XG4gIH1cbiAgcmV0dXJuIHBhZGRpbmc7XG59XG5cbmZ1bmN0aW9uIGNvbmNhdFRvRGVyKHNpZ25hdHVyZSwgc2l6ZSkge1xuICB2YXIgclBhZGRpbmcgPSBjb3VudFBhZGRpbmcoc2lnbmF0dXJlLCAwLCBzaXplKTtcbiAgdmFyIHNQYWRkaW5nID0gY291bnRQYWRkaW5nKHNpZ25hdHVyZSwgc2l6ZSwgc2lnbmF0dXJlLmxlbmd0aCk7XG4gIHZhciByTGVuZ3RoID0gc2l6ZSAtIHJQYWRkaW5nO1xuICB2YXIgc0xlbmd0aCA9IHNpemUgLSBzUGFkZGluZztcbiAgdmFyIHJzQnl0ZXMgPSByTGVuZ3RoICsgc0xlbmd0aCArIDQ7XG4gIHZhciBzaG9ydExlbmd0aCA9IHJzQnl0ZXMgPCAweDgwO1xuICB2YXIgZHN0ID0gQnVmZmVyLmFsbG9jKChzaG9ydExlbmd0aCA/IDIgOiAzKSArIHJzQnl0ZXMpO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgZHN0W29mZnNldCsrXSA9IDB4MzA7XG4gIGlmIChzaG9ydExlbmd0aCkge1xuICAgIGRzdFtvZmZzZXQrK10gPSByc0J5dGVzO1xuICB9IGVsc2Uge1xuICAgIGRzdFtvZmZzZXQrK10gPSAweDgxO1xuICAgIGRzdFtvZmZzZXQrK10gPSByc0J5dGVzICYgMHhGRjtcbiAgfVxuICBkc3Rbb2Zmc2V0KytdID0gMHgwMjtcbiAgZHN0W29mZnNldCsrXSA9IHJMZW5ndGg7XG4gIGlmIChyUGFkZGluZyA8IDApIHtcbiAgICBkc3Rbb2Zmc2V0KytdID0gMDtcbiAgICBvZmZzZXQgKz0gc2lnbmF0dXJlLmNvcHkoZHN0LCBvZmZzZXQsIDAsIHNpemUpO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldCArPSBzaWduYXR1cmUuY29weShkc3QsIG9mZnNldCwgclBhZGRpbmcsIHNpemUpO1xuICB9XG4gIGRzdFtvZmZzZXQrK10gPSAweDAyO1xuICBkc3Rbb2Zmc2V0KytdID0gc0xlbmd0aDtcbiAgaWYgKHNQYWRkaW5nIDwgMCkge1xuICAgIGRzdFtvZmZzZXQrK10gPSAwO1xuICAgIHNpZ25hdHVyZS5jb3B5KGRzdCwgb2Zmc2V0LCBzaXplKTtcbiAgfSBlbHNlIHtcbiAgICBzaWduYXR1cmUuY29weShkc3QsIG9mZnNldCwgc2l6ZSArIHNQYWRkaW5nKTtcbiAgfVxuICByZXR1cm4gZHN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udmVydFRvRm9yZ2U6IGNvbnZlcnRUb0ZvcmdlLFxuICBjb252ZXJ0VG9KV0s6IGNvbnZlcnRUb0pXSyxcbiAgY29udmVydFRvT2JqOiBjb252ZXJ0VG9PYmosXG4gIGNvbnZlcnRUb0J1ZmZlcjogY29udmVydFRvQnVmZmVyLFxuICBjdXJ2ZVNpemU6IGN1cnZlU2l6ZSxcbiAgZGVyVG9Db25jYXQ6IGRlclRvQ29uY2F0LFxuICBjb25jYXRUb0RlcjogY29uY2F0VG9EZXIsXG4gIGNvbnZlcnRUb1BFTTogY29udmVydFRvUEVNLFxuICBFQ19PSUQ6IEVDX09JRFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/ecdh.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/ecdh.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/ecdh.js - Elliptic Curve Diffie-Hellman algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    ecUtil = __webpack_require__(/*! ./ec-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js\"),\n    hkdf = __webpack_require__(/*! ./hkdf.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hkdf.js\"),\n    concat = __webpack_require__(/*! ./concat.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/concat.js\"),\n    aesKw = __webpack_require__(/*! ./aes-kw.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\");\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\");\nvar omit = __webpack_require__(/*! lodash/omit */ \"(ssr)/./node_modules/lodash/omit.js\");\nvar pick = __webpack_require__(/*! lodash/pick */ \"(ssr)/./node_modules/lodash/pick.js\");\n\nfunction idealHash(curve) {\n  switch (curve) {\n    case \"P-256\":\n      return \"SHA-256\";\n    case \"P-384\":\n      return \"SHA-384\";\n    case \"P-521\":\n      return \"SHA-512\";\n    default:\n      throw new Error(\"unsupported curve: \" + curve);\n  }\n}\n\n// ### Exported\nvar ecdh = module.exports = {};\n\n// ### Derivation algorithms\n// ### \"raw\" ECDH\nfunction ecdhDeriveFn() {\n  var alg = {\n    name: \"ECDH\"\n  };\n\n  var validatePublic = function(pk, form) {\n    var pubKey = pk && ecUtil.convertToForge(pk, true);\n    if (!pubKey || !pubKey.isValid()) {\n      return Promise.reject(new Error(\"invalid EC public key\"));\n    }\n\n    switch (form) {\n      case \"jwk\":\n        pubKey = ecUtil.convertToJWK(pk, true);\n        break;\n      case \"buffer\":\n        pubKey = ecUtil.convertToBuffer(pk, true);\n        break;\n    }\n    return Promise.resolve(pubKey);\n  }\n\n  // ### fallback implementation -- uses ecc + forge\n  var fallback = function(key, props) {\n    props = props || {};\n    var keyLen = props.length || 0;\n    // assume {key} is privateKey\n    // assume {props.public} is publicKey\n    var privKey = ecUtil.convertToForge(key, false);\n\n    var p = validatePublic(props.public, \"forge\");\n    p = p.then(function(pubKey) {\n      // {pubKey} is \"forge\"\n\n      var secret = privKey.computeSecret(pubKey);\n      if (keyLen) {\n        // truncate to requested key length\n        if (secret.length < keyLen) {\n          return Promise.reject(new Error(\"key length too large: \" + keyLen));\n        }\n        secret = secret.slice(0, keyLen);\n      }\n\n      return secret;\n    });\n    return p;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(key, props) {\n    key = key || {};\n    props = props || {};\n\n    var keyLen = props.length || 0,\n        algParams = merge(clone(alg), {\n          namedCurve: key.crv\n        });\n\n    // assume {key} is privateKey\n    if (!keyLen) {\n      // calculate key length from private key size\n      keyLen = key.d.length;\n    }\n    var privKey = ecUtil.convertToJWK(key, false);\n    privKey = helpers.subtleCrypto.importKey(\"jwk\",\n                                             privKey,\n                                             algParams,\n                                             false,\n                                             [ \"deriveBits\" ]);\n\n    // assume {props.public} is publicKey\n    var pubKey = validatePublic(props.public, \"jwk\");\n    pubKey = pubKey.then(function(pubKey) {\n      // {pubKey} is \"jwk\"\n      return helpers.subtleCrypto.importKey(\"jwk\",\n                                            pubKey,\n                                            algParams,\n                                            false,\n                                            []);\n    });\n\n    var p = Promise.all([privKey, pubKey]);\n    p = p.then(function(keypair) {\n      var privKey = keypair[0],\n          pubKey = keypair[1];\n\n      var algParams = merge(clone(alg), {\n        public: pubKey\n      });\n      return helpers.subtleCrypto.deriveBits(algParams, privKey, keyLen * 8);\n    });\n    p = p.then(function(result) {\n      result = Buffer.from(result);\n      return result;\n    });\n    return p;\n  };\n\n  var nodejs = function(key, props) {\n    if (\"function\" !== typeof helpers.nodeCrypto.createECDH) {\n      throw new Error(\"unsupported algorithm: ECDH\");\n    }\n\n    props = props || {};\n    var keyLen = props.length || 0;\n    var curve;\n    switch (key.crv) {\n      case \"P-256\":\n        curve = \"prime256v1\";\n        break;\n      case \"P-384\":\n        curve = \"secp384r1\";\n        break;\n      case \"P-521\":\n        curve = \"secp521r1\";\n        break;\n      default:\n        return Promise.reject(new Error(\"invalid curve: \" + curve));\n    }\n\n    // assume {key} is privateKey\n    // assume {props.public} is publicKey\n    var privKey = ecUtil.convertToBuffer(key, false);\n\n    var p = validatePublic(props.public, \"buffer\");\n    p = p.then(function(pubKey) {\n      // {pubKey} is \"buffer\"\n      var ecdh = helpers.nodeCrypto.createECDH(curve);\n      // dummy call so computeSecret doesn't fail\n      // ecdh.generateKeys();\n      ecdh.setPrivateKey(privKey);\n      var secret = ecdh.computeSecret(pubKey);\n      if (keyLen) {\n        if (secret.length < keyLen) {\n          return Promise.reject(new Error(\"key length too large: \" + keyLen));\n        }\n        secret = secret.slice(0, keyLen);\n      }\n      return secret;\n    });\n    return p;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction ecdhConcatDeriveFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n\n  var fn = function(key, props) {\n    props = props || {};\n\n    var hash;\n    try {\n      hash = props.hash || idealHash(key.crv);\n      if (!hash) {\n        throw new Error(\"invalid hash: \" + hash);\n      }\n      hash.toUpperCase();\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n\n    var params = [\"public\"];\n    // derive shared secret\n    // NOTE: whitelist items from {props} for ECDH\n    var promise = ecdh.ECDH.derive(key, pick(props, params));\n    // expand\n    promise = promise.then(function(shared) {\n      // NOTE: blacklist items from {props} for ECDH\n      return concat[\"CONCAT-\" + hash].derive(shared, omit(props, params));\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\nfunction ecdhHkdfDeriveFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n\n  var fn = function(key, props) {\n    props = props || {};\n\n    var hash;\n    try {\n      hash = props.hash || idealHash(key.crv);\n      if (!hash) {\n        throw new Error(\"invalid hash: \" + hash);\n      }\n      hash.toUpperCase();\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n\n    var params = [\"public\"];\n    // derive shared secret\n    // NOTE: whitelist items from {props} for ECDH\n    var promise = ecdh.ECDH.derive(key, pick(props, params));\n    // extract-and-expand\n    promise = promise.then(function(shared) {\n      // NOTE: blacklist items from {props} for ECDH\n      return hkdf[\"HKDF-\" + hash].derive(shared, omit(props, params));\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\n// ### Wrap/Unwrap algorithms\nfunction doEcdhesCommonDerive(privKey, pubKey, props) {\n  function prependLen(input) {\n    return Buffer.concat([\n      helpers.int32ToBuffer(input.length),\n      input\n    ]);\n  }\n\n  var algId = props.algorithm || \"\",\n      keyLen = CONSTANTS.KEYLENGTH[algId],\n      apu = util.asBuffer(props.apu || \"\", \"base64url\"),\n      apv = util.asBuffer(props.apv || \"\", \"base64url\");\n  var otherInfo = Buffer.concat([\n    prependLen(Buffer.from(algId, \"utf8\")),\n    prependLen(apu),\n    prependLen(apv),\n    helpers.int32ToBuffer(keyLen)\n  ]);\n\n  var params = {\n    public: pubKey,\n    length: keyLen / 8,\n    hash: \"SHA-256\",\n    otherInfo: otherInfo\n  };\n  return ecdh[\"ECDH-CONCAT\"].derive(privKey, params);\n}\n\nfunction ecdhesDirEncryptFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function(key, pdata, props) {\n    props = props || {};\n\n    // {props.epk} is private\n    if (!props.epk || !props.epk.d) {\n      return Promise.reject(new Error(\"missing ephemeral private key\"));\n    }\n    var epk = ecUtil.convertToObj(props.epk, false);\n\n    // {key} is public\n    if (!key || !key.x || !key.y) {\n      return Promise.reject(new Error(\"missing static public key\"));\n    }\n    var spk = ecUtil.convertToObj(key, true);\n\n    // derive ECDH shared\n    var promise = doEcdhesCommonDerive(epk, spk, {\n      algorithm: props.enc,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function(shared) {\n      return {\n        data: shared,\n        once: true,\n        direct: true\n      };\n    });\n    return promise;\n  };\n\n  return fn;\n}\nfunction ecdhesDirDecryptFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function(key, cdata, props) {\n    props = props || {};\n\n    // {props.epk} is public\n    if (!props.epk || !props.epk.x || !props.epk.y) {\n      return Promise.reject(new Error(\"missing ephemeral public key\"));\n    }\n    var epk = ecUtil.convertToObj(props.epk, true);\n\n    // {key} is private\n    if (!key || !key.d) {\n      return Promise.reject(new Error(\"missing static private key\"));\n    }\n    var spk = ecUtil.convertToObj(key, false);\n\n    // derive ECDH shared\n    var promise = doEcdhesCommonDerive(spk, epk, {\n      algorithm: props.enc,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function(shared) {\n      return shared;\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\nfunction ecdhesKwEncryptFn(wrap) {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function(key, pdata, props) {\n    props = props || {};\n\n    // {props.epk} is private\n    if (!props.epk || !props.epk.d) {\n      return Promise.reject(new Error(\"missing ephemeral private key\"));\n    }\n    var epk = ecUtil.convertToObj(props.epk, false);\n\n    // {key} is public\n    if (!key || !key.x || !key.y) {\n      return Promise.reject(new Error(\"missing static public key\"));\n    }\n    var spk = ecUtil.convertToObj(key, true);\n\n    // derive ECDH shared\n    var promise = doEcdhesCommonDerive(epk, spk, {\n      algorithm: props.alg,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function(shared) {\n      // wrap provided key with ECDH shared\n      return wrap(shared, pdata);\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\nfunction ecdhesKwDecryptFn(unwrap) {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function(key, cdata, props) {\n    props = props || {};\n\n    // {props.epk} is public\n    if (!props.epk || !props.epk.x || !props.epk.y) {\n      return Promise.reject(new Error(\"missing ephemeral public key\"));\n    }\n    var epk = ecUtil.convertToObj(props.epk, true);\n\n    // {key} is private\n    if (!key || !key.d) {\n      return Promise.reject(new Error(\"missing static private key\"));\n    }\n    var spk = ecUtil.convertToObj(key, false);\n\n    // derive ECDH shared\n    var promise = doEcdhesCommonDerive(spk, epk, {\n      algorithm: props.alg,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function(shared) {\n      // unwrap provided key with ECDH shared\n      return unwrap(shared, cdata);\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\n// ### Public API\n// * [name].derive\n[\n  \"ECDH\",\n  \"ECDH-HKDF\",\n  \"ECDH-CONCAT\"\n].forEach(function(name) {\n  var kdf = /^ECDH(?:-(\\w+))?$/g.exec(name || \"\")[1];\n  var op = ecdh[name] = ecdh[name] || {};\n  switch (kdf || \"\") {\n    case \"CONCAT\":\n      op.derive = ecdhConcatDeriveFn();\n      break;\n    case \"HKDF\":\n      op.derive = ecdhHkdfDeriveFn();\n      break;\n    case \"\":\n      op.derive = ecdhDeriveFn();\n      break;\n    default:\n      op.derive = null;\n  }\n});\n\n// * [name].encrypt\n// * [name].decrypt\n[\n  \"ECDH-ES\",\n  \"ECDH-ES+A128KW\",\n  \"ECDH-ES+A192KW\",\n  \"ECDH-ES+A256KW\"\n].forEach(function(name) {\n  var kw = /^ECDH-ES(?:\\+(.+))?/g.exec(name || \"\")[1];\n  var op = ecdh[name] = ecdh[name] || {};\n  if (!kw) {\n    op.encrypt = ecdhesDirEncryptFn();\n    op.decrypt = ecdhesDirDecryptFn();\n  } else {\n    kw = aesKw[kw];\n    if (kw) {\n      op.encrypt = ecdhesKwEncryptFn(kw.encrypt);\n      op.decrypt = ecdhesKwDecryptFn(kw.decrypt);\n    } else {\n      op.ecrypt = op.decrypt = null;\n    }\n  }\n});\n//*/\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2VjZGguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQyx1RUFBZTtBQUNuQyxXQUFXLG1CQUFPLENBQUMsaUVBQVM7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLDhFQUFjO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyx3RUFBVztBQUM5QixhQUFhLG1CQUFPLENBQUMsNEVBQWE7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLDRFQUFhO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyw4RUFBYztBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBZ0I7O0FBRXhDLFlBQVksbUJBQU8sQ0FBQywwREFBYztBQUNsQyxXQUFXLG1CQUFPLENBQUMsd0RBQWE7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLHdEQUFhOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLGNBQWM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLFVBQVUsUUFBUTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxjQUFjO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsS0FBSztBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2VjZGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL2VjZGguanMgLSBFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUtSGVsbG1hbiBhbGdvcml0aG1zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi4vdXRpbC9tZXJnZVwiKSxcbiAgICB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIiksXG4gICAgZWNVdGlsID0gcmVxdWlyZShcIi4vZWMtdXRpbC5qc1wiKSxcbiAgICBoa2RmID0gcmVxdWlyZShcIi4vaGtkZi5qc1wiKSxcbiAgICBjb25jYXQgPSByZXF1aXJlKFwiLi9jb25jYXQuanNcIiksXG4gICAgYWVzS3cgPSByZXF1aXJlKFwiLi9hZXMta3cuanNcIiksXG4gICAgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIiksXG4gICAgQ09OU1RBTlRTID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xuXG52YXIgY2xvbmUgPSByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpO1xudmFyIG9taXQgPSByZXF1aXJlKFwibG9kYXNoL29taXRcIik7XG52YXIgcGljayA9IHJlcXVpcmUoXCJsb2Rhc2gvcGlja1wiKTtcblxuZnVuY3Rpb24gaWRlYWxIYXNoKGN1cnZlKSB7XG4gIHN3aXRjaCAoY3VydmUpIHtcbiAgICBjYXNlIFwiUC0yNTZcIjpcbiAgICAgIHJldHVybiBcIlNIQS0yNTZcIjtcbiAgICBjYXNlIFwiUC0zODRcIjpcbiAgICAgIHJldHVybiBcIlNIQS0zODRcIjtcbiAgICBjYXNlIFwiUC01MjFcIjpcbiAgICAgIHJldHVybiBcIlNIQS01MTJcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY3VydmU6IFwiICsgY3VydmUpO1xuICB9XG59XG5cbi8vICMjIyBFeHBvcnRlZFxudmFyIGVjZGggPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyAjIyMgRGVyaXZhdGlvbiBhbGdvcml0aG1zXG4vLyAjIyMgXCJyYXdcIiBFQ0RIXG5mdW5jdGlvbiBlY2RoRGVyaXZlRm4oKSB7XG4gIHZhciBhbGcgPSB7XG4gICAgbmFtZTogXCJFQ0RIXCJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGVQdWJsaWMgPSBmdW5jdGlvbihwaywgZm9ybSkge1xuICAgIHZhciBwdWJLZXkgPSBwayAmJiBlY1V0aWwuY29udmVydFRvRm9yZ2UocGssIHRydWUpO1xuICAgIGlmICghcHViS2V5IHx8ICFwdWJLZXkuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBFQyBwdWJsaWMga2V5XCIpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGZvcm0pIHtcbiAgICAgIGNhc2UgXCJqd2tcIjpcbiAgICAgICAgcHViS2V5ID0gZWNVdGlsLmNvbnZlcnRUb0pXSyhwaywgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJ1ZmZlclwiOlxuICAgICAgICBwdWJLZXkgPSBlY1V0aWwuY29udmVydFRvQnVmZmVyKHBrLCB0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHViS2V5KTtcbiAgfVxuXG4gIC8vICMjIyBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGVjYyArIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIHZhciBrZXlMZW4gPSBwcm9wcy5sZW5ndGggfHwgMDtcbiAgICAvLyBhc3N1bWUge2tleX0gaXMgcHJpdmF0ZUtleVxuICAgIC8vIGFzc3VtZSB7cHJvcHMucHVibGljfSBpcyBwdWJsaWNLZXlcbiAgICB2YXIgcHJpdktleSA9IGVjVXRpbC5jb252ZXJ0VG9Gb3JnZShrZXksIGZhbHNlKTtcblxuICAgIHZhciBwID0gdmFsaWRhdGVQdWJsaWMocHJvcHMucHVibGljLCBcImZvcmdlXCIpO1xuICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24ocHViS2V5KSB7XG4gICAgICAvLyB7cHViS2V5fSBpcyBcImZvcmdlXCJcblxuICAgICAgdmFyIHNlY3JldCA9IHByaXZLZXkuY29tcHV0ZVNlY3JldChwdWJLZXkpO1xuICAgICAgaWYgKGtleUxlbikge1xuICAgICAgICAvLyB0cnVuY2F0ZSB0byByZXF1ZXN0ZWQga2V5IGxlbmd0aFxuICAgICAgICBpZiAoc2VjcmV0Lmxlbmd0aCA8IGtleUxlbikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJrZXkgbGVuZ3RoIHRvbyBsYXJnZTogXCIgKyBrZXlMZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBzZWNyZXQgPSBzZWNyZXQuc2xpY2UoMCwga2V5TGVuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlY3JldDtcbiAgICB9KTtcbiAgICByZXR1cm4gcDtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIGltcGxlbWVudGF0aW9uXG4gIC8vIFRPRE86IGNhY2hlIENyeXB0b0tleSBzb29uZXJcbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcHJvcHMpIHtcbiAgICBrZXkgPSBrZXkgfHwge307XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIHZhciBrZXlMZW4gPSBwcm9wcy5sZW5ndGggfHwgMCxcbiAgICAgICAgYWxnUGFyYW1zID0gbWVyZ2UoY2xvbmUoYWxnKSwge1xuICAgICAgICAgIG5hbWVkQ3VydmU6IGtleS5jcnZcbiAgICAgICAgfSk7XG5cbiAgICAvLyBhc3N1bWUge2tleX0gaXMgcHJpdmF0ZUtleVxuICAgIGlmICgha2V5TGVuKSB7XG4gICAgICAvLyBjYWxjdWxhdGUga2V5IGxlbmd0aCBmcm9tIHByaXZhdGUga2V5IHNpemVcbiAgICAgIGtleUxlbiA9IGtleS5kLmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIHByaXZLZXkgPSBlY1V0aWwuY29udmVydFRvSldLKGtleSwgZmFsc2UpO1xuICAgIHByaXZLZXkgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJqd2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaXZLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGdQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgXCJkZXJpdmVCaXRzXCIgXSk7XG5cbiAgICAvLyBhc3N1bWUge3Byb3BzLnB1YmxpY30gaXMgcHVibGljS2V5XG4gICAgdmFyIHB1YktleSA9IHZhbGlkYXRlUHVibGljKHByb3BzLnB1YmxpYywgXCJqd2tcIik7XG4gICAgcHViS2V5ID0gcHViS2V5LnRoZW4oZnVuY3Rpb24ocHViS2V5KSB7XG4gICAgICAvLyB7cHViS2V5fSBpcyBcImp3a1wiXG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwiandrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxnUGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW10pO1xuICAgIH0pO1xuXG4gICAgdmFyIHAgPSBQcm9taXNlLmFsbChbcHJpdktleSwgcHViS2V5XSk7XG4gICAgcCA9IHAudGhlbihmdW5jdGlvbihrZXlwYWlyKSB7XG4gICAgICB2YXIgcHJpdktleSA9IGtleXBhaXJbMF0sXG4gICAgICAgICAgcHViS2V5ID0ga2V5cGFpclsxXTtcblxuICAgICAgdmFyIGFsZ1BhcmFtcyA9IG1lcmdlKGNsb25lKGFsZyksIHtcbiAgICAgICAgcHVibGljOiBwdWJLZXlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmRlcml2ZUJpdHMoYWxnUGFyYW1zLCBwcml2S2V5LCBrZXlMZW4gKiA4KTtcbiAgICB9KTtcbiAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gQnVmZmVyLmZyb20ocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgdmFyIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgcHJvcHMpIHtcbiAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZUVDREgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogRUNESFwiKTtcbiAgICB9XG5cbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIHZhciBrZXlMZW4gPSBwcm9wcy5sZW5ndGggfHwgMDtcbiAgICB2YXIgY3VydmU7XG4gICAgc3dpdGNoIChrZXkuY3J2KSB7XG4gICAgICBjYXNlIFwiUC0yNTZcIjpcbiAgICAgICAgY3VydmUgPSBcInByaW1lMjU2djFcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUC0zODRcIjpcbiAgICAgICAgY3VydmUgPSBcInNlY3AzODRyMVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJQLTUyMVwiOlxuICAgICAgICBjdXJ2ZSA9IFwic2VjcDUyMXIxXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgY3VydmU6IFwiICsgY3VydmUpKTtcbiAgICB9XG5cbiAgICAvLyBhc3N1bWUge2tleX0gaXMgcHJpdmF0ZUtleVxuICAgIC8vIGFzc3VtZSB7cHJvcHMucHVibGljfSBpcyBwdWJsaWNLZXlcbiAgICB2YXIgcHJpdktleSA9IGVjVXRpbC5jb252ZXJ0VG9CdWZmZXIoa2V5LCBmYWxzZSk7XG5cbiAgICB2YXIgcCA9IHZhbGlkYXRlUHVibGljKHByb3BzLnB1YmxpYywgXCJidWZmZXJcIik7XG4gICAgcCA9IHAudGhlbihmdW5jdGlvbihwdWJLZXkpIHtcbiAgICAgIC8vIHtwdWJLZXl9IGlzIFwiYnVmZmVyXCJcbiAgICAgIHZhciBlY2RoID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZUVDREgoY3VydmUpO1xuICAgICAgLy8gZHVtbXkgY2FsbCBzbyBjb21wdXRlU2VjcmV0IGRvZXNuJ3QgZmFpbFxuICAgICAgLy8gZWNkaC5nZW5lcmF0ZUtleXMoKTtcbiAgICAgIGVjZGguc2V0UHJpdmF0ZUtleShwcml2S2V5KTtcbiAgICAgIHZhciBzZWNyZXQgPSBlY2RoLmNvbXB1dGVTZWNyZXQocHViS2V5KTtcbiAgICAgIGlmIChrZXlMZW4pIHtcbiAgICAgICAgaWYgKHNlY3JldC5sZW5ndGggPCBrZXlMZW4pIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwia2V5IGxlbmd0aCB0b28gbGFyZ2U6IFwiICsga2V5TGVuKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjcmV0ID0gc2VjcmV0LnNsaWNlKDAsIGtleUxlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VjcmV0O1xuICAgIH0pO1xuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZWNkaENvbmNhdERlcml2ZUZuKCkge1xuICAvLyBOT1RFOiBubyBub2RlanMvd2ViY3J5cHRvL2ZhbGxiYWNrIG1vZGVsLCBzaW5jZSB0aGlzIGFsZ29yaXRobSBpc1xuICAvLyAgICAgICBpbXBsZW1lbnRlZCB1c2luZyBvdGhlciBwcmltaXRpdmVzXG5cbiAgdmFyIGZuID0gZnVuY3Rpb24oa2V5LCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICB2YXIgaGFzaDtcbiAgICB0cnkge1xuICAgICAgaGFzaCA9IHByb3BzLmhhc2ggfHwgaWRlYWxIYXNoKGtleS5jcnYpO1xuICAgICAgaWYgKCFoYXNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaGFzaDogXCIgKyBoYXNoKTtcbiAgICAgIH1cbiAgICAgIGhhc2gudG9VcHBlckNhc2UoKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gW1wicHVibGljXCJdO1xuICAgIC8vIGRlcml2ZSBzaGFyZWQgc2VjcmV0XG4gICAgLy8gTk9URTogd2hpdGVsaXN0IGl0ZW1zIGZyb20ge3Byb3BzfSBmb3IgRUNESFxuICAgIHZhciBwcm9taXNlID0gZWNkaC5FQ0RILmRlcml2ZShrZXksIHBpY2socHJvcHMsIHBhcmFtcykpO1xuICAgIC8vIGV4cGFuZFxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oc2hhcmVkKSB7XG4gICAgICAvLyBOT1RFOiBibGFja2xpc3QgaXRlbXMgZnJvbSB7cHJvcHN9IGZvciBFQ0RIXG4gICAgICByZXR1cm4gY29uY2F0W1wiQ09OQ0FULVwiICsgaGFzaF0uZGVyaXZlKHNoYXJlZCwgb21pdChwcm9wcywgcGFyYW1zKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgcmV0dXJuIGZuO1xufVxuXG5mdW5jdGlvbiBlY2RoSGtkZkRlcml2ZUZuKCkge1xuICAvLyBOT1RFOiBubyBub2RlanMvd2ViY3J5cHRvL2ZhbGxiYWNrIG1vZGVsLCBzaW5jZSB0aGlzIGFsZ29yaXRobSBpc1xuICAvLyAgICAgICBpbXBsZW1lbnRlZCB1c2luZyBvdGhlciBwcmltaXRpdmVzXG5cbiAgdmFyIGZuID0gZnVuY3Rpb24oa2V5LCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICB2YXIgaGFzaDtcbiAgICB0cnkge1xuICAgICAgaGFzaCA9IHByb3BzLmhhc2ggfHwgaWRlYWxIYXNoKGtleS5jcnYpO1xuICAgICAgaWYgKCFoYXNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaGFzaDogXCIgKyBoYXNoKTtcbiAgICAgIH1cbiAgICAgIGhhc2gudG9VcHBlckNhc2UoKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gW1wicHVibGljXCJdO1xuICAgIC8vIGRlcml2ZSBzaGFyZWQgc2VjcmV0XG4gICAgLy8gTk9URTogd2hpdGVsaXN0IGl0ZW1zIGZyb20ge3Byb3BzfSBmb3IgRUNESFxuICAgIHZhciBwcm9taXNlID0gZWNkaC5FQ0RILmRlcml2ZShrZXksIHBpY2socHJvcHMsIHBhcmFtcykpO1xuICAgIC8vIGV4dHJhY3QtYW5kLWV4cGFuZFxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oc2hhcmVkKSB7XG4gICAgICAvLyBOT1RFOiBibGFja2xpc3QgaXRlbXMgZnJvbSB7cHJvcHN9IGZvciBFQ0RIXG4gICAgICByZXR1cm4gaGtkZltcIkhLREYtXCIgKyBoYXNoXS5kZXJpdmUoc2hhcmVkLCBvbWl0KHByb3BzLCBwYXJhbXMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICByZXR1cm4gZm47XG59XG5cbi8vICMjIyBXcmFwL1Vud3JhcCBhbGdvcml0aG1zXG5mdW5jdGlvbiBkb0VjZGhlc0NvbW1vbkRlcml2ZShwcml2S2V5LCBwdWJLZXksIHByb3BzKSB7XG4gIGZ1bmN0aW9uIHByZXBlbmRMZW4oaW5wdXQpIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgICBoZWxwZXJzLmludDMyVG9CdWZmZXIoaW5wdXQubGVuZ3RoKSxcbiAgICAgIGlucHV0XG4gICAgXSk7XG4gIH1cblxuICB2YXIgYWxnSWQgPSBwcm9wcy5hbGdvcml0aG0gfHwgXCJcIixcbiAgICAgIGtleUxlbiA9IENPTlNUQU5UUy5LRVlMRU5HVEhbYWxnSWRdLFxuICAgICAgYXB1ID0gdXRpbC5hc0J1ZmZlcihwcm9wcy5hcHUgfHwgXCJcIiwgXCJiYXNlNjR1cmxcIiksXG4gICAgICBhcHYgPSB1dGlsLmFzQnVmZmVyKHByb3BzLmFwdiB8fCBcIlwiLCBcImJhc2U2NHVybFwiKTtcbiAgdmFyIG90aGVySW5mbyA9IEJ1ZmZlci5jb25jYXQoW1xuICAgIHByZXBlbmRMZW4oQnVmZmVyLmZyb20oYWxnSWQsIFwidXRmOFwiKSksXG4gICAgcHJlcGVuZExlbihhcHUpLFxuICAgIHByZXBlbmRMZW4oYXB2KSxcbiAgICBoZWxwZXJzLmludDMyVG9CdWZmZXIoa2V5TGVuKVxuICBdKTtcblxuICB2YXIgcGFyYW1zID0ge1xuICAgIHB1YmxpYzogcHViS2V5LFxuICAgIGxlbmd0aDoga2V5TGVuIC8gOCxcbiAgICBoYXNoOiBcIlNIQS0yNTZcIixcbiAgICBvdGhlckluZm86IG90aGVySW5mb1xuICB9O1xuICByZXR1cm4gZWNkaFtcIkVDREgtQ09OQ0FUXCJdLmRlcml2ZShwcml2S2V5LCBwYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBlY2RoZXNEaXJFbmNyeXB0Rm4oKSB7XG4gIC8vIE5PVEU6IG5vIG5vZGVqcy93ZWJjcnlwdG8vZmFsbGJhY2sgbW9kZWwsIHNpbmNlIHRoaXMgYWxnb3JpdGhtIGlzXG4gIC8vICAgICAgIGltcGxlbWVudGVkIHVzaW5nIG90aGVyIHByaW1pdGl2ZXNcbiAgdmFyIGZuID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgLy8ge3Byb3BzLmVwa30gaXMgcHJpdmF0ZVxuICAgIGlmICghcHJvcHMuZXBrIHx8ICFwcm9wcy5lcGsuZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm1pc3NpbmcgZXBoZW1lcmFsIHByaXZhdGUga2V5XCIpKTtcbiAgICB9XG4gICAgdmFyIGVwayA9IGVjVXRpbC5jb252ZXJ0VG9PYmoocHJvcHMuZXBrLCBmYWxzZSk7XG5cbiAgICAvLyB7a2V5fSBpcyBwdWJsaWNcbiAgICBpZiAoIWtleSB8fCAha2V5LnggfHwgIWtleS55KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibWlzc2luZyBzdGF0aWMgcHVibGljIGtleVwiKSk7XG4gICAgfVxuICAgIHZhciBzcGsgPSBlY1V0aWwuY29udmVydFRvT2JqKGtleSwgdHJ1ZSk7XG5cbiAgICAvLyBkZXJpdmUgRUNESCBzaGFyZWRcbiAgICB2YXIgcHJvbWlzZSA9IGRvRWNkaGVzQ29tbW9uRGVyaXZlKGVwaywgc3BrLCB7XG4gICAgICBhbGdvcml0aG06IHByb3BzLmVuYyxcbiAgICAgIGFwdTogcHJvcHMuYXB1LFxuICAgICAgYXB2OiBwcm9wcy5hcHZcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHNoYXJlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogc2hhcmVkLFxuICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICBkaXJlY3Q6IHRydWVcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgcmV0dXJuIGZuO1xufVxuZnVuY3Rpb24gZWNkaGVzRGlyRGVjcnlwdEZuKCkge1xuICAvLyBOT1RFOiBubyBub2RlanMvd2ViY3J5cHRvL2ZhbGxiYWNrIG1vZGVsLCBzaW5jZSB0aGlzIGFsZ29yaXRobSBpc1xuICAvLyAgICAgICBpbXBsZW1lbnRlZCB1c2luZyBvdGhlciBwcmltaXRpdmVzXG4gIHZhciBmbiA9IGZ1bmN0aW9uKGtleSwgY2RhdGEsIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIC8vIHtwcm9wcy5lcGt9IGlzIHB1YmxpY1xuICAgIGlmICghcHJvcHMuZXBrIHx8ICFwcm9wcy5lcGsueCB8fCAhcHJvcHMuZXBrLnkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJtaXNzaW5nIGVwaGVtZXJhbCBwdWJsaWMga2V5XCIpKTtcbiAgICB9XG4gICAgdmFyIGVwayA9IGVjVXRpbC5jb252ZXJ0VG9PYmoocHJvcHMuZXBrLCB0cnVlKTtcblxuICAgIC8vIHtrZXl9IGlzIHByaXZhdGVcbiAgICBpZiAoIWtleSB8fCAha2V5LmQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJtaXNzaW5nIHN0YXRpYyBwcml2YXRlIGtleVwiKSk7XG4gICAgfVxuICAgIHZhciBzcGsgPSBlY1V0aWwuY29udmVydFRvT2JqKGtleSwgZmFsc2UpO1xuXG4gICAgLy8gZGVyaXZlIEVDREggc2hhcmVkXG4gICAgdmFyIHByb21pc2UgPSBkb0VjZGhlc0NvbW1vbkRlcml2ZShzcGssIGVwaywge1xuICAgICAgYWxnb3JpdGhtOiBwcm9wcy5lbmMsXG4gICAgICBhcHU6IHByb3BzLmFwdSxcbiAgICAgIGFwdjogcHJvcHMuYXB2XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihzaGFyZWQpIHtcbiAgICAgIHJldHVybiBzaGFyZWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgcmV0dXJuIGZuO1xufVxuXG5mdW5jdGlvbiBlY2RoZXNLd0VuY3J5cHRGbih3cmFwKSB7XG4gIC8vIE5PVEU6IG5vIG5vZGVqcy93ZWJjcnlwdG8vZmFsbGJhY2sgbW9kZWwsIHNpbmNlIHRoaXMgYWxnb3JpdGhtIGlzXG4gIC8vICAgICAgIGltcGxlbWVudGVkIHVzaW5nIG90aGVyIHByaW1pdGl2ZXNcbiAgdmFyIGZuID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgLy8ge3Byb3BzLmVwa30gaXMgcHJpdmF0ZVxuICAgIGlmICghcHJvcHMuZXBrIHx8ICFwcm9wcy5lcGsuZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm1pc3NpbmcgZXBoZW1lcmFsIHByaXZhdGUga2V5XCIpKTtcbiAgICB9XG4gICAgdmFyIGVwayA9IGVjVXRpbC5jb252ZXJ0VG9PYmoocHJvcHMuZXBrLCBmYWxzZSk7XG5cbiAgICAvLyB7a2V5fSBpcyBwdWJsaWNcbiAgICBpZiAoIWtleSB8fCAha2V5LnggfHwgIWtleS55KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibWlzc2luZyBzdGF0aWMgcHVibGljIGtleVwiKSk7XG4gICAgfVxuICAgIHZhciBzcGsgPSBlY1V0aWwuY29udmVydFRvT2JqKGtleSwgdHJ1ZSk7XG5cbiAgICAvLyBkZXJpdmUgRUNESCBzaGFyZWRcbiAgICB2YXIgcHJvbWlzZSA9IGRvRWNkaGVzQ29tbW9uRGVyaXZlKGVwaywgc3BrLCB7XG4gICAgICBhbGdvcml0aG06IHByb3BzLmFsZyxcbiAgICAgIGFwdTogcHJvcHMuYXB1LFxuICAgICAgYXB2OiBwcm9wcy5hcHZcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHNoYXJlZCkge1xuICAgICAgLy8gd3JhcCBwcm92aWRlZCBrZXkgd2l0aCBFQ0RIIHNoYXJlZFxuICAgICAgcmV0dXJuIHdyYXAoc2hhcmVkLCBwZGF0YSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgcmV0dXJuIGZuO1xufVxuXG5mdW5jdGlvbiBlY2RoZXNLd0RlY3J5cHRGbih1bndyYXApIHtcbiAgLy8gTk9URTogbm8gbm9kZWpzL3dlYmNyeXB0by9mYWxsYmFjayBtb2RlbCwgc2luY2UgdGhpcyBhbGdvcml0aG0gaXNcbiAgLy8gICAgICAgaW1wbGVtZW50ZWQgdXNpbmcgb3RoZXIgcHJpbWl0aXZlc1xuICB2YXIgZm4gPSBmdW5jdGlvbihrZXksIGNkYXRhLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICAvLyB7cHJvcHMuZXBrfSBpcyBwdWJsaWNcbiAgICBpZiAoIXByb3BzLmVwayB8fCAhcHJvcHMuZXBrLnggfHwgIXByb3BzLmVway55KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibWlzc2luZyBlcGhlbWVyYWwgcHVibGljIGtleVwiKSk7XG4gICAgfVxuICAgIHZhciBlcGsgPSBlY1V0aWwuY29udmVydFRvT2JqKHByb3BzLmVwaywgdHJ1ZSk7XG5cbiAgICAvLyB7a2V5fSBpcyBwcml2YXRlXG4gICAgaWYgKCFrZXkgfHwgIWtleS5kKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibWlzc2luZyBzdGF0aWMgcHJpdmF0ZSBrZXlcIikpO1xuICAgIH1cbiAgICB2YXIgc3BrID0gZWNVdGlsLmNvbnZlcnRUb09iaihrZXksIGZhbHNlKTtcblxuICAgIC8vIGRlcml2ZSBFQ0RIIHNoYXJlZFxuICAgIHZhciBwcm9taXNlID0gZG9FY2RoZXNDb21tb25EZXJpdmUoc3BrLCBlcGssIHtcbiAgICAgIGFsZ29yaXRobTogcHJvcHMuYWxnLFxuICAgICAgYXB1OiBwcm9wcy5hcHUsXG4gICAgICBhcHY6IHByb3BzLmFwdlxuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oc2hhcmVkKSB7XG4gICAgICAvLyB1bndyYXAgcHJvdmlkZWQga2V5IHdpdGggRUNESCBzaGFyZWRcbiAgICAgIHJldHVybiB1bndyYXAoc2hhcmVkLCBjZGF0YSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vLyAjIyMgUHVibGljIEFQSVxuLy8gKiBbbmFtZV0uZGVyaXZlXG5bXG4gIFwiRUNESFwiLFxuICBcIkVDREgtSEtERlwiLFxuICBcIkVDREgtQ09OQ0FUXCJcbl0uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBrZGYgPSAvXkVDREgoPzotKFxcdyspKT8kL2cuZXhlYyhuYW1lIHx8IFwiXCIpWzFdO1xuICB2YXIgb3AgPSBlY2RoW25hbWVdID0gZWNkaFtuYW1lXSB8fCB7fTtcbiAgc3dpdGNoIChrZGYgfHwgXCJcIikge1xuICAgIGNhc2UgXCJDT05DQVRcIjpcbiAgICAgIG9wLmRlcml2ZSA9IGVjZGhDb25jYXREZXJpdmVGbigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkhLREZcIjpcbiAgICAgIG9wLmRlcml2ZSA9IGVjZGhIa2RmRGVyaXZlRm4oKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJcIjpcbiAgICAgIG9wLmRlcml2ZSA9IGVjZGhEZXJpdmVGbigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG9wLmRlcml2ZSA9IG51bGw7XG4gIH1cbn0pO1xuXG4vLyAqIFtuYW1lXS5lbmNyeXB0XG4vLyAqIFtuYW1lXS5kZWNyeXB0XG5bXG4gIFwiRUNESC1FU1wiLFxuICBcIkVDREgtRVMrQTEyOEtXXCIsXG4gIFwiRUNESC1FUytBMTkyS1dcIixcbiAgXCJFQ0RILUVTK0EyNTZLV1wiXG5dLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICB2YXIga3cgPSAvXkVDREgtRVMoPzpcXCsoLispKT8vZy5leGVjKG5hbWUgfHwgXCJcIilbMV07XG4gIHZhciBvcCA9IGVjZGhbbmFtZV0gPSBlY2RoW25hbWVdIHx8IHt9O1xuICBpZiAoIWt3KSB7XG4gICAgb3AuZW5jcnlwdCA9IGVjZGhlc0RpckVuY3J5cHRGbigpO1xuICAgIG9wLmRlY3J5cHQgPSBlY2RoZXNEaXJEZWNyeXB0Rm4oKTtcbiAgfSBlbHNlIHtcbiAgICBrdyA9IGFlc0t3W2t3XTtcbiAgICBpZiAoa3cpIHtcbiAgICAgIG9wLmVuY3J5cHQgPSBlY2RoZXNLd0VuY3J5cHRGbihrdy5lbmNyeXB0KTtcbiAgICAgIG9wLmRlY3J5cHQgPSBlY2RoZXNLd0RlY3J5cHRGbihrdy5kZWNyeXB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3AuZWNyeXB0ID0gb3AuZGVjcnlwdCA9IG51bGw7XG4gICAgfVxuICB9XG59KTtcbi8vKi9cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/ecdh.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/ecdsa.js":
/*!********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/ecdsa.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/ecdsa.js - Elliptic Curve Digitial Signature Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar ecUtil = __webpack_require__(/*! ./ec-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    sha = __webpack_require__(/*! ./sha.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\");\n\nfunction idealCurve(hash) {\n  switch (hash) {\n    case \"SHA-256\":\n      return \"P-256\";\n    case \"SHA-384\":\n      return \"P-384\";\n    case \"SHA-512\":\n      return \"P-521\";\n    default:\n      throw new Error(\"unsupported hash: \" + hash);\n  }\n}\n\nfunction ecdsaSignFN(hash) {\n  var curve = idealCurve(hash);\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function(key, pdata /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToForge(key, false);\n\n    var promise;\n    // generate hash\n    promise = sha[hash].digest(pdata);\n    // sign hash\n    promise = promise.then(function(result) {\n      result = pk.sign(result);\n      result = Buffer.concat([result.r, result.s]);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  };\n\n  // ### WebCrypto API implementation\n  var webcrypto = function(key, pdata /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToJWK(key, false);\n\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\",\n                                             pk,\n                                             alg,\n                                             true,\n                                             [ \"sign\" ]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      result = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = hash.toLowerCase().replace(\"-\", \"\");\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(nodeHash) > -1) {\n    nodejs = function(key, pdata) {\n      if (curve !== key.crv) {\n        return Promise.reject(new Error(\"invalid curve\"));\n      }\n\n      var promise;\n      promise = Promise.resolve(helpers.nodeCrypto.createSign(nodeHash));\n      promise = promise.then(function (sign) {\n        sign.update(pdata);\n        return sign;\n      });\n\n      var size;\n\n      switch (nodeHash.slice(-3)) {\n        case \"384\":\n          size = 48;\n          break;\n        case \"512\":\n          size = 66;\n          break;\n        default:\n          size = 32;\n      }\n\n      promise = promise.then(function (sign) {\n        return ecUtil.derToConcat(sign.sign(ecUtil.convertToPEM(key, true)), size);\n      });\n\n      promise = promise.then(function (result) {\n        return {\n          data: pdata,\n          mac: result\n        };\n      });\n\n      return promise;\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction ecdsaVerifyFN(hash) {\n  var curve = idealCurve(hash);\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function(key, pdata, mac /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToForge(key, true);\n\n    var promise;\n    // generate hash\n    promise = sha[hash].digest(pdata);\n    // verify hash\n    promise = promise.then(function(result) {\n      var len = mac.length / 2;\n      var rs = {\n        r: mac.slice(0, len),\n        s: mac.slice(len)\n      };\n      if (!pk.verify(result, rs)) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  // ### WebCrypto API implementation\n  var webcrypto = function(key, pdata, mac /* , props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToJWK(key, true);\n\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\",\n                                             pk,\n                                             alg,\n                                             true,\n                                             [\"verify\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function(result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = hash.toLowerCase().replace(\"-\", \"\");\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(nodeHash) > -1) {\n    nodejs = function(key, pdata, mac /* , props */) {\n      if (curve !== key.crv) {\n        return Promise.reject(new Error(\"invalid curve\"));\n      }\n\n      var size;\n      switch (nodeHash.slice(-3)) {\n        case \"384\":\n          size = 48;\n          break;\n        case \"512\":\n          size = 66;\n          break;\n        default:\n          size = 32;\n      }\n\n      var promise;\n      promise = Promise.resolve(helpers.nodeCrypto.createVerify(nodeHash));\n      promise = promise.then(function (verify) {\n        verify.update(pdata);\n        verify.end();\n        return verify.verify(ecUtil.convertToPEM(key, false), ecUtil.concatToDer(mac, size));\n      });\n      promise = promise.then(function (result) {\n        if (!result) {\n          throw new Error(\"verification failed\");\n        }\n        return {\n          data: pdata,\n          mac: mac,\n          valid: true\n        };\n      });\n\n      return promise;\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\nvar ecdsa = {};\n\n// * [name].sign\n// * [name].verify\n[\n  \"ES256\",\n  \"ES384\",\n  \"ES512\"\n].forEach(function(name) {\n  var hash = name.replace(/ES(\\d+)/g, function(m, size) {\n    return \"SHA-\" + size;\n  });\n  ecdsa[name] = {\n    sign: ecdsaSignFN(hash),\n    verify: ecdsaVerifyFN(hash)\n  };\n});\n\nmodule.exports = ecdsa;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2VjZHNhLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsOEVBQWM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLDhFQUFjO0FBQ3BDLFVBQVUsbUJBQU8sQ0FBQyxzRUFBVTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9lY2RzYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvZWNkc2EuanMgLSBFbGxpcHRpYyBDdXJ2ZSBEaWdpdGlhbCBTaWduYXR1cmUgQWxnb3JpdGhtc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGVjVXRpbCA9IHJlcXVpcmUoXCIuL2VjLXV0aWwuanNcIiksXG4gICAgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIiksXG4gICAgc2hhID0gcmVxdWlyZShcIi4vc2hhLmpzXCIpO1xuXG5mdW5jdGlvbiBpZGVhbEN1cnZlKGhhc2gpIHtcbiAgc3dpdGNoIChoYXNoKSB7XG4gICAgY2FzZSBcIlNIQS0yNTZcIjpcbiAgICAgIHJldHVybiBcIlAtMjU2XCI7XG4gICAgY2FzZSBcIlNIQS0zODRcIjpcbiAgICAgIHJldHVybiBcIlAtMzg0XCI7XG4gICAgY2FzZSBcIlNIQS01MTJcIjpcbiAgICAgIHJldHVybiBcIlAtNTIxXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGhhc2g6IFwiICsgaGFzaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZWNkc2FTaWduRk4oaGFzaCkge1xuICB2YXIgY3VydmUgPSBpZGVhbEN1cnZlKGhhc2gpO1xuXG4gIC8vICMjIyBGYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgcGRhdGEgLyosIHByb3BzICovKSB7XG4gICAgaWYgKGN1cnZlICE9PSBrZXkuY3J2KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBjdXJ2ZVwiKSk7XG4gICAgfVxuICAgIHZhciBwayA9IGVjVXRpbC5jb252ZXJ0VG9Gb3JnZShrZXksIGZhbHNlKTtcblxuICAgIHZhciBwcm9taXNlO1xuICAgIC8vIGdlbmVyYXRlIGhhc2hcbiAgICBwcm9taXNlID0gc2hhW2hhc2hdLmRpZ2VzdChwZGF0YSk7XG4gICAgLy8gc2lnbiBoYXNoXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHJlc3VsdCA9IHBrLnNpZ24ocmVzdWx0KTtcbiAgICAgIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoW3Jlc3VsdC5yLCByZXN1bHQuc10pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogcmVzdWx0XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG8gQVBJIGltcGxlbWVudGF0aW9uXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHBkYXRhIC8qLCBwcm9wcyAqLykge1xuICAgIGlmIChjdXJ2ZSAhPT0ga2V5LmNydikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgY3VydmVcIikpO1xuICAgIH1cbiAgICB2YXIgcGsgPSBlY1V0aWwuY29udmVydFRvSldLKGtleSwgZmFsc2UpO1xuXG4gICAgdmFyIHByb21pc2U7XG4gICAgdmFyIGFsZyA9IHtcbiAgICAgIG5hbWU6IFwiRUNEU0FcIixcbiAgICAgIG5hbWVkQ3VydmU6IHBrLmNydixcbiAgICAgIGhhc2g6IHtcbiAgICAgICAgbmFtZTogaGFzaFxuICAgICAgfVxuICAgIH07XG4gICAgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcImp3a1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBcInNpZ25cIiBdKTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLnNpZ24oYWxnLCBrZXksIHBkYXRhKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gQnVmZmVyLmZyb20ocmVzdWx0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IHJlc3VsdFxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICB2YXIgbm9kZWpzO1xuICB2YXIgbm9kZUhhc2ggPSBoYXNoLnRvTG93ZXJDYXNlKCkucmVwbGFjZShcIi1cIiwgXCJcIik7XG4gIGlmIChoZWxwZXJzLm5vZGVDcnlwdG8gJiYgaGVscGVycy5ub2RlQ3J5cHRvLmdldEhhc2hlcygpLmluZGV4T2Yobm9kZUhhc2gpID4gLTEpIHtcbiAgICBub2RlanMgPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAgICBpZiAoY3VydmUgIT09IGtleS5jcnYpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgY3VydmVcIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZTtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZVNpZ24obm9kZUhhc2gpKTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHNpZ24pIHtcbiAgICAgICAgc2lnbi51cGRhdGUocGRhdGEpO1xuICAgICAgICByZXR1cm4gc2lnbjtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc2l6ZTtcblxuICAgICAgc3dpdGNoIChub2RlSGFzaC5zbGljZSgtMykpIHtcbiAgICAgICAgY2FzZSBcIjM4NFwiOlxuICAgICAgICAgIHNpemUgPSA0ODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjUxMlwiOlxuICAgICAgICAgIHNpemUgPSA2NjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzaXplID0gMzI7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHNpZ24pIHtcbiAgICAgICAgcmV0dXJuIGVjVXRpbC5kZXJUb0NvbmNhdChzaWduLnNpZ24oZWNVdGlsLmNvbnZlcnRUb1BFTShrZXksIHRydWUpKSwgc2l6ZSk7XG4gICAgICB9KTtcblxuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgICAgbWFjOiByZXN1bHRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBlY2RzYVZlcmlmeUZOKGhhc2gpIHtcbiAgdmFyIGN1cnZlID0gaWRlYWxDdXJ2ZShoYXNoKTtcblxuICAvLyAjIyMgRmFsbGJhY2sgaW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIHBkYXRhLCBtYWMgLyosIHByb3BzICovKSB7XG4gICAgaWYgKGN1cnZlICE9PSBrZXkuY3J2KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBjdXJ2ZVwiKSk7XG4gICAgfVxuICAgIHZhciBwayA9IGVjVXRpbC5jb252ZXJ0VG9Gb3JnZShrZXksIHRydWUpO1xuXG4gICAgdmFyIHByb21pc2U7XG4gICAgLy8gZ2VuZXJhdGUgaGFzaFxuICAgIHByb21pc2UgPSBzaGFbaGFzaF0uZGlnZXN0KHBkYXRhKTtcbiAgICAvLyB2ZXJpZnkgaGFzaFxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICB2YXIgbGVuID0gbWFjLmxlbmd0aCAvIDI7XG4gICAgICB2YXIgcnMgPSB7XG4gICAgICAgIHI6IG1hYy5zbGljZSgwLCBsZW4pLFxuICAgICAgICBzOiBtYWMuc2xpY2UobGVuKVxuICAgICAgfTtcbiAgICAgIGlmICghcGsudmVyaWZ5KHJlc3VsdCwgcnMpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ2ZXJpZmljYXRpb24gZmFpbGVkXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IG1hYyxcbiAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0byBBUEkgaW1wbGVtZW50YXRpb25cbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIG1hYyAvKiAsIHByb3BzICovKSB7XG4gICAgaWYgKGN1cnZlICE9PSBrZXkuY3J2KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBjdXJ2ZVwiKSk7XG4gICAgfVxuICAgIHZhciBwayA9IGVjVXRpbC5jb252ZXJ0VG9KV0soa2V5LCB0cnVlKTtcblxuICAgIHZhciBwcm9taXNlO1xuICAgIHZhciBhbGcgPSB7XG4gICAgICBuYW1lOiBcIkVDRFNBXCIsXG4gICAgICBuYW1lZEN1cnZlOiBway5jcnYsXG4gICAgICBoYXNoOiB7XG4gICAgICAgIG5hbWU6IGhhc2hcbiAgICAgIH1cbiAgICB9O1xuICAgIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJqd2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInZlcmlmeVwiXSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by52ZXJpZnkoYWxnLCBrZXksIG1hYywgcGRhdGEpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidmVyaWZpY2F0aW9uIGZhaWxlZFwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBtYWMsXG4gICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHZhciBub2RlanM7XG4gIHZhciBub2RlSGFzaCA9IGhhc2gudG9Mb3dlckNhc2UoKS5yZXBsYWNlKFwiLVwiLCBcIlwiKTtcbiAgaWYgKGhlbHBlcnMubm9kZUNyeXB0byAmJiBoZWxwZXJzLm5vZGVDcnlwdG8uZ2V0SGFzaGVzKCkuaW5kZXhPZihub2RlSGFzaCkgPiAtMSkge1xuICAgIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIG1hYyAvKiAsIHByb3BzICovKSB7XG4gICAgICBpZiAoY3VydmUgIT09IGtleS5jcnYpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgY3VydmVcIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2l6ZTtcbiAgICAgIHN3aXRjaCAobm9kZUhhc2guc2xpY2UoLTMpKSB7XG4gICAgICAgIGNhc2UgXCIzODRcIjpcbiAgICAgICAgICBzaXplID0gNDg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI1MTJcIjpcbiAgICAgICAgICBzaXplID0gNjY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc2l6ZSA9IDMyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZTtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZVZlcmlmeShub2RlSGFzaCkpO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAodmVyaWZ5KSB7XG4gICAgICAgIHZlcmlmeS51cGRhdGUocGRhdGEpO1xuICAgICAgICB2ZXJpZnkuZW5kKCk7XG4gICAgICAgIHJldHVybiB2ZXJpZnkudmVyaWZ5KGVjVXRpbC5jb252ZXJ0VG9QRU0oa2V5LCBmYWxzZSksIGVjVXRpbC5jb25jYXRUb0RlcihtYWMsIHNpemUpKTtcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmVyaWZpY2F0aW9uIGZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICAgIG1hYzogbWFjLFxuICAgICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuLy8gIyMjIFB1YmxpYyBBUElcbnZhciBlY2RzYSA9IHt9O1xuXG4vLyAqIFtuYW1lXS5zaWduXG4vLyAqIFtuYW1lXS52ZXJpZnlcbltcbiAgXCJFUzI1NlwiLFxuICBcIkVTMzg0XCIsXG4gIFwiRVM1MTJcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGhhc2ggPSBuYW1lLnJlcGxhY2UoL0VTKFxcZCspL2csIGZ1bmN0aW9uKG0sIHNpemUpIHtcbiAgICByZXR1cm4gXCJTSEEtXCIgKyBzaXplO1xuICB9KTtcbiAgZWNkc2FbbmFtZV0gPSB7XG4gICAgc2lnbjogZWNkc2FTaWduRk4oaGFzaCksXG4gICAgdmVyaWZ5OiBlY2RzYVZlcmlmeUZOKGhhc2gpXG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBlY2RzYTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/ecdsa.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/helpers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * algorithms/helpers.js - Internal functions and fields used in Cryptographic\n * Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nif (typeof Promise === \"undefined\") {\n  (__webpack_require__(/*! es6-promise */ \"(ssr)/./node_modules/es6-promise/dist/es6-promise.js\").polyfill)();\n}\n\n// ###\nexports.int32ToBuffer = function(v, b) {\n  b = b || Buffer.alloc(4);\n  b[0] = (v >>> 24) & 0xff;\n  b[1] = (v >>> 16) & 0xff;\n  b[2] = (v >>> 8) & 0xff;\n  b[3] = v & 0xff;\n  return b;\n};\n\nvar MAX_INT32 = Math.pow(2, 32);\nexports.int64ToBuffer = function(v, b) {\n  b = b || Buffer.alloc(8);\n  var hi = Math.floor(v / MAX_INT32),\n      lo = v % MAX_INT32;\n  hi = exports.int32ToBuffer(hi);\n  lo = exports.int32ToBuffer(lo);\n  b = Buffer.concat([hi, lo]);\n  return b;\n};\n\n// ### crypto and DOMException in browsers ###\n/* global crypto:false, DOMException:false */\n\nfunction getCryptoSubtle() {\n  if (\"undefined\" !== typeof crypto) {\n    if (\"undefined\" !== typeof crypto.subtle) {\n      return crypto.subtle;\n    }\n  }\n\n  return undefined;\n}\nfunction getCryptoNodeJS() {\n  var crypto;\n  try {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n  } catch (err) {\n    return undefined;\n  }\n\n  if (!Object.keys(crypto).length) {\n    // treat empty the same as missing\n    return undefined;\n  }\n\n  return crypto;\n}\n\nvar supported = {};\nObject.defineProperty(exports, \"subtleCrypto\", ({\n  get: function() {\n    var result;\n\n    if (\"subtleCrypto\" in supported) {\n      result = supported.subtleCrypto;\n    } else {\n      result = supported.subtleCrypto = getCryptoSubtle();\n    }\n\n    return result;\n  },\n  enumerable: true\n}));\nObject.defineProperty(exports, \"nodeCrypto\", ({\n  get: function() {\n    var result;\n\n    if (\"nodeCrypto\" in supported) {\n      result = supported.nodeCrypto;\n    } else {\n      result = supported.nodeCrypto = getCryptoNodeJS();\n    }\n\n    return result;\n  },\n  enumerable: true\n}));\n\nexports.setupFallback = function(nodejs, webcrypto, fallback) {\n  var impl;\n\n  if (nodejs && exports.nodeCrypto) {\n    impl = function main() {\n      var args = arguments,\n          promise;\n\n      function check(err) {\n        if (0 === err.message.indexOf(\"unsupported algorithm:\")) {\n          impl = fallback;\n          return impl.apply(null, args);\n        }\n\n        return Promise.reject(err);\n      }\n\n      try {\n        promise = Promise.resolve(nodejs.apply(null, args));\n      } catch(err) {\n        promise = check(err);\n      }\n\n      return promise;\n    };\n  } else if (webcrypto && exports.subtleCrypto) {\n    impl = function main() {\n      var args = arguments,\n         promise;\n\n      function check(err) {\n        if (err.code === DOMException.NOT_SUPPORTED_ERR ||\n            // Firefox rejects some operations erroneously complaining about inputs\n            err.message === \"Only ArrayBuffer and ArrayBufferView objects can be passed as CryptoOperationData\" ||\n            // MS Edge rejects with not an Error\n            !(err instanceof Error)) {\n          // not actually supported -- always use fallback\n          impl = fallback;\n          return impl.apply(null, args);\n        }\n\n       return Promise.reject(err);\n      }\n\n      try {\n        promise = webcrypto.apply(null, args);\n        promise = promise.catch(check);\n      } catch(err) {\n        promise = check(err);\n      }\n\n      return promise;\n    };\n  } else {\n    impl = fallback;\n  }\n\n  return impl;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQSxFQUFFLHlHQUErQjtBQUNqQzs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdEQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMsRUFBQztBQUNGLDhDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMsRUFBQzs7QUFFRixxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvaGVscGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvaGVscGVycy5qcyAtIEludGVybmFsIGZ1bmN0aW9ucyBhbmQgZmllbGRzIHVzZWQgaW4gQ3J5cHRvZ3JhcGhpY1xuICogQWxnb3JpdGhtc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZiBQcm9taXNlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIHJlcXVpcmUoXCJlczYtcHJvbWlzZVwiKS5wb2x5ZmlsbCgpO1xufVxuXG4vLyAjIyNcbmV4cG9ydHMuaW50MzJUb0J1ZmZlciA9IGZ1bmN0aW9uKHYsIGIpIHtcbiAgYiA9IGIgfHwgQnVmZmVyLmFsbG9jKDQpO1xuICBiWzBdID0gKHYgPj4+IDI0KSAmIDB4ZmY7XG4gIGJbMV0gPSAodiA+Pj4gMTYpICYgMHhmZjtcbiAgYlsyXSA9ICh2ID4+PiA4KSAmIDB4ZmY7XG4gIGJbM10gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGI7XG59O1xuXG52YXIgTUFYX0lOVDMyID0gTWF0aC5wb3coMiwgMzIpO1xuZXhwb3J0cy5pbnQ2NFRvQnVmZmVyID0gZnVuY3Rpb24odiwgYikge1xuICBiID0gYiB8fCBCdWZmZXIuYWxsb2MoOCk7XG4gIHZhciBoaSA9IE1hdGguZmxvb3IodiAvIE1BWF9JTlQzMiksXG4gICAgICBsbyA9IHYgJSBNQVhfSU5UMzI7XG4gIGhpID0gZXhwb3J0cy5pbnQzMlRvQnVmZmVyKGhpKTtcbiAgbG8gPSBleHBvcnRzLmludDMyVG9CdWZmZXIobG8pO1xuICBiID0gQnVmZmVyLmNvbmNhdChbaGksIGxvXSk7XG4gIHJldHVybiBiO1xufTtcblxuLy8gIyMjIGNyeXB0byBhbmQgRE9NRXhjZXB0aW9uIGluIGJyb3dzZXJzICMjI1xuLyogZ2xvYmFsIGNyeXB0bzpmYWxzZSwgRE9NRXhjZXB0aW9uOmZhbHNlICovXG5cbmZ1bmN0aW9uIGdldENyeXB0b1N1YnRsZSgpIHtcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBjcnlwdG8pIHtcbiAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGNyeXB0by5zdWJ0bGUpIHtcbiAgICAgIHJldHVybiBjcnlwdG8uc3VidGxlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRDcnlwdG9Ob2RlSlMoKSB7XG4gIHZhciBjcnlwdG87XG4gIHRyeSB7XG4gICAgY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICghT2JqZWN0LmtleXMoY3J5cHRvKS5sZW5ndGgpIHtcbiAgICAvLyB0cmVhdCBlbXB0eSB0aGUgc2FtZSBhcyBtaXNzaW5nXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBjcnlwdG87XG59XG5cbnZhciBzdXBwb3J0ZWQgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN1YnRsZUNyeXB0b1wiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChcInN1YnRsZUNyeXB0b1wiIGluIHN1cHBvcnRlZCkge1xuICAgICAgcmVzdWx0ID0gc3VwcG9ydGVkLnN1YnRsZUNyeXB0bztcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gc3VwcG9ydGVkLnN1YnRsZUNyeXB0byA9IGdldENyeXB0b1N1YnRsZSgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm9kZUNyeXB0b1wiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChcIm5vZGVDcnlwdG9cIiBpbiBzdXBwb3J0ZWQpIHtcbiAgICAgIHJlc3VsdCA9IHN1cHBvcnRlZC5ub2RlQ3J5cHRvO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBzdXBwb3J0ZWQubm9kZUNyeXB0byA9IGdldENyeXB0b05vZGVKUygpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pO1xuXG5leHBvcnRzLnNldHVwRmFsbGJhY2sgPSBmdW5jdGlvbihub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spIHtcbiAgdmFyIGltcGw7XG5cbiAgaWYgKG5vZGVqcyAmJiBleHBvcnRzLm5vZGVDcnlwdG8pIHtcbiAgICBpbXBsID0gZnVuY3Rpb24gbWFpbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHByb21pc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrKGVycikge1xuICAgICAgICBpZiAoMCA9PT0gZXJyLm1lc3NhZ2UuaW5kZXhPZihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTpcIikpIHtcbiAgICAgICAgICBpbXBsID0gZmFsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIGltcGwuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShub2RlanMuYXBwbHkobnVsbCwgYXJncykpO1xuICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgcHJvbWlzZSA9IGNoZWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gIH0gZWxzZSBpZiAod2ViY3J5cHRvICYmIGV4cG9ydHMuc3VidGxlQ3J5cHRvKSB7XG4gICAgaW1wbCA9IGZ1bmN0aW9uIG1haW4oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgIHByb21pc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IERPTUV4Y2VwdGlvbi5OT1RfU1VQUE9SVEVEX0VSUiB8fFxuICAgICAgICAgICAgLy8gRmlyZWZveCByZWplY3RzIHNvbWUgb3BlcmF0aW9ucyBlcnJvbmVvdXNseSBjb21wbGFpbmluZyBhYm91dCBpbnB1dHNcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSBcIk9ubHkgQXJyYXlCdWZmZXIgYW5kIEFycmF5QnVmZmVyVmlldyBvYmplY3RzIGNhbiBiZSBwYXNzZWQgYXMgQ3J5cHRvT3BlcmF0aW9uRGF0YVwiIHx8XG4gICAgICAgICAgICAvLyBNUyBFZGdlIHJlamVjdHMgd2l0aCBub3QgYW4gRXJyb3JcbiAgICAgICAgICAgICEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgLy8gbm90IGFjdHVhbGx5IHN1cHBvcnRlZCAtLSBhbHdheXMgdXNlIGZhbGxiYWNrXG4gICAgICAgICAgaW1wbCA9IGZhbGxiYWNrO1xuICAgICAgICAgIHJldHVybiBpbXBsLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvbWlzZSA9IHdlYmNyeXB0by5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UuY2F0Y2goY2hlY2spO1xuICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgcHJvbWlzZSA9IGNoZWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW1wbCA9IGZhbGxiYWNrO1xuICB9XG5cbiAgcmV0dXJuIGltcGw7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/hkdf.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/hkdf.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/hkdf.js - HMAC-based Extract-and-Expand Key Derivation\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    hmac = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js\");\n\nfunction hkdfDeriveFn(name) {\n  var hash = name.replace(\"HKDF-\", \"\"),\n      op = name.replace(\"HKDF-SHA-\", \"HS\");\n\n  // NOTE: no nodejs/webcrypto/fallback model, since this HKDF is\n  //       implemented using the HMAC algorithms\n\n  var fn = function(key, props) {\n    var hashLen = CONSTANTS.HASHLENGTH[hash] / 8;\n\n    if (\"string\" === typeof op) {\n      op = hmac[op].sign;\n    }\n\n    // prepare options\n    props = props || {};\n    var salt = props.salt;\n    if (!salt || 0 === salt.length) {\n      salt = Buffer.alloc(hashLen);\n    }\n    var info = props.info || Buffer.alloc(0);\n    var keyLen = props.length || hashLen;\n\n    var promise;\n\n    // Setup Expansion\n    var N = Math.ceil(keyLen / hashLen),\n        okm = [],\n        idx = 0;\n    function expand(key, T) {\n      if (N === idx++) {\n        return Buffer.concat(okm).slice(0, keyLen);\n      }\n\n      if (!T) {\n        T = Buffer.alloc(0);\n      }\n      T = Buffer.concat([T, info, Buffer.from([idx])]);\n      T = op(key, T);\n      T = T.then(function(result) {\n        T = result.mac;\n        okm.push(T);\n\n        return expand(key, T);\n      });\n      return T;\n    }\n\n    // Step 1: Extract\n    promise = op(salt, key, { length: salt.length * 8 });\n    promise = promise.then(function(result) {\n      // Step 2: Expand\n      return expand(result.mac);\n    });\n\n    return promise;\n  };\n\n  return fn;\n}\n\n// Public API\n// * [name].derive\nvar hkdf = {};\n[\n  \"HKDF-SHA-1\",\n  \"HKDF-SHA-256\",\n  \"HKDF-SHA-384\",\n  \"HKDF-SHA-512\"\n].forEach(function(name) {\n  hkdf[name] = {\n    derive: hkdfDeriveFn(name)\n  };\n});\n\nmodule.exports = hkdf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2hrZGYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLGtGQUFnQjtBQUN4QyxXQUFXLG1CQUFPLENBQUMsd0VBQVc7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9oa2RmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9oa2RmLmpzIC0gSE1BQy1iYXNlZCBFeHRyYWN0LWFuZC1FeHBhbmQgS2V5IERlcml2YXRpb25cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDT05TVEFOVFMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIiksXG4gICAgaG1hYyA9IHJlcXVpcmUoXCIuL2htYWMuanNcIik7XG5cbmZ1bmN0aW9uIGhrZGZEZXJpdmVGbihuYW1lKSB7XG4gIHZhciBoYXNoID0gbmFtZS5yZXBsYWNlKFwiSEtERi1cIiwgXCJcIiksXG4gICAgICBvcCA9IG5hbWUucmVwbGFjZShcIkhLREYtU0hBLVwiLCBcIkhTXCIpO1xuXG4gIC8vIE5PVEU6IG5vIG5vZGVqcy93ZWJjcnlwdG8vZmFsbGJhY2sgbW9kZWwsIHNpbmNlIHRoaXMgSEtERiBpc1xuICAvLyAgICAgICBpbXBsZW1lbnRlZCB1c2luZyB0aGUgSE1BQyBhbGdvcml0aG1zXG5cbiAgdmFyIGZuID0gZnVuY3Rpb24oa2V5LCBwcm9wcykge1xuICAgIHZhciBoYXNoTGVuID0gQ09OU1RBTlRTLkhBU0hMRU5HVEhbaGFzaF0gLyA4O1xuXG4gICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcCkge1xuICAgICAgb3AgPSBobWFjW29wXS5zaWduO1xuICAgIH1cblxuICAgIC8vIHByZXBhcmUgb3B0aW9uc1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgdmFyIHNhbHQgPSBwcm9wcy5zYWx0O1xuICAgIGlmICghc2FsdCB8fCAwID09PSBzYWx0Lmxlbmd0aCkge1xuICAgICAgc2FsdCA9IEJ1ZmZlci5hbGxvYyhoYXNoTGVuKTtcbiAgICB9XG4gICAgdmFyIGluZm8gPSBwcm9wcy5pbmZvIHx8IEJ1ZmZlci5hbGxvYygwKTtcbiAgICB2YXIga2V5TGVuID0gcHJvcHMubGVuZ3RoIHx8IGhhc2hMZW47XG5cbiAgICB2YXIgcHJvbWlzZTtcblxuICAgIC8vIFNldHVwIEV4cGFuc2lvblxuICAgIHZhciBOID0gTWF0aC5jZWlsKGtleUxlbiAvIGhhc2hMZW4pLFxuICAgICAgICBva20gPSBbXSxcbiAgICAgICAgaWR4ID0gMDtcbiAgICBmdW5jdGlvbiBleHBhbmQoa2V5LCBUKSB7XG4gICAgICBpZiAoTiA9PT0gaWR4KyspIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob2ttKS5zbGljZSgwLCBrZXlMZW4pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIVQpIHtcbiAgICAgICAgVCA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgIH1cbiAgICAgIFQgPSBCdWZmZXIuY29uY2F0KFtULCBpbmZvLCBCdWZmZXIuZnJvbShbaWR4XSldKTtcbiAgICAgIFQgPSBvcChrZXksIFQpO1xuICAgICAgVCA9IFQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgVCA9IHJlc3VsdC5tYWM7XG4gICAgICAgIG9rbS5wdXNoKFQpO1xuXG4gICAgICAgIHJldHVybiBleHBhbmQoa2V5LCBUKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFQ7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAxOiBFeHRyYWN0XG4gICAgcHJvbWlzZSA9IG9wKHNhbHQsIGtleSwgeyBsZW5ndGg6IHNhbHQubGVuZ3RoICogOCB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgLy8gU3RlcCAyOiBFeHBhbmRcbiAgICAgIHJldHVybiBleHBhbmQocmVzdWx0Lm1hYyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICByZXR1cm4gZm47XG59XG5cbi8vIFB1YmxpYyBBUElcbi8vICogW25hbWVdLmRlcml2ZVxudmFyIGhrZGYgPSB7fTtcbltcbiAgXCJIS0RGLVNIQS0xXCIsXG4gIFwiSEtERi1TSEEtMjU2XCIsXG4gIFwiSEtERi1TSEEtMzg0XCIsXG4gIFwiSEtERi1TSEEtNTEyXCJcbl0uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIGhrZGZbbmFtZV0gPSB7XG4gICAgZGVyaXZlOiBoa2RmRGVyaXZlRm4obmFtZSlcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhrZGY7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/hkdf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/hmac.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/hmac.js - HMAC-based \"signatures\"\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar CONSTANTS = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    DataBuffer = __webpack_require__(/*! ../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\");\n\nfunction hmacSignFN(name) {\n  var md = name.replace(\"HS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"HS\", \"SHA-\");\n\n  function checkKeyLength(len, key) {\n    len = (len || CONSTANTS.HASHLENGTH[hash]) / 8;\n    if (len > key.length) {\n      return Promise.reject(new Error(\"invalid key length\"));\n    }\n\n    return Promise.resolve(key);\n  }\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, pdata, props) {\n    props = props || {};\n    var promise;\n    promise = checkKeyLength(props.length, key);\n    promise = promise.then(function() {\n      var sig = forge.hmac.create();\n      sig.start(md, key.toString(\"binary\"));\n      sig.update(pdata.toString(\"binary\"));\n      sig = Buffer.from(sig.digest().bytes(), \"binary\");\n\n      return {\n        data: pdata,\n        mac: sig\n      }\n    });\n    return promise;\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata, props) {\n    props = props || {};\n\n    var alg = {\n      name: \"HMAC\",\n      hash: {\n        name: hash\n      }\n    };\n    var promise;\n    promise = checkKeyLength(props.length, key);\n    promise = promise.then(function() {\n      return helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"sign\"]);\n    });\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      var sig = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n\n    return promise;\n  };\n\n  // ### NodeJS implementation\n  var nodejs = function(key, pdata, props) {\n    props = props || {};\n\n    var promise;\n    promise = checkKeyLength(props.length, key);\n    promise = promise.then(function() {\n      var hmac = helpers.nodeCrypto.createHmac(md, key);\n      hmac.update(pdata);\n\n      var sig = hmac.digest();\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction hmacVerifyFN(name) {\n  var md = name.replace(\"HS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"HS\", \"SHA-\");\n\n  function compare(len, expected, actual) {\n    len = (len || CONSTANTS.HASHLENGTH[hash]) / 8;\n    var valid = true;\n    for (var idx = 0; len > idx; idx++) {\n      valid = valid && (expected[idx] === actual[idx]);\n    }\n    return valid;\n  }\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, pdata, mac, props) {\n    props = props || {};\n\n    var vrfy = forge.hmac.create();\n    vrfy.start(md, new DataBuffer(key));\n    vrfy.update(pdata.toString(\"binary\"));\n    vrfy = Buffer.from(vrfy.digest().bytes(), \"binary\");\n\n    if (compare(props.length, mac, vrfy)) {\n      return Promise.resolve({\n        data: pdata,\n        mac: mac,\n        valid: true\n      });\n    } else {\n      return Promise.reject(new Error(\"verification failed\"));\n    }\n  };\n\n  var webcrypto = function(key, pdata, mac, props) {\n    props = props || {};\n\n    var alg = {\n      name: \"HMAC\",\n      hash: {\n        name: hash\n      }\n    };\n    var promise;\n    if (props.length) {\n      promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"sign\"]);\n      promise = promise.then(function(key) {\n        return helpers.subtleCrypto.sign(alg, key, pdata);\n      });\n      promise = promise.then(function(result) {\n        var sig = Buffer.from(result);\n        return compare(props.length, mac, sig);\n      });\n    } else {\n      promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"verify\"]);\n      promise = promise.then(function(key) {\n        return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n      });\n    }\n    promise = promise.then(function(result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verifaction failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs = function(key, pdata, mac, props) {\n    props = props || {};\n\n    var hmac = helpers.nodeCrypto.createHmac(md, key);\n    hmac.update(pdata);\n\n    var sig = hmac.digest();\n    if (!compare(props.length, mac, sig)) {\n      throw new Error(\"verification failed\");\n    }\n    return {\n      data: pdata,\n      mac: sig,\n      valid: true\n    };\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].sign\n// * [name].verify\nvar hmac = {};\n[\n  \"HS1\",\n  \"HS256\",\n  \"HS384\",\n  \"HS512\"\n].forEach(function(alg) {\n  hmac[alg] = {\n    sign: hmacSignFN(alg),\n    verify: hmacVerifyFN(alg)\n  };\n});\n\nmodule.exports = hmac;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2htYWMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFhO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQywwRUFBa0I7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQXVCO0FBQ2hELGNBQWMsbUJBQU8sQ0FBQyw4RUFBYzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvaG1hYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvaG1hYy5qcyAtIEhNQUMtYmFzZWQgXCJzaWduYXR1cmVzXCJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDT05TVEFOVFMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIiksXG4gICAgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZS5qc1wiKSxcbiAgICBEYXRhQnVmZmVyID0gcmVxdWlyZShcIi4uL3V0aWwvZGF0YWJ1ZmZlci5qc1wiKSxcbiAgICBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKTtcblxuZnVuY3Rpb24gaG1hY1NpZ25GTihuYW1lKSB7XG4gIHZhciBtZCA9IG5hbWUucmVwbGFjZShcIkhTXCIsIFwiU0hBXCIpLnRvTG93ZXJDYXNlKCksXG4gICAgICBoYXNoID0gbmFtZS5yZXBsYWNlKFwiSFNcIiwgXCJTSEEtXCIpO1xuXG4gIGZ1bmN0aW9uIGNoZWNrS2V5TGVuZ3RoKGxlbiwga2V5KSB7XG4gICAgbGVuID0gKGxlbiB8fCBDT05TVEFOVFMuSEFTSExFTkdUSFtoYXNoXSkgLyA4O1xuICAgIGlmIChsZW4gPiBrZXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBrZXkgbGVuZ3RoXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleSk7XG4gIH1cblxuICAvLyAjIyMgRmFsbGJhY2sgSW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIHBkYXRhLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgdmFyIHByb21pc2U7XG4gICAgcHJvbWlzZSA9IGNoZWNrS2V5TGVuZ3RoKHByb3BzLmxlbmd0aCwga2V5KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNpZyA9IGZvcmdlLmhtYWMuY3JlYXRlKCk7XG4gICAgICBzaWcuc3RhcnQobWQsIGtleS50b1N0cmluZyhcImJpbmFyeVwiKSk7XG4gICAgICBzaWcudXBkYXRlKHBkYXRhLnRvU3RyaW5nKFwiYmluYXJ5XCIpKTtcbiAgICAgIHNpZyA9IEJ1ZmZlci5mcm9tKHNpZy5kaWdlc3QoKS5ieXRlcygpLCBcImJpbmFyeVwiKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogc2lnXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBJbXBsZW1lbnRhdGlvblxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgdmFyIGFsZyA9IHtcbiAgICAgIG5hbWU6IFwiSE1BQ1wiLFxuICAgICAgaGFzaDoge1xuICAgICAgICBuYW1lOiBoYXNoXG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBwcm9taXNlID0gY2hlY2tLZXlMZW5ndGgocHJvcHMubGVuZ3RoLCBrZXkpO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgYWxnLCB0cnVlLCBbXCJzaWduXCJdKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLnNpZ24oYWxnLCBrZXksIHBkYXRhKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgdmFyIHNpZyA9IEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBzaWdcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyAjIyMgTm9kZUpTIGltcGxlbWVudGF0aW9uXG4gIHZhciBub2RlanMgPSBmdW5jdGlvbihrZXksIHBkYXRhLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICB2YXIgcHJvbWlzZTtcbiAgICBwcm9taXNlID0gY2hlY2tLZXlMZW5ndGgocHJvcHMubGVuZ3RoLCBrZXkpO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaG1hYyA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVIbWFjKG1kLCBrZXkpO1xuICAgICAgaG1hYy51cGRhdGUocGRhdGEpO1xuXG4gICAgICB2YXIgc2lnID0gaG1hYy5kaWdlc3QoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IHNpZ1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGhtYWNWZXJpZnlGTihuYW1lKSB7XG4gIHZhciBtZCA9IG5hbWUucmVwbGFjZShcIkhTXCIsIFwiU0hBXCIpLnRvTG93ZXJDYXNlKCksXG4gICAgICBoYXNoID0gbmFtZS5yZXBsYWNlKFwiSFNcIiwgXCJTSEEtXCIpO1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmUobGVuLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gICAgbGVuID0gKGxlbiB8fCBDT05TVEFOVFMuSEFTSExFTkdUSFtoYXNoXSkgLyA4O1xuICAgIHZhciB2YWxpZCA9IHRydWU7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgbGVuID4gaWR4OyBpZHgrKykge1xuICAgICAgdmFsaWQgPSB2YWxpZCAmJiAoZXhwZWN0ZWRbaWR4XSA9PT0gYWN0dWFsW2lkeF0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH1cblxuICAvLyAjIyMgRmFsbGJhY2sgSW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIHBkYXRhLCBtYWMsIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIHZhciB2cmZ5ID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICB2cmZ5LnN0YXJ0KG1kLCBuZXcgRGF0YUJ1ZmZlcihrZXkpKTtcbiAgICB2cmZ5LnVwZGF0ZShwZGF0YS50b1N0cmluZyhcImJpbmFyeVwiKSk7XG4gICAgdnJmeSA9IEJ1ZmZlci5mcm9tKHZyZnkuZGlnZXN0KCkuYnl0ZXMoKSwgXCJiaW5hcnlcIik7XG5cbiAgICBpZiAoY29tcGFyZShwcm9wcy5sZW5ndGgsIG1hYywgdnJmeSkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBtYWMsXG4gICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInZlcmlmaWNhdGlvbiBmYWlsZWRcIikpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgbWFjLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICB2YXIgYWxnID0ge1xuICAgICAgbmFtZTogXCJITUFDXCIsXG4gICAgICBoYXNoOiB7XG4gICAgICAgIG5hbWU6IGhhc2hcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwcm9taXNlO1xuICAgIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICAgIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJyYXdcIiwga2V5LCBhbGcsIHRydWUsIFtcInNpZ25cIl0pO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLnNpZ24oYWxnLCBrZXksIHBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgdmFyIHNpZyA9IEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiBjb21wYXJlKHByb3BzLmxlbmd0aCwgbWFjLCBzaWcpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJyYXdcIiwga2V5LCBhbGcsIHRydWUsIFtcInZlcmlmeVwiXSk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8udmVyaWZ5KGFsZywga2V5LCBtYWMsIHBkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInZlcmlmYWN0aW9uIGZhaWxlZFwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IG1hYyxcbiAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICB2YXIgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgbWFjLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICB2YXIgaG1hYyA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVIbWFjKG1kLCBrZXkpO1xuICAgIGhtYWMudXBkYXRlKHBkYXRhKTtcblxuICAgIHZhciBzaWcgPSBobWFjLmRpZ2VzdCgpO1xuICAgIGlmICghY29tcGFyZShwcm9wcy5sZW5ndGgsIG1hYywgc2lnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmVyaWZpY2F0aW9uIGZhaWxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgbWFjOiBzaWcsXG4gICAgICB2YWxpZDogdHJ1ZVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG4vLyAjIyMgUHVibGljIEFQSVxuLy8gKiBbbmFtZV0uc2lnblxuLy8gKiBbbmFtZV0udmVyaWZ5XG52YXIgaG1hYyA9IHt9O1xuW1xuICBcIkhTMVwiLFxuICBcIkhTMjU2XCIsXG4gIFwiSFMzODRcIixcbiAgXCJIUzUxMlwiXG5dLmZvckVhY2goZnVuY3Rpb24oYWxnKSB7XG4gIGhtYWNbYWxnXSA9IHtcbiAgICBzaWduOiBobWFjU2lnbkZOKGFsZyksXG4gICAgdmVyaWZ5OiBobWFjVmVyaWZ5Rk4oYWxnKVxuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gaG1hYztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/index.js":
/*!********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * algorithms/index.js - Cryptographic Algorithms Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\n// setup implementations\nvar implementations = [\n  __webpack_require__(/*! ./aes-cbc-hmac-sha2.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-cbc-hmac-sha2.js\"),\n  __webpack_require__(/*! ./aes-gcm.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-gcm.js\"),\n  __webpack_require__(/*! ./aes-kw.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js\"),\n  __webpack_require__(/*! ./concat.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/concat.js\"),\n  __webpack_require__(/*! ./dir.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/dir.js\"),\n  __webpack_require__(/*! ./ecdh.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ecdh.js\"),\n  __webpack_require__(/*! ./ecdsa.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ecdsa.js\"),\n  __webpack_require__(/*! ./hkdf.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hkdf.js\"),\n  __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js\"),\n  __webpack_require__(/*! ./pbes2.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/pbes2.js\"),\n  __webpack_require__(/*! ./rsaes.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsaes.js\"),\n  __webpack_require__(/*! ./rsassa.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsassa.js\"),\n  __webpack_require__(/*! ./sha.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\")\n];\n\nvar ALGS_DIGEST = {};\nvar ALGS_DERIVE = {};\nvar ALGS_SIGN = {},\n    ALGS_VRFY = {};\nvar ALGS_ENC = {},\n    ALGS_DEC = {};\n\nimplementations.forEach(function(mod) {\n  Object.keys(mod).forEach(function(alg) {\n    var op = mod[alg];\n\n    if (\"function\" === typeof op.encrypt) {\n      ALGS_ENC[alg] = op.encrypt;\n    }\n    if (\"function\" === typeof op.decrypt) {\n      ALGS_DEC[alg] = op.decrypt;\n    }\n    if (\"function\" === typeof op.sign) {\n      ALGS_SIGN[alg] = op.sign;\n    }\n    if (\"function\" === typeof op.verify) {\n      ALGS_VRFY[alg] = op.verify;\n    }\n    if (\"function\" === typeof op.digest) {\n      ALGS_DIGEST[alg] = op.digest;\n    }\n    if (\"function\" === typeof op.derive) {\n      ALGS_DERIVE[alg] = op.derive;\n    }\n  });\n});\n\n// public API\nexports.digest = function(alg, data, props) {\n  var op = ALGS_DIGEST[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(data, props);\n};\n\nexports.derive = function(alg, key, props) {\n  var op = ALGS_DERIVE[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, props);\n};\n\nexports.sign = function(alg, key, pdata, props) {\n  var op = ALGS_SIGN[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, pdata, props || {});\n};\n\nexports.verify = function(alg, key, pdata, mac, props) {\n  var op = ALGS_VRFY[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, pdata, mac, props || {});\n};\n\nexports.encrypt = function(alg, key, pdata, props) {\n  var op = ALGS_ENC[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, pdata, props || {});\n};\n\nexports.decrypt = function(alg, key, cdata, props) {\n  var op = ALGS_DEC[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, cdata, props || {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLGtHQUF3QjtBQUNsQyxFQUFFLG1CQUFPLENBQUMsOEVBQWM7QUFDeEIsRUFBRSxtQkFBTyxDQUFDLDRFQUFhO0FBQ3ZCLEVBQUUsbUJBQU8sQ0FBQyw0RUFBYTtBQUN2QixFQUFFLG1CQUFPLENBQUMsc0VBQVU7QUFDcEIsRUFBRSxtQkFBTyxDQUFDLHdFQUFXO0FBQ3JCLEVBQUUsbUJBQU8sQ0FBQywwRUFBWTtBQUN0QixFQUFFLG1CQUFPLENBQUMsd0VBQVc7QUFDckIsRUFBRSxtQkFBTyxDQUFDLHdFQUFXO0FBQ3JCLEVBQUUsbUJBQU8sQ0FBQywwRUFBWTtBQUN0QixFQUFFLG1CQUFPLENBQUMsMEVBQVk7QUFDdEIsRUFBRSxtQkFBTyxDQUFDLDRFQUFhO0FBQ3ZCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBVTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4Qzs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvaW5kZXguanMgLSBDcnlwdG9ncmFwaGljIEFsZ29yaXRobXMgRW50cnkgUG9pbnRcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHNldHVwIGltcGxlbWVudGF0aW9uc1xudmFyIGltcGxlbWVudGF0aW9ucyA9IFtcbiAgcmVxdWlyZShcIi4vYWVzLWNiYy1obWFjLXNoYTIuanNcIiksXG4gIHJlcXVpcmUoXCIuL2Flcy1nY20uanNcIiksXG4gIHJlcXVpcmUoXCIuL2Flcy1rdy5qc1wiKSxcbiAgcmVxdWlyZShcIi4vY29uY2F0LmpzXCIpLFxuICByZXF1aXJlKFwiLi9kaXIuanNcIiksXG4gIHJlcXVpcmUoXCIuL2VjZGguanNcIiksXG4gIHJlcXVpcmUoXCIuL2VjZHNhLmpzXCIpLFxuICByZXF1aXJlKFwiLi9oa2RmLmpzXCIpLFxuICByZXF1aXJlKFwiLi9obWFjLmpzXCIpLFxuICByZXF1aXJlKFwiLi9wYmVzMi5qc1wiKSxcbiAgcmVxdWlyZShcIi4vcnNhZXMuanNcIiksXG4gIHJlcXVpcmUoXCIuL3JzYXNzYS5qc1wiKSxcbiAgcmVxdWlyZShcIi4vc2hhLmpzXCIpXG5dO1xuXG52YXIgQUxHU19ESUdFU1QgPSB7fTtcbnZhciBBTEdTX0RFUklWRSA9IHt9O1xudmFyIEFMR1NfU0lHTiA9IHt9LFxuICAgIEFMR1NfVlJGWSA9IHt9O1xudmFyIEFMR1NfRU5DID0ge30sXG4gICAgQUxHU19ERUMgPSB7fTtcblxuaW1wbGVtZW50YXRpb25zLmZvckVhY2goZnVuY3Rpb24obW9kKSB7XG4gIE9iamVjdC5rZXlzKG1vZCkuZm9yRWFjaChmdW5jdGlvbihhbGcpIHtcbiAgICB2YXIgb3AgPSBtb2RbYWxnXTtcblxuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcC5lbmNyeXB0KSB7XG4gICAgICBBTEdTX0VOQ1thbGddID0gb3AuZW5jcnlwdDtcbiAgICB9XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9wLmRlY3J5cHQpIHtcbiAgICAgIEFMR1NfREVDW2FsZ10gPSBvcC5kZWNyeXB0O1xuICAgIH1cbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb3Auc2lnbikge1xuICAgICAgQUxHU19TSUdOW2FsZ10gPSBvcC5zaWduO1xuICAgIH1cbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb3AudmVyaWZ5KSB7XG4gICAgICBBTEdTX1ZSRllbYWxnXSA9IG9wLnZlcmlmeTtcbiAgICB9XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9wLmRpZ2VzdCkge1xuICAgICAgQUxHU19ESUdFU1RbYWxnXSA9IG9wLmRpZ2VzdDtcbiAgICB9XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9wLmRlcml2ZSkge1xuICAgICAgQUxHU19ERVJJVkVbYWxnXSA9IG9wLmRlcml2ZTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8vIHB1YmxpYyBBUElcbmV4cG9ydHMuZGlnZXN0ID0gZnVuY3Rpb24oYWxnLCBkYXRhLCBwcm9wcykge1xuICB2YXIgb3AgPSBBTEdTX0RJR0VTVFthbGddO1xuICBpZiAoIW9wKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogXCIgKyBhbGcpKTtcbiAgfVxuXG4gIHJldHVybiBvcChkYXRhLCBwcm9wcyk7XG59O1xuXG5leHBvcnRzLmRlcml2ZSA9IGZ1bmN0aW9uKGFsZywga2V5LCBwcm9wcykge1xuICB2YXIgb3AgPSBBTEdTX0RFUklWRVthbGddO1xuICBpZiAoIW9wKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogXCIgKyBhbGcpKTtcbiAgfVxuXG4gIHJldHVybiBvcChrZXksIHByb3BzKTtcbn07XG5cbmV4cG9ydHMuc2lnbiA9IGZ1bmN0aW9uKGFsZywga2V5LCBwZGF0YSwgcHJvcHMpIHtcbiAgdmFyIG9wID0gQUxHU19TSUdOW2FsZ107XG4gIGlmICghb3ApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIiArIGFsZykpO1xuICB9XG5cbiAgcmV0dXJuIG9wKGtleSwgcGRhdGEsIHByb3BzIHx8IHt9KTtcbn07XG5cbmV4cG9ydHMudmVyaWZ5ID0gZnVuY3Rpb24oYWxnLCBrZXksIHBkYXRhLCBtYWMsIHByb3BzKSB7XG4gIHZhciBvcCA9IEFMR1NfVlJGWVthbGddO1xuICBpZiAoIW9wKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogXCIgKyBhbGcpKTtcbiAgfVxuXG4gIHJldHVybiBvcChrZXksIHBkYXRhLCBtYWMsIHByb3BzIHx8IHt9KTtcbn07XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uKGFsZywga2V5LCBwZGF0YSwgcHJvcHMpIHtcbiAgdmFyIG9wID0gQUxHU19FTkNbYWxnXTtcbiAgaWYgKCFvcCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IFwiICsgYWxnKSk7XG4gIH1cblxuICByZXR1cm4gb3Aoa2V5LCBwZGF0YSwgcHJvcHMgfHwge30pO1xufTtcblxuZXhwb3J0cy5kZWNyeXB0ID0gZnVuY3Rpb24oYWxnLCBrZXksIGNkYXRhLCBwcm9wcykge1xuICB2YXIgb3AgPSBBTEdTX0RFQ1thbGddO1xuICBpZiAoIW9wKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogXCIgKyBhbGcpKTtcbiAgfVxuXG4gIHJldHVybiBvcChrZXksIGNkYXRhLCBwcm9wcyB8fCB7fSk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/pbes2.js":
/*!********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/pbes2.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/pbes2.js - Password-Based Encryption (v2) Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    merge = __webpack_require__(/*! ../util/merge.js */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    KW = __webpack_require__(/*! ./aes-kw.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js\");\n\nvar NULL_BUFFER = Buffer.from([0]);\nvar DEFAULT_ITERATIONS = 8192;\nvar DEFAULT_SALT_LENGTH = 16;\n\nfunction fixSalt(hmac, kw, salt) {\n  var alg = \"PBES2-\" + hmac + \"+\" + kw;\n  var output = [\n    Buffer.from(alg, \"utf8\"),\n    NULL_BUFFER,\n    salt\n  ];\n  return Buffer.concat(output);\n}\n\nfunction pbkdf2Fn(hash) {\n  function prepareProps(props) {\n    props = props || {};\n    var keyLen = props.length || 0;\n    var salt = util.asBuffer(props.salt || Buffer.alloc(0), \"base64u4l\"),\n        itrs = props.iterations || 0;\n\n    if (0 >= keyLen) {\n      throw new Error(\"invalid key length\");\n    }\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n\n    props.length = keyLen;\n    props.salt = salt;\n    props.iterations = itrs;\n\n    return props;\n  }\n\n  var fallback = function(key, props) {\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n\n    var promise = new Promise(function(resolve, reject) {\n      var md = forge.md[hash.replace(\"-\", \"\").toLowerCase()].create();\n      var cb = function(err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          dk = Buffer.from(dk, \"binary\");\n          resolve(dk);\n        }\n      };\n\n      forge.pkcs5.pbkdf2(key.toString(\"binary\"),\n                         salt.toString(\"binary\"),\n                         itrs,\n                         keyLen,\n                         md,\n                         cb);\n    });\n    return promise;\n  };\n  var webcrypto = function(key, props) {\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n\n    var promise = Promise.resolve(key);\n    promise = promise.then(function(keyval) {\n      return helpers.subtleCrypto.importKey(\"raw\", keyval, \"PBKDF2\", false, [\"deriveBits\"]);\n    });\n    promise = promise.then(function(key) {\n      var mainAlgo = {\n        name: \"PBKDF2\",\n        salt: new Uint8Array(salt),\n        iterations: itrs,\n        hash: hash\n      };\n\n      return helpers.subtleCrypto.deriveBits(mainAlgo, key, keyLen * 8);\n    });\n    promise = promise.then(function(result) {\n      return util.asBuffer(result);\n    });\n    return promise;\n  };\n  var nodejs = function(key, props) {\n    if (6 > helpers.nodeCrypto.pbkdf2.length) {\n      throw new Error(\"unsupported algorithm: PBKDF2-\" + hash);\n    }\n\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n\n        var md = hash.replace(\"-\", \"\");\n    var promise = new Promise(function(resolve, reject) {\n      function cb(err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(dk);\n        }\n      }\n      helpers.nodeCrypto.pbkdf2(key, salt, itrs, keyLen, md, cb);\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction pbes2EncryptFN(hmac, kw) {\n  var deriveAlg = \"PBKDF2-\" + hmac.replace(\"HS\", \"SHA-\");\n  var keyLen = CONSTANTS.KEYLENGTH[kw] / 8;\n\n  return function(key, pdata, props) {\n    props = props || {};\n\n    var salt = util.asBuffer(props.p2s || Buffer.alloc(0), \"base64url\"),\n      itrs = props.p2c || DEFAULT_ITERATIONS;\n\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n    if (0 === salt.length) {\n      salt = util.randomBytes(DEFAULT_SALT_LENGTH);\n    } else if (8 > salt.length) {\n      throw new Error(\"salt too small\");\n    }\n    var header = {\n      p2s: util.base64url.encode(salt),\n      p2c: itrs\n    };\n    salt = fixSalt(hmac, kw, salt);\n    props = merge(props, {\n      salt: salt,\n      iterations: itrs,\n      length: keyLen\n    });\n\n    var promise = Promise.resolve(key);\n    // STEP 1: derive shared key\n    promise = promise.then(function (key) {\n      return pbes2[deriveAlg].derive(key, props);\n    });\n    // STEP 2: encrypt cek\n    promise = promise.then(function (dk) {\n      return KW[kw].encrypt(dk, pdata);\n    });\n    // STEP 3: (re-)apply headers\n    promise = promise.then(function (results) {\n      results.header = merge(results.header || {}, header);\n      return results;\n    });\n\n    return promise;\n  };\n}\n\nfunction pbes2DecryptFN(hmac, kw) {\n  var deriveAlg = \"PBKDF2-\" + hmac.replace(\"HS\", \"SHA-\");\n  var keyLen = CONSTANTS.KEYLENGTH[kw] / 8;\n\n  return function(key, cdata, props) {\n    props = props || {};\n\n    var salt = util.asBuffer(props.p2s || Buffer.alloc(0), \"base64url\"),\n        itrs = props.p2c || 0;\n\n    if (0 >= itrs) {\n      return Promise.reject(new Error(\"invalid iteration count\"));\n    }\n\n    if (8 > salt.length) {\n      return Promise.reject(new Error(\"salt too small\"));\n    }\n    salt = fixSalt(hmac, kw, salt);\n    props = merge(props, {\n      salt: salt,\n      iterations: itrs,\n      length: keyLen\n    });\n\n    var promise = Promise.resolve(key);\n\n    // STEP 1: derived shared key\n    promise = promise.then(function(key) {\n      return pbes2[deriveAlg].derive(key, props);\n    });\n    // STEP 2: decrypt cek\n    promise = promise.then(function(dk) {\n      return KW[kw].decrypt(dk, cdata);\n    });\n\n    return promise;\n  };\n}\n\n// ### Public API\nvar pbes2 = {};\n\n// * [name].derive\n[\n  \"PBKDF2-SHA-256\",\n  \"PBKDF2-SHA-384\",\n  \"PBKDF2-SHA-512\"\n].forEach(function(alg) {\n  var hash = alg.replace(\"PBKDF2-\", \"\");\n  pbes2[alg] = {\n    derive: pbkdf2Fn(hash)\n  };\n});\n\n// [name].encrypt\n// [name].decrypt\n[\n  \"PBES2-HS256+A128KW\",\n  \"PBES2-HS384+A192KW\",\n  \"PBES2-HS512+A256KW\"\n].forEach(function(alg) {\n  var parts = /PBES2-(HS\\d+)\\+(A\\d+KW)/g.exec(alg);\n  var hmac = parts[1],\n      kw = parts[2];\n  pbes2[alg] = {\n    encrypt: pbes2EncryptFN(hmac, kw),\n    decrypt: pbes2DecryptFN(hmac, kw)\n  };\n});\n\nmodule.exports = pbes2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3BiZXMyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQywwRUFBa0I7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLGlFQUFTO0FBQzVCLGNBQWMsbUJBQU8sQ0FBQyw4RUFBYztBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDeEMsU0FBUyxtQkFBTyxDQUFDLDRFQUFhOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvcGJlczIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL3BiZXMyLmpzIC0gUGFzc3dvcmQtQmFzZWQgRW5jcnlwdGlvbiAodjIpIEFsZ29yaXRobXNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlLmpzXCIpLFxuICAgIG1lcmdlID0gcmVxdWlyZShcIi4uL3V0aWwvbWVyZ2UuanNcIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpLFxuICAgIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpLFxuICAgIENPTlNUQU5UUyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKSxcbiAgICBLVyA9IHJlcXVpcmUoXCIuL2Flcy1rdy5qc1wiKTtcblxudmFyIE5VTExfQlVGRkVSID0gQnVmZmVyLmZyb20oWzBdKTtcbnZhciBERUZBVUxUX0lURVJBVElPTlMgPSA4MTkyO1xudmFyIERFRkFVTFRfU0FMVF9MRU5HVEggPSAxNjtcblxuZnVuY3Rpb24gZml4U2FsdChobWFjLCBrdywgc2FsdCkge1xuICB2YXIgYWxnID0gXCJQQkVTMi1cIiArIGhtYWMgKyBcIitcIiArIGt3O1xuICB2YXIgb3V0cHV0ID0gW1xuICAgIEJ1ZmZlci5mcm9tKGFsZywgXCJ1dGY4XCIpLFxuICAgIE5VTExfQlVGRkVSLFxuICAgIHNhbHRcbiAgXTtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gcGJrZGYyRm4oaGFzaCkge1xuICBmdW5jdGlvbiBwcmVwYXJlUHJvcHMocHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIHZhciBrZXlMZW4gPSBwcm9wcy5sZW5ndGggfHwgMDtcbiAgICB2YXIgc2FsdCA9IHV0aWwuYXNCdWZmZXIocHJvcHMuc2FsdCB8fCBCdWZmZXIuYWxsb2MoMCksIFwiYmFzZTY0dTRsXCIpLFxuICAgICAgICBpdHJzID0gcHJvcHMuaXRlcmF0aW9ucyB8fCAwO1xuXG4gICAgaWYgKDAgPj0ga2V5TGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtleSBsZW5ndGhcIik7XG4gICAgfVxuICAgIGlmICgwID49IGl0cnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaXRlcmF0aW9uIGNvdW50XCIpO1xuICAgIH1cblxuICAgIHByb3BzLmxlbmd0aCA9IGtleUxlbjtcbiAgICBwcm9wcy5zYWx0ID0gc2FsdDtcbiAgICBwcm9wcy5pdGVyYXRpb25zID0gaXRycztcblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgcHJvcHMpIHtcbiAgICB0cnkge1xuICAgICAgcHJvcHMgPSBwcmVwYXJlUHJvcHMocHJvcHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIGtleUxlbiA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgc2FsdCA9IHByb3BzLnNhbHQsXG4gICAgICAgIGl0cnMgPSBwcm9wcy5pdGVyYXRpb25zO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBtZCA9IGZvcmdlLm1kW2hhc2gucmVwbGFjZShcIi1cIiwgXCJcIikudG9Mb3dlckNhc2UoKV0uY3JlYXRlKCk7XG4gICAgICB2YXIgY2IgPSBmdW5jdGlvbihlcnIsIGRrKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkayA9IEJ1ZmZlci5mcm9tKGRrLCBcImJpbmFyeVwiKTtcbiAgICAgICAgICByZXNvbHZlKGRrKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yZ2UucGtjczUucGJrZGYyKGtleS50b1N0cmluZyhcImJpbmFyeVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBzYWx0LnRvU3RyaW5nKFwiYmluYXJ5XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGl0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAga2V5TGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgIG1kLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcHJvcHMpIHtcbiAgICB0cnkge1xuICAgICAgcHJvcHMgPSBwcmVwYXJlUHJvcHMocHJvcHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIGtleUxlbiA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgc2FsdCA9IHByb3BzLnNhbHQsXG4gICAgICAgIGl0cnMgPSBwcm9wcy5pdGVyYXRpb25zO1xuXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoa2V5KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleXZhbCkge1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcInJhd1wiLCBrZXl2YWwsIFwiUEJLREYyXCIsIGZhbHNlLCBbXCJkZXJpdmVCaXRzXCJdKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIG1haW5BbGdvID0ge1xuICAgICAgICBuYW1lOiBcIlBCS0RGMlwiLFxuICAgICAgICBzYWx0OiBuZXcgVWludDhBcnJheShzYWx0KSxcbiAgICAgICAgaXRlcmF0aW9uczogaXRycyxcbiAgICAgICAgaGFzaDogaGFzaFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmRlcml2ZUJpdHMobWFpbkFsZ28sIGtleSwga2V5TGVuICogOCk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHJldHVybiB1dGlsLmFzQnVmZmVyKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG4gIHZhciBub2RlanMgPSBmdW5jdGlvbihrZXksIHByb3BzKSB7XG4gICAgaWYgKDYgPiBoZWxwZXJzLm5vZGVDcnlwdG8ucGJrZGYyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBQQktERjItXCIgKyBoYXNoKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcHJvcHMgPSBwcmVwYXJlUHJvcHMocHJvcHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIGtleUxlbiA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgc2FsdCA9IHByb3BzLnNhbHQsXG4gICAgICAgIGl0cnMgPSBwcm9wcy5pdGVyYXRpb25zO1xuXG4gICAgICAgIHZhciBtZCA9IGhhc2gucmVwbGFjZShcIi1cIiwgXCJcIik7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGNiKGVyciwgZGspIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZGspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoZWxwZXJzLm5vZGVDcnlwdG8ucGJrZGYyKGtleSwgc2FsdCwgaXRycywga2V5TGVuLCBtZCwgY2IpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcGJlczJFbmNyeXB0Rk4oaG1hYywga3cpIHtcbiAgdmFyIGRlcml2ZUFsZyA9IFwiUEJLREYyLVwiICsgaG1hYy5yZXBsYWNlKFwiSFNcIiwgXCJTSEEtXCIpO1xuICB2YXIga2V5TGVuID0gQ09OU1RBTlRTLktFWUxFTkdUSFtrd10gLyA4O1xuXG4gIHJldHVybiBmdW5jdGlvbihrZXksIHBkYXRhLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICB2YXIgc2FsdCA9IHV0aWwuYXNCdWZmZXIocHJvcHMucDJzIHx8IEJ1ZmZlci5hbGxvYygwKSwgXCJiYXNlNjR1cmxcIiksXG4gICAgICBpdHJzID0gcHJvcHMucDJjIHx8IERFRkFVTFRfSVRFUkFUSU9OUztcblxuICAgIGlmICgwID49IGl0cnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaXRlcmF0aW9uIGNvdW50XCIpO1xuICAgIH1cbiAgICBpZiAoMCA9PT0gc2FsdC5sZW5ndGgpIHtcbiAgICAgIHNhbHQgPSB1dGlsLnJhbmRvbUJ5dGVzKERFRkFVTFRfU0FMVF9MRU5HVEgpO1xuICAgIH0gZWxzZSBpZiAoOCA+IHNhbHQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzYWx0IHRvbyBzbWFsbFwiKTtcbiAgICB9XG4gICAgdmFyIGhlYWRlciA9IHtcbiAgICAgIHAyczogdXRpbC5iYXNlNjR1cmwuZW5jb2RlKHNhbHQpLFxuICAgICAgcDJjOiBpdHJzXG4gICAgfTtcbiAgICBzYWx0ID0gZml4U2FsdChobWFjLCBrdywgc2FsdCk7XG4gICAgcHJvcHMgPSBtZXJnZShwcm9wcywge1xuICAgICAgc2FsdDogc2FsdCxcbiAgICAgIGl0ZXJhdGlvbnM6IGl0cnMsXG4gICAgICBsZW5ndGg6IGtleUxlblxuICAgIH0pO1xuXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoa2V5KTtcbiAgICAvLyBTVEVQIDE6IGRlcml2ZSBzaGFyZWQga2V5XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gcGJlczJbZGVyaXZlQWxnXS5kZXJpdmUoa2V5LCBwcm9wcyk7XG4gICAgfSk7XG4gICAgLy8gU1RFUCAyOiBlbmNyeXB0IGNla1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRrKSB7XG4gICAgICByZXR1cm4gS1dba3ddLmVuY3J5cHQoZGssIHBkYXRhKTtcbiAgICB9KTtcbiAgICAvLyBTVEVQIDM6IChyZS0pYXBwbHkgaGVhZGVyc1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgIHJlc3VsdHMuaGVhZGVyID0gbWVyZ2UocmVzdWx0cy5oZWFkZXIgfHwge30sIGhlYWRlcik7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYmVzMkRlY3J5cHRGTihobWFjLCBrdykge1xuICB2YXIgZGVyaXZlQWxnID0gXCJQQktERjItXCIgKyBobWFjLnJlcGxhY2UoXCJIU1wiLCBcIlNIQS1cIik7XG4gIHZhciBrZXlMZW4gPSBDT05TVEFOVFMuS0VZTEVOR1RIW2t3XSAvIDg7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgY2RhdGEsIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIHZhciBzYWx0ID0gdXRpbC5hc0J1ZmZlcihwcm9wcy5wMnMgfHwgQnVmZmVyLmFsbG9jKDApLCBcImJhc2U2NHVybFwiKSxcbiAgICAgICAgaXRycyA9IHByb3BzLnAyYyB8fCAwO1xuXG4gICAgaWYgKDAgPj0gaXRycykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgaXRlcmF0aW9uIGNvdW50XCIpKTtcbiAgICB9XG5cbiAgICBpZiAoOCA+IHNhbHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwic2FsdCB0b28gc21hbGxcIikpO1xuICAgIH1cbiAgICBzYWx0ID0gZml4U2FsdChobWFjLCBrdywgc2FsdCk7XG4gICAgcHJvcHMgPSBtZXJnZShwcm9wcywge1xuICAgICAgc2FsdDogc2FsdCxcbiAgICAgIGl0ZXJhdGlvbnM6IGl0cnMsXG4gICAgICBsZW5ndGg6IGtleUxlblxuICAgIH0pO1xuXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoa2V5KTtcblxuICAgIC8vIFNURVAgMTogZGVyaXZlZCBzaGFyZWQga2V5XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBwYmVzMltkZXJpdmVBbGddLmRlcml2ZShrZXksIHByb3BzKTtcbiAgICB9KTtcbiAgICAvLyBTVEVQIDI6IGRlY3J5cHQgY2VrXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihkaykge1xuICAgICAgcmV0dXJuIEtXW2t3XS5kZWNyeXB0KGRrLCBjZGF0YSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbn1cblxuLy8gIyMjIFB1YmxpYyBBUElcbnZhciBwYmVzMiA9IHt9O1xuXG4vLyAqIFtuYW1lXS5kZXJpdmVcbltcbiAgXCJQQktERjItU0hBLTI1NlwiLFxuICBcIlBCS0RGMi1TSEEtMzg0XCIsXG4gIFwiUEJLREYyLVNIQS01MTJcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKGFsZykge1xuICB2YXIgaGFzaCA9IGFsZy5yZXBsYWNlKFwiUEJLREYyLVwiLCBcIlwiKTtcbiAgcGJlczJbYWxnXSA9IHtcbiAgICBkZXJpdmU6IHBia2RmMkZuKGhhc2gpXG4gIH07XG59KTtcblxuLy8gW25hbWVdLmVuY3J5cHRcbi8vIFtuYW1lXS5kZWNyeXB0XG5bXG4gIFwiUEJFUzItSFMyNTYrQTEyOEtXXCIsXG4gIFwiUEJFUzItSFMzODQrQTE5MktXXCIsXG4gIFwiUEJFUzItSFM1MTIrQTI1NktXXCJcbl0uZm9yRWFjaChmdW5jdGlvbihhbGcpIHtcbiAgdmFyIHBhcnRzID0gL1BCRVMyLShIU1xcZCspXFwrKEFcXGQrS1cpL2cuZXhlYyhhbGcpO1xuICB2YXIgaG1hYyA9IHBhcnRzWzFdLFxuICAgICAga3cgPSBwYXJ0c1syXTtcbiAgcGJlczJbYWxnXSA9IHtcbiAgICBlbmNyeXB0OiBwYmVzMkVuY3J5cHRGTihobWFjLCBrdyksXG4gICAgZGVjcnlwdDogcGJlczJEZWNyeXB0Rk4oaG1hYywga3cpXG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYmVzMjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/pbes2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/rsa-util.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/rsa-util.js - RSA Utility Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\n// ### RSA-specific Helpers\nfunction convertToForge(key, isPublic) {\n  var parts = isPublic ?\n              [\"n\", \"e\"] :\n              [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"];\n  parts = parts.map(function(f) {\n    return new forge.jsbn.BigInteger(key[f].toString(\"hex\"), 16);\n  });\n\n  var fn = isPublic ?\n           forge.pki.rsa.setPublicKey :\n           forge.pki.rsa.setPrivateKey;\n  return fn.apply(forge.pki.rsa, parts);\n}\n\nfunction convertToJWK(key, isPublic) {\n  var result = clone(key);\n  var parts = isPublic ?\n              [\"n\", \"e\"] :\n              [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"];\n  parts.forEach(function(f) {\n    result[f] = util.base64url.encode(result[f]);\n  });\n\n  // remove potentially troublesome properties\n  delete result.key_ops;\n  delete result.use;\n  delete result.alg;\n\n  if (isPublic) {\n    delete result.d;\n    delete result.p;\n    delete result.q;\n    delete result.dp;\n    delete result.dq;\n    delete result.qi;\n  }\n\n  return result;\n}\n\nfunction convertToPem(key, isPublic) {\n  var cacheKey = isPublic ? \"__cachedPublicPem\" : \"__cachedPrivatePem\";\n  if (key[cacheKey]) {\n    return key[cacheKey];\n  }\n\n  var value;\n  if (isPublic) {\n    value = forge.pki.publicKeyToPem(convertToForge(key, isPublic));\n  } else {\n    value = forge.pki.privateKeyToPem(convertToForge(key, isPublic));\n  }\n\n  Object.defineProperty(key, cacheKey, { value: value });\n  return value;\n}\n\nmodule.exports = {\n  convertToForge: convertToForge,\n  convertToJWK: convertToJWK,\n  convertToPem: convertToPem\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3JzYS11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMERBQWM7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QyxXQUFXLG1CQUFPLENBQUMsaUVBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9yc2EtdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvcnNhLXV0aWwuanMgLSBSU0EgVXRpbGl0eSBGdW5jdGlvbnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjbG9uZSA9IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIiksXG4gICAgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZS5qc1wiKSxcbiAgICB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5cbi8vICMjIyBSU0Etc3BlY2lmaWMgSGVscGVyc1xuZnVuY3Rpb24gY29udmVydFRvRm9yZ2Uoa2V5LCBpc1B1YmxpYykge1xuICB2YXIgcGFydHMgPSBpc1B1YmxpYyA/XG4gICAgICAgICAgICAgIFtcIm5cIiwgXCJlXCJdIDpcbiAgICAgICAgICAgICAgW1wiblwiLCBcImVcIiwgXCJkXCIsIFwicFwiLCBcInFcIiwgXCJkcFwiLCBcImRxXCIsIFwicWlcIl07XG4gIHBhcnRzID0gcGFydHMubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gbmV3IGZvcmdlLmpzYm4uQmlnSW50ZWdlcihrZXlbZl0udG9TdHJpbmcoXCJoZXhcIiksIDE2KTtcbiAgfSk7XG5cbiAgdmFyIGZuID0gaXNQdWJsaWMgP1xuICAgICAgICAgICBmb3JnZS5wa2kucnNhLnNldFB1YmxpY0tleSA6XG4gICAgICAgICAgIGZvcmdlLnBraS5yc2Euc2V0UHJpdmF0ZUtleTtcbiAgcmV0dXJuIGZuLmFwcGx5KGZvcmdlLnBraS5yc2EsIHBhcnRzKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRvSldLKGtleSwgaXNQdWJsaWMpIHtcbiAgdmFyIHJlc3VsdCA9IGNsb25lKGtleSk7XG4gIHZhciBwYXJ0cyA9IGlzUHVibGljID9cbiAgICAgICAgICAgICAgW1wiblwiLCBcImVcIl0gOlxuICAgICAgICAgICAgICBbXCJuXCIsIFwiZVwiLCBcImRcIiwgXCJwXCIsIFwicVwiLCBcImRwXCIsIFwiZHFcIiwgXCJxaVwiXTtcbiAgcGFydHMuZm9yRWFjaChmdW5jdGlvbihmKSB7XG4gICAgcmVzdWx0W2ZdID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKHJlc3VsdFtmXSk7XG4gIH0pO1xuXG4gIC8vIHJlbW92ZSBwb3RlbnRpYWxseSB0cm91Ymxlc29tZSBwcm9wZXJ0aWVzXG4gIGRlbGV0ZSByZXN1bHQua2V5X29wcztcbiAgZGVsZXRlIHJlc3VsdC51c2U7XG4gIGRlbGV0ZSByZXN1bHQuYWxnO1xuXG4gIGlmIChpc1B1YmxpYykge1xuICAgIGRlbGV0ZSByZXN1bHQuZDtcbiAgICBkZWxldGUgcmVzdWx0LnA7XG4gICAgZGVsZXRlIHJlc3VsdC5xO1xuICAgIGRlbGV0ZSByZXN1bHQuZHA7XG4gICAgZGVsZXRlIHJlc3VsdC5kcTtcbiAgICBkZWxldGUgcmVzdWx0LnFpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY29udmVydFRvUGVtKGtleSwgaXNQdWJsaWMpIHtcbiAgdmFyIGNhY2hlS2V5ID0gaXNQdWJsaWMgPyBcIl9fY2FjaGVkUHVibGljUGVtXCIgOiBcIl9fY2FjaGVkUHJpdmF0ZVBlbVwiO1xuICBpZiAoa2V5W2NhY2hlS2V5XSkge1xuICAgIHJldHVybiBrZXlbY2FjaGVLZXldO1xuICB9XG5cbiAgdmFyIHZhbHVlO1xuICBpZiAoaXNQdWJsaWMpIHtcbiAgICB2YWx1ZSA9IGZvcmdlLnBraS5wdWJsaWNLZXlUb1BlbShjb252ZXJ0VG9Gb3JnZShrZXksIGlzUHVibGljKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBmb3JnZS5wa2kucHJpdmF0ZUtleVRvUGVtKGNvbnZlcnRUb0ZvcmdlKGtleSwgaXNQdWJsaWMpKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShrZXksIGNhY2hlS2V5LCB7IHZhbHVlOiB2YWx1ZSB9KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udmVydFRvRm9yZ2U6IGNvbnZlcnRUb0ZvcmdlLFxuICBjb252ZXJ0VG9KV0s6IGNvbnZlcnRUb0pXSyxcbiAgY29udmVydFRvUGVtOiBjb252ZXJ0VG9QZW1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/rsaes.js":
/*!********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/rsaes.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/rsaes.js - RSA Signatures\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    DataBuffer = __webpack_require__(/*! ../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\"),\n    rsaUtil = __webpack_require__(/*! ./rsa-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js\");\n\nvar nodeSupport = {\n  \"RSA-OAEP\": \"RSA_PKCS1_OAEP_PADDING\",\n  RSA1_5: \"RSA_PKCS1_PADDING\"\n};\n\nfunction nodeSupportCheck(name) {\n  return helpers.nodeCrypto && helpers.nodeCrypto.constants && Object.keys(nodeSupport).indexOf(name) !== -1;\n}\n\n// ### RSAES-PKCS1-v1_5\n\n// ### RSAES-OAEP\nfunction rsaesEncryptFn(name) {\n  var alg = {\n    name: name\n  };\n\n  if (\"RSA-OAEP-256\" === name) {\n    alg.name = \"RSA-OAEP\";\n    alg.hash = {\n      name: \"SHA-256\"\n    };\n  } else if (\"RSA-OAEP\" === name) {\n    alg.hash = {\n      name: \"SHA-1\"\n    };\n  } else {\n    alg.name = \"RSAES-PKCS1-v1_5\";\n  }\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, pdata) {\n    // convert pdata to byte string\n    pdata = new DataBuffer(pdata).bytes();\n\n    // encrypt it\n    var pki = rsaUtil.convertToForge(key, true),\n        params = {};\n    if (\"RSA-OAEP\" === alg.name) {\n      params.md = alg.hash.name.toLowerCase().replace(/-/g, \"\");\n      params.md = forge.md[params.md].create();\n    }\n    var cdata = pki.encrypt(pdata, alg.name.toUpperCase(), params);\n\n    // convert cdata to Buffer\n    cdata = new DataBuffer(cdata).native();\n\n    return Promise.resolve({\n      data: cdata\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto;\n  if (\"RSAES-PKCS1-v1_5\" !== alg.name) {\n    webcrypto = function(key, pdata) {\n      key = rsaUtil.convertToJWK(key, true);\n      var promise;\n      promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"encrypt\"]);\n      promise = promise.then(function(key) {\n        return helpers.subtleCrypto.encrypt(alg, key, pdata);\n      });\n      promise = promise.then(function(result) {\n        var cdata = Buffer.from(result);\n        return {\n          data: cdata\n        };\n      });\n\n      return promise;\n    };\n  } else {\n    webcrypto = null;\n  }\n\n  var nodejs;\n  if (nodeSupportCheck(name)) {\n    nodejs = function (key, pdata) {\n      key = rsaUtil.convertToPem(key, true);\n\n      var cdata = helpers.nodeCrypto.publicEncrypt({\n        key: key,\n        padding: helpers.nodeCrypto.constants[nodeSupport[name]]\n      }, pdata);\n\n      return {\n        data: cdata\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction rsaesDecryptFn(name) {\n  var alg = {\n    name: name\n  };\n\n  if (\"RSA-OAEP-256\" === name) {\n    alg.name = \"RSA-OAEP\";\n    alg.hash = {\n      name: \"SHA-256\"\n    };\n  } else if (\"RSA-OAEP\" === name) {\n    alg.hash = {\n      name: \"SHA-1\"\n    };\n  } else {\n    alg.name = \"RSAES-PKCS1-v1_5\";\n  }\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, cdata) {\n    // convert cdata to byte string\n    cdata = new DataBuffer(cdata).bytes();\n\n    // decrypt it\n    var pki = rsaUtil.convertToForge(key, false),\n        params = {};\n    if (\"RSA-OAEP\" === alg.name) {\n      params.md = alg.hash.name.toLowerCase().replace(/-/g, \"\");\n      params.md = forge.md[params.md].create();\n    }\n    var pdata = pki.decrypt(cdata, alg.name.toUpperCase(), params);\n\n    // convert pdata to Buffer\n    pdata = new DataBuffer(pdata).native();\n\n    return Promise.resolve(pdata);\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto;\n  if (\"RSAES-PKCS1-v1_5\" !== alg.name) {\n    webcrypto = function(key, pdata) {\n      key = rsaUtil.convertToJWK(key, false);\n      var promise;\n      promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"decrypt\"]);\n      promise = promise.then(function(key) {\n        return helpers.subtleCrypto.decrypt(alg, key, pdata);\n      });\n      promise = promise.then(function(result) {\n        var pdata = Buffer.from(result);\n        return pdata;\n      });\n\n      return promise;\n    };\n  } else {\n    webcrypto = null;\n  }\n\n  var nodejs;\n  if (nodeSupportCheck(name)) { // node ^6.12.0 || >= 8.0.0\n    nodejs = function(key, pdata) {\n      key = rsaUtil.convertToPem(key, false);\n      return helpers.nodeCrypto.privateDecrypt({\n        key: key,\n        padding: helpers.nodeCrypto.constants[nodeSupport[name]]\n      }, pdata);\n    };\n  } else if (helpers.nodeCrypto && name === \"RSA-OAEP\") { // node (>= 6.0.0 && < 6.12.0) || ^7.0.0\n    nodejs = function(key, pdata) {\n      key = rsaUtil.convertToPem(key, false);\n      return helpers.nodeCrypto.privateDecrypt(key, pdata);\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar rsaes = {};\n[\n  \"RSA-OAEP\",\n  \"RSA-OAEP-256\",\n  \"RSA1_5\"\n].forEach(function(name) {\n  rsaes[name] = {\n    encrypt: rsaesEncryptFn(name),\n    decrypt: rsaesDecryptFn(name)\n  };\n});\n\nmodule.exports = rsaes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3JzYWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3RDLGNBQWMsbUJBQU8sQ0FBQyw4RUFBYztBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyxvRkFBdUI7QUFDaEQsY0FBYyxtQkFBTyxDQUFDLGdGQUFlOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUksc0RBQXNEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9yc2Flcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvcnNhZXMuanMgLSBSU0EgU2lnbmF0dXJlc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2UuanNcIiksXG4gICAgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIiksXG4gICAgRGF0YUJ1ZmZlciA9IHJlcXVpcmUoXCIuLi91dGlsL2RhdGFidWZmZXIuanNcIiksXG4gICAgcnNhVXRpbCA9IHJlcXVpcmUoXCIuL3JzYS11dGlsLmpzXCIpO1xuXG52YXIgbm9kZVN1cHBvcnQgPSB7XG4gIFwiUlNBLU9BRVBcIjogXCJSU0FfUEtDUzFfT0FFUF9QQURESU5HXCIsXG4gIFJTQTFfNTogXCJSU0FfUEtDUzFfUEFERElOR1wiXG59O1xuXG5mdW5jdGlvbiBub2RlU3VwcG9ydENoZWNrKG5hbWUpIHtcbiAgcmV0dXJuIGhlbHBlcnMubm9kZUNyeXB0byAmJiBoZWxwZXJzLm5vZGVDcnlwdG8uY29uc3RhbnRzICYmIE9iamVjdC5rZXlzKG5vZGVTdXBwb3J0KS5pbmRleE9mKG5hbWUpICE9PSAtMTtcbn1cblxuLy8gIyMjIFJTQUVTLVBLQ1MxLXYxXzVcblxuLy8gIyMjIFJTQUVTLU9BRVBcbmZ1bmN0aW9uIHJzYWVzRW5jcnlwdEZuKG5hbWUpIHtcbiAgdmFyIGFsZyA9IHtcbiAgICBuYW1lOiBuYW1lXG4gIH07XG5cbiAgaWYgKFwiUlNBLU9BRVAtMjU2XCIgPT09IG5hbWUpIHtcbiAgICBhbGcubmFtZSA9IFwiUlNBLU9BRVBcIjtcbiAgICBhbGcuaGFzaCA9IHtcbiAgICAgIG5hbWU6IFwiU0hBLTI1NlwiXG4gICAgfTtcbiAgfSBlbHNlIGlmIChcIlJTQS1PQUVQXCIgPT09IG5hbWUpIHtcbiAgICBhbGcuaGFzaCA9IHtcbiAgICAgIG5hbWU6IFwiU0hBLTFcIlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgYWxnLm5hbWUgPSBcIlJTQUVTLVBLQ1MxLXYxXzVcIjtcbiAgfVxuXG4gIC8vICMjIyBGYWxsYmFjayBJbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICAvLyBjb252ZXJ0IHBkYXRhIHRvIGJ5dGUgc3RyaW5nXG4gICAgcGRhdGEgPSBuZXcgRGF0YUJ1ZmZlcihwZGF0YSkuYnl0ZXMoKTtcblxuICAgIC8vIGVuY3J5cHQgaXRcbiAgICB2YXIgcGtpID0gcnNhVXRpbC5jb252ZXJ0VG9Gb3JnZShrZXksIHRydWUpLFxuICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICBpZiAoXCJSU0EtT0FFUFwiID09PSBhbGcubmFtZSkge1xuICAgICAgcGFyYW1zLm1kID0gYWxnLmhhc2gubmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0vZywgXCJcIik7XG4gICAgICBwYXJhbXMubWQgPSBmb3JnZS5tZFtwYXJhbXMubWRdLmNyZWF0ZSgpO1xuICAgIH1cbiAgICB2YXIgY2RhdGEgPSBwa2kuZW5jcnlwdChwZGF0YSwgYWxnLm5hbWUudG9VcHBlckNhc2UoKSwgcGFyYW1zKTtcblxuICAgIC8vIGNvbnZlcnQgY2RhdGEgdG8gQnVmZmVyXG4gICAgY2RhdGEgPSBuZXcgRGF0YUJ1ZmZlcihjZGF0YSkubmF0aXZlKCk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGRhdGE6IGNkYXRhXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBJbXBsZW1lbnRhdGlvblxuICB2YXIgd2ViY3J5cHRvO1xuICBpZiAoXCJSU0FFUy1QS0NTMS12MV81XCIgIT09IGFsZy5uYW1lKSB7XG4gICAgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgICAga2V5ID0gcnNhVXRpbC5jb252ZXJ0VG9KV0soa2V5LCB0cnVlKTtcbiAgICAgIHZhciBwcm9taXNlO1xuICAgICAgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcImp3a1wiLCBrZXksIGFsZywgdHJ1ZSwgW1wiZW5jcnlwdFwiXSk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uZW5jcnlwdChhbGcsIGtleSwgcGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICB2YXIgY2RhdGEgPSBCdWZmZXIuZnJvbShyZXN1bHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IGNkYXRhXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB3ZWJjcnlwdG8gPSBudWxsO1xuICB9XG5cbiAgdmFyIG5vZGVqcztcbiAgaWYgKG5vZGVTdXBwb3J0Q2hlY2sobmFtZSkpIHtcbiAgICBub2RlanMgPSBmdW5jdGlvbiAoa2V5LCBwZGF0YSkge1xuICAgICAga2V5ID0gcnNhVXRpbC5jb252ZXJ0VG9QZW0oa2V5LCB0cnVlKTtcblxuICAgICAgdmFyIGNkYXRhID0gaGVscGVycy5ub2RlQ3J5cHRvLnB1YmxpY0VuY3J5cHQoe1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcGFkZGluZzogaGVscGVycy5ub2RlQ3J5cHRvLmNvbnN0YW50c1tub2RlU3VwcG9ydFtuYW1lXV1cbiAgICAgIH0sIHBkYXRhKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogY2RhdGFcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcnNhZXNEZWNyeXB0Rm4obmFtZSkge1xuICB2YXIgYWxnID0ge1xuICAgIG5hbWU6IG5hbWVcbiAgfTtcblxuICBpZiAoXCJSU0EtT0FFUC0yNTZcIiA9PT0gbmFtZSkge1xuICAgIGFsZy5uYW1lID0gXCJSU0EtT0FFUFwiO1xuICAgIGFsZy5oYXNoID0ge1xuICAgICAgbmFtZTogXCJTSEEtMjU2XCJcbiAgICB9O1xuICB9IGVsc2UgaWYgKFwiUlNBLU9BRVBcIiA9PT0gbmFtZSkge1xuICAgIGFsZy5oYXNoID0ge1xuICAgICAgbmFtZTogXCJTSEEtMVwiXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBhbGcubmFtZSA9IFwiUlNBRVMtUEtDUzEtdjFfNVwiO1xuICB9XG5cbiAgLy8gIyMjIEZhbGxiYWNrIEltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBjZGF0YSkge1xuICAgIC8vIGNvbnZlcnQgY2RhdGEgdG8gYnl0ZSBzdHJpbmdcbiAgICBjZGF0YSA9IG5ldyBEYXRhQnVmZmVyKGNkYXRhKS5ieXRlcygpO1xuXG4gICAgLy8gZGVjcnlwdCBpdFxuICAgIHZhciBwa2kgPSByc2FVdGlsLmNvbnZlcnRUb0ZvcmdlKGtleSwgZmFsc2UpLFxuICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICBpZiAoXCJSU0EtT0FFUFwiID09PSBhbGcubmFtZSkge1xuICAgICAgcGFyYW1zLm1kID0gYWxnLmhhc2gubmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0vZywgXCJcIik7XG4gICAgICBwYXJhbXMubWQgPSBmb3JnZS5tZFtwYXJhbXMubWRdLmNyZWF0ZSgpO1xuICAgIH1cbiAgICB2YXIgcGRhdGEgPSBwa2kuZGVjcnlwdChjZGF0YSwgYWxnLm5hbWUudG9VcHBlckNhc2UoKSwgcGFyYW1zKTtcblxuICAgIC8vIGNvbnZlcnQgcGRhdGEgdG8gQnVmZmVyXG4gICAgcGRhdGEgPSBuZXcgRGF0YUJ1ZmZlcihwZGF0YSkubmF0aXZlKCk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBkYXRhKTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIEltcGxlbWVudGF0aW9uXG4gIHZhciB3ZWJjcnlwdG87XG4gIGlmIChcIlJTQUVTLVBLQ1MxLXYxXzVcIiAhPT0gYWxnLm5hbWUpIHtcbiAgICB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAgICBrZXkgPSByc2FVdGlsLmNvbnZlcnRUb0pXSyhrZXksIGZhbHNlKTtcbiAgICAgIHZhciBwcm9taXNlO1xuICAgICAgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcImp3a1wiLCBrZXksIGFsZywgdHJ1ZSwgW1wiZGVjcnlwdFwiXSk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uZGVjcnlwdChhbGcsIGtleSwgcGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICB2YXIgcGRhdGEgPSBCdWZmZXIuZnJvbShyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcGRhdGE7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB3ZWJjcnlwdG8gPSBudWxsO1xuICB9XG5cbiAgdmFyIG5vZGVqcztcbiAgaWYgKG5vZGVTdXBwb3J0Q2hlY2sobmFtZSkpIHsgLy8gbm9kZSBeNi4xMi4wIHx8ID49IDguMC4wXG4gICAgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgICAga2V5ID0gcnNhVXRpbC5jb252ZXJ0VG9QZW0oa2V5LCBmYWxzZSk7XG4gICAgICByZXR1cm4gaGVscGVycy5ub2RlQ3J5cHRvLnByaXZhdGVEZWNyeXB0KHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHBhZGRpbmc6IGhlbHBlcnMubm9kZUNyeXB0by5jb25zdGFudHNbbm9kZVN1cHBvcnRbbmFtZV1dXG4gICAgICB9LCBwZGF0YSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChoZWxwZXJzLm5vZGVDcnlwdG8gJiYgbmFtZSA9PT0gXCJSU0EtT0FFUFwiKSB7IC8vIG5vZGUgKD49IDYuMC4wICYmIDwgNi4xMi4wKSB8fCBeNy4wLjBcbiAgICBub2RlanMgPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAgICBrZXkgPSByc2FVdGlsLmNvbnZlcnRUb1BlbShrZXksIGZhbHNlKTtcbiAgICAgIHJldHVybiBoZWxwZXJzLm5vZGVDcnlwdG8ucHJpdmF0ZURlY3J5cHQoa2V5LCBwZGF0YSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuLy8gIyMjIFB1YmxpYyBBUElcbi8vICogW25hbWVdLmVuY3J5cHRcbi8vICogW25hbWVdLmRlY3J5cHRcbnZhciByc2FlcyA9IHt9O1xuW1xuICBcIlJTQS1PQUVQXCIsXG4gIFwiUlNBLU9BRVAtMjU2XCIsXG4gIFwiUlNBMV81XCJcbl0uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIHJzYWVzW25hbWVdID0ge1xuICAgIGVuY3J5cHQ6IHJzYWVzRW5jcnlwdEZuKG5hbWUpLFxuICAgIGRlY3J5cHQ6IHJzYWVzRGVjcnlwdEZuKG5hbWUpXG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSByc2FlcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/rsaes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/rsassa.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/rsassa.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/rsassa.js - RSA Signatures\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    rsaUtil = __webpack_require__(/*! ./rsa-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js\");\n\nfunction nodePSSsupport() {\n  return helpers.nodeCrypto && helpers.nodeCrypto.constants && helpers.nodeCrypto.constants.RSA_PSS_SALTLEN_DIGEST;\n}\n\n// ### RSASSA-PKCS1-v1_5\n\nfunction rsassaV15SignFn(name) {\n  var md = name.replace(\"RS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"RS\", \"SHA-\");\n\n  var alg = {\n    name: \"RSASSA-PKCS1-V1_5\",\n    hash: {\n      name: hash\n    }\n  };\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, pdata) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n\n    // sign it\n    var pki = rsaUtil.convertToForge(key, false);\n    var sig = pki.sign(digest, \"RSASSA-PKCS1-V1_5\");\n    sig = Buffer.from(sig, \"binary\");\n\n    return Promise.resolve({\n      data: pdata,\n      mac: sig\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata) {\n    key = rsaUtil.convertToJWK(key, false);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"sign\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      var sig = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = \"RSA-\" + hash.replace(\"-\", \"\");\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(nodeHash) > -1) {\n    nodejs = function(key, pdata) {\n      var sign = helpers.nodeCrypto.createSign(nodeHash);\n      sign.update(pdata);\n\n      return {\n        data: pdata,\n        mac: sign.sign(rsaUtil.convertToPem(key, false))\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction rsassaV15VerifyFn(name) {\n  var md = name.replace(\"RS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"RS\", \"SHA-\");\n  var alg = {\n    name: \"RSASSA-PKCS1-V1_5\",\n    hash: {\n      name: hash\n    }\n  };\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function(key, pdata, mac) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n    digest = digest.digest().bytes();\n\n    // verify it\n    var pki = rsaUtil.convertToForge(key, true);\n    var sig = mac.toString(\"binary\");\n    var result = pki.verify(digest, sig, \"RSASSA-PKCS1-V1_5\");\n    if (!result) {\n      return Promise.reject(new Error(\"verification failed\"));\n    }\n    return Promise.resolve({\n      data: pdata,\n      mac: mac,\n      valid: true\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata, mac) {\n    key = rsaUtil.convertToJWK(key, true);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"verify\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function(result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs;\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(md) > -1) {\n    nodejs = function(key, pdata, mac) {\n      var verify = helpers.nodeCrypto.createVerify(md);\n      verify.update(pdata);\n      verify.end();\n      var result = verify.verify(rsaUtil.convertToPem(key, true), mac);\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### RSA-PSS\nfunction rsassaPssSignFn(name) {\n  var md = name.replace(\"PS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"PS\", \"SHA-\");\n\n  var alg = {\n    name: \"RSA-PSS\",\n    hash: {\n      name: hash\n    },\n    saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n  };\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function (key, pdata) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n\n    // setup padding\n    var pss = forge.pss.create({\n      md: forge.md[md].create(),\n      mgf: forge.mgf.mgf1.create(forge.md[md].create()),\n      saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n    });\n\n    // sign it\n    var pki = rsaUtil.convertToForge(key, false);\n    var sig = pki.sign(digest, pss);\n    sig = Buffer.from(sig, \"binary\");\n\n    return Promise.resolve({\n      data: pdata,\n      mac: sig\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata) {\n    key = rsaUtil.convertToJWK(key, false);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"sign\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function (result) {\n      var sig = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = \"RSA-\" + hash.replace(\"-\", \"\");\n  if (nodePSSsupport()) {\n    nodejs = function(key, pdata) {\n      var sign = helpers.nodeCrypto.createSign(nodeHash);\n      sign.update(pdata);\n\n      var sig = sign.sign({\n        key: rsaUtil.convertToPem(key, false),\n        padding: helpers.nodeCrypto.constants.RSA_PKCS1_PSS_PADDING,\n        saltLength: helpers.nodeCrypto.constants.RSA_PSS_SALTLEN_DIGEST\n      });\n\n      return {\n        data: pdata,\n        mac: sig\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction rsassaPssVerifyFn(name) {\n  var md = name.replace(\"PS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"PS\", \"SHA-\");\n\n  var alg = {\n    name: \"RSA-PSS\",\n    hash: {\n      name: hash\n    },\n    saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n  };\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function (key, pdata, mac) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n    digest = digest.digest().bytes();\n\n    // setup padding\n    var pss = forge.pss.create({\n      md: forge.md[md].create(),\n      mgf: forge.mgf.mgf1.create(forge.md[md].create()),\n      saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n    });\n\n    // verify it\n    var pki = rsaUtil.convertToForge(key, true);\n    var sig = mac.toString(\"binary\");\n    var result = pki.verify(digest, sig, pss);\n    if (!result) {\n      return Promise.reject(new Error(\"verification failed\"));\n    }\n    return Promise.resolve({\n      data: pdata,\n      mac: mac,\n      valid: true\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata, mac) {\n    key = rsaUtil.convertToJWK(key, true);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"verify\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function (result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs;\n  if (nodePSSsupport()) {\n    nodejs = function(key, pdata, mac) {\n      var verify = helpers.nodeCrypto.createVerify(md);\n      verify.update(pdata);\n      verify.end();\n      var result = verify.verify({\n        key: rsaUtil.convertToPem(key, true),\n        padding: helpers.nodeCrypto.constants.RSA_PKCS1_PSS_PADDING,\n        saltLength: helpers.nodeCrypto.constants.RSA_PSS_SALTLEN_DIGEST\n      }, mac);\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].sign\n// * [name].verify\nvar rsassa = {};\n[\n  \"PS256\",\n  \"PS384\",\n  \"PS512\"\n].forEach(function(name) {\n  rsassa[name] = {\n    sign: rsassaPssSignFn(name),\n    verify: rsassaPssVerifyFn(name)\n  };\n});\n\n[\n  \"RS256\",\n  \"RS384\",\n  \"RS512\"\n].forEach(function(name) {\n  rsassa[name] = {\n    sign: rsassaV15SignFn(name),\n    verify: rsassaV15VerifyFn(name)\n  };\n});\n\nmodule.exports = rsassa;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3JzYXNzYS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBYTtBQUNyQyxjQUFjLG1CQUFPLENBQUMsOEVBQWM7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLGdGQUFlOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9yc2Fzc2EuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL3JzYXNzYS5qcyAtIFJTQSBTaWduYXR1cmVzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZS5qc1wiKSxcbiAgICBDT05TVEFOVFMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIiksXG4gICAgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIiksXG4gICAgcnNhVXRpbCA9IHJlcXVpcmUoXCIuL3JzYS11dGlsLmpzXCIpO1xuXG5mdW5jdGlvbiBub2RlUFNTc3VwcG9ydCgpIHtcbiAgcmV0dXJuIGhlbHBlcnMubm9kZUNyeXB0byAmJiBoZWxwZXJzLm5vZGVDcnlwdG8uY29uc3RhbnRzICYmIGhlbHBlcnMubm9kZUNyeXB0by5jb25zdGFudHMuUlNBX1BTU19TQUxUTEVOX0RJR0VTVDtcbn1cblxuLy8gIyMjIFJTQVNTQS1QS0NTMS12MV81XG5cbmZ1bmN0aW9uIHJzYXNzYVYxNVNpZ25GbihuYW1lKSB7XG4gIHZhciBtZCA9IG5hbWUucmVwbGFjZShcIlJTXCIsIFwiU0hBXCIpLnRvTG93ZXJDYXNlKCksXG4gICAgICBoYXNoID0gbmFtZS5yZXBsYWNlKFwiUlNcIiwgXCJTSEEtXCIpO1xuXG4gIHZhciBhbGcgPSB7XG4gICAgbmFtZTogXCJSU0FTU0EtUEtDUzEtVjFfNVwiLFxuICAgIGhhc2g6IHtcbiAgICAgIG5hbWU6IGhhc2hcbiAgICB9XG4gIH07XG5cbiAgLy8gIyMjIEZhbGxiYWNrIEltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgIC8vIGNyZWF0ZSB0aGUgZGlnZXN0XG4gICAgdmFyIGRpZ2VzdCA9IGZvcmdlLm1kW21kXS5jcmVhdGUoKTtcbiAgICBkaWdlc3Quc3RhcnQoKTtcbiAgICBkaWdlc3QudXBkYXRlKHBkYXRhKTtcblxuICAgIC8vIHNpZ24gaXRcbiAgICB2YXIgcGtpID0gcnNhVXRpbC5jb252ZXJ0VG9Gb3JnZShrZXksIGZhbHNlKTtcbiAgICB2YXIgc2lnID0gcGtpLnNpZ24oZGlnZXN0LCBcIlJTQVNTQS1QS0NTMS1WMV81XCIpO1xuICAgIHNpZyA9IEJ1ZmZlci5mcm9tKHNpZywgXCJiaW5hcnlcIik7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgbWFjOiBzaWdcbiAgICB9KTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIEltcGxlbWVudGF0aW9uXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAga2V5ID0gcnNhVXRpbC5jb252ZXJ0VG9KV0soa2V5LCBmYWxzZSk7XG4gICAgdmFyIHByb21pc2U7XG4gICAgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcImp3a1wiLCBrZXksIGFsZywgdHJ1ZSwgW1wic2lnblwiXSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5zaWduKGFsZywga2V5LCBwZGF0YSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHZhciBzaWcgPSBCdWZmZXIuZnJvbShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogc2lnXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgdmFyIG5vZGVqcztcbiAgdmFyIG5vZGVIYXNoID0gXCJSU0EtXCIgKyBoYXNoLnJlcGxhY2UoXCItXCIsIFwiXCIpO1xuICBpZiAoaGVscGVycy5ub2RlQ3J5cHRvICYmIGhlbHBlcnMubm9kZUNyeXB0by5nZXRIYXNoZXMoKS5pbmRleE9mKG5vZGVIYXNoKSA+IC0xKSB7XG4gICAgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgICAgdmFyIHNpZ24gPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlU2lnbihub2RlSGFzaCk7XG4gICAgICBzaWduLnVwZGF0ZShwZGF0YSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IHNpZ24uc2lnbihyc2FVdGlsLmNvbnZlcnRUb1BlbShrZXksIGZhbHNlKSlcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcnNhc3NhVjE1VmVyaWZ5Rm4obmFtZSkge1xuICB2YXIgbWQgPSBuYW1lLnJlcGxhY2UoXCJSU1wiLCBcIlNIQVwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgaGFzaCA9IG5hbWUucmVwbGFjZShcIlJTXCIsIFwiU0hBLVwiKTtcbiAgdmFyIGFsZyA9IHtcbiAgICBuYW1lOiBcIlJTQVNTQS1QS0NTMS1WMV81XCIsXG4gICAgaGFzaDoge1xuICAgICAgbmFtZTogaGFzaFxuICAgIH1cbiAgfTtcblxuICAvLyAjIyMgRmFsbGJhY2sgaW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIHBkYXRhLCBtYWMpIHtcbiAgICAvLyBjcmVhdGUgdGhlIGRpZ2VzdFxuICAgIHZhciBkaWdlc3QgPSBmb3JnZS5tZFttZF0uY3JlYXRlKCk7XG4gICAgZGlnZXN0LnN0YXJ0KCk7XG4gICAgZGlnZXN0LnVwZGF0ZShwZGF0YSk7XG4gICAgZGlnZXN0ID0gZGlnZXN0LmRpZ2VzdCgpLmJ5dGVzKCk7XG5cbiAgICAvLyB2ZXJpZnkgaXRcbiAgICB2YXIgcGtpID0gcnNhVXRpbC5jb252ZXJ0VG9Gb3JnZShrZXksIHRydWUpO1xuICAgIHZhciBzaWcgPSBtYWMudG9TdHJpbmcoXCJiaW5hcnlcIik7XG4gICAgdmFyIHJlc3VsdCA9IHBraS52ZXJpZnkoZGlnZXN0LCBzaWcsIFwiUlNBU1NBLVBLQ1MxLVYxXzVcIik7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ2ZXJpZmljYXRpb24gZmFpbGVkXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBkYXRhOiBwZGF0YSxcbiAgICAgIG1hYzogbWFjLFxuICAgICAgdmFsaWQ6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIEltcGxlbWVudGF0aW9uXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHBkYXRhLCBtYWMpIHtcbiAgICBrZXkgPSByc2FVdGlsLmNvbnZlcnRUb0pXSyhrZXksIHRydWUpO1xuICAgIHZhciBwcm9taXNlO1xuICAgIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJqd2tcIiwga2V5LCBhbGcsIHRydWUsIFtcInZlcmlmeVwiXSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by52ZXJpZnkoYWxnLCBrZXksIG1hYywgcGRhdGEpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidmVyaWZpY2F0aW9uIGZhaWxlZFwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IG1hYyxcbiAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICB2YXIgbm9kZWpzO1xuICBpZiAoaGVscGVycy5ub2RlQ3J5cHRvICYmIGhlbHBlcnMubm9kZUNyeXB0by5nZXRIYXNoZXMoKS5pbmRleE9mKG1kKSA+IC0xKSB7XG4gICAgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgbWFjKSB7XG4gICAgICB2YXIgdmVyaWZ5ID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZVZlcmlmeShtZCk7XG4gICAgICB2ZXJpZnkudXBkYXRlKHBkYXRhKTtcbiAgICAgIHZlcmlmeS5lbmQoKTtcbiAgICAgIHZhciByZXN1bHQgPSB2ZXJpZnkudmVyaWZ5KHJzYVV0aWwuY29udmVydFRvUGVtKGtleSwgdHJ1ZSksIG1hYyk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidmVyaWZpY2F0aW9uIGZhaWxlZFwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IG1hYyxcbiAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuLy8gIyMjIFJTQS1QU1NcbmZ1bmN0aW9uIHJzYXNzYVBzc1NpZ25GbihuYW1lKSB7XG4gIHZhciBtZCA9IG5hbWUucmVwbGFjZShcIlBTXCIsIFwiU0hBXCIpLnRvTG93ZXJDYXNlKCksXG4gICAgICBoYXNoID0gbmFtZS5yZXBsYWNlKFwiUFNcIiwgXCJTSEEtXCIpO1xuXG4gIHZhciBhbGcgPSB7XG4gICAgbmFtZTogXCJSU0EtUFNTXCIsXG4gICAgaGFzaDoge1xuICAgICAgbmFtZTogaGFzaFxuICAgIH0sXG4gICAgc2FsdExlbmd0aDogQ09OU1RBTlRTLkhBU0hMRU5HVEhbaGFzaF0gLyA4XG4gIH07XG5cbiAgLy8gIyMjIEZhbGxiYWNrIGltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24gKGtleSwgcGRhdGEpIHtcbiAgICAvLyBjcmVhdGUgdGhlIGRpZ2VzdFxuICAgIHZhciBkaWdlc3QgPSBmb3JnZS5tZFttZF0uY3JlYXRlKCk7XG4gICAgZGlnZXN0LnN0YXJ0KCk7XG4gICAgZGlnZXN0LnVwZGF0ZShwZGF0YSk7XG5cbiAgICAvLyBzZXR1cCBwYWRkaW5nXG4gICAgdmFyIHBzcyA9IGZvcmdlLnBzcy5jcmVhdGUoe1xuICAgICAgbWQ6IGZvcmdlLm1kW21kXS5jcmVhdGUoKSxcbiAgICAgIG1nZjogZm9yZ2UubWdmLm1nZjEuY3JlYXRlKGZvcmdlLm1kW21kXS5jcmVhdGUoKSksXG4gICAgICBzYWx0TGVuZ3RoOiBDT05TVEFOVFMuSEFTSExFTkdUSFtoYXNoXSAvIDhcbiAgICB9KTtcblxuICAgIC8vIHNpZ24gaXRcbiAgICB2YXIgcGtpID0gcnNhVXRpbC5jb252ZXJ0VG9Gb3JnZShrZXksIGZhbHNlKTtcbiAgICB2YXIgc2lnID0gcGtpLnNpZ24oZGlnZXN0LCBwc3MpO1xuICAgIHNpZyA9IEJ1ZmZlci5mcm9tKHNpZywgXCJiaW5hcnlcIik7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgbWFjOiBzaWdcbiAgICB9KTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIEltcGxlbWVudGF0aW9uXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAga2V5ID0gcnNhVXRpbC5jb252ZXJ0VG9KV0soa2V5LCBmYWxzZSk7XG4gICAgdmFyIHByb21pc2U7XG4gICAgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcImp3a1wiLCBrZXksIGFsZywgdHJ1ZSwgW1wic2lnblwiXSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uc2lnbihhbGcsIGtleSwgcGRhdGEpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgdmFyIHNpZyA9IEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBzaWdcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICB2YXIgbm9kZWpzO1xuICB2YXIgbm9kZUhhc2ggPSBcIlJTQS1cIiArIGhhc2gucmVwbGFjZShcIi1cIiwgXCJcIik7XG4gIGlmIChub2RlUFNTc3VwcG9ydCgpKSB7XG4gICAgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgICAgdmFyIHNpZ24gPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlU2lnbihub2RlSGFzaCk7XG4gICAgICBzaWduLnVwZGF0ZShwZGF0YSk7XG5cbiAgICAgIHZhciBzaWcgPSBzaWduLnNpZ24oe1xuICAgICAgICBrZXk6IHJzYVV0aWwuY29udmVydFRvUGVtKGtleSwgZmFsc2UpLFxuICAgICAgICBwYWRkaW5nOiBoZWxwZXJzLm5vZGVDcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9QU1NfUEFERElORyxcbiAgICAgICAgc2FsdExlbmd0aDogaGVscGVycy5ub2RlQ3J5cHRvLmNvbnN0YW50cy5SU0FfUFNTX1NBTFRMRU5fRElHRVNUXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogc2lnXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHJzYXNzYVBzc1ZlcmlmeUZuKG5hbWUpIHtcbiAgdmFyIG1kID0gbmFtZS5yZXBsYWNlKFwiUFNcIiwgXCJTSEFcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgIGhhc2ggPSBuYW1lLnJlcGxhY2UoXCJQU1wiLCBcIlNIQS1cIik7XG5cbiAgdmFyIGFsZyA9IHtcbiAgICBuYW1lOiBcIlJTQS1QU1NcIixcbiAgICBoYXNoOiB7XG4gICAgICBuYW1lOiBoYXNoXG4gICAgfSxcbiAgICBzYWx0TGVuZ3RoOiBDT05TVEFOVFMuSEFTSExFTkdUSFtoYXNoXSAvIDhcbiAgfTtcblxuICAvLyAjIyMgRmFsbGJhY2sgaW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbiAoa2V5LCBwZGF0YSwgbWFjKSB7XG4gICAgLy8gY3JlYXRlIHRoZSBkaWdlc3RcbiAgICB2YXIgZGlnZXN0ID0gZm9yZ2UubWRbbWRdLmNyZWF0ZSgpO1xuICAgIGRpZ2VzdC5zdGFydCgpO1xuICAgIGRpZ2VzdC51cGRhdGUocGRhdGEpO1xuICAgIGRpZ2VzdCA9IGRpZ2VzdC5kaWdlc3QoKS5ieXRlcygpO1xuXG4gICAgLy8gc2V0dXAgcGFkZGluZ1xuICAgIHZhciBwc3MgPSBmb3JnZS5wc3MuY3JlYXRlKHtcbiAgICAgIG1kOiBmb3JnZS5tZFttZF0uY3JlYXRlKCksXG4gICAgICBtZ2Y6IGZvcmdlLm1nZi5tZ2YxLmNyZWF0ZShmb3JnZS5tZFttZF0uY3JlYXRlKCkpLFxuICAgICAgc2FsdExlbmd0aDogQ09OU1RBTlRTLkhBU0hMRU5HVEhbaGFzaF0gLyA4XG4gICAgfSk7XG5cbiAgICAvLyB2ZXJpZnkgaXRcbiAgICB2YXIgcGtpID0gcnNhVXRpbC5jb252ZXJ0VG9Gb3JnZShrZXksIHRydWUpO1xuICAgIHZhciBzaWcgPSBtYWMudG9TdHJpbmcoXCJiaW5hcnlcIik7XG4gICAgdmFyIHJlc3VsdCA9IHBraS52ZXJpZnkoZGlnZXN0LCBzaWcsIHBzcyk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ2ZXJpZmljYXRpb24gZmFpbGVkXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBkYXRhOiBwZGF0YSxcbiAgICAgIG1hYzogbWFjLFxuICAgICAgdmFsaWQ6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIEltcGxlbWVudGF0aW9uXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHBkYXRhLCBtYWMpIHtcbiAgICBrZXkgPSByc2FVdGlsLmNvbnZlcnRUb0pXSyhrZXksIHRydWUpO1xuICAgIHZhciBwcm9taXNlO1xuICAgIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJqd2tcIiwga2V5LCBhbGcsIHRydWUsIFtcInZlcmlmeVwiXSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8udmVyaWZ5KGFsZywga2V5LCBtYWMsIHBkYXRhKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ2ZXJpZmljYXRpb24gZmFpbGVkXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogbWFjLFxuICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHZhciBub2RlanM7XG4gIGlmIChub2RlUFNTc3VwcG9ydCgpKSB7XG4gICAgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgbWFjKSB7XG4gICAgICB2YXIgdmVyaWZ5ID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZVZlcmlmeShtZCk7XG4gICAgICB2ZXJpZnkudXBkYXRlKHBkYXRhKTtcbiAgICAgIHZlcmlmeS5lbmQoKTtcbiAgICAgIHZhciByZXN1bHQgPSB2ZXJpZnkudmVyaWZ5KHtcbiAgICAgICAga2V5OiByc2FVdGlsLmNvbnZlcnRUb1BlbShrZXksIHRydWUpLFxuICAgICAgICBwYWRkaW5nOiBoZWxwZXJzLm5vZGVDcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9QU1NfUEFERElORyxcbiAgICAgICAgc2FsdExlbmd0aDogaGVscGVycy5ub2RlQ3J5cHRvLmNvbnN0YW50cy5SU0FfUFNTX1NBTFRMRU5fRElHRVNUXG4gICAgICB9LCBtYWMpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInZlcmlmaWNhdGlvbiBmYWlsZWRcIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBtYWMsXG4gICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbi8vICMjIyBQdWJsaWMgQVBJXG4vLyAqIFtuYW1lXS5zaWduXG4vLyAqIFtuYW1lXS52ZXJpZnlcbnZhciByc2Fzc2EgPSB7fTtcbltcbiAgXCJQUzI1NlwiLFxuICBcIlBTMzg0XCIsXG4gIFwiUFM1MTJcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgcnNhc3NhW25hbWVdID0ge1xuICAgIHNpZ246IHJzYXNzYVBzc1NpZ25GbihuYW1lKSxcbiAgICB2ZXJpZnk6IHJzYXNzYVBzc1ZlcmlmeUZuKG5hbWUpXG4gIH07XG59KTtcblxuW1xuICBcIlJTMjU2XCIsXG4gIFwiUlMzODRcIixcbiAgXCJSUzUxMlwiXG5dLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICByc2Fzc2FbbmFtZV0gPSB7XG4gICAgc2lnbjogcnNhc3NhVjE1U2lnbkZuKG5hbWUpLFxuICAgIHZlcmlmeTogcnNhc3NhVjE1VmVyaWZ5Rm4obmFtZSlcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJzYXNzYTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/rsassa.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/sha.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/sha.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/sha.js - Cryptographic Secure Hash Algorithms, versions 1 and 2\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\");\n\nfunction hashDigestFN(hash) {\n  var md = hash.replace(\"SHA-\", \"SHA\").toLowerCase();\n\n  var alg = {\n    name: hash\n  };\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(pdata /* props */) {\n    var digest = forge.md[md].create();\n    digest.update(pdata.toString(\"binary\"));\n    digest = Buffer.from(digest.digest().bytes(), \"binary\");\n\n    return Promise.resolve(digest);\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(pdata /* props */) {\n    var promise;\n    promise = helpers.subtleCrypto.digest(alg, pdata);\n    promise = promise.then(function(result) {\n      result = Buffer.from(result);\n      return result;\n    });\n    return promise;\n  };\n\n  // ### nodejs Implementation\n  var nodejs = function(pdata /* props */) {\n    var digest = helpers.nodeCrypto.createHash(md);\n    digest.update(pdata);\n    return digest.digest();\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// Public API\n// * [name].digest\nvar sha = {};\n[\n  \"SHA-1\",\n  \"SHA-256\",\n  \"SHA-384\",\n  \"SHA-512\"\n].forEach(function(name) {\n  sha[name] = {\n    digest: hashDigestFN(name)\n  };\n});\n\nmodule.exports = sha;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3NoYS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QyxjQUFjLG1CQUFPLENBQUMsOEVBQWM7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9zaGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL3NoYS5qcyAtIENyeXB0b2dyYXBoaWMgU2VjdXJlIEhhc2ggQWxnb3JpdGhtcywgdmVyc2lvbnMgMSBhbmQgMlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2UuanNcIiksXG4gICAgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIik7XG5cbmZ1bmN0aW9uIGhhc2hEaWdlc3RGTihoYXNoKSB7XG4gIHZhciBtZCA9IGhhc2gucmVwbGFjZShcIlNIQS1cIiwgXCJTSEFcIikudG9Mb3dlckNhc2UoKTtcblxuICB2YXIgYWxnID0ge1xuICAgIG5hbWU6IGhhc2hcbiAgfTtcblxuICAvLyAjIyMgRmFsbGJhY2sgSW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihwZGF0YSAvKiBwcm9wcyAqLykge1xuICAgIHZhciBkaWdlc3QgPSBmb3JnZS5tZFttZF0uY3JlYXRlKCk7XG4gICAgZGlnZXN0LnVwZGF0ZShwZGF0YS50b1N0cmluZyhcImJpbmFyeVwiKSk7XG4gICAgZGlnZXN0ID0gQnVmZmVyLmZyb20oZGlnZXN0LmRpZ2VzdCgpLmJ5dGVzKCksIFwiYmluYXJ5XCIpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkaWdlc3QpO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgSW1wbGVtZW50YXRpb25cbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKHBkYXRhIC8qIHByb3BzICovKSB7XG4gICAgdmFyIHByb21pc2U7XG4gICAgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmRpZ2VzdChhbGcsIHBkYXRhKTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gQnVmZmVyLmZyb20ocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gIyMjIG5vZGVqcyBJbXBsZW1lbnRhdGlvblxuICB2YXIgbm9kZWpzID0gZnVuY3Rpb24ocGRhdGEgLyogcHJvcHMgKi8pIHtcbiAgICB2YXIgZGlnZXN0ID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZUhhc2gobWQpO1xuICAgIGRpZ2VzdC51cGRhdGUocGRhdGEpO1xuICAgIHJldHVybiBkaWdlc3QuZGlnZXN0KCk7XG4gIH07XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG4vLyBQdWJsaWMgQVBJXG4vLyAqIFtuYW1lXS5kaWdlc3RcbnZhciBzaGEgPSB7fTtcbltcbiAgXCJTSEEtMVwiLFxuICBcIlNIQS0yNTZcIixcbiAgXCJTSEEtMzg0XCIsXG4gIFwiU0hBLTUxMlwiXG5dLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICBzaGFbbmFtZV0gPSB7XG4gICAgZGlnZXN0OiBoYXNoRGlnZXN0Rk4obmFtZSlcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js":
/*!********************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/gcm/helpers.js - AES-GCM Helper Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/umd/index.js\"),\n    fill = __webpack_require__(/*! lodash/fill */ \"(ssr)/./node_modules/lodash/fill.js\"),\n    pack = __webpack_require__(/*! ../pack.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\");\n\nvar E1 = 0xe1000000,\n    E1B = 0xe1,\n    E1L = new Long(E1 >> 8);\n\nfunction generateLookup() {\n  var lookup = [];\n\n  for (var c = 0; c < 256; ++c) {\n    var v = 0;\n    for (var i = 7; i >= 0; --i) {\n      if ((c & (1 << i)) !== 0) {\n        v ^= (E1 >>> (7 - i));\n      }\n    }\n    lookup.push(v);\n  }\n\n  return lookup;\n}\n\nvar helpers = module.exports = {\n  // ### Constants\n  E1: E1,\n  E1B: E1B,\n  E1L: E1L,\n  LOOKUP: generateLookup(),\n\n  // ### Array Helpers\n  arrayCopy: function(src, srcPos, dest, destPos, length) {\n    // Start by checking for negatives since arrays in JS auto-expand\n    if (srcPos < 0 || destPos < 0 || length < 0) {\n      throw new TypeError(\"Invalid input.\");\n    }\n\n    if (dest instanceof Uint8Array) {\n      // Check for overflow if dest is a typed-array\n      if (destPos >= dest.length || (destPos + length) > dest.length) {\n        throw new TypeError(\"Invalid input.\");\n      }\n\n      if (srcPos !== 0 || length < src.length) {\n        if (src instanceof Uint8Array) {\n          src = src.subarray(srcPos, srcPos + length);\n        } else {\n          src = src.slice(srcPos, srcPos + length);\n        }\n      }\n\n      dest.set(src, destPos);\n    } else {\n      for (var i = 0; i < length; ++i) {\n        dest[destPos + i] = src[srcPos + i];\n      }\n    }\n  },\n  arrayEqual: function(a1, a2) {\n    a1 = a1 || [];\n    a2 = a2 || [];\n\n    var len = Math.min(a1.length, a2.length),\n        result = (a1.length === a2.length);\n\n    for (var idx = 0; idx < len; idx++) {\n      result = result &&\n               (\"undefined\" !== typeof a1[idx]) &&\n               (\"undefined\" !== typeof a2[idx]) &&\n               (a1[idx] === a2[idx]);\n    }\n\n    return result;\n  },\n\n  // ### Conversions\n  asBytes: function(x, z) {\n    switch (arguments.length) {\n      case 1:\n        z = Buffer.alloc(16);\n        pack.intToBigEndian(x, z, 0);\n        return z;\n      case 2:\n        pack.intToBigEndian(x, z, 0);\n        break;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  },\n  asInts: function(x, z) {\n    switch (arguments.length) {\n      case 1:\n        z = [];\n        fill(z, 0, 0, 4);\n        pack.bigEndianToInt(x, 0, z);\n        return z;\n      case 2:\n        pack.bigEndianToInt(x, 0, z);\n        break;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  },\n  oneAsInts: function() {\n    var tmp = [];\n    for (var c = 0; c < 4; ++c) {\n        tmp.push(1 << 31);\n    }\n    return tmp;\n  },\n\n  // ## Bit-wise\n  shiftRight: function(x, z) {\n    var b, c;\n    switch (arguments.length) {\n      case 1:\n        b = x[0];\n        x[0] = b >>> 1;\n        c = b << 31;\n        b = x[1];\n        x[1] = (b >>> 1) | c;\n        c = b << 31;\n        b = x[2];\n        x[2] = (b >>> 1) | c;\n        c = b << 31;\n        b = x[3];\n        x[3] = (b >>> 1) | c;\n        return (b << 31) & 0xffffffff;\n      case 2:\n        b = x[0];\n        z[0] = b >>> 1;\n        c = b << 31;\n        b = x[1];\n        z[1] = (b >>> 1) | c;\n        c = b << 31;\n        b = x[2];\n        z[2] = (b >>> 1) | c;\n        c = b << 31;\n        b = x[3];\n        z[3] = (b >>> 1) | c;\n        return (b << 31) & 0xffffffff;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  },\n  shiftRightN: function(x, n, z) {\n    var nInv, b, c;\n    switch (arguments.length) {\n      case 2:\n        b = x[0];\n        nInv = 32 - n;\n        x[0] = b >>> n;\n        c = b << nInv;\n        b = x[1];\n        x[1] = (b >>> n) | c;\n        c = b << nInv;\n        b = x[2];\n        x[2] = (b >>> n) | c;\n        c = b << nInv;\n        b = x[3];\n        x[3] = (b >>> n) | c;\n        return b << nInv;\n      case 3:\n        b = x[0];\n        nInv = 32 - n;\n        z[0] = b >>> n;\n        c = b << nInv;\n        b = x[1];\n        z[1] = (b >>> n) | c;\n        c = b << nInv;\n        b = x[2];\n        z[2] = (b >>> n) | c;\n        c = b << nInv;\n        b = x[3];\n        z[3] = (b >>> n) | c;\n        return b << nInv;\n      default:\n        throw new TypeError(\"Expected 2 or 3 arguments.\");\n    }\n  },\n  xor: function(x, y, z) {\n    switch (arguments.length) {\n      case 2:\n        x[0] ^= y[0];\n        x[1] ^= y[1];\n        x[2] ^= y[2];\n        x[3] ^= y[3];\n        break;\n      case 3:\n        z[0] = x[0] ^ y[0];\n        z[1] = x[1] ^ y[1];\n        z[2] = x[2] ^ y[2];\n        z[3] = x[3] ^ y[3];\n        break;\n      default:\n        throw new TypeError(\"Expected 2 or 3 arguments.\");\n    }\n  },\n\n  multiply: function(x, y) {\n    var r0 = x.slice();\n    var r1 = [];\n\n    for (var i = 0; i < 4; ++i) {\n      var bits = y[i];\n      for (var j = 31; j >= 0; --j) {\n        if ((bits & (1 << j)) !== 0) {\n          helpers.xor(r1, r0);\n        }\n\n        if (helpers.shiftRight(r0) !== 0) {\n          r0[0] ^= helpers.E1;\n        }\n      }\n    }\n\n    helpers.arrayCopy(r1, 0, x, 0, 4);\n  },\n  multiplyP: function(x, y) {\n    switch (arguments.length) {\n      case 1:\n        if (helpers.shiftRight(x) !== 0) {\n          x[0] ^= helpers.E1;\n        }\n        break;\n      case 2:\n        if (helpers.shiftRight(x, y) !== 0) {\n          y[0] ^= helpers.E1;\n        }\n        break;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  },\n  multiplyP8: function(x, y) {\n    var c;\n    switch (arguments.length) {\n      case 1:\n        c = helpers.shiftRightN(x, 8);\n        x[0] ^= helpers.LOOKUP[c >>> 24];\n        break;\n      case 2:\n        c = helpers.shiftRightN(x, 8, y);\n        y[0] ^= helpers.LOOKUP[c >>> 24];\n        break;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2djbS9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsb0RBQU07QUFDekIsV0FBVyxtQkFBTyxDQUFDLHdEQUFhO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQywrRUFBWTs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTixzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2djbS9oZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogZGVwcy9jaXBoZXJtb2Rlcy9nY20vaGVscGVycy5qcyAtIEFFUy1HQ00gSGVscGVyIEZ1bmN0aW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIExvbmcgPSByZXF1aXJlKFwibG9uZ1wiKSxcbiAgICBmaWxsID0gcmVxdWlyZShcImxvZGFzaC9maWxsXCIpLFxuICAgIHBhY2sgPSByZXF1aXJlKFwiLi4vcGFjay5qc1wiKTtcblxudmFyIEUxID0gMHhlMTAwMDAwMCxcbiAgICBFMUIgPSAweGUxLFxuICAgIEUxTCA9IG5ldyBMb25nKEUxID4+IDgpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUxvb2t1cCgpIHtcbiAgdmFyIGxvb2t1cCA9IFtdO1xuXG4gIGZvciAodmFyIGMgPSAwOyBjIDwgMjU2OyArK2MpIHtcbiAgICB2YXIgdiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDc7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAoKGMgJiAoMSA8PCBpKSkgIT09IDApIHtcbiAgICAgICAgdiBePSAoRTEgPj4+ICg3IC0gaSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBsb29rdXAucHVzaCh2KTtcbiAgfVxuXG4gIHJldHVybiBsb29rdXA7XG59XG5cbnZhciBoZWxwZXJzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vICMjIyBDb25zdGFudHNcbiAgRTE6IEUxLFxuICBFMUI6IEUxQixcbiAgRTFMOiBFMUwsXG4gIExPT0tVUDogZ2VuZXJhdGVMb29rdXAoKSxcblxuICAvLyAjIyMgQXJyYXkgSGVscGVyc1xuICBhcnJheUNvcHk6IGZ1bmN0aW9uKHNyYywgc3JjUG9zLCBkZXN0LCBkZXN0UG9zLCBsZW5ndGgpIHtcbiAgICAvLyBTdGFydCBieSBjaGVja2luZyBmb3IgbmVnYXRpdmVzIHNpbmNlIGFycmF5cyBpbiBKUyBhdXRvLWV4cGFuZFxuICAgIGlmIChzcmNQb3MgPCAwIHx8IGRlc3RQb3MgPCAwIHx8IGxlbmd0aCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGlucHV0LlwiKTtcbiAgICB9XG5cbiAgICBpZiAoZGVzdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIC8vIENoZWNrIGZvciBvdmVyZmxvdyBpZiBkZXN0IGlzIGEgdHlwZWQtYXJyYXlcbiAgICAgIGlmIChkZXN0UG9zID49IGRlc3QubGVuZ3RoIHx8IChkZXN0UG9zICsgbGVuZ3RoKSA+IGRlc3QubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGlucHV0LlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNyY1BvcyAhPT0gMCB8fCBsZW5ndGggPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzcmMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YmFycmF5KHNyY1Bvcywgc3JjUG9zICsgbGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc2xpY2Uoc3JjUG9zLCBzcmNQb3MgKyBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlc3Quc2V0KHNyYywgZGVzdFBvcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZGVzdFtkZXN0UG9zICsgaV0gPSBzcmNbc3JjUG9zICsgaV07XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBhcnJheUVxdWFsOiBmdW5jdGlvbihhMSwgYTIpIHtcbiAgICBhMSA9IGExIHx8IFtdO1xuICAgIGEyID0gYTIgfHwgW107XG5cbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYTEubGVuZ3RoLCBhMi5sZW5ndGgpLFxuICAgICAgICByZXN1bHQgPSAoYTEubGVuZ3RoID09PSBhMi5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmXG4gICAgICAgICAgICAgICAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGExW2lkeF0pICYmXG4gICAgICAgICAgICAgICAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGEyW2lkeF0pICYmXG4gICAgICAgICAgICAgICAoYTFbaWR4XSA9PT0gYTJbaWR4XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvLyAjIyMgQ29udmVyc2lvbnNcbiAgYXNCeXRlczogZnVuY3Rpb24oeCwgeikge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICB6ID0gQnVmZmVyLmFsbG9jKDE2KTtcbiAgICAgICAgcGFjay5pbnRUb0JpZ0VuZGlhbih4LCB6LCAwKTtcbiAgICAgICAgcmV0dXJuIHo7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHBhY2suaW50VG9CaWdFbmRpYW4oeCwgeiwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDEgb3IgMiBhcmd1bWVudHMuXCIpO1xuICAgIH1cbiAgfSxcbiAgYXNJbnRzOiBmdW5jdGlvbih4LCB6KSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHogPSBbXTtcbiAgICAgICAgZmlsbCh6LCAwLCAwLCA0KTtcbiAgICAgICAgcGFjay5iaWdFbmRpYW5Ub0ludCh4LCAwLCB6KTtcbiAgICAgICAgcmV0dXJuIHo7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHBhY2suYmlnRW5kaWFuVG9JbnQoeCwgMCwgeik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDEgb3IgMiBhcmd1bWVudHMuXCIpO1xuICAgIH1cbiAgfSxcbiAgb25lQXNJbnRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG1wID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCA0OyArK2MpIHtcbiAgICAgICAgdG1wLnB1c2goMSA8PCAzMSk7XG4gICAgfVxuICAgIHJldHVybiB0bXA7XG4gIH0sXG5cbiAgLy8gIyMgQml0LXdpc2VcbiAgc2hpZnRSaWdodDogZnVuY3Rpb24oeCwgeikge1xuICAgIHZhciBiLCBjO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBiID0geFswXTtcbiAgICAgICAgeFswXSA9IGIgPj4+IDE7XG4gICAgICAgIGMgPSBiIDw8IDMxO1xuICAgICAgICBiID0geFsxXTtcbiAgICAgICAgeFsxXSA9IChiID4+PiAxKSB8IGM7XG4gICAgICAgIGMgPSBiIDw8IDMxO1xuICAgICAgICBiID0geFsyXTtcbiAgICAgICAgeFsyXSA9IChiID4+PiAxKSB8IGM7XG4gICAgICAgIGMgPSBiIDw8IDMxO1xuICAgICAgICBiID0geFszXTtcbiAgICAgICAgeFszXSA9IChiID4+PiAxKSB8IGM7XG4gICAgICAgIHJldHVybiAoYiA8PCAzMSkgJiAweGZmZmZmZmZmO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBiID0geFswXTtcbiAgICAgICAgelswXSA9IGIgPj4+IDE7XG4gICAgICAgIGMgPSBiIDw8IDMxO1xuICAgICAgICBiID0geFsxXTtcbiAgICAgICAgelsxXSA9IChiID4+PiAxKSB8IGM7XG4gICAgICAgIGMgPSBiIDw8IDMxO1xuICAgICAgICBiID0geFsyXTtcbiAgICAgICAgelsyXSA9IChiID4+PiAxKSB8IGM7XG4gICAgICAgIGMgPSBiIDw8IDMxO1xuICAgICAgICBiID0geFszXTtcbiAgICAgICAgelszXSA9IChiID4+PiAxKSB8IGM7XG4gICAgICAgIHJldHVybiAoYiA8PCAzMSkgJiAweGZmZmZmZmZmO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDEgb3IgMiBhcmd1bWVudHMuXCIpO1xuICAgIH1cbiAgfSxcbiAgc2hpZnRSaWdodE46IGZ1bmN0aW9uKHgsIG4sIHopIHtcbiAgICB2YXIgbkludiwgYiwgYztcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgYiA9IHhbMF07XG4gICAgICAgIG5JbnYgPSAzMiAtIG47XG4gICAgICAgIHhbMF0gPSBiID4+PiBuO1xuICAgICAgICBjID0gYiA8PCBuSW52O1xuICAgICAgICBiID0geFsxXTtcbiAgICAgICAgeFsxXSA9IChiID4+PiBuKSB8IGM7XG4gICAgICAgIGMgPSBiIDw8IG5JbnY7XG4gICAgICAgIGIgPSB4WzJdO1xuICAgICAgICB4WzJdID0gKGIgPj4+IG4pIHwgYztcbiAgICAgICAgYyA9IGIgPDwgbkludjtcbiAgICAgICAgYiA9IHhbM107XG4gICAgICAgIHhbM10gPSAoYiA+Pj4gbikgfCBjO1xuICAgICAgICByZXR1cm4gYiA8PCBuSW52O1xuICAgICAgY2FzZSAzOlxuICAgICAgICBiID0geFswXTtcbiAgICAgICAgbkludiA9IDMyIC0gbjtcbiAgICAgICAgelswXSA9IGIgPj4+IG47XG4gICAgICAgIGMgPSBiIDw8IG5JbnY7XG4gICAgICAgIGIgPSB4WzFdO1xuICAgICAgICB6WzFdID0gKGIgPj4+IG4pIHwgYztcbiAgICAgICAgYyA9IGIgPDwgbkludjtcbiAgICAgICAgYiA9IHhbMl07XG4gICAgICAgIHpbMl0gPSAoYiA+Pj4gbikgfCBjO1xuICAgICAgICBjID0gYiA8PCBuSW52O1xuICAgICAgICBiID0geFszXTtcbiAgICAgICAgelszXSA9IChiID4+PiBuKSB8IGM7XG4gICAgICAgIHJldHVybiBiIDw8IG5JbnY7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMiBvciAzIGFyZ3VtZW50cy5cIik7XG4gICAgfVxuICB9LFxuICB4b3I6IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgeFswXSBePSB5WzBdO1xuICAgICAgICB4WzFdIF49IHlbMV07XG4gICAgICAgIHhbMl0gXj0geVsyXTtcbiAgICAgICAgeFszXSBePSB5WzNdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgelswXSA9IHhbMF0gXiB5WzBdO1xuICAgICAgICB6WzFdID0geFsxXSBeIHlbMV07XG4gICAgICAgIHpbMl0gPSB4WzJdIF4geVsyXTtcbiAgICAgICAgelszXSA9IHhbM10gXiB5WzNdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAyIG9yIDMgYXJndW1lbnRzLlwiKTtcbiAgICB9XG4gIH0sXG5cbiAgbXVsdGlwbHk6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgcjAgPSB4LnNsaWNlKCk7XG4gICAgdmFyIHIxID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgdmFyIGJpdHMgPSB5W2ldO1xuICAgICAgZm9yICh2YXIgaiA9IDMxOyBqID49IDA7IC0taikge1xuICAgICAgICBpZiAoKGJpdHMgJiAoMSA8PCBqKSkgIT09IDApIHtcbiAgICAgICAgICBoZWxwZXJzLnhvcihyMSwgcjApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlbHBlcnMuc2hpZnRSaWdodChyMCkgIT09IDApIHtcbiAgICAgICAgICByMFswXSBePSBoZWxwZXJzLkUxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGVscGVycy5hcnJheUNvcHkocjEsIDAsIHgsIDAsIDQpO1xuICB9LFxuICBtdWx0aXBseVA6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKGhlbHBlcnMuc2hpZnRSaWdodCh4KSAhPT0gMCkge1xuICAgICAgICAgIHhbMF0gXj0gaGVscGVycy5FMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaWYgKGhlbHBlcnMuc2hpZnRSaWdodCh4LCB5KSAhPT0gMCkge1xuICAgICAgICAgIHlbMF0gXj0gaGVscGVycy5FMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAxIG9yIDIgYXJndW1lbnRzLlwiKTtcbiAgICB9XG4gIH0sXG4gIG11bHRpcGx5UDg6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgYztcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgYyA9IGhlbHBlcnMuc2hpZnRSaWdodE4oeCwgOCk7XG4gICAgICAgIHhbMF0gXj0gaGVscGVycy5MT09LVVBbYyA+Pj4gMjRdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgYyA9IGhlbHBlcnMuc2hpZnRSaWdodE4oeCwgOCwgeSk7XG4gICAgICAgIHlbMF0gXj0gaGVscGVycy5MT09LVVBbYyA+Pj4gMjRdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAxIG9yIDIgYXJndW1lbnRzLlwiKTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/gcm/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/gcm/index.js - AES-GCM implementation Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n \n\nvar Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/umd/index.js\"),\n    forge = __webpack_require__(/*! ../../../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    multipliers = __webpack_require__(/*! ./multipliers.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/multipliers.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js\"),\n    pack = __webpack_require__(/*! ../pack.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\"),\n    DataBuffer = __webpack_require__(/*! ../../../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\"),\n    cipherHelpers = __webpack_require__(/*! ../helpers.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/helpers.js\");\n\nvar BLOCK_SIZE = 16;\n\n// ### GCM Mode\n// ### Constructor\nfunction Gcm(options) {\n  options = options || {};\n\n  this.name = \"GCM\";\n  this.cipher = options.cipher;\n  this.blockSize = this.blockSize || 16;\n}\n\n// ### exports\nmodule.exports = {\n  createCipher: function(options) {\n    var alg = new forge.aes.Algorithm(\"AES-GCM\", Gcm);\n    alg.initialize({\n      key: new DataBuffer(options.key)\n    });\n    alg.mode.start(options);\n\n    return alg.mode;\n  },\n  createDecipher: function(options) {\n    var alg = new forge.aes.Algorithm(\"AES-GCM\", Gcm);\n    alg.initialize({\n      key: new DataBuffer(options.key)\n    });\n    alg.mode._decrypt = true;\n    alg.mode.start(options);\n\n    return alg.mode;\n  }\n};\n\n// ### Public API\nGcm.prototype.start = function(options) {\n  this.tag = null;\n\n  options = options || {};\n\n  if (!(\"iv\" in options)) {\n    throw new Error(\"Gcm needs ParametersWithIV or AEADParameters\");\n  }\n  this.nonce = options.iv;\n  if (this.nonce == null || this.nonce.length < 1) {\n    throw new Error(\"IV must be at least 1 byte\");\n  }\n\n  // TODO: variable tagLength?\n  this.tagLength = 16;\n\n  // TODO: validate tag\n  if (\"tag\" in options) {\n    this.tag = Buffer.from(options.tag);\n  }\n\n  var bufLength = !this._decrypt ?\n                  this.blockSize :\n                  (this.blockSize + this.tagLength);\n  this.bufBlock = Buffer.alloc(bufLength);\n\n  var multiplier = options.multiplier;\n  if (multiplier == null) {\n    multiplier = new (multipliers[\"8k\"])();\n  }\n  this.multiplier = multiplier;\n\n  this.H = this.zeroBlock();\n  cipherHelpers.encrypt(this.cipher, this.H, 0, this.H, 0);\n\n  // GcmMultiplier tables don\"t change unless the key changes\n  // (and are expensive to init)\n  this.multiplier.init(this.H);\n  this.exp = null;\n\n  this.J0 = this.zeroBlock();\n\n  if (this.nonce.length === 12) {\n    this.nonce.copy(this.J0, 0, 0, this.nonce.length);\n    this.J0[this.blockSize - 1] = 0x01;\n  } else {\n    this.gHASH(this.J0, this.nonce, this.nonce.length);\n    var X = this.zeroBlock();\n    pack.longToBigEndian(new Long(this.nonce.length).\n                         multiply(8), X, 8);\n    this.gHASHBlock(this.J0, X);\n  }\n\n  this.S = this.zeroBlock();\n  this.SAt = this.zeroBlock();\n  this.SAtPre = this.zeroBlock();\n  this.atBlock = this.zeroBlock();\n  this.atBlockPos = 0;\n  this.atLength = Long.ZERO;\n  this.atLengthPre = Long.ZERO;\n  this.counter = Buffer.from(this.J0);\n  this.bufOff = 0;\n  this.totalLength = Long.ZERO;\n\n  if (\"additionalData\" in options) {\n    this.processAADBytes(options.additionalData, 0, options.additionalData.length);\n  }\n};\n\nGcm.prototype.update = function(inV, inOff, len, out, outOff) {\n  var resultLen = 0;\n\n  while (len > 0) {\n    var inLen = Math.min(len, this.bufBlock.length - this.bufOff);\n    inV.copy(this.bufBlock, this.bufOff, inOff, inOff + inLen);\n    len -= inLen;\n    inOff += inLen;\n    this.bufOff += inLen;\n    if (this.bufOff === this.bufBlock.length) {\n      this.outputBlock(out, outOff + resultLen);\n      resultLen += this.blockSize;\n    }\n  }\n\n  return resultLen;\n};\nGcm.prototype.finish = function(out, outOff) {\n  var resultLen = 0;\n\n  if (this._decrypt) {\n    // append tag\n    resultLen += this.update(this.tag, 0, this.tag.length, out, outOff);\n  }\n\n  if (this.totalLength.isZero()) {\n    this.initCipher();\n  }\n\n  var extra = this.bufOff;\n  if (this._decrypt) {\n    if (extra < this.tagLength) {\n      throw new Error(\"data too short\");\n    }\n    extra -= this.tagLength;\n  }\n\n  if (extra > 0) {\n    this.gCTRPartial(this.bufBlock, 0, extra, out, outOff + resultLen);\n    resultLen += extra;\n  }\n\n  this.atLength = this.atLength.add(this.atBlockPos);\n\n  // Final gHASH\n  var X = this.zeroBlock();\n  pack.longToBigEndian(this.atLength.multiply(8),\n                       X,\n                       0);\n  pack.longToBigEndian(this.totalLength.multiply(8),\n                       X,\n                       8);\n\n  this.gHASHBlock(this.S, X);\n\n  // TODO Fix this if tagLength becomes configurable\n  // T = MSBt(GCTRk(J0,S))\n  var tag = Buffer.alloc(this.blockSize);\n  cipherHelpers.encrypt(this.cipher, this.J0, 0, tag, 0);\n  this.xor(tag, this.S);\n\n  if (this._decrypt) {\n    if (!helpers.arrayEqual(this.tag, tag)) {\n      throw new Error(\"mac check in Gcm failed\");\n    }\n  } else {\n    // We place into tag our calculated value for T\n    this.tag = Buffer.alloc(this.tagLength);\n    tag.copy(this.tag, 0, 0, this.tagLength);\n  }\n\n  return resultLen;\n};\n\n// ### \"Internal\" Helper Functions\nGcm.prototype.initCipher = function() {\n  if (this.atLength.greaterThan(Long.ZERO)) {\n    this.SAt.copy(this.SAtPre, 0, 0, this.blockSize);\n    this.atLengthPre = this.atLength.add(Long.ZERO);\n  }\n\n  // Finish hash for partial AAD block\n  if (this.atBlockPos > 0) {\n    this.gHASHPartial(this.SAtPre, this.atBlock, 0, this.atBlockPos);\n    this.atLengthPre = this.atLengthPre.add(this.atBlockPos);\n  }\n\n  if (this.atLengthPre.greaterThan(Long.ZERO)) {\n    this.SAtPre.copy(this.S, 0, 0, this.blockSize);\n  }\n};\n\nGcm.prototype.outputBlock = function(output, offset) {\n  if (this.totalLength.isZero()) {\n    this.initCipher();\n  }\n  this.gCTRBlock(this.bufBlock, output, offset);\n  if (!this._decrypt) {\n    this.bufOff = 0;\n  } else {\n    this.bufBlock.copy(this.bufBlock, 0, this.blockSize, this.blockSize + this.tagLength);\n    this.bufOff = this.tagLength;\n  }\n};\n\nGcm.prototype.processAADBytes = function(inV, inOff, len) {\n  for (var i = 0; i < len; ++i) {\n    this.atBlock[this.atBlockPos] = inV[inOff + i];\n    if (++this.atBlockPos === this.blockSize) {\n      // Hash each block as it fills\n      this.gHASHBlock(this.SAt, this.atBlock);\n      this.atBlockPos = 0;\n      this.atLength = this.atLength.add(this.blockSize);\n    }\n  }\n};\n\nGcm.prototype.getNextCounterBlock = function() {\n  for (var i = 15; i >= 12; --i) {\n    var b = ((this.counter[i] + 1) & 0xff);\n    this.counter[i] = b;\n\n    if (b !== 0) {\n      break;\n    }\n  }\n\n  // encrypt counter\n  var outb = Buffer.alloc(this.blockSize);\n  cipherHelpers.encrypt(this.cipher, this.counter, 0, outb, 0);\n\n  return outb;\n};\n\nGcm.prototype.gCTRBlock = function(block, out, outOff) {\n  var tmp = this.getNextCounterBlock();\n\n  this.xor(tmp, block);\n  tmp.copy(out, outOff, 0, this.blockSize);\n\n  this.gHASHBlock(this.S, !this._decrypt ? tmp : block);\n\n  this.totalLength = this.totalLength.add(this.blockSize);\n};\nGcm.prototype.gCTRPartial = function(buf, off, len, out, outOff) {\n  var tmp = this.getNextCounterBlock();\n\n  this.xor(tmp, buf, off, len);\n  tmp.copy(out, outOff, 0, len);\n\n  this.gHASHPartial(this.S, !this._decrypt ? tmp : buf, 0, len);\n\n  this.totalLength = this.totalLength.add(len);\n};\n\nGcm.prototype.gHASHBlock = function(Y, b) {\n  this.xor(Y, b);\n  this.multiplier.multiplyH(Y);\n};\nGcm.prototype.gHASHPartial = function(Y, b, off, len) {\n  this.xor(Y, b, off, len);\n  this.multiplier.multiplyH(Y);\n};\n\nGcm.prototype.xor = function(block, val, off, len) {\n  switch (arguments.length) {\n    case 2:\n      for (var i = 15; i >= 0; --i) {\n        block[i] ^= val[i];\n      }\n      break;\n    case 4:\n      while (len-- > 0) {\n        block[len] ^= val[off + len];\n      }\n      break;\n    default:\n      throw new TypeError(\"Expected 2 or 4 arguments.\");\n  }\n\n  return block;\n};\n\nGcm.prototype.zeroBlock = function() {\n  var block = Buffer.alloc(BLOCK_SIZE);\n  return block;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2djbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBYzs7QUFFZCxXQUFXLG1CQUFPLENBQUMsb0RBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLGdGQUF3QjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLHdGQUFjO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQywrRUFBWTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQywwRkFBNkI7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMscUZBQWU7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2RlcHMvY2lwaGVybW9kZXMvZ2NtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogZGVwcy9jaXBoZXJtb2Rlcy9nY20vaW5kZXguanMgLSBBRVMtR0NNIGltcGxlbWVudGF0aW9uIEVudHJ5IFBvaW50XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cbiBcInVzZSBzdHJpY3RcIjtcblxudmFyIExvbmcgPSByZXF1aXJlKFwibG9uZ1wiKSxcbiAgICBmb3JnZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9kZXBzL2ZvcmdlLmpzXCIpLFxuICAgIG11bHRpcGxpZXJzID0gcmVxdWlyZShcIi4vbXVsdGlwbGllcnMuanNcIiksXG4gICAgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIiksXG4gICAgcGFjayA9IHJlcXVpcmUoXCIuLi9wYWNrLmpzXCIpLFxuICAgIERhdGFCdWZmZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbC9kYXRhYnVmZmVyLmpzXCIpLFxuICAgIGNpcGhlckhlbHBlcnMgPSByZXF1aXJlKFwiLi4vaGVscGVycy5qc1wiKTtcblxudmFyIEJMT0NLX1NJWkUgPSAxNjtcblxuLy8gIyMjIEdDTSBNb2RlXG4vLyAjIyMgQ29uc3RydWN0b3JcbmZ1bmN0aW9uIEdjbShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMubmFtZSA9IFwiR0NNXCI7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemUgfHwgMTY7XG59XG5cbi8vICMjIyBleHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlQ2lwaGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGFsZyA9IG5ldyBmb3JnZS5hZXMuQWxnb3JpdGhtKFwiQUVTLUdDTVwiLCBHY20pO1xuICAgIGFsZy5pbml0aWFsaXplKHtcbiAgICAgIGtleTogbmV3IERhdGFCdWZmZXIob3B0aW9ucy5rZXkpXG4gICAgfSk7XG4gICAgYWxnLm1vZGUuc3RhcnQob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gYWxnLm1vZGU7XG4gIH0sXG4gIGNyZWF0ZURlY2lwaGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGFsZyA9IG5ldyBmb3JnZS5hZXMuQWxnb3JpdGhtKFwiQUVTLUdDTVwiLCBHY20pO1xuICAgIGFsZy5pbml0aWFsaXplKHtcbiAgICAgIGtleTogbmV3IERhdGFCdWZmZXIob3B0aW9ucy5rZXkpXG4gICAgfSk7XG4gICAgYWxnLm1vZGUuX2RlY3J5cHQgPSB0cnVlO1xuICAgIGFsZy5tb2RlLnN0YXJ0KG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGFsZy5tb2RlO1xuICB9XG59O1xuXG4vLyAjIyMgUHVibGljIEFQSVxuR2NtLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy50YWcgPSBudWxsO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmICghKFwiaXZcIiBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkdjbSBuZWVkcyBQYXJhbWV0ZXJzV2l0aElWIG9yIEFFQURQYXJhbWV0ZXJzXCIpO1xuICB9XG4gIHRoaXMubm9uY2UgPSBvcHRpb25zLml2O1xuICBpZiAodGhpcy5ub25jZSA9PSBudWxsIHx8IHRoaXMubm9uY2UubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIklWIG11c3QgYmUgYXQgbGVhc3QgMSBieXRlXCIpO1xuICB9XG5cbiAgLy8gVE9ETzogdmFyaWFibGUgdGFnTGVuZ3RoP1xuICB0aGlzLnRhZ0xlbmd0aCA9IDE2O1xuXG4gIC8vIFRPRE86IHZhbGlkYXRlIHRhZ1xuICBpZiAoXCJ0YWdcIiBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy50YWcgPSBCdWZmZXIuZnJvbShvcHRpb25zLnRhZyk7XG4gIH1cblxuICB2YXIgYnVmTGVuZ3RoID0gIXRoaXMuX2RlY3J5cHQgP1xuICAgICAgICAgICAgICAgICAgdGhpcy5ibG9ja1NpemUgOlxuICAgICAgICAgICAgICAgICAgKHRoaXMuYmxvY2tTaXplICsgdGhpcy50YWdMZW5ndGgpO1xuICB0aGlzLmJ1ZkJsb2NrID0gQnVmZmVyLmFsbG9jKGJ1Zkxlbmd0aCk7XG5cbiAgdmFyIG11bHRpcGxpZXIgPSBvcHRpb25zLm11bHRpcGxpZXI7XG4gIGlmIChtdWx0aXBsaWVyID09IG51bGwpIHtcbiAgICBtdWx0aXBsaWVyID0gbmV3IChtdWx0aXBsaWVyc1tcIjhrXCJdKSgpO1xuICB9XG4gIHRoaXMubXVsdGlwbGllciA9IG11bHRpcGxpZXI7XG5cbiAgdGhpcy5IID0gdGhpcy56ZXJvQmxvY2soKTtcbiAgY2lwaGVySGVscGVycy5lbmNyeXB0KHRoaXMuY2lwaGVyLCB0aGlzLkgsIDAsIHRoaXMuSCwgMCk7XG5cbiAgLy8gR2NtTXVsdGlwbGllciB0YWJsZXMgZG9uXCJ0IGNoYW5nZSB1bmxlc3MgdGhlIGtleSBjaGFuZ2VzXG4gIC8vIChhbmQgYXJlIGV4cGVuc2l2ZSB0byBpbml0KVxuICB0aGlzLm11bHRpcGxpZXIuaW5pdCh0aGlzLkgpO1xuICB0aGlzLmV4cCA9IG51bGw7XG5cbiAgdGhpcy5KMCA9IHRoaXMuemVyb0Jsb2NrKCk7XG5cbiAgaWYgKHRoaXMubm9uY2UubGVuZ3RoID09PSAxMikge1xuICAgIHRoaXMubm9uY2UuY29weSh0aGlzLkowLCAwLCAwLCB0aGlzLm5vbmNlLmxlbmd0aCk7XG4gICAgdGhpcy5KMFt0aGlzLmJsb2NrU2l6ZSAtIDFdID0gMHgwMTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdIQVNIKHRoaXMuSjAsIHRoaXMubm9uY2UsIHRoaXMubm9uY2UubGVuZ3RoKTtcbiAgICB2YXIgWCA9IHRoaXMuemVyb0Jsb2NrKCk7XG4gICAgcGFjay5sb25nVG9CaWdFbmRpYW4obmV3IExvbmcodGhpcy5ub25jZS5sZW5ndGgpLlxuICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGx5KDgpLCBYLCA4KTtcbiAgICB0aGlzLmdIQVNIQmxvY2sodGhpcy5KMCwgWCk7XG4gIH1cblxuICB0aGlzLlMgPSB0aGlzLnplcm9CbG9jaygpO1xuICB0aGlzLlNBdCA9IHRoaXMuemVyb0Jsb2NrKCk7XG4gIHRoaXMuU0F0UHJlID0gdGhpcy56ZXJvQmxvY2soKTtcbiAgdGhpcy5hdEJsb2NrID0gdGhpcy56ZXJvQmxvY2soKTtcbiAgdGhpcy5hdEJsb2NrUG9zID0gMDtcbiAgdGhpcy5hdExlbmd0aCA9IExvbmcuWkVSTztcbiAgdGhpcy5hdExlbmd0aFByZSA9IExvbmcuWkVSTztcbiAgdGhpcy5jb3VudGVyID0gQnVmZmVyLmZyb20odGhpcy5KMCk7XG4gIHRoaXMuYnVmT2ZmID0gMDtcbiAgdGhpcy50b3RhbExlbmd0aCA9IExvbmcuWkVSTztcblxuICBpZiAoXCJhZGRpdGlvbmFsRGF0YVwiIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLnByb2Nlc3NBQURCeXRlcyhvcHRpb25zLmFkZGl0aW9uYWxEYXRhLCAwLCBvcHRpb25zLmFkZGl0aW9uYWxEYXRhLmxlbmd0aCk7XG4gIH1cbn07XG5cbkdjbS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oaW5WLCBpbk9mZiwgbGVuLCBvdXQsIG91dE9mZikge1xuICB2YXIgcmVzdWx0TGVuID0gMDtcblxuICB3aGlsZSAobGVuID4gMCkge1xuICAgIHZhciBpbkxlbiA9IE1hdGgubWluKGxlbiwgdGhpcy5idWZCbG9jay5sZW5ndGggLSB0aGlzLmJ1Zk9mZik7XG4gICAgaW5WLmNvcHkodGhpcy5idWZCbG9jaywgdGhpcy5idWZPZmYsIGluT2ZmLCBpbk9mZiArIGluTGVuKTtcbiAgICBsZW4gLT0gaW5MZW47XG4gICAgaW5PZmYgKz0gaW5MZW47XG4gICAgdGhpcy5idWZPZmYgKz0gaW5MZW47XG4gICAgaWYgKHRoaXMuYnVmT2ZmID09PSB0aGlzLmJ1ZkJsb2NrLmxlbmd0aCkge1xuICAgICAgdGhpcy5vdXRwdXRCbG9jayhvdXQsIG91dE9mZiArIHJlc3VsdExlbik7XG4gICAgICByZXN1bHRMZW4gKz0gdGhpcy5ibG9ja1NpemU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdExlbjtcbn07XG5HY20ucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKG91dCwgb3V0T2ZmKSB7XG4gIHZhciByZXN1bHRMZW4gPSAwO1xuXG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgLy8gYXBwZW5kIHRhZ1xuICAgIHJlc3VsdExlbiArPSB0aGlzLnVwZGF0ZSh0aGlzLnRhZywgMCwgdGhpcy50YWcubGVuZ3RoLCBvdXQsIG91dE9mZik7XG4gIH1cblxuICBpZiAodGhpcy50b3RhbExlbmd0aC5pc1plcm8oKSkge1xuICAgIHRoaXMuaW5pdENpcGhlcigpO1xuICB9XG5cbiAgdmFyIGV4dHJhID0gdGhpcy5idWZPZmY7XG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgaWYgKGV4dHJhIDwgdGhpcy50YWdMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRhdGEgdG9vIHNob3J0XCIpO1xuICAgIH1cbiAgICBleHRyYSAtPSB0aGlzLnRhZ0xlbmd0aDtcbiAgfVxuXG4gIGlmIChleHRyYSA+IDApIHtcbiAgICB0aGlzLmdDVFJQYXJ0aWFsKHRoaXMuYnVmQmxvY2ssIDAsIGV4dHJhLCBvdXQsIG91dE9mZiArIHJlc3VsdExlbik7XG4gICAgcmVzdWx0TGVuICs9IGV4dHJhO1xuICB9XG5cbiAgdGhpcy5hdExlbmd0aCA9IHRoaXMuYXRMZW5ndGguYWRkKHRoaXMuYXRCbG9ja1Bvcyk7XG5cbiAgLy8gRmluYWwgZ0hBU0hcbiAgdmFyIFggPSB0aGlzLnplcm9CbG9jaygpO1xuICBwYWNrLmxvbmdUb0JpZ0VuZGlhbih0aGlzLmF0TGVuZ3RoLm11bHRpcGx5KDgpLFxuICAgICAgICAgICAgICAgICAgICAgICBYLFxuICAgICAgICAgICAgICAgICAgICAgICAwKTtcbiAgcGFjay5sb25nVG9CaWdFbmRpYW4odGhpcy50b3RhbExlbmd0aC5tdWx0aXBseSg4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgWCxcbiAgICAgICAgICAgICAgICAgICAgICAgOCk7XG5cbiAgdGhpcy5nSEFTSEJsb2NrKHRoaXMuUywgWCk7XG5cbiAgLy8gVE9ETyBGaXggdGhpcyBpZiB0YWdMZW5ndGggYmVjb21lcyBjb25maWd1cmFibGVcbiAgLy8gVCA9IE1TQnQoR0NUUmsoSjAsUykpXG4gIHZhciB0YWcgPSBCdWZmZXIuYWxsb2ModGhpcy5ibG9ja1NpemUpO1xuICBjaXBoZXJIZWxwZXJzLmVuY3J5cHQodGhpcy5jaXBoZXIsIHRoaXMuSjAsIDAsIHRhZywgMCk7XG4gIHRoaXMueG9yKHRhZywgdGhpcy5TKTtcblxuICBpZiAodGhpcy5fZGVjcnlwdCkge1xuICAgIGlmICghaGVscGVycy5hcnJheUVxdWFsKHRoaXMudGFnLCB0YWcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYWMgY2hlY2sgaW4gR2NtIGZhaWxlZFwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgcGxhY2UgaW50byB0YWcgb3VyIGNhbGN1bGF0ZWQgdmFsdWUgZm9yIFRcbiAgICB0aGlzLnRhZyA9IEJ1ZmZlci5hbGxvYyh0aGlzLnRhZ0xlbmd0aCk7XG4gICAgdGFnLmNvcHkodGhpcy50YWcsIDAsIDAsIHRoaXMudGFnTGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRMZW47XG59O1xuXG4vLyAjIyMgXCJJbnRlcm5hbFwiIEhlbHBlciBGdW5jdGlvbnNcbkdjbS5wcm90b3R5cGUuaW5pdENpcGhlciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5hdExlbmd0aC5ncmVhdGVyVGhhbihMb25nLlpFUk8pKSB7XG4gICAgdGhpcy5TQXQuY29weSh0aGlzLlNBdFByZSwgMCwgMCwgdGhpcy5ibG9ja1NpemUpO1xuICAgIHRoaXMuYXRMZW5ndGhQcmUgPSB0aGlzLmF0TGVuZ3RoLmFkZChMb25nLlpFUk8pO1xuICB9XG5cbiAgLy8gRmluaXNoIGhhc2ggZm9yIHBhcnRpYWwgQUFEIGJsb2NrXG4gIGlmICh0aGlzLmF0QmxvY2tQb3MgPiAwKSB7XG4gICAgdGhpcy5nSEFTSFBhcnRpYWwodGhpcy5TQXRQcmUsIHRoaXMuYXRCbG9jaywgMCwgdGhpcy5hdEJsb2NrUG9zKTtcbiAgICB0aGlzLmF0TGVuZ3RoUHJlID0gdGhpcy5hdExlbmd0aFByZS5hZGQodGhpcy5hdEJsb2NrUG9zKTtcbiAgfVxuXG4gIGlmICh0aGlzLmF0TGVuZ3RoUHJlLmdyZWF0ZXJUaGFuKExvbmcuWkVSTykpIHtcbiAgICB0aGlzLlNBdFByZS5jb3B5KHRoaXMuUywgMCwgMCwgdGhpcy5ibG9ja1NpemUpO1xuICB9XG59O1xuXG5HY20ucHJvdG90eXBlLm91dHB1dEJsb2NrID0gZnVuY3Rpb24ob3V0cHV0LCBvZmZzZXQpIHtcbiAgaWYgKHRoaXMudG90YWxMZW5ndGguaXNaZXJvKCkpIHtcbiAgICB0aGlzLmluaXRDaXBoZXIoKTtcbiAgfVxuICB0aGlzLmdDVFJCbG9jayh0aGlzLmJ1ZkJsb2NrLCBvdXRwdXQsIG9mZnNldCk7XG4gIGlmICghdGhpcy5fZGVjcnlwdCkge1xuICAgIHRoaXMuYnVmT2ZmID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmJ1ZkJsb2NrLmNvcHkodGhpcy5idWZCbG9jaywgMCwgdGhpcy5ibG9ja1NpemUsIHRoaXMuYmxvY2tTaXplICsgdGhpcy50YWdMZW5ndGgpO1xuICAgIHRoaXMuYnVmT2ZmID0gdGhpcy50YWdMZW5ndGg7XG4gIH1cbn07XG5cbkdjbS5wcm90b3R5cGUucHJvY2Vzc0FBREJ5dGVzID0gZnVuY3Rpb24oaW5WLCBpbk9mZiwgbGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB0aGlzLmF0QmxvY2tbdGhpcy5hdEJsb2NrUG9zXSA9IGluVltpbk9mZiArIGldO1xuICAgIGlmICgrK3RoaXMuYXRCbG9ja1BvcyA9PT0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAgIC8vIEhhc2ggZWFjaCBibG9jayBhcyBpdCBmaWxsc1xuICAgICAgdGhpcy5nSEFTSEJsb2NrKHRoaXMuU0F0LCB0aGlzLmF0QmxvY2spO1xuICAgICAgdGhpcy5hdEJsb2NrUG9zID0gMDtcbiAgICAgIHRoaXMuYXRMZW5ndGggPSB0aGlzLmF0TGVuZ3RoLmFkZCh0aGlzLmJsb2NrU2l6ZSk7XG4gICAgfVxuICB9XG59O1xuXG5HY20ucHJvdG90eXBlLmdldE5leHRDb3VudGVyQmxvY2sgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDE1OyBpID49IDEyOyAtLWkpIHtcbiAgICB2YXIgYiA9ICgodGhpcy5jb3VudGVyW2ldICsgMSkgJiAweGZmKTtcbiAgICB0aGlzLmNvdW50ZXJbaV0gPSBiO1xuXG4gICAgaWYgKGIgIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuY3J5cHQgY291bnRlclxuICB2YXIgb3V0YiA9IEJ1ZmZlci5hbGxvYyh0aGlzLmJsb2NrU2l6ZSk7XG4gIGNpcGhlckhlbHBlcnMuZW5jcnlwdCh0aGlzLmNpcGhlciwgdGhpcy5jb3VudGVyLCAwLCBvdXRiLCAwKTtcblxuICByZXR1cm4gb3V0Yjtcbn07XG5cbkdjbS5wcm90b3R5cGUuZ0NUUkJsb2NrID0gZnVuY3Rpb24oYmxvY2ssIG91dCwgb3V0T2ZmKSB7XG4gIHZhciB0bXAgPSB0aGlzLmdldE5leHRDb3VudGVyQmxvY2soKTtcblxuICB0aGlzLnhvcih0bXAsIGJsb2NrKTtcbiAgdG1wLmNvcHkob3V0LCBvdXRPZmYsIDAsIHRoaXMuYmxvY2tTaXplKTtcblxuICB0aGlzLmdIQVNIQmxvY2sodGhpcy5TLCAhdGhpcy5fZGVjcnlwdCA/IHRtcCA6IGJsb2NrKTtcblxuICB0aGlzLnRvdGFsTGVuZ3RoID0gdGhpcy50b3RhbExlbmd0aC5hZGQodGhpcy5ibG9ja1NpemUpO1xufTtcbkdjbS5wcm90b3R5cGUuZ0NUUlBhcnRpYWwgPSBmdW5jdGlvbihidWYsIG9mZiwgbGVuLCBvdXQsIG91dE9mZikge1xuICB2YXIgdG1wID0gdGhpcy5nZXROZXh0Q291bnRlckJsb2NrKCk7XG5cbiAgdGhpcy54b3IodG1wLCBidWYsIG9mZiwgbGVuKTtcbiAgdG1wLmNvcHkob3V0LCBvdXRPZmYsIDAsIGxlbik7XG5cbiAgdGhpcy5nSEFTSFBhcnRpYWwodGhpcy5TLCAhdGhpcy5fZGVjcnlwdCA/IHRtcCA6IGJ1ZiwgMCwgbGVuKTtcblxuICB0aGlzLnRvdGFsTGVuZ3RoID0gdGhpcy50b3RhbExlbmd0aC5hZGQobGVuKTtcbn07XG5cbkdjbS5wcm90b3R5cGUuZ0hBU0hCbG9jayA9IGZ1bmN0aW9uKFksIGIpIHtcbiAgdGhpcy54b3IoWSwgYik7XG4gIHRoaXMubXVsdGlwbGllci5tdWx0aXBseUgoWSk7XG59O1xuR2NtLnByb3RvdHlwZS5nSEFTSFBhcnRpYWwgPSBmdW5jdGlvbihZLCBiLCBvZmYsIGxlbikge1xuICB0aGlzLnhvcihZLCBiLCBvZmYsIGxlbik7XG4gIHRoaXMubXVsdGlwbGllci5tdWx0aXBseUgoWSk7XG59O1xuXG5HY20ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uKGJsb2NrLCB2YWwsIG9mZiwgbGVuKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMjpcbiAgICAgIGZvciAodmFyIGkgPSAxNTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgYmxvY2tbaV0gXj0gdmFsW2ldO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgd2hpbGUgKGxlbi0tID4gMCkge1xuICAgICAgICBibG9ja1tsZW5dIF49IHZhbFtvZmYgKyBsZW5dO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAyIG9yIDQgYXJndW1lbnRzLlwiKTtcbiAgfVxuXG4gIHJldHVybiBibG9jaztcbn07XG5cbkdjbS5wcm90b3R5cGUuemVyb0Jsb2NrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBibG9jayA9IEJ1ZmZlci5hbGxvYyhCTE9DS19TSVpFKTtcbiAgcmV0dXJuIGJsb2NrO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/multipliers.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/gcm/multipliers.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/gcm/multipliers.js - AES-GCM Multipliers\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n \n\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js\"),\n    pack = __webpack_require__(/*! ../pack.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\");\n\n\n// ### 8K Table Multiplier\nfunction Gcm8KMultiplier() {\n  this.H = [];\n  this.M = null;\n}\n\nGcm8KMultiplier.prototype.init = function(H) {\n  var i, j, k;\n  if (this.M == null) {\n    // sc: I realize this UGLY...\n    //M = new int[32][16][4];\n    this.M = [];\n    for (i = 0; i < 32; ++i) {\n      this.M[i] = [];\n      for (j = 0; j < 16; ++j) {\n        this.M[i][j] = [];\n        for (k = 0; k < 4; ++k) {\n          this.M[i][j][k] = 0;\n        }\n      }\n    }\n  } else if (helpers.arrayEqual(this.H, H)) {\n    return;\n  }\n\n  this.H = H.slice();\n\n  // M[0][0] is ZEROES;\n  // M[1][0] is ZEROES;\n  helpers.asInts(H, this.M[1][8]);\n\n  for (j = 4; j >= 1; j >>= 1) {\n    helpers.multiplyP(this.M[1][j + j], this.M[1][j]);\n  }\n  helpers.multiplyP(this.M[1][1], this.M[0][8]);\n\n  for (j = 4; j >= 1; j >>= 1) {\n    helpers.multiplyP(this.M[0][j + j], this.M[0][j]);\n  }\n\n  i = 0;\n  for (;;) {\n    for (j = 2; j < 16; j += j) {\n      for (k = 1; k < j; ++k) {\n        helpers.xor(this.M[i][j], this.M[i][k], this.M[i][j + k]);\n      }\n    }\n\n    if (++i === 32) {\n      return;\n    }\n\n    if (i > 1) {\n      // M[i][0] is ZEROES;\n      for (j = 8; j > 0; j >>= 1) {\n        helpers.multiplyP8(this.M[i - 2][j], this.M[i][j]);\n      }\n    }\n  }\n};\nGcm8KMultiplier.prototype.multiplyH = function(x) {\n  var z = [];\n  for (var i = 15; i >= 0; --i) {\n    var m = this.M[i + i][x[i] & 0x0f];\n    z[0] ^= m[0];\n    z[1] ^= m[1];\n    z[2] ^= m[2];\n    z[3] ^= m[3];\n    m = this.M[i + i + 1][(x[i] & 0xf0) >>> 4];\n    z[0] ^= m[0];\n    z[1] ^= m[1];\n    z[2] ^= m[2];\n    z[3] ^= m[3];\n  }\n\n  pack.intToBigEndian(z, x, 0);\n};\n\n\nmodule.exports = {\n  \"8k\": Gcm8KMultiplier\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2djbS9tdWx0aXBsaWVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBYzs7QUFFZCxjQUFjLG1CQUFPLENBQUMsd0ZBQWM7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLCtFQUFZOzs7QUFHL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsUUFBUTtBQUN4QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2RlcHMvY2lwaGVybW9kZXMvZ2NtL211bHRpcGxpZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogZGVwcy9jaXBoZXJtb2Rlcy9nY20vbXVsdGlwbGllcnMuanMgLSBBRVMtR0NNIE11bHRpcGxpZXJzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cbiBcInVzZSBzdHJpY3RcIjtcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpLFxuICAgIHBhY2sgPSByZXF1aXJlKFwiLi4vcGFjay5qc1wiKTtcblxuXG4vLyAjIyMgOEsgVGFibGUgTXVsdGlwbGllclxuZnVuY3Rpb24gR2NtOEtNdWx0aXBsaWVyKCkge1xuICB0aGlzLkggPSBbXTtcbiAgdGhpcy5NID0gbnVsbDtcbn1cblxuR2NtOEtNdWx0aXBsaWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oSCkge1xuICB2YXIgaSwgaiwgaztcbiAgaWYgKHRoaXMuTSA9PSBudWxsKSB7XG4gICAgLy8gc2M6IEkgcmVhbGl6ZSB0aGlzIFVHTFkuLi5cbiAgICAvL00gPSBuZXcgaW50WzMyXVsxNl1bNF07XG4gICAgdGhpcy5NID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICAgIHRoaXMuTVtpXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgICAgdGhpcy5NW2ldW2pdID0gW107XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCA0OyArK2spIHtcbiAgICAgICAgICB0aGlzLk1baV1bal1ba10gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGhlbHBlcnMuYXJyYXlFcXVhbCh0aGlzLkgsIEgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5IID0gSC5zbGljZSgpO1xuXG4gIC8vIE1bMF1bMF0gaXMgWkVST0VTO1xuICAvLyBNWzFdWzBdIGlzIFpFUk9FUztcbiAgaGVscGVycy5hc0ludHMoSCwgdGhpcy5NWzFdWzhdKTtcblxuICBmb3IgKGogPSA0OyBqID49IDE7IGogPj49IDEpIHtcbiAgICBoZWxwZXJzLm11bHRpcGx5UCh0aGlzLk1bMV1baiArIGpdLCB0aGlzLk1bMV1bal0pO1xuICB9XG4gIGhlbHBlcnMubXVsdGlwbHlQKHRoaXMuTVsxXVsxXSwgdGhpcy5NWzBdWzhdKTtcblxuICBmb3IgKGogPSA0OyBqID49IDE7IGogPj49IDEpIHtcbiAgICBoZWxwZXJzLm11bHRpcGx5UCh0aGlzLk1bMF1baiArIGpdLCB0aGlzLk1bMF1bal0pO1xuICB9XG5cbiAgaSA9IDA7XG4gIGZvciAoOzspIHtcbiAgICBmb3IgKGogPSAyOyBqIDwgMTY7IGogKz0gaikge1xuICAgICAgZm9yIChrID0gMTsgayA8IGo7ICsraykge1xuICAgICAgICBoZWxwZXJzLnhvcih0aGlzLk1baV1bal0sIHRoaXMuTVtpXVtrXSwgdGhpcy5NW2ldW2ogKyBrXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCsraSA9PT0gMzIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaSA+IDEpIHtcbiAgICAgIC8vIE1baV1bMF0gaXMgWkVST0VTO1xuICAgICAgZm9yIChqID0gODsgaiA+IDA7IGogPj49IDEpIHtcbiAgICAgICAgaGVscGVycy5tdWx0aXBseVA4KHRoaXMuTVtpIC0gMl1bal0sIHRoaXMuTVtpXVtqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuR2NtOEtNdWx0aXBsaWVyLnByb3RvdHlwZS5tdWx0aXBseUggPSBmdW5jdGlvbih4KSB7XG4gIHZhciB6ID0gW107XG4gIGZvciAodmFyIGkgPSAxNTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgbSA9IHRoaXMuTVtpICsgaV1beFtpXSAmIDB4MGZdO1xuICAgIHpbMF0gXj0gbVswXTtcbiAgICB6WzFdIF49IG1bMV07XG4gICAgelsyXSBePSBtWzJdO1xuICAgIHpbM10gXj0gbVszXTtcbiAgICBtID0gdGhpcy5NW2kgKyBpICsgMV1bKHhbaV0gJiAweGYwKSA+Pj4gNF07XG4gICAgelswXSBePSBtWzBdO1xuICAgIHpbMV0gXj0gbVsxXTtcbiAgICB6WzJdIF49IG1bMl07XG4gICAgelszXSBePSBtWzNdO1xuICB9XG5cbiAgcGFjay5pbnRUb0JpZ0VuZGlhbih6LCB4LCAwKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFwiOGtcIjogR2NtOEtNdWx0aXBsaWVyXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/multipliers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/helpers.js":
/*!****************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/helpers.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/helpers.js - Cipher Helper Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar pack = __webpack_require__(/*! ./pack.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\");\n\nfunction doEncrypt(cipher, inb, inOff, outb, outOff) {\n  var input = new Array(4),\n      output = new Array(4);\n\n  pack.bigEndianToInt(inb, inOff, input);\n  cipher.encrypt(input, output);\n  pack.intToBigEndian(output, outb, outOff);\n}\n\nmodule.exports = {\n  encrypt: doEncrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyw4RUFBVzs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2hlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBkZXBzL2NpcGhlcm1vZGVzL2hlbHBlcnMuanMgLSBDaXBoZXIgSGVscGVyIEZ1bmN0aW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHBhY2sgPSByZXF1aXJlKFwiLi9wYWNrLmpzXCIpO1xuXG5mdW5jdGlvbiBkb0VuY3J5cHQoY2lwaGVyLCBpbmIsIGluT2ZmLCBvdXRiLCBvdXRPZmYpIHtcbiAgdmFyIGlucHV0ID0gbmV3IEFycmF5KDQpLFxuICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KDQpO1xuXG4gIHBhY2suYmlnRW5kaWFuVG9JbnQoaW5iLCBpbk9mZiwgaW5wdXQpO1xuICBjaXBoZXIuZW5jcnlwdChpbnB1dCwgb3V0cHV0KTtcbiAgcGFjay5pbnRUb0JpZ0VuZGlhbihvdXRwdXQsIG91dGIsIG91dE9mZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNyeXB0OiBkb0VuY3J5cHRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js":
/*!*************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/pack.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/pack.js - Pack/Unpack Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/umd/index.js\");\n\nvar pack = module.exports = {\n  intToBigEndian: function(n, bs, off) {\n    if (typeof n === \"number\") {\n      switch (arguments.length) {\n        case 1:\n          bs = Buffer.alloc(4);\n          pack.intToBigEndian(n, bs, 0);\n          break;\n        case 3:\n          bs[off] = 0xff & (n >>> 24);\n          bs[++off] = 0xff & (n >>> 16);\n          bs[++off] = 0xff & (n >>> 8);\n          bs[++off] = 0xff & (n);\n          break;\n        default:\n          throw new TypeError(\"Expected 1 or 3 arguments.\");\n      }\n    } else {\n      switch (arguments.length) {\n        case 1:\n          bs = Buffer.alloc(4 * n.length);\n          pack.intToBigEndian(n, bs, 0);\n          break;\n        case 3:\n          for (var i = 0; i < n.length; ++i) {\n            pack.intToBigEndian(n[i], bs, off);\n            off += 4;\n          }\n          break;\n        default:\n          throw new TypeError(\"Expected 1 or 3 arguments.\");\n      }\n    }\n\n    return bs;\n  },\n  longToBigEndian: function(n, bs, off) {\n    if (!Array.isArray(n)) {\n      // Single\n      switch (arguments.length) {\n        case 1:\n          bs = Buffer.alloc(8);\n          pack.longToBigEndian(n, bs, 0);\n          break;\n        case 3:\n          var lo = n.low,\n              hi = n.high;\n          pack.intToBigEndian(hi, bs, off);\n          pack.intToBigEndian(lo, bs, off + 4);\n          break;\n        default:\n          throw new TypeError(\"Expected 1 or 3 arguments.\");\n      }\n    } else {\n      // Array\n      switch (arguments.length) {\n        case 1:\n          bs = Buffer.alloc(8 * n.length);\n          pack.longToBigEndian(n, bs, 0);\n          break;\n        case 3:\n          for (var i = 0; i < n.length; ++i) {\n            pack.longToBigEndian(n[i], bs, off);\n            off += 8;\n          }\n          break;\n        default:\n          throw new TypeError(\"Expected 1 or 3 arguments.\");\n      }\n    }\n\n    return bs;\n  },\n\n  bigEndianToInt: function(bs, off, ns) {\n    switch (arguments.length) {\n      case 2:\n        var n = bs[off] << 24;\n        n |= (bs[++off] & 0xff) << 16;\n        n |= (bs[++off] & 0xff) << 8;\n        n |= (bs[++off] & 0xff);\n        return n;\n      case 3:\n        for (var i = 0; i < ns.length; ++i) {\n          ns[i] = pack.bigEndianToInt(bs, off);\n          off += 4;\n        }\n        break;\n      default:\n        throw new TypeError(\"Expected 2 or 3 arguments.\");\n    }\n  },\n  bigEndianToLong: function(bs, off, ns) {\n    switch (arguments.length) {\n      case 2:\n        var hi = pack.bigEndianToInt(bs, off);\n        var lo = pack.bigEndianToInt(bs, off + 4);\n        var num = new Long(lo, hi);\n        return num;\n      case 3:\n        for (var i = 0; i < ns.length; ++i) {\n          ns[i] = pack.bigEndianToLong(bs, off);\n          off += 8;\n        }\n        break;\n      default:\n        throw new TypeError(\"Expected 2 or 3 arguments.\");\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL3BhY2suanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxvREFBTTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2RlcHMvY2lwaGVybW9kZXMvcGFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGRlcHMvY2lwaGVybW9kZXMvcGFjay5qcyAtIFBhY2svVW5wYWNrIEZ1bmN0aW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIExvbmcgPSByZXF1aXJlKFwibG9uZ1wiKTtcblxudmFyIHBhY2sgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW50VG9CaWdFbmRpYW46IGZ1bmN0aW9uKG4sIGJzLCBvZmYpIHtcbiAgICBpZiAodHlwZW9mIG4gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYnMgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgICAgcGFjay5pbnRUb0JpZ0VuZGlhbihuLCBicywgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBic1tvZmZdID0gMHhmZiAmIChuID4+PiAyNCk7XG4gICAgICAgICAgYnNbKytvZmZdID0gMHhmZiAmIChuID4+PiAxNik7XG4gICAgICAgICAgYnNbKytvZmZdID0gMHhmZiAmIChuID4+PiA4KTtcbiAgICAgICAgICBic1srK29mZl0gPSAweGZmICYgKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAxIG9yIDMgYXJndW1lbnRzLlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBicyA9IEJ1ZmZlci5hbGxvYyg0ICogbi5sZW5ndGgpO1xuICAgICAgICAgIHBhY2suaW50VG9CaWdFbmRpYW4obiwgYnMsIDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBwYWNrLmludFRvQmlnRW5kaWFuKG5baV0sIGJzLCBvZmYpO1xuICAgICAgICAgICAgb2ZmICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAxIG9yIDMgYXJndW1lbnRzLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnM7XG4gIH0sXG4gIGxvbmdUb0JpZ0VuZGlhbjogZnVuY3Rpb24obiwgYnMsIG9mZikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShuKSkge1xuICAgICAgLy8gU2luZ2xlXG4gICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJzID0gQnVmZmVyLmFsbG9jKDgpO1xuICAgICAgICAgIHBhY2subG9uZ1RvQmlnRW5kaWFuKG4sIGJzLCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhciBsbyA9IG4ubG93LFxuICAgICAgICAgICAgICBoaSA9IG4uaGlnaDtcbiAgICAgICAgICBwYWNrLmludFRvQmlnRW5kaWFuKGhpLCBicywgb2ZmKTtcbiAgICAgICAgICBwYWNrLmludFRvQmlnRW5kaWFuKGxvLCBicywgb2ZmICsgNCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDEgb3IgMyBhcmd1bWVudHMuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcnJheVxuICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBicyA9IEJ1ZmZlci5hbGxvYyg4ICogbi5sZW5ndGgpO1xuICAgICAgICAgIHBhY2subG9uZ1RvQmlnRW5kaWFuKG4sIGJzLCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcGFjay5sb25nVG9CaWdFbmRpYW4obltpXSwgYnMsIG9mZik7XG4gICAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDEgb3IgMyBhcmd1bWVudHMuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBicztcbiAgfSxcblxuICBiaWdFbmRpYW5Ub0ludDogZnVuY3Rpb24oYnMsIG9mZiwgbnMpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdmFyIG4gPSBic1tvZmZdIDw8IDI0O1xuICAgICAgICBuIHw9IChic1srK29mZl0gJiAweGZmKSA8PCAxNjtcbiAgICAgICAgbiB8PSAoYnNbKytvZmZdICYgMHhmZikgPDwgODtcbiAgICAgICAgbiB8PSAoYnNbKytvZmZdICYgMHhmZik7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgbnNbaV0gPSBwYWNrLmJpZ0VuZGlhblRvSW50KGJzLCBvZmYpO1xuICAgICAgICAgIG9mZiArPSA0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDIgb3IgMyBhcmd1bWVudHMuXCIpO1xuICAgIH1cbiAgfSxcbiAgYmlnRW5kaWFuVG9Mb25nOiBmdW5jdGlvbihicywgb2ZmLCBucykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICB2YXIgaGkgPSBwYWNrLmJpZ0VuZGlhblRvSW50KGJzLCBvZmYpO1xuICAgICAgICB2YXIgbG8gPSBwYWNrLmJpZ0VuZGlhblRvSW50KGJzLCBvZmYgKyA0KTtcbiAgICAgICAgdmFyIG51bSA9IG5ldyBMb25nKGxvLCBoaSk7XG4gICAgICAgIHJldHVybiBudW07XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBuc1tpXSA9IHBhY2suYmlnRW5kaWFuVG9Mb25nKGJzLCBvZmYpO1xuICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDIgb3IgMyBhcmd1bWVudHMuXCIpO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ecc/curves.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ecc/curves.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * deps/ecc/curves.js - Elliptic Curve NIST/SECG/X9.62 Parameters\n * Original Copyright (c) 2003-2005  Tom Wu.\n * Modifications Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n *\n * Ported from Tom Wu, which is ported from BouncyCastle\n * Modified to reuse existing external NPM modules, restricted to the\n * NIST//SECG/X9.62 prime curves only, and formatted to match project\n * coding styles.\n */\n\n\n// Named EC curves\n\nvar BigInteger = (__webpack_require__(/*! ../../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\").jsbn).BigInteger,\n    ec = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/math.js\");\n\n// ----------------\n// X9ECParameters\n\n// constructor\nfunction X9ECParameters(curve, g, n, h) {\n  this.curve = curve;\n  this.g = g;\n  this.n = n;\n  this.h = h;\n}\n\nfunction x9getCurve() {\n  return this.curve;\n}\n\nfunction x9getG() {\n  return this.g;\n}\n\nfunction x9getN() {\n  return this.n;\n}\n\nfunction x9getH() {\n  return this.h;\n}\n\nX9ECParameters.prototype.getCurve = x9getCurve;\nX9ECParameters.prototype.getG = x9getG;\nX9ECParameters.prototype.getN = x9getN;\nX9ECParameters.prototype.getH = x9getH;\n\n// ----------------\n// SECNamedCurves\n\nfunction fromHex(s) { return new BigInteger(s, 16); }\n\nfunction secp256r1() {\n  // p = 2^224 (2^32 - 1) + 2^192 + 2^96 - 1\n  var p = fromHex(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\");\n  var a = fromHex(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\");\n  var b = fromHex(\"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\");\n  var n = fromHex(\"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\");\n  var h = BigInteger.ONE;\n  var curve = new ec.ECCurveFp(p, a, b);\n  var G = curve.decodePointHex(\"04\"\n              + \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\"\n              + \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\");\n  return new X9ECParameters(curve, G, n, h);\n}\n\nfunction secp384r1() {\n  // p = 2^384 - 2^128 - 2^96 + 2^32 - 1\n  var p = fromHex(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\");\n  var a = fromHex(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\");\n  var b = fromHex(\"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\");\n  var n = fromHex(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\");\n  var h = BigInteger.ONE;\n  var curve = new ec.ECCurveFp(p, a, b);\n  var G = curve.decodePointHex(\"04\"\n              + \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7\"\n              + \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\");\n  return new X9ECParameters(curve, G, n, h);\n}\n\nfunction secp521r1() {\n  // p = 2^521 - 1\n  var p = fromHex(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\");\n  var a = fromHex(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC\");\n  var b = fromHex(\"0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00\");\n  var n = fromHex(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\");\n  var h = BigInteger.ONE;\n  var curve = new ec.ECCurveFp(p, a, b);\n  var G = curve.decodePointHex(\"04\"\n                + \"00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66\"\n                + \"011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650\");\n  return new X9ECParameters(curve, G, n, h);\n}\n\n// ----------------\n// Public API\n\nvar CURVES = module.exports = {\n  \"secp256r1\": secp256r1(),\n  \"secp384r1\": secp384r1(),\n  \"secp521r1\": secp521r1()\n};\n\n// also export NIST names\nCURVES[\"P-256\"] = CURVES.secp256r1;\nCURVES[\"P-384\"] = CURVES.secp384r1;\nCURVES[\"P-521\"] = CURVES.secp521r1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2VjYy9jdXJ2ZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjs7QUFFQSxpQkFBaUIsc0dBQWdDO0FBQ2pELFNBQVMsbUJBQU8sQ0FBQyxzRUFBVzs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2VjYy9jdXJ2ZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBkZXBzL2VjYy9jdXJ2ZXMuanMgLSBFbGxpcHRpYyBDdXJ2ZSBOSVNUL1NFQ0cvWDkuNjIgUGFyYW1ldGVyc1xuICogT3JpZ2luYWwgQ29weXJpZ2h0IChjKSAyMDAzLTIwMDUgIFRvbSBXdS5cbiAqIE1vZGlmaWNhdGlvbnMgQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKlxuICogUG9ydGVkIGZyb20gVG9tIFd1LCB3aGljaCBpcyBwb3J0ZWQgZnJvbSBCb3VuY3lDYXN0bGVcbiAqIE1vZGlmaWVkIHRvIHJldXNlIGV4aXN0aW5nIGV4dGVybmFsIE5QTSBtb2R1bGVzLCByZXN0cmljdGVkIHRvIHRoZVxuICogTklTVC8vU0VDRy9YOS42MiBwcmltZSBjdXJ2ZXMgb25seSwgYW5kIGZvcm1hdHRlZCB0byBtYXRjaCBwcm9qZWN0XG4gKiBjb2Rpbmcgc3R5bGVzLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gTmFtZWQgRUMgY3VydmVzXG5cbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZShcIi4uLy4uL2RlcHMvZm9yZ2VcIikuanNibi5CaWdJbnRlZ2VyLFxuICAgIGVjID0gcmVxdWlyZShcIi4vbWF0aC5qc1wiKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLVxuLy8gWDlFQ1BhcmFtZXRlcnNcblxuLy8gY29uc3RydWN0b3JcbmZ1bmN0aW9uIFg5RUNQYXJhbWV0ZXJzKGN1cnZlLCBnLCBuLCBoKSB7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy5nID0gZztcbiAgdGhpcy5uID0gbjtcbiAgdGhpcy5oID0gaDtcbn1cblxuZnVuY3Rpb24geDlnZXRDdXJ2ZSgpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmU7XG59XG5cbmZ1bmN0aW9uIHg5Z2V0RygpIHtcbiAgcmV0dXJuIHRoaXMuZztcbn1cblxuZnVuY3Rpb24geDlnZXROKCkge1xuICByZXR1cm4gdGhpcy5uO1xufVxuXG5mdW5jdGlvbiB4OWdldEgoKSB7XG4gIHJldHVybiB0aGlzLmg7XG59XG5cblg5RUNQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRDdXJ2ZSA9IHg5Z2V0Q3VydmU7XG5YOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0RyA9IHg5Z2V0Rztcblg5RUNQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXROID0geDlnZXROO1xuWDlFQ1BhcmFtZXRlcnMucHJvdG90eXBlLmdldEggPSB4OWdldEg7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS1cbi8vIFNFQ05hbWVkQ3VydmVzXG5cbmZ1bmN0aW9uIGZyb21IZXgocykgeyByZXR1cm4gbmV3IEJpZ0ludGVnZXIocywgMTYpOyB9XG5cbmZ1bmN0aW9uIHNlY3AyNTZyMSgpIHtcbiAgLy8gcCA9IDJeMjI0ICgyXjMyIC0gMSkgKyAyXjE5MiArIDJeOTYgLSAxXG4gIHZhciBwID0gZnJvbUhleChcIkZGRkZGRkZGMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZcIik7XG4gIHZhciBhID0gZnJvbUhleChcIkZGRkZGRkZGMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkNcIik7XG4gIHZhciBiID0gZnJvbUhleChcIjVBQzYzNUQ4QUEzQTkzRTdCM0VCQkQ1NTc2OTg4NkJDNjUxRDA2QjBDQzUzQjBGNjNCQ0UzQzNFMjdEMjYwNEJcIik7XG4gIHZhciBuID0gZnJvbUhleChcIkZGRkZGRkZGMDAwMDAwMDBGRkZGRkZGRkZGRkZGRkZGQkNFNkZBQURBNzE3OUU4NEYzQjlDQUMyRkM2MzI1NTFcIik7XG4gIHZhciBoID0gQmlnSW50ZWdlci5PTkU7XG4gIHZhciBjdXJ2ZSA9IG5ldyBlYy5FQ0N1cnZlRnAocCwgYSwgYik7XG4gIHZhciBHID0gY3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiXG4gICAgICAgICAgICAgICsgXCI2QjE3RDFGMkUxMkM0MjQ3RjhCQ0U2RTU2M0E0NDBGMjc3MDM3RDgxMkRFQjMzQTBGNEExMzk0NUQ4OThDMjk2XCJcbiAgICAgICAgICAgICAgKyBcIjRGRTM0MkUyRkUxQTdGOUI4RUU3RUI0QTdDMEY5RTE2MkJDRTMzNTc2QjMxNUVDRUNCQjY0MDY4MzdCRjUxRjVcIik7XG4gIHJldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsIEcsIG4sIGgpO1xufVxuXG5mdW5jdGlvbiBzZWNwMzg0cjEoKSB7XG4gIC8vIHAgPSAyXjM4NCAtIDJeMTI4IC0gMl45NiArIDJeMzIgLSAxXG4gIHZhciBwID0gZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkVGRkZGRkZGRjAwMDAwMDAwMDAwMDAwMDBGRkZGRkZGRlwiKTtcbiAgdmFyIGEgPSBmcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRUZGRkZGRkZGMDAwMDAwMDAwMDAwMDAwMEZGRkZGRkZDXCIpO1xuICB2YXIgYiA9IGZyb21IZXgoXCJCMzMxMkZBN0UyM0VFN0U0OTg4RTA1NkJFM0Y4MkQxOTE4MUQ5QzZFRkU4MTQxMTIwMzE0MDg4RjUwMTM4NzVBQzY1NjM5OEQ4QTJFRDE5RDJBODVDOEVERDNFQzJBRUZcIik7XG4gIHZhciBuID0gZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkM3NjM0RDgxRjQzNzJEREY1ODFBMERCMjQ4QjBBNzdBRUNFQzE5NkFDQ0M1Mjk3M1wiKTtcbiAgdmFyIGggPSBCaWdJbnRlZ2VyLk9ORTtcbiAgdmFyIGN1cnZlID0gbmV3IGVjLkVDQ3VydmVGcChwLCBhLCBiKTtcbiAgdmFyIEcgPSBjdXJ2ZS5kZWNvZGVQb2ludEhleChcIjA0XCJcbiAgICAgICAgICAgICAgKyBcIkFBODdDQTIyQkU4QjA1Mzc4RUIxQzcxRUYzMjBBRDc0NkUxRDNCNjI4QkE3OUI5ODU5Rjc0MUUwODI1NDJBMzg1NTAyRjI1REJGNTUyOTZDM0E1NDVFMzg3Mjc2MEFCN1wiXG4gICAgICAgICAgICAgICsgXCIzNjE3REU0QTk2MjYyQzZGNUQ5RTk4QkY5MjkyREMyOUY4RjQxREJEMjg5QTE0N0NFOURBMzExM0I1RjBCOEMwMEE2MEIxQ0UxRDdFODE5RDdBNDMxRDdDOTBFQTBFNUZcIik7XG4gIHJldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsIEcsIG4sIGgpO1xufVxuXG5mdW5jdGlvbiBzZWNwNTIxcjEoKSB7XG4gIC8vIHAgPSAyXjUyMSAtIDFcbiAgdmFyIHAgPSBmcm9tSGV4KFwiMDFGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGXCIpO1xuICB2YXIgYSA9IGZyb21IZXgoXCIwMUZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkNcIik7XG4gIHZhciBiID0gZnJvbUhleChcIjAwNTE5NTNFQjk2MThFMUM5QTFGOTI5QTIxQTBCNjg1NDBFRUEyREE3MjVCOTlCMzE1RjNCOEI0ODk5MThFRjEwOUUxNTYxOTM5NTFFQzdFOTM3QjE2NTJDMEJEM0JCMUJGMDczNTczREY4ODNEMkMzNEYxRUY0NTFGRDQ2QjUwM0YwMFwiKTtcbiAgdmFyIG4gPSBmcm9tSGV4KFwiMDFGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkE1MTg2ODc4M0JGMkY5NjZCN0ZDQzAxNDhGNzA5QTVEMDNCQjVDOUI4ODk5QzQ3QUVCQjZGQjcxRTkxMzg2NDA5XCIpO1xuICB2YXIgaCA9IEJpZ0ludGVnZXIuT05FO1xuICB2YXIgY3VydmUgPSBuZXcgZWMuRUNDdXJ2ZUZwKHAsIGEsIGIpO1xuICB2YXIgRyA9IGN1cnZlLmRlY29kZVBvaW50SGV4KFwiMDRcIlxuICAgICAgICAgICAgICAgICsgXCIwMEM2ODU4RTA2QjcwNDA0RTlDRDlFM0VDQjY2MjM5NUI0NDI5QzY0ODEzOTA1M0ZCNTIxRjgyOEFGNjA2QjREM0RCQUExNEI1RTc3RUZFNzU5MjhGRTFEQzEyN0EyRkZBOERFMzM0OEIzQzE4NTZBNDI5QkY5N0U3RTMxQzJFNUJENjZcIlxuICAgICAgICAgICAgICAgICsgXCIwMTE4MzkyOTZBNzg5QTNCQzAwNDVDOEE1RkI0MkM3RDFCRDk5OEY1NDQ0OTU3OUI0NDY4MTdBRkJEMTcyNzNFNjYyQzk3RUU3Mjk5NUVGNDI2NDBDNTUwQjkwMTNGQUQwNzYxMzUzQzcwODZBMjcyQzI0MDg4QkU5NDc2OUZEMTY2NTBcIik7XG4gIHJldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsIEcsIG4sIGgpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tXG4vLyBQdWJsaWMgQVBJXG5cbnZhciBDVVJWRVMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCJzZWNwMjU2cjFcIjogc2VjcDI1NnIxKCksXG4gIFwic2VjcDM4NHIxXCI6IHNlY3AzODRyMSgpLFxuICBcInNlY3A1MjFyMVwiOiBzZWNwNTIxcjEoKVxufTtcblxuLy8gYWxzbyBleHBvcnQgTklTVCBuYW1lc1xuQ1VSVkVTW1wiUC0yNTZcIl0gPSBDVVJWRVMuc2VjcDI1NnIxO1xuQ1VSVkVTW1wiUC0zODRcIl0gPSBDVVJWRVMuc2VjcDM4NHIxO1xuQ1VSVkVTW1wiUC01MjFcIl0gPSBDVVJWRVMuc2VjcDUyMXIxO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ecc/curves.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ecc/index.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ecc/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * deps/ecc/index.js - Elliptic Curve Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    BigInteger = forge.jsbn.BigInteger,\n    ec = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/math.js\"),\n    CURVES = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/curves.js\");\n\n// ### Helpers\nfunction hex2bn(s) {\n  return new BigInteger(s, 16);\n}\n\nfunction bn2bin(bn, len) {\n  if (!len) {\n    len = Math.ceil(bn.bitLength() / 8);\n  }\n  len = len * 2;\n\n  var hex = bn.toString(16);\n  // truncate-left if too large\n  hex = hex.substring(Math.max(hex.length - len, 0));\n  // pad-left if too small\n  while (len > hex.length) {\n    hex = \"0\" + hex;\n  }\n\n  return Buffer.from(hex, \"hex\");\n}\nfunction bin2bn(s) {\n  if (\"string\" === typeof s) {\n    s = Buffer.from(s, \"binary\");\n  }\n  return hex2bn(s.toString(\"hex\"));\n}\n\nfunction keySizeBytes(params) {\n  return Math.ceil(params.getN().bitLength() / 8);\n}\n\nfunction namedCurve(curve) {\n  var params = CURVES[curve];\n  if (!params) {\n    throw new TypeError(\"unsupported named curve: \" + curve);\n  }\n\n  return params;\n}\n\nfunction normalizeEcdsa(params, md) {\n  var log2n = params.getN().bitLength(),\n      mdLen = md.length * 8;\n\n  var e = bin2bn(md);\n  if (log2n < mdLen) {\n    e = e.shiftRight(mdLen - log2n);\n  }\n\n  return e;\n}\n\n// ### EC Public Key\n\n/**\n *\n * @param {String} curve The named curve\n * @param {BigInteger} x The X coordinate\n * @param {BigInteger} y The Y coordinate\n */\nfunction ECPublicKey(curve, x, y) {\n  var params = namedCurve(curve),\n      c = params.getCurve();\n  var key = new ec.ECPointFp(c,\n                             c.fromBigInteger(x),\n                             c.fromBigInteger(y));\n\n  this.curve = curve;\n  this.params = params;\n  this.point = key;\n\n  var size = keySizeBytes(params);\n  this.x = bn2bin(x, size);\n  this.y = bn2bin(y, size);\n}\n\n// basics\nECPublicKey.prototype.isValid = function() {\n  return this.params.curve.contains(this.point);\n}\n\n// ECDSA\nECPublicKey.prototype.verify = function(md, sig) {\n  var N = this.params.getN(),\n      G = this.params.getG();\n\n  // prepare and validate (r, s)\n  var r = bin2bn(sig.r),\n      s = bin2bn(sig.s);\n  if (r.compareTo(BigInteger.ONE) < 0 || r.compareTo(N) >= 0) {\n    return false;\n  }\n  if (s.compareTo(BigInteger.ONE) < 0 || r.compareTo(N) >= 0) {\n    return false;\n  }\n\n  // normalize input\n  var e = normalizeEcdsa(this.params, md);\n  // verify (r, s)\n  var w = s.modInverse(N),\n      u1 = e.multiply(w).mod(N),\n      u2 = r.multiply(w).mod(N);\n\n  var v = G.multiplyTwo(u1, this.point, u2).getX().toBigInteger();\n  v = v.mod(N);\n\n  return v.equals(r);\n};\n\n// ### EC Private Key\n\n/**\n * @param {String} curve The named curve\n * @param {Buffer} key The private key value\n */\nfunction ECPrivateKey(curve, key) {\n  var params = namedCurve(curve);\n  this.curve = curve;\n  this.params = params;\n\n  var size = keySizeBytes(params);\n  this.d = bn2bin(key, size);\n}\n\nECPrivateKey.prototype.toPublicKey = function() {\n  var d = bin2bn(this.d);\n  var P = this.params.getG().multiply(d);\n  return new ECPublicKey(this.curve,\n                         P.getX().toBigInteger(),\n                         P.getY().toBigInteger());\n};\n\n// ECDSA\nECPrivateKey.prototype.sign = function(md) {\n  var keysize = keySizeBytes(this.params),\n      N = this.params.getN(),\n      G = this.params.getG(),\n      e = normalizeEcdsa(this.params, md),\n      d = bin2bn(this.d);\n\n  var r, s;\n  var k, x1, z;\n  do {\n    do {\n      // determine random nonce\n      do {\n        k = bin2bn(forge.random.getBytes(keysize));\n      } while (k.equals(BigInteger.ZERO) || k.compareTo(N) >= 0);\n      // (x1, y1) = k * G\n      x1 = G.multiply(k).getX().toBigInteger();\n      // r = x1 mod N\n      r = x1.mod(N);\n    } while (r.equals(BigInteger.ZERO));\n    // s = (k^-1 * (e + r * d)) mod N\n    z = d.multiply(r);\n    z = e.add(z);\n    s = k.modInverse(N).multiply(z).mod(N);\n  } while (s.equals(BigInteger.ONE));\n\n  // convert (r, s) to bytes\n  var len = keySizeBytes(this.params);\n  r = bn2bin(r, len);\n  s = bn2bin(s, len);\n\n  return {\n    r: r,\n    s: s\n  };\n};\n\n// basics\nECPrivateKey.prototype.isValid = function() {\n  var d = bin2bn(this.d),\n      n1 = this.params.getN().subtract(BigInteger.ONE);\n\n  return (d.compareTo(BigInteger.ONE) >= 0) &&\n         (d.compareTo(n1) < 0);\n}\n\n// ECDH\nECPrivateKey.prototype.computeSecret = function(pubkey) {\n  var d = bin2bn(this.d);\n  var S = pubkey.point.multiply(d).getX().toBigInteger();\n  S = bn2bin(S, keySizeBytes(this.params));\n  return S;\n};\n\n// ### Public API\nexports.generateKeyPair = function(curve) {\n  var params = namedCurve(curve),\n      n = params.getN();\n\n  // generate random within range [1, N-1)\n  var r = forge.random.getBytes(keySizeBytes(params));\n  r = bin2bn(r);\n\n  var n1 = n.subtract(BigInteger.ONE);\n  var d = r.mod(n1).add(BigInteger.ONE);\n\n  var privkey = new ECPrivateKey(curve, d),\n      pubkey = privkey.toPublicKey();\n\n  return {\n    \"private\": privkey,\n    \"public\": pubkey\n  };\n};\n\nexports.asPublicKey = function(curve, x, y) {\n  if (\"string\" === typeof x) {\n    x = hex2bn(x);\n  } else if (Buffer.isBuffer(x)) {\n    x = bin2bn(x);\n  }\n\n  if (\"string\" === typeof y) {\n    y = hex2bn(y);\n  } else if (Buffer.isBuffer(y)) {\n    y = bin2bn(y);\n  }\n\n  var pubkey = new ECPublicKey(curve, x, y);\n  return pubkey;\n};\nexports.asPrivateKey = function(curve, d) {\n  // Elaborate way to get to a Buffer from a (String|Buffer|BigInteger)\n  if (\"string\" === typeof d) {\n    d = hex2bn(d);\n  } else if (Buffer.isBuffer(d)) {\n    d = bin2bn(d);\n  }\n\n  var privkey = new ECPrivateKey(curve, d);\n  return privkey;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2VjYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QztBQUNBLFNBQVMsbUJBQU8sQ0FBQyxzRUFBVztBQUM1QixhQUFhLG1CQUFPLENBQUMsMEVBQWE7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2RlcHMvZWNjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZGVwcy9lY2MvaW5kZXguanMgLSBFbGxpcHRpYyBDdXJ2ZSBFbnRyeSBQb2ludFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZvcmdlID0gcmVxdWlyZShcIi4uLy4uL2RlcHMvZm9yZ2VcIiksXG4gICAgQmlnSW50ZWdlciA9IGZvcmdlLmpzYm4uQmlnSW50ZWdlcixcbiAgICBlYyA9IHJlcXVpcmUoXCIuL21hdGguanNcIiksXG4gICAgQ1VSVkVTID0gcmVxdWlyZShcIi4vY3VydmVzLmpzXCIpO1xuXG4vLyAjIyMgSGVscGVyc1xuZnVuY3Rpb24gaGV4MmJuKHMpIHtcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHMsIDE2KTtcbn1cblxuZnVuY3Rpb24gYm4yYmluKGJuLCBsZW4pIHtcbiAgaWYgKCFsZW4pIHtcbiAgICBsZW4gPSBNYXRoLmNlaWwoYm4uYml0TGVuZ3RoKCkgLyA4KTtcbiAgfVxuICBsZW4gPSBsZW4gKiAyO1xuXG4gIHZhciBoZXggPSBibi50b1N0cmluZygxNik7XG4gIC8vIHRydW5jYXRlLWxlZnQgaWYgdG9vIGxhcmdlXG4gIGhleCA9IGhleC5zdWJzdHJpbmcoTWF0aC5tYXgoaGV4Lmxlbmd0aCAtIGxlbiwgMCkpO1xuICAvLyBwYWQtbGVmdCBpZiB0b28gc21hbGxcbiAgd2hpbGUgKGxlbiA+IGhleC5sZW5ndGgpIHtcbiAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShoZXgsIFwiaGV4XCIpO1xufVxuZnVuY3Rpb24gYmluMmJuKHMpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBzKSB7XG4gICAgcyA9IEJ1ZmZlci5mcm9tKHMsIFwiYmluYXJ5XCIpO1xuICB9XG4gIHJldHVybiBoZXgyYm4ocy50b1N0cmluZyhcImhleFwiKSk7XG59XG5cbmZ1bmN0aW9uIGtleVNpemVCeXRlcyhwYXJhbXMpIHtcbiAgcmV0dXJuIE1hdGguY2VpbChwYXJhbXMuZ2V0TigpLmJpdExlbmd0aCgpIC8gOCk7XG59XG5cbmZ1bmN0aW9uIG5hbWVkQ3VydmUoY3VydmUpIHtcbiAgdmFyIHBhcmFtcyA9IENVUlZFU1tjdXJ2ZV07XG4gIGlmICghcGFyYW1zKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInVuc3VwcG9ydGVkIG5hbWVkIGN1cnZlOiBcIiArIGN1cnZlKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVjZHNhKHBhcmFtcywgbWQpIHtcbiAgdmFyIGxvZzJuID0gcGFyYW1zLmdldE4oKS5iaXRMZW5ndGgoKSxcbiAgICAgIG1kTGVuID0gbWQubGVuZ3RoICogODtcblxuICB2YXIgZSA9IGJpbjJibihtZCk7XG4gIGlmIChsb2cybiA8IG1kTGVuKSB7XG4gICAgZSA9IGUuc2hpZnRSaWdodChtZExlbiAtIGxvZzJuKTtcbiAgfVxuXG4gIHJldHVybiBlO1xufVxuXG4vLyAjIyMgRUMgUHVibGljIEtleVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY3VydmUgVGhlIG5hbWVkIGN1cnZlXG4gKiBAcGFyYW0ge0JpZ0ludGVnZXJ9IHggVGhlIFggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtCaWdJbnRlZ2VyfSB5IFRoZSBZIGNvb3JkaW5hdGVcbiAqL1xuZnVuY3Rpb24gRUNQdWJsaWNLZXkoY3VydmUsIHgsIHkpIHtcbiAgdmFyIHBhcmFtcyA9IG5hbWVkQ3VydmUoY3VydmUpLFxuICAgICAgYyA9IHBhcmFtcy5nZXRDdXJ2ZSgpO1xuICB2YXIga2V5ID0gbmV3IGVjLkVDUG9pbnRGcChjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmZyb21CaWdJbnRlZ2VyKHgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmZyb21CaWdJbnRlZ2VyKHkpKTtcblxuICB0aGlzLmN1cnZlID0gY3VydmU7XG4gIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB0aGlzLnBvaW50ID0ga2V5O1xuXG4gIHZhciBzaXplID0ga2V5U2l6ZUJ5dGVzKHBhcmFtcyk7XG4gIHRoaXMueCA9IGJuMmJpbih4LCBzaXplKTtcbiAgdGhpcy55ID0gYm4yYmluKHksIHNpemUpO1xufVxuXG4vLyBiYXNpY3NcbkVDUHVibGljS2V5LnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnBhcmFtcy5jdXJ2ZS5jb250YWlucyh0aGlzLnBvaW50KTtcbn1cblxuLy8gRUNEU0FcbkVDUHVibGljS2V5LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbihtZCwgc2lnKSB7XG4gIHZhciBOID0gdGhpcy5wYXJhbXMuZ2V0TigpLFxuICAgICAgRyA9IHRoaXMucGFyYW1zLmdldEcoKTtcblxuICAvLyBwcmVwYXJlIGFuZCB2YWxpZGF0ZSAociwgcylcbiAgdmFyIHIgPSBiaW4yYm4oc2lnLnIpLFxuICAgICAgcyA9IGJpbjJibihzaWcucyk7XG4gIGlmIChyLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPCAwIHx8IHIuY29tcGFyZVRvKE4pID49IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHMuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA8IDAgfHwgci5jb21wYXJlVG8oTikgPj0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBpbnB1dFxuICB2YXIgZSA9IG5vcm1hbGl6ZUVjZHNhKHRoaXMucGFyYW1zLCBtZCk7XG4gIC8vIHZlcmlmeSAociwgcylcbiAgdmFyIHcgPSBzLm1vZEludmVyc2UoTiksXG4gICAgICB1MSA9IGUubXVsdGlwbHkodykubW9kKE4pLFxuICAgICAgdTIgPSByLm11bHRpcGx5KHcpLm1vZChOKTtcblxuICB2YXIgdiA9IEcubXVsdGlwbHlUd28odTEsIHRoaXMucG9pbnQsIHUyKS5nZXRYKCkudG9CaWdJbnRlZ2VyKCk7XG4gIHYgPSB2Lm1vZChOKTtcblxuICByZXR1cm4gdi5lcXVhbHMocik7XG59O1xuXG4vLyAjIyMgRUMgUHJpdmF0ZSBLZXlcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gY3VydmUgVGhlIG5hbWVkIGN1cnZlXG4gKiBAcGFyYW0ge0J1ZmZlcn0ga2V5IFRoZSBwcml2YXRlIGtleSB2YWx1ZVxuICovXG5mdW5jdGlvbiBFQ1ByaXZhdGVLZXkoY3VydmUsIGtleSkge1xuICB2YXIgcGFyYW1zID0gbmFtZWRDdXJ2ZShjdXJ2ZSk7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG5cbiAgdmFyIHNpemUgPSBrZXlTaXplQnl0ZXMocGFyYW1zKTtcbiAgdGhpcy5kID0gYm4yYmluKGtleSwgc2l6ZSk7XG59XG5cbkVDUHJpdmF0ZUtleS5wcm90b3R5cGUudG9QdWJsaWNLZXkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGQgPSBiaW4yYm4odGhpcy5kKTtcbiAgdmFyIFAgPSB0aGlzLnBhcmFtcy5nZXRHKCkubXVsdGlwbHkoZCk7XG4gIHJldHVybiBuZXcgRUNQdWJsaWNLZXkodGhpcy5jdXJ2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBQLmdldFgoKS50b0JpZ0ludGVnZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBQLmdldFkoKS50b0JpZ0ludGVnZXIoKSk7XG59O1xuXG4vLyBFQ0RTQVxuRUNQcml2YXRlS2V5LnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24obWQpIHtcbiAgdmFyIGtleXNpemUgPSBrZXlTaXplQnl0ZXModGhpcy5wYXJhbXMpLFxuICAgICAgTiA9IHRoaXMucGFyYW1zLmdldE4oKSxcbiAgICAgIEcgPSB0aGlzLnBhcmFtcy5nZXRHKCksXG4gICAgICBlID0gbm9ybWFsaXplRWNkc2EodGhpcy5wYXJhbXMsIG1kKSxcbiAgICAgIGQgPSBiaW4yYm4odGhpcy5kKTtcblxuICB2YXIgciwgcztcbiAgdmFyIGssIHgxLCB6O1xuICBkbyB7XG4gICAgZG8ge1xuICAgICAgLy8gZGV0ZXJtaW5lIHJhbmRvbSBub25jZVxuICAgICAgZG8ge1xuICAgICAgICBrID0gYmluMmJuKGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhrZXlzaXplKSk7XG4gICAgICB9IHdoaWxlIChrLmVxdWFscyhCaWdJbnRlZ2VyLlpFUk8pIHx8IGsuY29tcGFyZVRvKE4pID49IDApO1xuICAgICAgLy8gKHgxLCB5MSkgPSBrICogR1xuICAgICAgeDEgPSBHLm11bHRpcGx5KGspLmdldFgoKS50b0JpZ0ludGVnZXIoKTtcbiAgICAgIC8vIHIgPSB4MSBtb2QgTlxuICAgICAgciA9IHgxLm1vZChOKTtcbiAgICB9IHdoaWxlIChyLmVxdWFscyhCaWdJbnRlZ2VyLlpFUk8pKTtcbiAgICAvLyBzID0gKGteLTEgKiAoZSArIHIgKiBkKSkgbW9kIE5cbiAgICB6ID0gZC5tdWx0aXBseShyKTtcbiAgICB6ID0gZS5hZGQoeik7XG4gICAgcyA9IGsubW9kSW52ZXJzZShOKS5tdWx0aXBseSh6KS5tb2QoTik7XG4gIH0gd2hpbGUgKHMuZXF1YWxzKEJpZ0ludGVnZXIuT05FKSk7XG5cbiAgLy8gY29udmVydCAociwgcykgdG8gYnl0ZXNcbiAgdmFyIGxlbiA9IGtleVNpemVCeXRlcyh0aGlzLnBhcmFtcyk7XG4gIHIgPSBibjJiaW4ociwgbGVuKTtcbiAgcyA9IGJuMmJpbihzLCBsZW4pO1xuXG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBzOiBzXG4gIH07XG59O1xuXG4vLyBiYXNpY3NcbkVDUHJpdmF0ZUtleS5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZCA9IGJpbjJibih0aGlzLmQpLFxuICAgICAgbjEgPSB0aGlzLnBhcmFtcy5nZXROKCkuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuXG4gIHJldHVybiAoZC5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID49IDApICYmXG4gICAgICAgICAoZC5jb21wYXJlVG8objEpIDwgMCk7XG59XG5cbi8vIEVDREhcbkVDUHJpdmF0ZUtleS5wcm90b3R5cGUuY29tcHV0ZVNlY3JldCA9IGZ1bmN0aW9uKHB1YmtleSkge1xuICB2YXIgZCA9IGJpbjJibih0aGlzLmQpO1xuICB2YXIgUyA9IHB1YmtleS5wb2ludC5tdWx0aXBseShkKS5nZXRYKCkudG9CaWdJbnRlZ2VyKCk7XG4gIFMgPSBibjJiaW4oUywga2V5U2l6ZUJ5dGVzKHRoaXMucGFyYW1zKSk7XG4gIHJldHVybiBTO1xufTtcblxuLy8gIyMjIFB1YmxpYyBBUElcbmV4cG9ydHMuZ2VuZXJhdGVLZXlQYWlyID0gZnVuY3Rpb24oY3VydmUpIHtcbiAgdmFyIHBhcmFtcyA9IG5hbWVkQ3VydmUoY3VydmUpLFxuICAgICAgbiA9IHBhcmFtcy5nZXROKCk7XG5cbiAgLy8gZ2VuZXJhdGUgcmFuZG9tIHdpdGhpbiByYW5nZSBbMSwgTi0xKVxuICB2YXIgciA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhrZXlTaXplQnl0ZXMocGFyYW1zKSk7XG4gIHIgPSBiaW4yYm4ocik7XG5cbiAgdmFyIG4xID0gbi5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gIHZhciBkID0gci5tb2QobjEpLmFkZChCaWdJbnRlZ2VyLk9ORSk7XG5cbiAgdmFyIHByaXZrZXkgPSBuZXcgRUNQcml2YXRlS2V5KGN1cnZlLCBkKSxcbiAgICAgIHB1YmtleSA9IHByaXZrZXkudG9QdWJsaWNLZXkoKTtcblxuICByZXR1cm4ge1xuICAgIFwicHJpdmF0ZVwiOiBwcml2a2V5LFxuICAgIFwicHVibGljXCI6IHB1YmtleVxuICB9O1xufTtcblxuZXhwb3J0cy5hc1B1YmxpY0tleSA9IGZ1bmN0aW9uKGN1cnZlLCB4LCB5KSB7XG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgeCkge1xuICAgIHggPSBoZXgyYm4oeCk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHgpKSB7XG4gICAgeCA9IGJpbjJibih4KTtcbiAgfVxuXG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgeSkge1xuICAgIHkgPSBoZXgyYm4oeSk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHkpKSB7XG4gICAgeSA9IGJpbjJibih5KTtcbiAgfVxuXG4gIHZhciBwdWJrZXkgPSBuZXcgRUNQdWJsaWNLZXkoY3VydmUsIHgsIHkpO1xuICByZXR1cm4gcHVia2V5O1xufTtcbmV4cG9ydHMuYXNQcml2YXRlS2V5ID0gZnVuY3Rpb24oY3VydmUsIGQpIHtcbiAgLy8gRWxhYm9yYXRlIHdheSB0byBnZXQgdG8gYSBCdWZmZXIgZnJvbSBhIChTdHJpbmd8QnVmZmVyfEJpZ0ludGVnZXIpXG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZCkge1xuICAgIGQgPSBoZXgyYm4oZCk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGQpKSB7XG4gICAgZCA9IGJpbjJibihkKTtcbiAgfVxuXG4gIHZhciBwcml2a2V5ID0gbmV3IEVDUHJpdmF0ZUtleShjdXJ2ZSwgZCk7XG4gIHJldHVybiBwcml2a2V5O1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ecc/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ecc/math.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ecc/math.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * deps/ecc/math.js - Elliptic Curve Math\n * Original Copyright (c) 2003-2005  Tom Wu.\n * Modifications Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n *\n * Ported from Tom Wu, which is ported from BouncyCastle\n * Modified to reuse existing external NPM modules, restricted to the\n * NIST//SECG/X9.62 prime curves only, and formatted to match project\n * coding styles.\n */\n\n\n// Basic Javascript Elliptic Curve implementation\n// Ported loosely from BouncyCastle's Java EC code\n// Only Fp curves implemented for now\n\nvar BigInteger = (__webpack_require__(/*! ../../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\").jsbn).BigInteger;\n\n// ----------------\n// Helpers\n\nfunction nbi() {\n  return new BigInteger(null);\n}\n\n// ----------------\n// Barrett modular reduction\n\n// constructor\nfunction Barrett(m) {\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x) {\n  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n  else if(x.compareTo(this.m) < 0) return x;\n  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n}\n\nfunction barrettRevert(x) { return x; }\n\n// x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\n  if (x.s < 0) { throw Error(\"Barrett reduction on negative input\"); }\n  x.drShiftTo(this.m.t-1,this.r2);\n  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n  x.subTo(this.r2,x);\n  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = x^2 mod m; x != r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = x*y mod m; x,y != r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n\n// ----------------\n// ECFieldElementFp\n\n// constructor\nfunction ECFieldElementFp(q, x) {\n  this.x = x;\n  // TODO if(x.compareTo(q) >= 0) error\n  this.p = q;\n}\n\nfunction feFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n  return (this.p.equals(other.p) && this.x.equals(other.x));\n}\n\nfunction feFpToBigInteger() {\n  return this.x;\n}\n\nfunction feFpNegate() {\n  return new ECFieldElementFp(this.p, this.x.negate().mod(this.p));\n}\n\nfunction feFpAdd(b) {\n  return new ECFieldElementFp(this.p, this.x.add(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpSubtract(b) {\n  return new ECFieldElementFp(this.p, this.x.subtract(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpMultiply(b) {\n  return new ECFieldElementFp(this.p, this.x.multiply(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpSquare() {\n  return new ECFieldElementFp(this.p, this.x.pow(2).mod(this.p));\n}\n\nfunction feFpDivide(b) {\n  return new ECFieldElementFp(this.p, this.x.multiply(b.toBigInteger().modInverse(this.p)).mod(this.p));\n}\n\nECFieldElementFp.prototype.equals = feFpEquals;\nECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;\nECFieldElementFp.prototype.negate = feFpNegate;\nECFieldElementFp.prototype.add = feFpAdd;\nECFieldElementFp.prototype.subtract = feFpSubtract;\nECFieldElementFp.prototype.multiply = feFpMultiply;\nECFieldElementFp.prototype.square = feFpSquare;\nECFieldElementFp.prototype.divide = feFpDivide;\n\n// ----------------\n// ECPointFp\n\n// constructor\nfunction ECPointFp(curve, x, y, z) {\n  this.curve = curve;\n  this.x = x;\n  this.y = y;\n  // Projective coordinates: either zinv == null or z * zinv == 1\n  // z and zinv are just BigIntegers, not fieldElements\n  if (!z) {\n    this.z = BigInteger.ONE;\n  } else {\n    this.z = z;\n  }\n  this.zinv = null;\n  //TODO: compression flag\n}\n\nfunction pointFpGetX() {\n  if(!this.zinv) {\n    this.zinv = this.z.modInverse(this.curve.p);\n  }\n  var r = this.x.toBigInteger().multiply(this.zinv);\n  this.curve.reduce(r);\n  return this.curve.fromBigInteger(r);\n}\n\nfunction pointFpGetY() {\n  if(!this.zinv) {\n    this.zinv = this.z.modInverse(this.curve.p);\n  }\n  var r = this.y.toBigInteger().multiply(this.zinv);\n  this.curve.reduce(r);\n  return this.curve.fromBigInteger(r);\n}\n\nfunction pointFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n  if (this.isInfinity()) {\n    return other.isInfinity();\n  }\n  if (other.isInfinity()) {\n    return this.isInfinity();\n  }\n  var u, v;\n  // u = Y2 * Z1 - Y1 * Z2\n  u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.p);\n  if (!u.equals(BigInteger.ZERO)) {\n    return false;\n  }\n  // v = X2 * Z1 - X1 * Z2\n  v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.p);\n  return v.equals(BigInteger.ZERO);\n}\n\nfunction pointFpIsInfinity() {\n  if ((this.x == null) && (this.y == null)) {\n    return true;\n  }\n  return (this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO));\n}\n\nfunction pointFpNegate() {\n    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);\n}\n\nfunction pointFpAdd(b) {\n  if (this.isInfinity()) {\n    return b;\n  }\n  if (b.isInfinity()) {\n    return this;\n  }\n\n  // u = Y2 * Z1 - Y1 * Z2\n  var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.p);\n  // v = X2 * Z1 - X1 * Z2\n  var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.p);\n\n  if (BigInteger.ZERO.equals(v)) {\n    if (BigInteger.ZERO.equals(u)) {\n      return this.twice(); // this == b, so double\n    }\n    return this.curve.getInfinity(); // this = -b, so infinity\n  }\n\n  var THREE = new BigInteger(\"3\");\n  var x1 = this.x.toBigInteger();\n  var y1 = this.y.toBigInteger();\n\n  var v2 = v.pow(2);\n  var v3 = v2.multiply(v);\n  var x1v2 = x1.multiply(v2);\n  var zu2 = u.pow(2).multiply(this.z);\n\n  // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)\n  var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p);\n  // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3\n  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p);\n  // z3 = v^3 * z1 * z2\n  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p);\n\n  return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);\n}\n\nfunction pointFpTwice() {\n  if(this.isInfinity()) {\n    return this;\n  }\n  if (this.y.toBigInteger().signum() === 0) {\n    return this.curve.getInfinity();\n  }\n\n  // TODO: optimized handling of constants\n  var THREE = new BigInteger(\"3\");\n  var x1 = this.x.toBigInteger();\n  var y1 = this.y.toBigInteger();\n\n  var y1z1 = y1.multiply(this.z);\n  var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p);\n  var a = this.curve.a.toBigInteger();\n\n  // w = 3 * x1^2 + a * z1^2\n  var w = x1.pow(2).multiply(THREE);\n  if (!BigInteger.ZERO.equals(a)) {\n    w = w.add(this.z.pow(2).multiply(a));\n  }\n  w = w.mod(this.curve.p);\n  //this.curve.reduce(w);\n  // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)\n  var x3 = w.pow(2).subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p);\n  // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3\n  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(2).multiply(w)).mod(this.curve.p);\n  // z3 = 8 * (y1 * z1)^3\n  var z3 = y1z1.pow(2).multiply(y1z1).shiftLeft(3).mod(this.curve.p);\n\n  return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);\n}\n\n// Simple NAF (Non-Adjacent Form) multiplication algorithm\n// TODO: modularize the multiplication algorithm\nfunction pointFpMultiply(k) {\n  if (this.isInfinity()) {\n    return this;\n  }\n  if (k.signum() === 0) {\n    return this.curve.getInfinity();\n  }\n\n  var e = k;\n  var h = e.multiply(new BigInteger(\"3\"));\n\n  var neg = this.negate();\n  var R = this;\n\n  var i;\n  for(i = h.bitLength() - 2; i > 0; --i) {\n    R = R.twice();\n\n    var hBit = h.testBit(i);\n    var eBit = e.testBit(i);\n\n    if (hBit !== eBit) {\n      R = R.add(hBit ? this : neg);\n    }\n  }\n\n  return R;\n}\n\n// Compute this*j + x*k (simultaneous multiplication)\nfunction pointFpMultiplyTwo(j, x, k) {\n  var i;\n  if (j.bitLength() > k.bitLength()) {\n    i = j.bitLength() - 1;\n  } else {\n    i = k.bitLength() - 1;\n  }\n\n  var R = this.curve.getInfinity();\n  var both = this.add(x);\n  while (i >= 0) {\n    R = R.twice();\n    if (j.testBit(i)) {\n      if (k.testBit(i)) {\n        R = R.add(both);\n      }\n      else {\n        R = R.add(this);\n      }\n    }\n    else {\n      if (k.testBit(i)) {\n        R = R.add(x);\n      }\n    }\n    --i;\n  }\n\n  return R;\n}\n\nECPointFp.prototype.getX = pointFpGetX;\nECPointFp.prototype.getY = pointFpGetY;\nECPointFp.prototype.equals = pointFpEquals;\nECPointFp.prototype.isInfinity = pointFpIsInfinity;\nECPointFp.prototype.negate = pointFpNegate;\nECPointFp.prototype.add = pointFpAdd;\nECPointFp.prototype.twice = pointFpTwice;\nECPointFp.prototype.multiply = pointFpMultiply;\nECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;\n\n// ----------------\n// ECCurveFp\n\n// constructor\nfunction ECCurveFp(p, a, b) {\n  this.p = p;\n  this.a = this.fromBigInteger(a);\n  this.b = this.fromBigInteger(b);\n  this.infinity = new ECPointFp(this, null, null);\n  this.reducer = new Barrett(this.p);\n}\n\nfunction curveFpgetP() {\n  return this.p;\n}\n\nfunction curveFpGetA() {\n  return this.a;\n}\n\nfunction curveFpGetB() {\n  return this.b;\n}\n\nfunction curveFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n  return (this.p.equals(other.p) && this.a.equals(other.a) && this.b.equals(other.b));\n}\n\nfunction curveFpContains(pt) {\n  // y^2 = x^3 + a*x + b mod p\n  var x = pt.getX().toBigInteger(),\n      y = pt.getY().toBigInteger(),\n      a = this.a.toBigInteger(),\n      b = this.b.toBigInteger(),\n      p = this.p;\n\n  var left = y.pow(2).mod(p),\n      right = x.pow(3).add(a.multiply(x)).add(b).mod(p)\n\n  return left.equals(right);\n}\n\nfunction curveFpGetInfinity() {\n  return this.infinity;\n}\n\nfunction curveFpFromBigInteger(x) {\n  return new ECFieldElementFp(this.p, x);\n}\n\nfunction curveReduce(x) {\n  this.reducer.reduce(x);\n}\n\n// for now, work with hex strings because they're easier in JS\nfunction curveFpDecodePointHex(s) {\n  switch (parseInt(s.substring(0, 2), 16)) {\n    // first byte\n    case 0:\n      return this.infinity;\n    case 2:\n    case 3:\n      // point compression not supported yet\n      return null;\n    case 4:\n    case 6:\n    case 7:\n      var len = (s.length - 2) / 2;\n      var xHex = s.substr(2, len);\n      var yHex = s.substr(len + 2, len);\n\n      return new ECPointFp(this,\n                           this.fromBigInteger(new BigInteger(xHex, 16)),\n                           this.fromBigInteger(new BigInteger(yHex, 16)));\n\n    default: // unsupported\n      return null;\n    }\n}\n\nfunction curveFpEncodePointHex(p) {\n  if (p.isInfinity()) {\n    return \"00\";\n  }\n  var xHex = p.getX().toBigInteger().toString(16);\n  var yHex = p.getY().toBigInteger().toString(16);\n  var oLen = this.getP().toString(16).length;\n  if ((oLen % 2) !== 0) {\n    oLen++;\n  }\n  while (xHex.length < oLen) {\n    xHex = \"0\" + xHex;\n  }\n  while (yHex.length < oLen) {\n    yHex = \"0\" + yHex;\n  }\n  return \"04\" + xHex + yHex;\n}\n\nECCurveFp.prototype.getP = curveFpgetP;\nECCurveFp.prototype.getA = curveFpGetA;\nECCurveFp.prototype.getB = curveFpGetB;\nECCurveFp.prototype.equals = curveFpEquals;\nECCurveFp.prototype.contains = curveFpContains;\nECCurveFp.prototype.getInfinity = curveFpGetInfinity;\nECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;\nECCurveFp.prototype.reduce = curveReduce;\nECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;\nECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;\n\n// Exports\nmodule.exports = {\n  ECFieldElementFp: ECFieldElementFp,\n  ECPointFp: ECPointFp,\n  ECCurveFp: ECCurveFp\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2VjYy9tYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzR0FBZ0M7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZUFBZSxhQUFhLGdCQUFnQjtBQUNyRDs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsNkJBQTZCLGVBQWU7O0FBRTVDLGtCQUFrQjtBQUNsQiwrQkFBK0IsbUJBQW1COztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvZGVwcy9lY2MvbWF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGRlcHMvZWNjL21hdGguanMgLSBFbGxpcHRpYyBDdXJ2ZSBNYXRoXG4gKiBPcmlnaW5hbCBDb3B5cmlnaHQgKGMpIDIwMDMtMjAwNSAgVG9tIFd1LlxuICogTW9kaWZpY2F0aW9ucyBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqXG4gKiBQb3J0ZWQgZnJvbSBUb20gV3UsIHdoaWNoIGlzIHBvcnRlZCBmcm9tIEJvdW5jeUNhc3RsZVxuICogTW9kaWZpZWQgdG8gcmV1c2UgZXhpc3RpbmcgZXh0ZXJuYWwgTlBNIG1vZHVsZXMsIHJlc3RyaWN0ZWQgdG8gdGhlXG4gKiBOSVNULy9TRUNHL1g5LjYyIHByaW1lIGN1cnZlcyBvbmx5LCBhbmQgZm9ybWF0dGVkIHRvIG1hdGNoIHByb2plY3RcbiAqIGNvZGluZyBzdHlsZXMuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG4vLyBCYXNpYyBKYXZhc2NyaXB0IEVsbGlwdGljIEN1cnZlIGltcGxlbWVudGF0aW9uXG4vLyBQb3J0ZWQgbG9vc2VseSBmcm9tIEJvdW5jeUNhc3RsZSdzIEphdmEgRUMgY29kZVxuLy8gT25seSBGcCBjdXJ2ZXMgaW1wbGVtZW50ZWQgZm9yIG5vd1xuXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoXCIuLi8uLi9kZXBzL2ZvcmdlXCIpLmpzYm4uQmlnSW50ZWdlcjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLVxuLy8gSGVscGVyc1xuXG5mdW5jdGlvbiBuYmkoKSB7XG4gIHJldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLVxuLy8gQmFycmV0dCBtb2R1bGFyIHJlZHVjdGlvblxuXG4vLyBjb25zdHJ1Y3RvclxuZnVuY3Rpb24gQmFycmV0dChtKSB7XG4gIC8vIHNldHVwIEJhcnJldHRcbiAgdGhpcy5yMiA9IG5iaSgpO1xuICB0aGlzLnEzID0gbmJpKCk7XG4gIEJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyKm0udCx0aGlzLnIyKTtcbiAgdGhpcy5tdSA9IHRoaXMucjIuZGl2aWRlKG0pO1xuICB0aGlzLm0gPSBtO1xufVxuXG5mdW5jdGlvbiBiYXJyZXR0Q29udmVydCh4KSB7XG4gIGlmKHgucyA8IDAgfHwgeC50ID4gMip0aGlzLm0udCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gIGVsc2UgaWYoeC5jb21wYXJlVG8odGhpcy5tKSA8IDApIHJldHVybiB4O1xuICBlbHNlIHsgdmFyIHIgPSBuYmkoKTsgeC5jb3B5VG8ocik7IHRoaXMucmVkdWNlKHIpOyByZXR1cm4gcjsgfVxufVxuXG5mdW5jdGlvbiBiYXJyZXR0UmV2ZXJ0KHgpIHsgcmV0dXJuIHg7IH1cblxuLy8geCA9IHggbW9kIG0gKEhBQyAxNC40MilcbmZ1bmN0aW9uIGJhcnJldHRSZWR1Y2UoeCkge1xuICBpZiAoeC5zIDwgMCkgeyB0aHJvdyBFcnJvcihcIkJhcnJldHQgcmVkdWN0aW9uIG9uIG5lZ2F0aXZlIGlucHV0XCIpOyB9XG4gIHguZHJTaGlmdFRvKHRoaXMubS50LTEsdGhpcy5yMik7XG4gIGlmKHgudCA+IHRoaXMubS50KzEpIHsgeC50ID0gdGhpcy5tLnQrMTsgeC5jbGFtcCgpOyB9XG4gIHRoaXMubXUubXVsdGlwbHlVcHBlclRvKHRoaXMucjIsdGhpcy5tLnQrMSx0aGlzLnEzKTtcbiAgdGhpcy5tLm11bHRpcGx5TG93ZXJUbyh0aGlzLnEzLHRoaXMubS50KzEsdGhpcy5yMik7XG4gIHdoaWxlKHguY29tcGFyZVRvKHRoaXMucjIpIDwgMCkgeC5kQWRkT2Zmc2V0KDEsdGhpcy5tLnQrMSk7XG4gIHguc3ViVG8odGhpcy5yMix4KTtcbiAgd2hpbGUoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB4LnN1YlRvKHRoaXMubSx4KTtcbn1cblxuLy8gciA9IHheMiBtb2QgbTsgeCAhPSByXG5mdW5jdGlvbiBiYXJyZXR0U3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbi8vIHIgPSB4KnkgbW9kIG07IHgseSAhPSByXG5mdW5jdGlvbiBiYXJyZXR0TXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbkJhcnJldHQucHJvdG90eXBlLmNvbnZlcnQgPSBiYXJyZXR0Q29udmVydDtcbkJhcnJldHQucHJvdG90eXBlLnJldmVydCA9IGJhcnJldHRSZXZlcnQ7XG5CYXJyZXR0LnByb3RvdHlwZS5yZWR1Y2UgPSBiYXJyZXR0UmVkdWNlO1xuQmFycmV0dC5wcm90b3R5cGUubXVsVG8gPSBiYXJyZXR0TXVsVG87XG5CYXJyZXR0LnByb3RvdHlwZS5zcXJUbyA9IGJhcnJldHRTcXJUbztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLVxuLy8gRUNGaWVsZEVsZW1lbnRGcFxuXG4vLyBjb25zdHJ1Y3RvclxuZnVuY3Rpb24gRUNGaWVsZEVsZW1lbnRGcChxLCB4KSB7XG4gIHRoaXMueCA9IHg7XG4gIC8vIFRPRE8gaWYoeC5jb21wYXJlVG8ocSkgPj0gMCkgZXJyb3JcbiAgdGhpcy5wID0gcTtcbn1cblxuZnVuY3Rpb24gZmVGcEVxdWFscyhvdGhlcikge1xuICBpZiAob3RoZXIgPT09IHRoaXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gKHRoaXMucC5lcXVhbHMob3RoZXIucCkgJiYgdGhpcy54LmVxdWFscyhvdGhlci54KSk7XG59XG5cbmZ1bmN0aW9uIGZlRnBUb0JpZ0ludGVnZXIoKSB7XG4gIHJldHVybiB0aGlzLng7XG59XG5cbmZ1bmN0aW9uIGZlRnBOZWdhdGUoKSB7XG4gIHJldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnAsIHRoaXMueC5uZWdhdGUoKS5tb2QodGhpcy5wKSk7XG59XG5cbmZ1bmN0aW9uIGZlRnBBZGQoYikge1xuICByZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5wLCB0aGlzLnguYWRkKGIudG9CaWdJbnRlZ2VyKCkpLm1vZCh0aGlzLnApKTtcbn1cblxuZnVuY3Rpb24gZmVGcFN1YnRyYWN0KGIpIHtcbiAgcmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucCwgdGhpcy54LnN1YnRyYWN0KGIudG9CaWdJbnRlZ2VyKCkpLm1vZCh0aGlzLnApKTtcbn1cblxuZnVuY3Rpb24gZmVGcE11bHRpcGx5KGIpIHtcbiAgcmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucCwgdGhpcy54Lm11bHRpcGx5KGIudG9CaWdJbnRlZ2VyKCkpLm1vZCh0aGlzLnApKTtcbn1cblxuZnVuY3Rpb24gZmVGcFNxdWFyZSgpIHtcbiAgcmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucCwgdGhpcy54LnBvdygyKS5tb2QodGhpcy5wKSk7XG59XG5cbmZ1bmN0aW9uIGZlRnBEaXZpZGUoYikge1xuICByZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5wLCB0aGlzLngubXVsdGlwbHkoYi50b0JpZ0ludGVnZXIoKS5tb2RJbnZlcnNlKHRoaXMucCkpLm1vZCh0aGlzLnApKTtcbn1cblxuRUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUuZXF1YWxzID0gZmVGcEVxdWFscztcbkVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLnRvQmlnSW50ZWdlciA9IGZlRnBUb0JpZ0ludGVnZXI7XG5FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5uZWdhdGUgPSBmZUZwTmVnYXRlO1xuRUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUuYWRkID0gZmVGcEFkZDtcbkVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLnN1YnRyYWN0ID0gZmVGcFN1YnRyYWN0O1xuRUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUubXVsdGlwbHkgPSBmZUZwTXVsdGlwbHk7XG5FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5zcXVhcmUgPSBmZUZwU3F1YXJlO1xuRUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUuZGl2aWRlID0gZmVGcERpdmlkZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLVxuLy8gRUNQb2ludEZwXG5cbi8vIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBFQ1BvaW50RnAoY3VydmUsIHgsIHksIHopIHtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xuICAvLyBQcm9qZWN0aXZlIGNvb3JkaW5hdGVzOiBlaXRoZXIgemludiA9PSBudWxsIG9yIHogKiB6aW52ID09IDFcbiAgLy8geiBhbmQgemludiBhcmUganVzdCBCaWdJbnRlZ2Vycywgbm90IGZpZWxkRWxlbWVudHNcbiAgaWYgKCF6KSB7XG4gICAgdGhpcy56ID0gQmlnSW50ZWdlci5PTkU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy56ID0gejtcbiAgfVxuICB0aGlzLnppbnYgPSBudWxsO1xuICAvL1RPRE86IGNvbXByZXNzaW9uIGZsYWdcbn1cblxuZnVuY3Rpb24gcG9pbnRGcEdldFgoKSB7XG4gIGlmKCF0aGlzLnppbnYpIHtcbiAgICB0aGlzLnppbnYgPSB0aGlzLnoubW9kSW52ZXJzZSh0aGlzLmN1cnZlLnApO1xuICB9XG4gIHZhciByID0gdGhpcy54LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMuemludik7XG4gIHRoaXMuY3VydmUucmVkdWNlKHIpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcihyKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRGcEdldFkoKSB7XG4gIGlmKCF0aGlzLnppbnYpIHtcbiAgICB0aGlzLnppbnYgPSB0aGlzLnoubW9kSW52ZXJzZSh0aGlzLmN1cnZlLnApO1xuICB9XG4gIHZhciByID0gdGhpcy55LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMuemludik7XG4gIHRoaXMuY3VydmUucmVkdWNlKHIpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcihyKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRGcEVxdWFscyhvdGhlcikge1xuICBpZiAob3RoZXIgPT09IHRoaXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpIHtcbiAgICByZXR1cm4gb3RoZXIuaXNJbmZpbml0eSgpO1xuICB9XG4gIGlmIChvdGhlci5pc0luZmluaXR5KCkpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luZmluaXR5KCk7XG4gIH1cbiAgdmFyIHUsIHY7XG4gIC8vIHUgPSBZMiAqIFoxIC0gWTEgKiBaMlxuICB1ID0gb3RoZXIueS50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHRoaXMueS50b0JpZ0ludGVnZXIoKS5tdWx0aXBseShvdGhlci56KSkubW9kKHRoaXMuY3VydmUucCk7XG4gIGlmICghdS5lcXVhbHMoQmlnSW50ZWdlci5aRVJPKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyB2ID0gWDIgKiBaMSAtIFgxICogWjJcbiAgdiA9IG90aGVyLngudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh0aGlzLngudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkob3RoZXIueikpLm1vZCh0aGlzLmN1cnZlLnApO1xuICByZXR1cm4gdi5lcXVhbHMoQmlnSW50ZWdlci5aRVJPKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRGcElzSW5maW5pdHkoKSB7XG4gIGlmICgodGhpcy54ID09IG51bGwpICYmICh0aGlzLnkgPT0gbnVsbCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gKHRoaXMuei5lcXVhbHMoQmlnSW50ZWdlci5aRVJPKSAmJiAhdGhpcy55LnRvQmlnSW50ZWdlcigpLmVxdWFscyhCaWdJbnRlZ2VyLlpFUk8pKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRGcE5lZ2F0ZSgpIHtcbiAgICByZXR1cm4gbmV3IEVDUG9pbnRGcCh0aGlzLmN1cnZlLCB0aGlzLngsIHRoaXMueS5uZWdhdGUoKSwgdGhpcy56KTtcbn1cblxuZnVuY3Rpb24gcG9pbnRGcEFkZChiKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSkge1xuICAgIHJldHVybiBiO1xuICB9XG4gIGlmIChiLmlzSW5maW5pdHkoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdSA9IFkyICogWjEgLSBZMSAqIFoyXG4gIHZhciB1ID0gYi55LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy55LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KGIueikpLm1vZCh0aGlzLmN1cnZlLnApO1xuICAvLyB2ID0gWDIgKiBaMSAtIFgxICogWjJcbiAgdmFyIHYgPSBiLngudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh0aGlzLngudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkoYi56KSkubW9kKHRoaXMuY3VydmUucCk7XG5cbiAgaWYgKEJpZ0ludGVnZXIuWkVSTy5lcXVhbHModikpIHtcbiAgICBpZiAoQmlnSW50ZWdlci5aRVJPLmVxdWFscyh1KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHdpY2UoKTsgLy8gdGhpcyA9PSBiLCBzbyBkb3VibGVcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VydmUuZ2V0SW5maW5pdHkoKTsgLy8gdGhpcyA9IC1iLCBzbyBpbmZpbml0eVxuICB9XG5cbiAgdmFyIFRIUkVFID0gbmV3IEJpZ0ludGVnZXIoXCIzXCIpO1xuICB2YXIgeDEgPSB0aGlzLngudG9CaWdJbnRlZ2VyKCk7XG4gIHZhciB5MSA9IHRoaXMueS50b0JpZ0ludGVnZXIoKTtcblxuICB2YXIgdjIgPSB2LnBvdygyKTtcbiAgdmFyIHYzID0gdjIubXVsdGlwbHkodik7XG4gIHZhciB4MXYyID0geDEubXVsdGlwbHkodjIpO1xuICB2YXIgenUyID0gdS5wb3coMikubXVsdGlwbHkodGhpcy56KTtcblxuICAvLyB4MyA9IHYgKiAoejIgKiAoejEgKiB1XjIgLSAyICogeDEgKiB2XjIpIC0gdl4zKVxuICB2YXIgeDMgPSB6dTIuc3VidHJhY3QoeDF2Mi5zaGlmdExlZnQoMSkpLm11bHRpcGx5KGIueikuc3VidHJhY3QodjMpLm11bHRpcGx5KHYpLm1vZCh0aGlzLmN1cnZlLnApO1xuICAvLyB5MyA9IHoyICogKDMgKiB4MSAqIHUgKiB2XjIgLSB5MSAqIHZeMyAtIHoxICogdV4zKSArIHUgKiB2XjNcbiAgdmFyIHkzID0geDF2Mi5tdWx0aXBseShUSFJFRSkubXVsdGlwbHkodSkuc3VidHJhY3QoeTEubXVsdGlwbHkodjMpKS5zdWJ0cmFjdCh6dTIubXVsdGlwbHkodSkpLm11bHRpcGx5KGIueikuYWRkKHUubXVsdGlwbHkodjMpKS5tb2QodGhpcy5jdXJ2ZS5wKTtcbiAgLy8gejMgPSB2XjMgKiB6MSAqIHoyXG4gIHZhciB6MyA9IHYzLm11bHRpcGx5KHRoaXMueikubXVsdGlwbHkoYi56KS5tb2QodGhpcy5jdXJ2ZS5wKTtcblxuICByZXR1cm4gbmV3IEVDUG9pbnRGcCh0aGlzLmN1cnZlLCB0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHgzKSwgdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcih5MyksIHozKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRGcFR3aWNlKCkge1xuICBpZih0aGlzLmlzSW5maW5pdHkoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmICh0aGlzLnkudG9CaWdJbnRlZ2VyKCkuc2lnbnVtKCkgPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpO1xuICB9XG5cbiAgLy8gVE9ETzogb3B0aW1pemVkIGhhbmRsaW5nIG9mIGNvbnN0YW50c1xuICB2YXIgVEhSRUUgPSBuZXcgQmlnSW50ZWdlcihcIjNcIik7XG4gIHZhciB4MSA9IHRoaXMueC50b0JpZ0ludGVnZXIoKTtcbiAgdmFyIHkxID0gdGhpcy55LnRvQmlnSW50ZWdlcigpO1xuXG4gIHZhciB5MXoxID0geTEubXVsdGlwbHkodGhpcy56KTtcbiAgdmFyIHkxc3F6MSA9IHkxejEubXVsdGlwbHkoeTEpLm1vZCh0aGlzLmN1cnZlLnApO1xuICB2YXIgYSA9IHRoaXMuY3VydmUuYS50b0JpZ0ludGVnZXIoKTtcblxuICAvLyB3ID0gMyAqIHgxXjIgKyBhICogejFeMlxuICB2YXIgdyA9IHgxLnBvdygyKS5tdWx0aXBseShUSFJFRSk7XG4gIGlmICghQmlnSW50ZWdlci5aRVJPLmVxdWFscyhhKSkge1xuICAgIHcgPSB3LmFkZCh0aGlzLnoucG93KDIpLm11bHRpcGx5KGEpKTtcbiAgfVxuICB3ID0gdy5tb2QodGhpcy5jdXJ2ZS5wKTtcbiAgLy90aGlzLmN1cnZlLnJlZHVjZSh3KTtcbiAgLy8geDMgPSAyICogeTEgKiB6MSAqICh3XjIgLSA4ICogeDEgKiB5MV4yICogejEpXG4gIHZhciB4MyA9IHcucG93KDIpLnN1YnRyYWN0KHgxLnNoaWZ0TGVmdCgzKS5tdWx0aXBseSh5MXNxejEpKS5zaGlmdExlZnQoMSkubXVsdGlwbHkoeTF6MSkubW9kKHRoaXMuY3VydmUucCk7XG4gIC8vIHkzID0gNCAqIHkxXjIgKiB6MSAqICgzICogdyAqIHgxIC0gMiAqIHkxXjIgKiB6MSkgLSB3XjNcbiAgdmFyIHkzID0gdy5tdWx0aXBseShUSFJFRSkubXVsdGlwbHkoeDEpLnN1YnRyYWN0KHkxc3F6MS5zaGlmdExlZnQoMSkpLnNoaWZ0TGVmdCgyKS5tdWx0aXBseSh5MXNxejEpLnN1YnRyYWN0KHcucG93KDIpLm11bHRpcGx5KHcpKS5tb2QodGhpcy5jdXJ2ZS5wKTtcbiAgLy8gejMgPSA4ICogKHkxICogejEpXjNcbiAgdmFyIHozID0geTF6MS5wb3coMikubXVsdGlwbHkoeTF6MSkuc2hpZnRMZWZ0KDMpLm1vZCh0aGlzLmN1cnZlLnApO1xuXG4gIHJldHVybiBuZXcgRUNQb2ludEZwKHRoaXMuY3VydmUsIHRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIoeDMpLCB0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHkzKSwgejMpO1xufVxuXG4vLyBTaW1wbGUgTkFGIChOb24tQWRqYWNlbnQgRm9ybSkgbXVsdGlwbGljYXRpb24gYWxnb3JpdGhtXG4vLyBUT0RPOiBtb2R1bGFyaXplIHRoZSBtdWx0aXBsaWNhdGlvbiBhbGdvcml0aG1cbmZ1bmN0aW9uIHBvaW50RnBNdWx0aXBseShrKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmIChrLnNpZ251bSgpID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VydmUuZ2V0SW5maW5pdHkoKTtcbiAgfVxuXG4gIHZhciBlID0gaztcbiAgdmFyIGggPSBlLm11bHRpcGx5KG5ldyBCaWdJbnRlZ2VyKFwiM1wiKSk7XG5cbiAgdmFyIG5lZyA9IHRoaXMubmVnYXRlKCk7XG4gIHZhciBSID0gdGhpcztcblxuICB2YXIgaTtcbiAgZm9yKGkgPSBoLmJpdExlbmd0aCgpIC0gMjsgaSA+IDA7IC0taSkge1xuICAgIFIgPSBSLnR3aWNlKCk7XG5cbiAgICB2YXIgaEJpdCA9IGgudGVzdEJpdChpKTtcbiAgICB2YXIgZUJpdCA9IGUudGVzdEJpdChpKTtcblxuICAgIGlmIChoQml0ICE9PSBlQml0KSB7XG4gICAgICBSID0gUi5hZGQoaEJpdCA/IHRoaXMgOiBuZWcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSO1xufVxuXG4vLyBDb21wdXRlIHRoaXMqaiArIHgqayAoc2ltdWx0YW5lb3VzIG11bHRpcGxpY2F0aW9uKVxuZnVuY3Rpb24gcG9pbnRGcE11bHRpcGx5VHdvKGosIHgsIGspIHtcbiAgdmFyIGk7XG4gIGlmIChqLmJpdExlbmd0aCgpID4gay5iaXRMZW5ndGgoKSkge1xuICAgIGkgPSBqLmJpdExlbmd0aCgpIC0gMTtcbiAgfSBlbHNlIHtcbiAgICBpID0gay5iaXRMZW5ndGgoKSAtIDE7XG4gIH1cblxuICB2YXIgUiA9IHRoaXMuY3VydmUuZ2V0SW5maW5pdHkoKTtcbiAgdmFyIGJvdGggPSB0aGlzLmFkZCh4KTtcbiAgd2hpbGUgKGkgPj0gMCkge1xuICAgIFIgPSBSLnR3aWNlKCk7XG4gICAgaWYgKGoudGVzdEJpdChpKSkge1xuICAgICAgaWYgKGsudGVzdEJpdChpKSkge1xuICAgICAgICBSID0gUi5hZGQoYm90aCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgUiA9IFIuYWRkKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChrLnRlc3RCaXQoaSkpIHtcbiAgICAgICAgUiA9IFIuYWRkKHgpO1xuICAgICAgfVxuICAgIH1cbiAgICAtLWk7XG4gIH1cblxuICByZXR1cm4gUjtcbn1cblxuRUNQb2ludEZwLnByb3RvdHlwZS5nZXRYID0gcG9pbnRGcEdldFg7XG5FQ1BvaW50RnAucHJvdG90eXBlLmdldFkgPSBwb2ludEZwR2V0WTtcbkVDUG9pbnRGcC5wcm90b3R5cGUuZXF1YWxzID0gcG9pbnRGcEVxdWFscztcbkVDUG9pbnRGcC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IHBvaW50RnBJc0luZmluaXR5O1xuRUNQb2ludEZwLnByb3RvdHlwZS5uZWdhdGUgPSBwb2ludEZwTmVnYXRlO1xuRUNQb2ludEZwLnByb3RvdHlwZS5hZGQgPSBwb2ludEZwQWRkO1xuRUNQb2ludEZwLnByb3RvdHlwZS50d2ljZSA9IHBvaW50RnBUd2ljZTtcbkVDUG9pbnRGcC5wcm90b3R5cGUubXVsdGlwbHkgPSBwb2ludEZwTXVsdGlwbHk7XG5FQ1BvaW50RnAucHJvdG90eXBlLm11bHRpcGx5VHdvID0gcG9pbnRGcE11bHRpcGx5VHdvO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tXG4vLyBFQ0N1cnZlRnBcblxuLy8gY29uc3RydWN0b3JcbmZ1bmN0aW9uIEVDQ3VydmVGcChwLCBhLCBiKSB7XG4gIHRoaXMucCA9IHA7XG4gIHRoaXMuYSA9IHRoaXMuZnJvbUJpZ0ludGVnZXIoYSk7XG4gIHRoaXMuYiA9IHRoaXMuZnJvbUJpZ0ludGVnZXIoYik7XG4gIHRoaXMuaW5maW5pdHkgPSBuZXcgRUNQb2ludEZwKHRoaXMsIG51bGwsIG51bGwpO1xuICB0aGlzLnJlZHVjZXIgPSBuZXcgQmFycmV0dCh0aGlzLnApO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUZwZ2V0UCgpIHtcbiAgcmV0dXJuIHRoaXMucDtcbn1cblxuZnVuY3Rpb24gY3VydmVGcEdldEEoKSB7XG4gIHJldHVybiB0aGlzLmE7XG59XG5cbmZ1bmN0aW9uIGN1cnZlRnBHZXRCKCkge1xuICByZXR1cm4gdGhpcy5iO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUZwRXF1YWxzKG90aGVyKSB7XG4gIGlmIChvdGhlciA9PT0gdGhpcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiAodGhpcy5wLmVxdWFscyhvdGhlci5wKSAmJiB0aGlzLmEuZXF1YWxzKG90aGVyLmEpICYmIHRoaXMuYi5lcXVhbHMob3RoZXIuYikpO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUZwQ29udGFpbnMocHQpIHtcbiAgLy8geV4yID0geF4zICsgYSp4ICsgYiBtb2QgcFxuICB2YXIgeCA9IHB0LmdldFgoKS50b0JpZ0ludGVnZXIoKSxcbiAgICAgIHkgPSBwdC5nZXRZKCkudG9CaWdJbnRlZ2VyKCksXG4gICAgICBhID0gdGhpcy5hLnRvQmlnSW50ZWdlcigpLFxuICAgICAgYiA9IHRoaXMuYi50b0JpZ0ludGVnZXIoKSxcbiAgICAgIHAgPSB0aGlzLnA7XG5cbiAgdmFyIGxlZnQgPSB5LnBvdygyKS5tb2QocCksXG4gICAgICByaWdodCA9IHgucG93KDMpLmFkZChhLm11bHRpcGx5KHgpKS5hZGQoYikubW9kKHApXG5cbiAgcmV0dXJuIGxlZnQuZXF1YWxzKHJpZ2h0KTtcbn1cblxuZnVuY3Rpb24gY3VydmVGcEdldEluZmluaXR5KCkge1xuICByZXR1cm4gdGhpcy5pbmZpbml0eTtcbn1cblxuZnVuY3Rpb24gY3VydmVGcEZyb21CaWdJbnRlZ2VyKHgpIHtcbiAgcmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucCwgeCk7XG59XG5cbmZ1bmN0aW9uIGN1cnZlUmVkdWNlKHgpIHtcbiAgdGhpcy5yZWR1Y2VyLnJlZHVjZSh4KTtcbn1cblxuLy8gZm9yIG5vdywgd29yayB3aXRoIGhleCBzdHJpbmdzIGJlY2F1c2UgdGhleSdyZSBlYXNpZXIgaW4gSlNcbmZ1bmN0aW9uIGN1cnZlRnBEZWNvZGVQb2ludEhleChzKSB7XG4gIHN3aXRjaCAocGFyc2VJbnQocy5zdWJzdHJpbmcoMCwgMiksIDE2KSkge1xuICAgIC8vIGZpcnN0IGJ5dGVcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gdGhpcy5pbmZpbml0eTtcbiAgICBjYXNlIDI6XG4gICAgY2FzZSAzOlxuICAgICAgLy8gcG9pbnQgY29tcHJlc3Npb24gbm90IHN1cHBvcnRlZCB5ZXRcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgNDpcbiAgICBjYXNlIDY6XG4gICAgY2FzZSA3OlxuICAgICAgdmFyIGxlbiA9IChzLmxlbmd0aCAtIDIpIC8gMjtcbiAgICAgIHZhciB4SGV4ID0gcy5zdWJzdHIoMiwgbGVuKTtcbiAgICAgIHZhciB5SGV4ID0gcy5zdWJzdHIobGVuICsgMiwgbGVuKTtcblxuICAgICAgcmV0dXJuIG5ldyBFQ1BvaW50RnAodGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbUJpZ0ludGVnZXIobmV3IEJpZ0ludGVnZXIoeEhleCwgMTYpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbUJpZ0ludGVnZXIobmV3IEJpZ0ludGVnZXIoeUhleCwgMTYpKSk7XG5cbiAgICBkZWZhdWx0OiAvLyB1bnN1cHBvcnRlZFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjdXJ2ZUZwRW5jb2RlUG9pbnRIZXgocCkge1xuICBpZiAocC5pc0luZmluaXR5KCkpIHtcbiAgICByZXR1cm4gXCIwMFwiO1xuICB9XG4gIHZhciB4SGV4ID0gcC5nZXRYKCkudG9CaWdJbnRlZ2VyKCkudG9TdHJpbmcoMTYpO1xuICB2YXIgeUhleCA9IHAuZ2V0WSgpLnRvQmlnSW50ZWdlcigpLnRvU3RyaW5nKDE2KTtcbiAgdmFyIG9MZW4gPSB0aGlzLmdldFAoKS50b1N0cmluZygxNikubGVuZ3RoO1xuICBpZiAoKG9MZW4gJSAyKSAhPT0gMCkge1xuICAgIG9MZW4rKztcbiAgfVxuICB3aGlsZSAoeEhleC5sZW5ndGggPCBvTGVuKSB7XG4gICAgeEhleCA9IFwiMFwiICsgeEhleDtcbiAgfVxuICB3aGlsZSAoeUhleC5sZW5ndGggPCBvTGVuKSB7XG4gICAgeUhleCA9IFwiMFwiICsgeUhleDtcbiAgfVxuICByZXR1cm4gXCIwNFwiICsgeEhleCArIHlIZXg7XG59XG5cbkVDQ3VydmVGcC5wcm90b3R5cGUuZ2V0UCA9IGN1cnZlRnBnZXRQO1xuRUNDdXJ2ZUZwLnByb3RvdHlwZS5nZXRBID0gY3VydmVGcEdldEE7XG5FQ0N1cnZlRnAucHJvdG90eXBlLmdldEIgPSBjdXJ2ZUZwR2V0QjtcbkVDQ3VydmVGcC5wcm90b3R5cGUuZXF1YWxzID0gY3VydmVGcEVxdWFscztcbkVDQ3VydmVGcC5wcm90b3R5cGUuY29udGFpbnMgPSBjdXJ2ZUZwQ29udGFpbnM7XG5FQ0N1cnZlRnAucHJvdG90eXBlLmdldEluZmluaXR5ID0gY3VydmVGcEdldEluZmluaXR5O1xuRUNDdXJ2ZUZwLnByb3RvdHlwZS5mcm9tQmlnSW50ZWdlciA9IGN1cnZlRnBGcm9tQmlnSW50ZWdlcjtcbkVDQ3VydmVGcC5wcm90b3R5cGUucmVkdWNlID0gY3VydmVSZWR1Y2U7XG5FQ0N1cnZlRnAucHJvdG90eXBlLmRlY29kZVBvaW50SGV4ID0gY3VydmVGcERlY29kZVBvaW50SGV4O1xuRUNDdXJ2ZUZwLnByb3RvdHlwZS5lbmNvZGVQb2ludEhleCA9IGN1cnZlRnBFbmNvZGVQb2ludEhleDtcblxuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVDRmllbGRFbGVtZW50RnA6IEVDRmllbGRFbGVtZW50RnAsXG4gIEVDUG9pbnRGcDogRUNQb2ludEZwLFxuICBFQ0N1cnZlRnA6IEVDQ3VydmVGcFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ecc/math.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/forge.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/forge.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/forge.js - Forge Package Customization\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! node-forge/lib/forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! node-forge/lib/aes */ \"(ssr)/./node_modules/node-forge/lib/aes.js\");\n__webpack_require__(/*! node-forge/lib/asn1 */ \"(ssr)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! node-forge/lib/cipher */ \"(ssr)/./node_modules/node-forge/lib/cipher.js\");\n__webpack_require__(/*! node-forge/lib/hmac */ \"(ssr)/./node_modules/node-forge/lib/hmac.js\");\n__webpack_require__(/*! node-forge/lib/mgf1 */ \"(ssr)/./node_modules/node-forge/lib/mgf1.js\");\n__webpack_require__(/*! node-forge/lib/pbkdf2 */ \"(ssr)/./node_modules/node-forge/lib/pbkdf2.js\");\n__webpack_require__(/*! node-forge/lib/pem */ \"(ssr)/./node_modules/node-forge/lib/pem.js\");\n__webpack_require__(/*! node-forge/lib/pkcs1 */ \"(ssr)/./node_modules/node-forge/lib/pkcs1.js\");\n__webpack_require__(/*! node-forge/lib/pkcs7 */ \"(ssr)/./node_modules/node-forge/lib/pkcs7.js\");\n__webpack_require__(/*! node-forge/lib/pki */ \"(ssr)/./node_modules/node-forge/lib/pki.js\");\n__webpack_require__(/*! node-forge/lib/prime */ \"(ssr)/./node_modules/node-forge/lib/prime.js\");\n__webpack_require__(/*! node-forge/lib/prng */ \"(ssr)/./node_modules/node-forge/lib/prng.js\");\n__webpack_require__(/*! node-forge/lib/pss */ \"(ssr)/./node_modules/node-forge/lib/pss.js\");\n__webpack_require__(/*! node-forge/lib/random */ \"(ssr)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! node-forge/lib/sha1 */ \"(ssr)/./node_modules/node-forge/lib/sha1.js\");\n__webpack_require__(/*! node-forge/lib/sha256 */ \"(ssr)/./node_modules/node-forge/lib/sha256.js\");\n__webpack_require__(/*! node-forge/lib/sha512 */ \"(ssr)/./node_modules/node-forge/lib/sha512.js\");\n__webpack_require__(/*! node-forge/lib/util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\n\n// Define AES \"raw\" cipher mode\nfunction modeRaw(options) {\n  options = options || {};\n  this.name = \"\";\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._blocks = this.blockSize / 4;\n  this._inBlock = new Array(this._blocks);\n  this._outBlock = new Array(this._blocks);\n}\n\nmodeRaw.prototype.start = function() {};\n\nmodeRaw.prototype.encrypt = function(input, output, finish) {\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  var i;\n\n  // get next block\n  for(i = 0; i < this._blocks; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(i = 0; i < this._blocks; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodeRaw.prototype.decrypt = function(input, output, finish) {\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  var i;\n\n  // get next block\n  for(i = 0; i < this._blocks; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // decrypt block\n  this.cipher.decrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(i = 0; i < this._blocks; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\n(function() {\n  var name = \"AES\",\n      mode = modeRaw,\n      factory;\n  factory = function() { return new forge.aes.Algorithm(name, mode); };\n  forge.cipher.registerAlgorithm(name, factory);\n})();\n\n// Ensure that the jsbn modInverse function always returns a positive result\nconst originalModInverse = forge.jsbn.BigInteger.prototype.modInverse;\nconst positiveModInverse = function(m) {\n  const inv = originalModInverse.apply(this, [m]);\n  return inv.mod(m);\n}\n\nforge.jsbn.BigInteger.prototype.modInverse = positiveModInverse;\n\nmodule.exports = forge;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2ZvcmdlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQXNCO0FBQzFDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzVCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsc0VBQW9CO0FBQzVCLG1CQUFPLENBQUMsMEVBQXNCO0FBQzlCLG1CQUFPLENBQUMsMEVBQXNCO0FBQzlCLG1CQUFPLENBQUMsc0VBQW9CO0FBQzVCLG1CQUFPLENBQUMsMEVBQXNCO0FBQzlCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsc0VBQW9CO0FBQzVCLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsd0VBQXFCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2RlcHMvZm9yZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBkZXBzL2ZvcmdlLmpzIC0gRm9yZ2UgUGFja2FnZSBDdXN0b21pemF0aW9uXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yZ2UgPSByZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvZm9yZ2VcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvYWVzXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL2FzbjFcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvY2lwaGVyXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL2htYWNcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvbWdmMVwiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9wYmtkZjJcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvcGVtXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3BrY3MxXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3BrY3M3XCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3BraVwiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9wcmltZVwiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9wcm5nXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3Bzc1wiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9yYW5kb21cIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvc2hhMVwiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9zaGEyNTZcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvc2hhNTEyXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3V0aWxcIik7XG5cbi8vIERlZmluZSBBRVMgXCJyYXdcIiBjaXBoZXIgbW9kZVxuZnVuY3Rpb24gbW9kZVJhdyhvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSBcIlwiO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9ibG9ja3MgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5fYmxvY2tzKTtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5fYmxvY2tzKTtcbn1cblxubW9kZVJhdy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHt9O1xuXG5tb2RlUmF3LnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIGlmKGlucHV0Lmxlbmd0aCgpIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXQubGVuZ3RoKCkgPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGk7XG5cbiAgLy8gZ2V0IG5leHQgYmxvY2tcbiAgZm9yKGkgPSAwOyBpIDwgdGhpcy5fYmxvY2tzOyArK2kpIHtcbiAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0XG4gIGZvcihpID0gMDsgaSA8IHRoaXMuX2Jsb2NrczsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxufTtcblxubW9kZVJhdy5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICBpZihpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpO1xuXG4gIC8vIGdldCBuZXh0IGJsb2NrXG4gIGZvcihpID0gMDsgaSA8IHRoaXMuX2Jsb2NrczsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBkZWNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmRlY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dFxuICBmb3IoaSA9IDA7IGkgPCB0aGlzLl9ibG9ja3M7ICsraSkge1xuICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tpXSk7XG4gIH1cbn07XG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIG5hbWUgPSBcIkFFU1wiLFxuICAgICAgbW9kZSA9IG1vZGVSYXcsXG4gICAgICBmYWN0b3J5O1xuICBmYWN0b3J5ID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgZm9yZ2UuYWVzLkFsZ29yaXRobShuYW1lLCBtb2RlKTsgfTtcbiAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xufSkoKTtcblxuLy8gRW5zdXJlIHRoYXQgdGhlIGpzYm4gbW9kSW52ZXJzZSBmdW5jdGlvbiBhbHdheXMgcmV0dXJucyBhIHBvc2l0aXZlIHJlc3VsdFxuY29uc3Qgb3JpZ2luYWxNb2RJbnZlcnNlID0gZm9yZ2UuanNibi5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnZlcnNlO1xuY29uc3QgcG9zaXRpdmVNb2RJbnZlcnNlID0gZnVuY3Rpb24obSkge1xuICBjb25zdCBpbnYgPSBvcmlnaW5hbE1vZEludmVyc2UuYXBwbHkodGhpcywgW21dKTtcbiAgcmV0dXJuIGludi5tb2QobSk7XG59XG5cbmZvcmdlLmpzYm4uQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52ZXJzZSA9IHBvc2l0aXZlTW9kSW52ZXJzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/forge.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/node-jose/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * index.js - Main Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nif (typeof Promise === \"undefined\") {\n  (__webpack_require__(/*! es6-promise */ \"(ssr)/./node_modules/es6-promise/dist/es6-promise.js\").polyfill)();\n}\n\nif (typeof Buffer === \"undefined\") {\n  (global || window).Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n}\n\nif (typeof process === \"undefined\") {\n  (global || window).process = __webpack_require__(/*! process */ \"process\");\n}\n\nif (!process.version) {\n  process.version = \"\";\n}\n\nvar JWS = __webpack_require__(/*! ./jws */ \"(ssr)/./node_modules/node-jose/lib/jws/index.js\");\n\nmodule.exports = {\n  JWA: __webpack_require__(/*! ./algorithms */ \"(ssr)/./node_modules/node-jose/lib/algorithms/index.js\"),\n  JWE: __webpack_require__(/*! ./jwe */ \"(ssr)/./node_modules/node-jose/lib/jwe/index.js\"),\n  JWK: __webpack_require__(/*! ./jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\"),\n  JWS: JWS,\n  util: __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n  parse: __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/node-jose/lib/parse/index.js\"),\n  canYouSee: JWS.createVerify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQSxFQUFFLHlHQUErQjtBQUNqQzs7QUFFQTtBQUNBLDhCQUE4QixvREFBd0I7QUFDdEQ7O0FBRUE7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyx3QkFBUztBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLDhEQUFPOztBQUV6QjtBQUNBLE9BQU8sbUJBQU8sQ0FBQyw0RUFBYztBQUM3QixPQUFPLG1CQUFPLENBQUMsOERBQU87QUFDdEIsT0FBTyxtQkFBTyxDQUFDLDhEQUFPO0FBQ3RCO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLGdFQUFRO0FBQ3hCLFNBQVMsbUJBQU8sQ0FBQyxrRUFBUztBQUMxQjtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogaW5kZXguanMgLSBNYWluIEVudHJ5IFBvaW50XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YgUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICByZXF1aXJlKFwiZXM2LXByb21pc2VcIikucG9seWZpbGwoKTtcbn1cblxuaWYgKHR5cGVvZiBCdWZmZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgKGdsb2JhbCB8fCB3aW5kb3cpLkJ1ZmZlciA9IHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xufVxuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgKGdsb2JhbCB8fCB3aW5kb3cpLnByb2Nlc3MgPSByZXF1aXJlKFwicHJvY2Vzc1wiKTtcbn1cblxuaWYgKCFwcm9jZXNzLnZlcnNpb24pIHtcbiAgcHJvY2Vzcy52ZXJzaW9uID0gXCJcIjtcbn1cblxudmFyIEpXUyA9IHJlcXVpcmUoXCIuL2p3c1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEpXQTogcmVxdWlyZShcIi4vYWxnb3JpdGhtc1wiKSxcbiAgSldFOiByZXF1aXJlKFwiLi9qd2VcIiksXG4gIEpXSzogcmVxdWlyZShcIi4vandrXCIpLFxuICBKV1M6IEpXUyxcbiAgdXRpbDogcmVxdWlyZShcIi4vdXRpbFwiKSxcbiAgcGFyc2U6IHJlcXVpcmUoXCIuL3BhcnNlXCIpLFxuICBjYW5Zb3VTZWU6IEpXUy5jcmVhdGVWZXJpZnlcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/decrypt.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/decrypt.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwe/decrypt.js - Decrypt from a JWE\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar base64url = __webpack_require__(/*! ../util/base64url */ \"(ssr)/./node_modules/node-jose/lib/util/base64url.js\"),\n    AlgConfig = __webpack_require__(/*! ../util/algconfig */ \"(ssr)/./node_modules/node-jose/lib/util/algconfig.js\"),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\"),\n    merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    pako = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/index.js\");\n\nvar DEFAULT_OPTIONS = {\n  algorithms: \"*\"\n};\n\n/**\n * @class JWE.Decrypter\n * @classdesc Processor of encrypted data.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead\n * call {@link JWE.createDecrypt}.\n */\nfunction JWEDecrypter(ks, globalOpts) {\n  var assumedKey,\n    keystore;\n\n  if (JWK.isKey(ks)) {\n    assumedKey = ks;\n    keystore = assumedKey.keystore;\n  } else if (JWK.isKeyStore(ks)) {\n    keystore = ks;\n  } else {\n    throw new TypeError(\"Keystore must be provided\");\n  }\n\n  globalOpts = merge({}, DEFAULT_OPTIONS, globalOpts);\n\n  /**\n   * Decrypts the given input.\n   *\n   * {opts}, if provided, is used to customize this specific decrypt operation.\n   * This argument has the same semantics as {JWE.createDecrypt}, and takes\n   * precedence over those options.\n   *\n   * The returned PRomise, when fulfilled, returns an object with the\n   * following members:\n   *\n   * - `header` - The JOSE Header, combined from the relevant \"header\" and\n   *            \"protected\" fields from the original JWE object.\n   * - `protected` - An array containing the names of the protected fields\n   * - `key` - The used to decrypt the content\n   * - `payload` - The decrypted content (as a Buffer)\n   * - `plaintext` - An alias for `payload`\n   *\n   * @param {Object|String} input The encrypted content\n   * @param {Object} [opts] The options for this decryption operation.\n   * @returns {Promise} A promise for the decyprted plaintext\n   */\n  Object.defineProperty(this, \"decrypt\", {\n    value: function(input, opts) {\n      opts = merge({}, globalOpts, opts || {});\n      var extraHandlers = opts.handlers || {};\n      var handlerKeys = Object.keys(extraHandlers);\n      var algSpec = new AlgConfig(opts.algorithms);\n\n      /* eslint camelcase: [0] */\n      if (typeof input === \"string\") {\n        input = input.split(\".\");\n        input = {\n          protected: input[0],\n          recipients: [\n            {\n              encrypted_key: input[1]\n            }\n          ],\n          iv: input[2],\n          ciphertext: input[3],\n          tag: input[4]\n        };\n      } else if (!input || typeof input !== \"object\") {\n        throw new Error(\"invalid input\");\n      }\n      if (\"encrypted_key\" in input) {\n        input.recipients = [\n          {\n            encrypted_key: input.encrypted_key\n          }\n        ];\n      }\n\n      var promise;\n\n      // ensure recipients exists\n      var rcptList = input.recipients || [{}];\n      promise = Promise.resolve(rcptList);\n\n      //combine fields\n      var fields,\n          protect;\n      promise = promise.then(function(rcptList) {\n        if (input.protected) {\n          protect = base64url.decode(input.protected).toString(\"utf8\");\n          protect = JSON.parse(protect);\n\n          // verify \"crit\" field first\n          var crit = protect.crit;\n          if (crit) {\n            if (!Array.isArray(crit)) {\n              return Promise.reject(new Error(\"Invalid 'crit' header\"));\n            }\n            for (var idx = 0; crit.length > idx; idx++) {\n              if (-1 === handlerKeys.indexOf(crit[idx])) {\n                return Promise.reject(new Error(\n                    \"Critical extension is not supported: \" + crit[idx]\n                ));\n              }\n            }\n          }\n\n          fields = protect;\n          protect = Object.keys(protect);\n        } else {\n          fields = {};\n          protect = [];\n        }\n        fields = merge(input.unprotected || {}, fields);\n\n        rcptList = rcptList.map(function(r) {\n          var promise = Promise.resolve();\n          var header = r.header || {};\n          header = merge(header, fields);\n          r.header = header;\n          r.protected = protect;\n\n          // check on allowed algorithms\n          if (!algSpec.match(header.alg)) {\n            promise = promise.then(function() {\n              return Promise.reject(new Error(\"Algorithm not allowed: \" + header.alg));\n            });\n          }\n          if (!algSpec.match(header.enc)) {\n            promise = promise.then(function () {\n              return Promise.reject(new Error(\"Algorithm not allowed: \" + header.enc));\n            });\n          }\n\n          if (header.epk) {\n            promise = promise.then(function() {\n              return JWK.asKey(header.epk);\n            });\n            promise = promise.then(function(epk) {\n              header.epk = epk.toObject(false);\n            });\n          }\n          return promise.then(function() {\n            return r;\n          });\n        });\n\n        return Promise.all(rcptList);\n      });\n\n      // decrypt with first key found\n      var algKey,\n        encKey,\n        kdata;\n      promise = promise.then(function(rcptList) {\n        var jwe = {};\n        return new Promise(function(resolve, reject) {\n          var processKey = function() {\n            var rcpt = rcptList.shift();\n            if (!rcpt) {\n              reject(new Error(\"no key found\"));\n              return;\n            }\n\n            var algPromise = Promise.resolve(rcpt);\n            algPromise = algPromise.then(function(rcpt) {\n              // try to unwrap encrypted key\n              var prekey = kdata = rcpt.encrypted_key || \"\";\n              prekey = base64url.decode(prekey);\n              algKey = assumedKey || keystore.get({\n                use: \"enc\",\n                alg: rcpt.header.alg,\n                kid: rcpt.header.kid\n              });\n              if (algKey) {\n                return algKey.unwrap(rcpt.header.alg, prekey, rcpt.header);\n              } else {\n                return Promise.reject();\n              }\n            });\n            algPromise = algPromise.then(function(key) {\n              encKey = {\n                \"kty\": \"oct\",\n                \"k\": base64url.encode(key)\n              };\n              encKey = JWK.asKey(encKey);\n              jwe.key = algKey;\n              jwe.header = rcpt.header;\n              jwe.protected = rcpt.protected;\n              resolve(jwe);\n            });\n            algPromise.catch(processKey);\n          };\n          processKey();\n        });\n      });\n\n      // assign decipher inputs\n      promise = promise.then(function(jwe) {\n        jwe.iv = input.iv;\n        jwe.tag = input.tag;\n        jwe.ciphertext = input.ciphertext;\n\n        return jwe;\n      });\n\n      // process any prepare-decrypt handlers\n      promise = promise.then(function(jwe) {\n        var processing = [];\n        handlerKeys.forEach(function(h) {\n          h = extraHandlers[h];\n          var p;\n          if (\"function\" === typeof h) {\n            p = h(jwe);\n          } else if (\"object\" === typeof h && \"function\" === typeof h.prepare) {\n            p = h.prepare(jwe);\n          }\n          if (p) {\n            processing.push(Promise.resolve(p));\n          }\n        });\n        return Promise.all(processing).then(function() {\n          // don't actually care about individual handler results\n          // assume {jwe} is updated\n          return jwe;\n        });\n      });\n\n      // prepare decrypt inputs\n      promise = promise.then(function(jwe) {\n        if (!Buffer.isBuffer(jwe.ciphertext)) {\n          jwe.ciphertext = base64url.decode(jwe.ciphertext);\n        }\n\n        return jwe;\n      });\n\n      // decrypt it!\n      promise = promise.then(function(jwe) {\n        var adata = input.protected;\n        if (\"aad\" in input && null != input.aad) {\n          adata += \".\" + input.aad;\n        }\n\n        var params = {\n          iv: jwe.iv,\n          adata: adata,\n          tag: jwe.tag,\n          kdata: kdata,\n          epu: jwe.epu,\n          epv: jwe.epv\n        };\n        var cdata = jwe.ciphertext;\n\n        delete jwe.iv;\n        delete jwe.tag;\n        delete jwe.ciphertext;\n\n        return encKey.\n          then(function(enkKey) {\n            return enkKey.decrypt(jwe.header.enc, cdata, params).\n              then(function(pdata) {\n                jwe.payload = jwe.plaintext = pdata;\n                return jwe;\n              });\n          });\n      });\n\n      // (OPTIONAL) decompress plaintext\n      promise = promise.then(function(jwe) {\n        if (\"DEF\" === jwe.header.zip) {\n          return new Promise(function(resolve, reject) {\n            try {\n              var data = pako.inflateRaw(Buffer.from(jwe.plaintext))\n\n              jwe.payload = jwe.plaintext = Buffer.from(data);\n              resolve(jwe);\n            } catch (err) {\n              reject(err);\n            }\n          });\n        }\n\n        return jwe;\n      });\n\n      // process any post-decrypt handlers\n      promise = promise.then(function(jwe) {\n        var processing = [];\n        handlerKeys.forEach(function(h) {\n          h = extraHandlers[h];\n          var p;\n          if (\"object\" === typeof h && \"function\" === typeof h.complete) {\n            p = h.complete(jwe);\n          }\n          if (p) {\n            processing.push(Promise.resolve(p));\n          }\n        });\n        return Promise.all(processing).then(function() {\n          // don't actually care about individual handler results\n          // assume {jwe} is updated\n          return jwe;\n        });\n      });\n\n      return promise;\n    }\n  });\n}\n\n/**\n * @description\n * Creates a new Decrypter for the given Key or KeyStore.\n *\n * {opts}, when provided, is used to customize decryption processes. The\n * following options are currently supported:\n *\n * - `handlers` - An object where each name is a JOSE header member name and\n *   the value can be a boolean, function, or an object.\n *\n * Handlers are intended to support 'crit' extensions. When a boolean value,\n * the member is expected to be processed once decryption is fully complete.\n * When a function, it is called just before the ciphertext is decrypted\n * (processed as if it were a `prepare` handler, as decribed below). When an\n * object, it can contain any of the following members:\n *\n * - `recipient` - A function called after a valid key is determined; it takes\n *   an object describing the recipient, and returns a Promise that is\n *   fulfilled once the handler's processing is complete.\n * - `prepare` - A function called just prior to decrypting the ciphertext;\n *   it takes an object describing the decryption result (but containing\n *   `ciphertext` and `tag' instead of `payload` and `plaintext`), and\n *   returns a Promise that is fulfilled once the handler's processing is\n *   complete.\n * - `complete` - A function called once decryption is complete, just prior\n *   to fulfilling the Promise returned by `decrypt()`; it takes the object\n *   that will be returned by `decrypt()`'s fulfilled Promise, and returns\n *   a Promise that is fulfilled once the handler's processing is complete.\n *\n * Note that normal processing of `decrypt()` does not continue until all\n * relevant handlers have completed. Any changes handlers make to the\n * provided objects affects `decrypt()`'s processing.\n *\n * @param {JWK.Key|JWK.KeyStore} ks The Key or KeyStore to use for decryption.\n * @param {Object} [opts] The options for this Decrypter.\n * @returns {JWE.Decrypter} The new Decrypter.\n */\nfunction createDecrypt(ks, opts) {\n  var dec = new JWEDecrypter(ks, opts);\n  return dec;\n}\n\nmodule.exports = {\n  decrypter: JWEDecrypter,\n  createDecrypt: createDecrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZGVjcnlwdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQW1CO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFtQjtBQUMzQyxVQUFVLG1CQUFPLENBQUMsK0RBQVE7QUFDMUIsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyxnREFBTTs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFLO0FBQ1gsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSztBQUMxQjtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixXQUFXO0FBQ1gsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBSztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsUUFBUTtBQUNuQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZGVjcnlwdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3ZS9kZWNyeXB0LmpzIC0gRGVjcnlwdCBmcm9tIGEgSldFXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBiYXNlNjR1cmwgPSByZXF1aXJlKFwiLi4vdXRpbC9iYXNlNjR1cmxcIiksXG4gICAgQWxnQ29uZmlnID0gcmVxdWlyZShcIi4uL3V0aWwvYWxnY29uZmlnXCIpLFxuICAgIEpXSyA9IHJlcXVpcmUoXCIuLi9qd2tcIiksXG4gICAgbWVyZ2UgPSByZXF1aXJlKFwiLi4vdXRpbC9tZXJnZVwiKSxcbiAgICBwYWtvID0gcmVxdWlyZShcInBha29cIik7XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIGFsZ29yaXRobXM6IFwiKlwiXG59O1xuXG4vKipcbiAqIEBjbGFzcyBKV0UuRGVjcnlwdGVyXG4gKiBAY2xhc3NkZXNjIFByb2Nlc3NvciBvZiBlbmNyeXB0ZWQgZGF0YS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqICoqTk9URToqKiBUaGlzIGNsYXNzIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuIEluc3RlYWRcbiAqIGNhbGwge0BsaW5rIEpXRS5jcmVhdGVEZWNyeXB0fS5cbiAqL1xuZnVuY3Rpb24gSldFRGVjcnlwdGVyKGtzLCBnbG9iYWxPcHRzKSB7XG4gIHZhciBhc3N1bWVkS2V5LFxuICAgIGtleXN0b3JlO1xuXG4gIGlmIChKV0suaXNLZXkoa3MpKSB7XG4gICAgYXNzdW1lZEtleSA9IGtzO1xuICAgIGtleXN0b3JlID0gYXNzdW1lZEtleS5rZXlzdG9yZTtcbiAgfSBlbHNlIGlmIChKV0suaXNLZXlTdG9yZShrcykpIHtcbiAgICBrZXlzdG9yZSA9IGtzO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJLZXlzdG9yZSBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICB9XG5cbiAgZ2xvYmFsT3B0cyA9IG1lcmdlKHt9LCBERUZBVUxUX09QVElPTlMsIGdsb2JhbE9wdHMpO1xuXG4gIC8qKlxuICAgKiBEZWNyeXB0cyB0aGUgZ2l2ZW4gaW5wdXQuXG4gICAqXG4gICAqIHtvcHRzfSwgaWYgcHJvdmlkZWQsIGlzIHVzZWQgdG8gY3VzdG9taXplIHRoaXMgc3BlY2lmaWMgZGVjcnlwdCBvcGVyYXRpb24uXG4gICAqIFRoaXMgYXJndW1lbnQgaGFzIHRoZSBzYW1lIHNlbWFudGljcyBhcyB7SldFLmNyZWF0ZURlY3J5cHR9LCBhbmQgdGFrZXNcbiAgICogcHJlY2VkZW5jZSBvdmVyIHRob3NlIG9wdGlvbnMuXG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBQUm9taXNlLCB3aGVuIGZ1bGZpbGxlZCwgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICogZm9sbG93aW5nIG1lbWJlcnM6XG4gICAqXG4gICAqIC0gYGhlYWRlcmAgLSBUaGUgSk9TRSBIZWFkZXIsIGNvbWJpbmVkIGZyb20gdGhlIHJlbGV2YW50IFwiaGVhZGVyXCIgYW5kXG4gICAqICAgICAgICAgICAgXCJwcm90ZWN0ZWRcIiBmaWVsZHMgZnJvbSB0aGUgb3JpZ2luYWwgSldFIG9iamVjdC5cbiAgICogLSBgcHJvdGVjdGVkYCAtIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIHRoZSBwcm90ZWN0ZWQgZmllbGRzXG4gICAqIC0gYGtleWAgLSBUaGUgdXNlZCB0byBkZWNyeXB0IHRoZSBjb250ZW50XG4gICAqIC0gYHBheWxvYWRgIC0gVGhlIGRlY3J5cHRlZCBjb250ZW50IChhcyBhIEJ1ZmZlcilcbiAgICogLSBgcGxhaW50ZXh0YCAtIEFuIGFsaWFzIGZvciBgcGF5bG9hZGBcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpbnB1dCBUaGUgZW5jcnlwdGVkIGNvbnRlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBUaGUgb3B0aW9ucyBmb3IgdGhpcyBkZWNyeXB0aW9uIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSBmb3IgdGhlIGRlY3lwcnRlZCBwbGFpbnRleHRcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlY3J5cHRcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihpbnB1dCwgb3B0cykge1xuICAgICAgb3B0cyA9IG1lcmdlKHt9LCBnbG9iYWxPcHRzLCBvcHRzIHx8IHt9KTtcbiAgICAgIHZhciBleHRyYUhhbmRsZXJzID0gb3B0cy5oYW5kbGVycyB8fCB7fTtcbiAgICAgIHZhciBoYW5kbGVyS2V5cyA9IE9iamVjdC5rZXlzKGV4dHJhSGFuZGxlcnMpO1xuICAgICAgdmFyIGFsZ1NwZWMgPSBuZXcgQWxnQ29uZmlnKG9wdHMuYWxnb3JpdGhtcyk7XG5cbiAgICAgIC8qIGVzbGludCBjYW1lbGNhc2U6IFswXSAqL1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpbnB1dCA9IGlucHV0LnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaW5wdXQgPSB7XG4gICAgICAgICAgcHJvdGVjdGVkOiBpbnB1dFswXSxcbiAgICAgICAgICByZWNpcGllbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVuY3J5cHRlZF9rZXk6IGlucHV0WzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBpdjogaW5wdXRbMl0sXG4gICAgICAgICAgY2lwaGVydGV4dDogaW5wdXRbM10sXG4gICAgICAgICAgdGFnOiBpbnB1dFs0XVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXRcIik7XG4gICAgICB9XG4gICAgICBpZiAoXCJlbmNyeXB0ZWRfa2V5XCIgaW4gaW5wdXQpIHtcbiAgICAgICAgaW5wdXQucmVjaXBpZW50cyA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbmNyeXB0ZWRfa2V5OiBpbnB1dC5lbmNyeXB0ZWRfa2V5XG4gICAgICAgICAgfVxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgLy8gZW5zdXJlIHJlY2lwaWVudHMgZXhpc3RzXG4gICAgICB2YXIgcmNwdExpc3QgPSBpbnB1dC5yZWNpcGllbnRzIHx8IFt7fV07XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHJjcHRMaXN0KTtcblxuICAgICAgLy9jb21iaW5lIGZpZWxkc1xuICAgICAgdmFyIGZpZWxkcyxcbiAgICAgICAgICBwcm90ZWN0O1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyY3B0TGlzdCkge1xuICAgICAgICBpZiAoaW5wdXQucHJvdGVjdGVkKSB7XG4gICAgICAgICAgcHJvdGVjdCA9IGJhc2U2NHVybC5kZWNvZGUoaW5wdXQucHJvdGVjdGVkKS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICAgICAgcHJvdGVjdCA9IEpTT04ucGFyc2UocHJvdGVjdCk7XG5cbiAgICAgICAgICAvLyB2ZXJpZnkgXCJjcml0XCIgZmllbGQgZmlyc3RcbiAgICAgICAgICB2YXIgY3JpdCA9IHByb3RlY3QuY3JpdDtcbiAgICAgICAgICBpZiAoY3JpdCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNyaXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkICdjcml0JyBoZWFkZXJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgY3JpdC5sZW5ndGggPiBpZHg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgIGlmICgtMSA9PT0gaGFuZGxlcktleXMuaW5kZXhPZihjcml0W2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJDcml0aWNhbCBleHRlbnNpb24gaXMgbm90IHN1cHBvcnRlZDogXCIgKyBjcml0W2lkeF1cbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpZWxkcyA9IHByb3RlY3Q7XG4gICAgICAgICAgcHJvdGVjdCA9IE9iamVjdC5rZXlzKHByb3RlY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpZWxkcyA9IHt9O1xuICAgICAgICAgIHByb3RlY3QgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHMgPSBtZXJnZShpbnB1dC51bnByb3RlY3RlZCB8fCB7fSwgZmllbGRzKTtcblxuICAgICAgICByY3B0TGlzdCA9IHJjcHRMaXN0Lm1hcChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICB2YXIgaGVhZGVyID0gci5oZWFkZXIgfHwge307XG4gICAgICAgICAgaGVhZGVyID0gbWVyZ2UoaGVhZGVyLCBmaWVsZHMpO1xuICAgICAgICAgIHIuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICAgIHIucHJvdGVjdGVkID0gcHJvdGVjdDtcblxuICAgICAgICAgIC8vIGNoZWNrIG9uIGFsbG93ZWQgYWxnb3JpdGhtc1xuICAgICAgICAgIGlmICghYWxnU3BlYy5tYXRjaChoZWFkZXIuYWxnKSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkFsZ29yaXRobSBub3QgYWxsb3dlZDogXCIgKyBoZWFkZXIuYWxnKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFhbGdTcGVjLm1hdGNoKGhlYWRlci5lbmMpKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkFsZ29yaXRobSBub3QgYWxsb3dlZDogXCIgKyBoZWFkZXIuZW5jKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGVhZGVyLmVwaykge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEpXSy5hc0tleShoZWFkZXIuZXBrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihlcGspIHtcbiAgICAgICAgICAgICAgaGVhZGVyLmVwayA9IGVway50b09iamVjdChmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocmNwdExpc3QpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGRlY3J5cHQgd2l0aCBmaXJzdCBrZXkgZm91bmRcbiAgICAgIHZhciBhbGdLZXksXG4gICAgICAgIGVuY0tleSxcbiAgICAgICAga2RhdGE7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJjcHRMaXN0KSB7XG4gICAgICAgIHZhciBqd2UgPSB7fTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBwcm9jZXNzS2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmNwdCA9IHJjcHRMaXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIXJjcHQpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIm5vIGtleSBmb3VuZFwiKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFsZ1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUocmNwdCk7XG4gICAgICAgICAgICBhbGdQcm9taXNlID0gYWxnUHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJjcHQpIHtcbiAgICAgICAgICAgICAgLy8gdHJ5IHRvIHVud3JhcCBlbmNyeXB0ZWQga2V5XG4gICAgICAgICAgICAgIHZhciBwcmVrZXkgPSBrZGF0YSA9IHJjcHQuZW5jcnlwdGVkX2tleSB8fCBcIlwiO1xuICAgICAgICAgICAgICBwcmVrZXkgPSBiYXNlNjR1cmwuZGVjb2RlKHByZWtleSk7XG4gICAgICAgICAgICAgIGFsZ0tleSA9IGFzc3VtZWRLZXkgfHwga2V5c3RvcmUuZ2V0KHtcbiAgICAgICAgICAgICAgICB1c2U6IFwiZW5jXCIsXG4gICAgICAgICAgICAgICAgYWxnOiByY3B0LmhlYWRlci5hbGcsXG4gICAgICAgICAgICAgICAga2lkOiByY3B0LmhlYWRlci5raWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChhbGdLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxnS2V5LnVud3JhcChyY3B0LmhlYWRlci5hbGcsIHByZWtleSwgcmNwdC5oZWFkZXIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFsZ1Byb21pc2UgPSBhbGdQcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgIGVuY0tleSA9IHtcbiAgICAgICAgICAgICAgICBcImt0eVwiOiBcIm9jdFwiLFxuICAgICAgICAgICAgICAgIFwia1wiOiBiYXNlNjR1cmwuZW5jb2RlKGtleSlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZW5jS2V5ID0gSldLLmFzS2V5KGVuY0tleSk7XG4gICAgICAgICAgICAgIGp3ZS5rZXkgPSBhbGdLZXk7XG4gICAgICAgICAgICAgIGp3ZS5oZWFkZXIgPSByY3B0LmhlYWRlcjtcbiAgICAgICAgICAgICAgandlLnByb3RlY3RlZCA9IHJjcHQucHJvdGVjdGVkO1xuICAgICAgICAgICAgICByZXNvbHZlKGp3ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFsZ1Byb21pc2UuY2F0Y2gocHJvY2Vzc0tleSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBwcm9jZXNzS2V5KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGFzc2lnbiBkZWNpcGhlciBpbnB1dHNcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgIGp3ZS5pdiA9IGlucHV0Lml2O1xuICAgICAgICBqd2UudGFnID0gaW5wdXQudGFnO1xuICAgICAgICBqd2UuY2lwaGVydGV4dCA9IGlucHV0LmNpcGhlcnRleHQ7XG5cbiAgICAgICAgcmV0dXJuIGp3ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwcm9jZXNzIGFueSBwcmVwYXJlLWRlY3J5cHQgaGFuZGxlcnNcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgIHZhciBwcm9jZXNzaW5nID0gW107XG4gICAgICAgIGhhbmRsZXJLZXlzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgIGggPSBleHRyYUhhbmRsZXJzW2hdO1xuICAgICAgICAgIHZhciBwO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBoKSB7XG4gICAgICAgICAgICBwID0gaChqd2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIGggJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaC5wcmVwYXJlKSB7XG4gICAgICAgICAgICBwID0gaC5wcmVwYXJlKGp3ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBwcm9jZXNzaW5nLnB1c2goUHJvbWlzZS5yZXNvbHZlKHApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvY2Vzc2luZykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBkb24ndCBhY3R1YWxseSBjYXJlIGFib3V0IGluZGl2aWR1YWwgaGFuZGxlciByZXN1bHRzXG4gICAgICAgICAgLy8gYXNzdW1lIHtqd2V9IGlzIHVwZGF0ZWRcbiAgICAgICAgICByZXR1cm4gandlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwcmVwYXJlIGRlY3J5cHQgaW5wdXRzXG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihqd2UuY2lwaGVydGV4dCkpIHtcbiAgICAgICAgICBqd2UuY2lwaGVydGV4dCA9IGJhc2U2NHVybC5kZWNvZGUoandlLmNpcGhlcnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGp3ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBkZWNyeXB0IGl0IVxuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgdmFyIGFkYXRhID0gaW5wdXQucHJvdGVjdGVkO1xuICAgICAgICBpZiAoXCJhYWRcIiBpbiBpbnB1dCAmJiBudWxsICE9IGlucHV0LmFhZCkge1xuICAgICAgICAgIGFkYXRhICs9IFwiLlwiICsgaW5wdXQuYWFkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICBpdjogandlLml2LFxuICAgICAgICAgIGFkYXRhOiBhZGF0YSxcbiAgICAgICAgICB0YWc6IGp3ZS50YWcsXG4gICAgICAgICAga2RhdGE6IGtkYXRhLFxuICAgICAgICAgIGVwdTogandlLmVwdSxcbiAgICAgICAgICBlcHY6IGp3ZS5lcHZcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNkYXRhID0gandlLmNpcGhlcnRleHQ7XG5cbiAgICAgICAgZGVsZXRlIGp3ZS5pdjtcbiAgICAgICAgZGVsZXRlIGp3ZS50YWc7XG4gICAgICAgIGRlbGV0ZSBqd2UuY2lwaGVydGV4dDtcblxuICAgICAgICByZXR1cm4gZW5jS2V5LlxuICAgICAgICAgIHRoZW4oZnVuY3Rpb24oZW5rS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW5rS2V5LmRlY3J5cHQoandlLmhlYWRlci5lbmMsIGNkYXRhLCBwYXJhbXMpLlxuICAgICAgICAgICAgICB0aGVuKGZ1bmN0aW9uKHBkYXRhKSB7XG4gICAgICAgICAgICAgICAgandlLnBheWxvYWQgPSBqd2UucGxhaW50ZXh0ID0gcGRhdGE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGp3ZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gKE9QVElPTkFMKSBkZWNvbXByZXNzIHBsYWludGV4dFxuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgaWYgKFwiREVGXCIgPT09IGp3ZS5oZWFkZXIuemlwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGRhdGEgPSBwYWtvLmluZmxhdGVSYXcoQnVmZmVyLmZyb20oandlLnBsYWludGV4dCkpXG5cbiAgICAgICAgICAgICAgandlLnBheWxvYWQgPSBqd2UucGxhaW50ZXh0ID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoandlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqd2U7XG4gICAgICB9KTtcblxuICAgICAgLy8gcHJvY2VzcyBhbnkgcG9zdC1kZWNyeXB0IGhhbmRsZXJzXG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICB2YXIgcHJvY2Vzc2luZyA9IFtdO1xuICAgICAgICBoYW5kbGVyS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICBoID0gZXh0cmFIYW5kbGVyc1toXTtcbiAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIGggJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaC5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcCA9IGguY29tcGxldGUoandlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHByb2Nlc3NpbmcucHVzaChQcm9taXNlLnJlc29sdmUocCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9jZXNzaW5nKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIGRvbid0IGFjdHVhbGx5IGNhcmUgYWJvdXQgaW5kaXZpZHVhbCBoYW5kbGVyIHJlc3VsdHNcbiAgICAgICAgICAvLyBhc3N1bWUge2p3ZX0gaXMgdXBkYXRlZFxuICAgICAgICAgIHJldHVybiBqd2U7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDcmVhdGVzIGEgbmV3IERlY3J5cHRlciBmb3IgdGhlIGdpdmVuIEtleSBvciBLZXlTdG9yZS5cbiAqXG4gKiB7b3B0c30sIHdoZW4gcHJvdmlkZWQsIGlzIHVzZWQgdG8gY3VzdG9taXplIGRlY3J5cHRpb24gcHJvY2Vzc2VzLiBUaGVcbiAqIGZvbGxvd2luZyBvcHRpb25zIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkOlxuICpcbiAqIC0gYGhhbmRsZXJzYCAtIEFuIG9iamVjdCB3aGVyZSBlYWNoIG5hbWUgaXMgYSBKT1NFIGhlYWRlciBtZW1iZXIgbmFtZSBhbmRcbiAqICAgdGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4sIGZ1bmN0aW9uLCBvciBhbiBvYmplY3QuXG4gKlxuICogSGFuZGxlcnMgYXJlIGludGVuZGVkIHRvIHN1cHBvcnQgJ2NyaXQnIGV4dGVuc2lvbnMuIFdoZW4gYSBib29sZWFuIHZhbHVlLFxuICogdGhlIG1lbWJlciBpcyBleHBlY3RlZCB0byBiZSBwcm9jZXNzZWQgb25jZSBkZWNyeXB0aW9uIGlzIGZ1bGx5IGNvbXBsZXRlLlxuICogV2hlbiBhIGZ1bmN0aW9uLCBpdCBpcyBjYWxsZWQganVzdCBiZWZvcmUgdGhlIGNpcGhlcnRleHQgaXMgZGVjcnlwdGVkXG4gKiAocHJvY2Vzc2VkIGFzIGlmIGl0IHdlcmUgYSBgcHJlcGFyZWAgaGFuZGxlciwgYXMgZGVjcmliZWQgYmVsb3cpLiBXaGVuIGFuXG4gKiBvYmplY3QsIGl0IGNhbiBjb250YWluIGFueSBvZiB0aGUgZm9sbG93aW5nIG1lbWJlcnM6XG4gKlxuICogLSBgcmVjaXBpZW50YCAtIEEgZnVuY3Rpb24gY2FsbGVkIGFmdGVyIGEgdmFsaWQga2V5IGlzIGRldGVybWluZWQ7IGl0IHRha2VzXG4gKiAgIGFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSByZWNpcGllbnQsIGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IGlzXG4gKiAgIGZ1bGZpbGxlZCBvbmNlIHRoZSBoYW5kbGVyJ3MgcHJvY2Vzc2luZyBpcyBjb21wbGV0ZS5cbiAqIC0gYHByZXBhcmVgIC0gQSBmdW5jdGlvbiBjYWxsZWQganVzdCBwcmlvciB0byBkZWNyeXB0aW5nIHRoZSBjaXBoZXJ0ZXh0O1xuICogICBpdCB0YWtlcyBhbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgZGVjcnlwdGlvbiByZXN1bHQgKGJ1dCBjb250YWluaW5nXG4gKiAgIGBjaXBoZXJ0ZXh0YCBhbmQgYHRhZycgaW5zdGVhZCBvZiBgcGF5bG9hZGAgYW5kIGBwbGFpbnRleHRgKSwgYW5kXG4gKiAgIHJldHVybnMgYSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIG9uY2UgdGhlIGhhbmRsZXIncyBwcm9jZXNzaW5nIGlzXG4gKiAgIGNvbXBsZXRlLlxuICogLSBgY29tcGxldGVgIC0gQSBmdW5jdGlvbiBjYWxsZWQgb25jZSBkZWNyeXB0aW9uIGlzIGNvbXBsZXRlLCBqdXN0IHByaW9yXG4gKiAgIHRvIGZ1bGZpbGxpbmcgdGhlIFByb21pc2UgcmV0dXJuZWQgYnkgYGRlY3J5cHQoKWA7IGl0IHRha2VzIHRoZSBvYmplY3RcbiAqICAgdGhhdCB3aWxsIGJlIHJldHVybmVkIGJ5IGBkZWNyeXB0KClgJ3MgZnVsZmlsbGVkIFByb21pc2UsIGFuZCByZXR1cm5zXG4gKiAgIGEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCBvbmNlIHRoZSBoYW5kbGVyJ3MgcHJvY2Vzc2luZyBpcyBjb21wbGV0ZS5cbiAqXG4gKiBOb3RlIHRoYXQgbm9ybWFsIHByb2Nlc3Npbmcgb2YgYGRlY3J5cHQoKWAgZG9lcyBub3QgY29udGludWUgdW50aWwgYWxsXG4gKiByZWxldmFudCBoYW5kbGVycyBoYXZlIGNvbXBsZXRlZC4gQW55IGNoYW5nZXMgaGFuZGxlcnMgbWFrZSB0byB0aGVcbiAqIHByb3ZpZGVkIG9iamVjdHMgYWZmZWN0cyBgZGVjcnlwdCgpYCdzIHByb2Nlc3NpbmcuXG4gKlxuICogQHBhcmFtIHtKV0suS2V5fEpXSy5LZXlTdG9yZX0ga3MgVGhlIEtleSBvciBLZXlTdG9yZSB0byB1c2UgZm9yIGRlY3J5cHRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIFRoZSBvcHRpb25zIGZvciB0aGlzIERlY3J5cHRlci5cbiAqIEByZXR1cm5zIHtKV0UuRGVjcnlwdGVyfSBUaGUgbmV3IERlY3J5cHRlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVjcnlwdChrcywgb3B0cykge1xuICB2YXIgZGVjID0gbmV3IEpXRURlY3J5cHRlcihrcywgb3B0cyk7XG4gIHJldHVybiBkZWM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWNyeXB0ZXI6IEpXRURlY3J5cHRlcixcbiAgY3JlYXRlRGVjcnlwdDogY3JlYXRlRGVjcnlwdFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/decrypt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/defaults.js":
/*!****************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/defaults.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/*!\n * jwe/defaults.js - Defaults for JWEs\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\n/**\n * @description\n * The default options for {@link JWE.createEncrypt}.\n *\n * @property {Boolean|String} zip Determines the compression algorithm to\n *           apply to the plaintext (if any) before it is encrypted. This can\n *           also be `true` (which is equivalent to `\"DEF\"`) or **`false`**\n *           (the default, which is equivalent to no compression).\n * @property {String} format Determines the serialization format of the\n *           output.  Expected to be `\"general\"` for general JSON\n *           Serialization, `\"flattened\"` for flattened JSON Serialization,\n *           or `\"compact\"` for Compact Serialization (default is\n *           **`\"general\"`**).\n * @property {Boolean} compact Determines if the output is the Compact\n *           serialization (`true`) or the JSON serialization (**`false`**,\n *           the default).\n * @property {String} contentAlg The algorithm used to encrypt the plaintext\n *           (default is **`\"A128CBC-HS256\"`**).\n * @property {String|String[]} protect The names of the headers to integrity\n *           protect.  The value `\"\"` means that none of the header parameters\n *           are integrity protected, while `\"*\"` (the default) means that all\n *           header parameters are integrity protected.\n */\nvar JWEDefaults = {\n  zip: false,\n  format: \"general\",\n  contentAlg: \"A128CBC-HS256\",\n  protect: \"*\"\n};\n\nmodule.exports = JWEDefaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZGVmYXVsdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd2UvZGVmYXVsdHMuanMgLSBEZWZhdWx0cyBmb3IgSldFc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3Ige0BsaW5rIEpXRS5jcmVhdGVFbmNyeXB0fS5cbiAqXG4gKiBAcHJvcGVydHkge0Jvb2xlYW58U3RyaW5nfSB6aXAgRGV0ZXJtaW5lcyB0aGUgY29tcHJlc3Npb24gYWxnb3JpdGhtIHRvXG4gKiAgICAgICAgICAgYXBwbHkgdG8gdGhlIHBsYWludGV4dCAoaWYgYW55KSBiZWZvcmUgaXQgaXMgZW5jcnlwdGVkLiBUaGlzIGNhblxuICogICAgICAgICAgIGFsc28gYmUgYHRydWVgICh3aGljaCBpcyBlcXVpdmFsZW50IHRvIGBcIkRFRlwiYCkgb3IgKipgZmFsc2VgKipcbiAqICAgICAgICAgICAodGhlIGRlZmF1bHQsIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gbm8gY29tcHJlc3Npb24pLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGZvcm1hdCBEZXRlcm1pbmVzIHRoZSBzZXJpYWxpemF0aW9uIGZvcm1hdCBvZiB0aGVcbiAqICAgICAgICAgICBvdXRwdXQuICBFeHBlY3RlZCB0byBiZSBgXCJnZW5lcmFsXCJgIGZvciBnZW5lcmFsIEpTT05cbiAqICAgICAgICAgICBTZXJpYWxpemF0aW9uLCBgXCJmbGF0dGVuZWRcImAgZm9yIGZsYXR0ZW5lZCBKU09OIFNlcmlhbGl6YXRpb24sXG4gKiAgICAgICAgICAgb3IgYFwiY29tcGFjdFwiYCBmb3IgQ29tcGFjdCBTZXJpYWxpemF0aW9uIChkZWZhdWx0IGlzXG4gKiAgICAgICAgICAgKipgXCJnZW5lcmFsXCJgKiopLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBjb21wYWN0IERldGVybWluZXMgaWYgdGhlIG91dHB1dCBpcyB0aGUgQ29tcGFjdFxuICogICAgICAgICAgIHNlcmlhbGl6YXRpb24gKGB0cnVlYCkgb3IgdGhlIEpTT04gc2VyaWFsaXphdGlvbiAoKipgZmFsc2VgKiosXG4gKiAgICAgICAgICAgdGhlIGRlZmF1bHQpLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGNvbnRlbnRBbGcgVGhlIGFsZ29yaXRobSB1c2VkIHRvIGVuY3J5cHQgdGhlIHBsYWludGV4dFxuICogICAgICAgICAgIChkZWZhdWx0IGlzICoqYFwiQTEyOENCQy1IUzI1NlwiYCoqKS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfFN0cmluZ1tdfSBwcm90ZWN0IFRoZSBuYW1lcyBvZiB0aGUgaGVhZGVycyB0byBpbnRlZ3JpdHlcbiAqICAgICAgICAgICBwcm90ZWN0LiAgVGhlIHZhbHVlIGBcIlwiYCBtZWFucyB0aGF0IG5vbmUgb2YgdGhlIGhlYWRlciBwYXJhbWV0ZXJzXG4gKiAgICAgICAgICAgYXJlIGludGVncml0eSBwcm90ZWN0ZWQsIHdoaWxlIGBcIipcImAgKHRoZSBkZWZhdWx0KSBtZWFucyB0aGF0IGFsbFxuICogICAgICAgICAgIGhlYWRlciBwYXJhbWV0ZXJzIGFyZSBpbnRlZ3JpdHkgcHJvdGVjdGVkLlxuICovXG52YXIgSldFRGVmYXVsdHMgPSB7XG4gIHppcDogZmFsc2UsXG4gIGZvcm1hdDogXCJnZW5lcmFsXCIsXG4gIGNvbnRlbnRBbGc6IFwiQTEyOENCQy1IUzI1NlwiLFxuICBwcm90ZWN0OiBcIipcIlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKV0VEZWZhdWx0cztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/defaults.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/encrypt.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/encrypt.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwe/encrypt.js - Encrypt to a JWE\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    generateCEK = (__webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/node-jose/lib/jwe/helpers.js\").generateCEK),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\"),\n    slice = (__webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/node-jose/lib/jwe/helpers.js\").slice),\n    pako = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/index.js\"),\n    CONSTANTS = __webpack_require__(/*! ../algorithms/constants */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\");\n\nvar assign = __webpack_require__(/*! lodash/assign */ \"(ssr)/./node_modules/lodash/assign.js\");\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\");\nvar DEFAULTS = __webpack_require__(/*! ./defaults */ \"(ssr)/./node_modules/node-jose/lib/jwe/defaults.js\");\n\n/**\n * @class JWE.Encrypter\n * @classdesc\n * Generator of encrypted data.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call {@link\n * JWE.createEncrypt}.\n */\nfunction JWEEncrypter(cfg, fields, recipients) {\n  var finalized = false,\n    format = cfg.format || \"general\",\n    protectAll = !!cfg.protectAll,\n    content = Buffer.alloc(0);\n\n  /**\n   * @member {String} JWE.Encrypter#zip\n   * @readonly\n   * @description\n   * Indicates the compression algorithm applied to the plaintext\n   * before it is encrypted.  The possible values are:\n   *\n   * + **`\"DEF\"`**: Compress the plaintext using the DEFLATE algorithm.\n   * + **`\"\"`**: Do not compress the plaintext.\n   */\n  Object.defineProperty(this, \"zip\", {\n    get: function() {\n      return fields.zip || \"\";\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Boolean} JWE.Encrypter#compact\n   * @readonly\n   * @description\n   * Indicates whether the output of this encryption generator is\n   * using the Compact serialization (`true`) or the JSON\n   * serialization (`false`).\n   */\n  Object.defineProperty(this, \"compact\", {\n    get: function() { return \"compact\" === format; },\n    enumerable: true\n  });\n  /**\n   * @member {String} JWE.Encrypter#format\n   * @readonly\n   * @description\n   * Indicates the format the output of this encryption generator takes.\n   */\n  Object.defineProperty(this, \"format\", {\n    get: function() { return format; },\n    enumerable: true\n  });\n  /**\n   * @member {String[]} JWE.Encrypter#protected\n   * @readonly\n   * @description\n   * The header parameter names that are protected. Protected header fields\n   * are first serialized to UTF-8 then encoded as util.base64url, then used as\n   * the additional authenticated data in the encryption operation.\n   */\n  Object.defineProperty(this, \"protected\", {\n    get: function() {\n      return clone(cfg.protect);\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Object} JWE.Encrypter#header\n   * @readonly\n   * @description\n   * The global header parameters, both protected and unprotected. Call\n   * {@link JWE.Encrypter#protected} to determine which parameters will\n   * be protected.\n   */\n  Object.defineProperty(this, \"header\", {\n    get: function() {\n      return clone(fields);\n    },\n    enumerable: true\n  });\n\n  /**\n   * @method JWE.Encrypter#update\n   * @description\n   * Updates the plaintext data for the encryption generator. The plaintext\n   * is appended to the end of any other plaintext already applied.\n   *\n   * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n   * converted to a Buffer internally to {encoding}.\n   *\n   * @param {Buffer|String} [data] The plaintext to apply.\n   * @param {String} [encoding] The encoding of the plaintext.\n   * @returns {JWE.Encrypter} This encryption generator.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n  Object.defineProperty(this, \"update\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n        if (content.length) {\n          content = Buffer.concat([content, data],\n                      content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n   * @method JWE.Encrypter#final\n   * @description\n   * Finishes the encryption operation.\n   *\n   * The returned Promise, when fulfilled, is the JSON Web Encryption (JWE)\n   * object, either in the Compact (if {@link JWE.Encrypter#compact} is\n   * `true`) or the JSON serialization.\n   *\n   * @param {Buffer|String} [data] The final plaintext data to apply.\n   * @param {String} [encoding] The encoding of the final plaintext data\n   *        (if any).\n   * @returns {Promise} A promise for the encryption operation.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n  Object.defineProperty(this, \"final\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      }\n\n      // last-minute data\n      this.update(data, encoding);\n\n      // mark as done...ish\n      finalized = true;\n      var promise = Promise.resolve({});\n\n      // determine CEK and IV\n      var encAlg = fields.enc;\n      var encKey;\n      promise = promise.then(function(jwe) {\n        if (cfg.cek) {\n          encKey = JWK.asKey(cfg.cek);\n        }\n        return jwe;\n      });\n\n      // process recipients\n      promise = promise.then(function(jwe) {\n        var procR = function(r, one) {\n          var props = {};\n          props = assign(props, fields);\n          props = assign(props, r.header);\n\n          var algKey = r.key,\n              algAlg = props.alg;\n\n          // generate Ephemeral EC Key\n          var tks,\n              rpromise;\n          if ((props.alg || \"\").indexOf(\"ECDH-ES\") === 0) {\n            tks = algKey.keystore.temp();\n            if (r.epk) {\n              rpromise = Promise.resolve(r.epk).\n                then(function(epk) {\n                  r.header.epk = epk.toJSON(false, [\"kid\"]);\n                  props.epk = epk.toObject(true, [\"kid\"]);\n                });\n            } else {\n              rpromise = tks.generate(\"EC\", algKey.get(\"crv\")).\n                then(function(epk) {\n                  r.header.epk = epk.toJSON(false, [\"kid\"]);\n                  props.epk = epk.toObject(true, [\"kid\"]);\n                });\n            }\n          } else {\n            rpromise = Promise.resolve();\n          }\n\n          // encrypt the CEK\n          rpromise = rpromise.then(function() {\n            var cek,\n                p;\n            // special case 'alg=dir'\n            if (\"dir\" === algAlg && one) {\n              encKey = Promise.resolve(algKey);\n              p = encKey.then(function(jwk) {\n                // fixup encAlg\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = jwk.algorithms(JWK.MODE_ENCRYPT)[0];\n                }\n                return {\n                  once: true,\n                  direct: true\n                };\n              });\n            } else {\n              if (!encKey) {\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = cfg.contentAlg;\n                }\n                encKey = generateCEK(encAlg);\n              }\n              p = encKey.then(function(jwk) {\n                cek = jwk.get(\"k\", true);\n                // algKey may or may not be a promise\n                return algKey;\n              });\n              p = p.then(function(algKey) {\n                return algKey.wrap(algAlg, cek, props);\n              });\n            }\n            return p;\n          });\n          rpromise = rpromise.then(function(wrapped) {\n            if (wrapped.once && !one) {\n              return Promise.reject(new Error(\"cannot use 'alg':'\" + algAlg + \"' with multiple recipients\"));\n            }\n\n            var rjwe = {},\n                cek;\n            if (wrapped.data) {\n              cek = wrapped.data;\n              cek = util.base64url.encode(cek);\n            }\n\n            if (wrapped.direct && cek) {\n              // replace content key\n              encKey = JWK.asKey({\n                kty: \"oct\",\n                k: cek\n              });\n            } else if (cek) {\n              /* eslint camelcase: [0] */\n              rjwe.encrypted_key = cek;\n            }\n\n            if (r.header && Object.keys(r.header).length) {\n              rjwe.header = clone(r.header || {});\n            }\n            if (wrapped.header) {\n              rjwe.header = assign(rjwe.header || {},\n                                     wrapped.header);\n            }\n\n            return rjwe;\n           });\n           return rpromise;\n        };\n\n        var p = Promise.all(recipients);\n        p = p.then(function(rcpts) {\n          var single = (1 === rcpts.length);\n          rcpts = rcpts.map(function(r) {\n            return procR(r, single);\n          });\n          return Promise.all(rcpts);\n        });\n        p = p.then(function(rcpts) {\n          jwe.recipients = rcpts.filter(function(r) { return !!r; });\n          return jwe;\n        });\n        return p;\n      });\n\n      // normalize headers\n      var props = {};\n      promise = promise.then(function(jwe) {\n        var protect,\n          lenProtect,\n          unprotect,\n          lenUnprotect;\n\n        unprotect = clone(fields);\n        if ((protectAll && jwe.recipients.length === 1) || \"compact\" === format) {\n          // merge single recipient into fields\n          protect = {};\n          protect = assign({},\n                     unprotect,\n                    jwe.recipients[0].header);\n          lenProtect = Object.keys(protect).length;\n\n          unprotect = undefined;\n          lenUnprotect = 0;\n\n          delete jwe.recipients[0].header;\n          if (Object.keys(jwe.recipients[0]).length === 0) {\n            jwe.recipients.splice(0, 1);\n          }\n        } else {\n          protect = {};\n          lenProtect = 0;\n          lenUnprotect = Object.keys(unprotect).length;\n          cfg.protect.forEach(function(f) {\n            // remove protected header values from body unprotected header\n            if (!(f in unprotect)) {\n              return;\n            }\n            protect[f] = unprotect[f];\n            lenProtect++;\n\n            delete unprotect[f];\n            lenUnprotect--;\n          });\n\n          jwe.recipients = (jwe.recipients || []).map(function(rcpt) {\n            rcpt = rcpt || {};\n            var header = rcpt.header;\n            if (header) {\n              Object.keys(header).forEach(function (f) {\n                if (f in protect) { delete header[f]; }\n              });\n              if (!Object.keys(header).length) {\n                delete rcpt.header;\n              }\n            }\n            return rcpt;\n          });\n        }\n\n        if (!jwe.recipients || jwe.recipients.length === 0) {\n          delete jwe.recipients;\n        }\n\n        // \"serialize\" (and setup merged props)\n        if (unprotect && lenUnprotect > 0) {\n          props = assign(props, unprotect);\n          jwe.unprotected = unprotect;\n        }\n        if (protect && lenProtect > 0) {\n          props = assign(props, protect);\n          protect = JSON.stringify(protect);\n          jwe.protected = util.base64url.encode(protect, \"utf8\");\n        }\n\n        return jwe;\n      });\n\n      // (OPTIONAL) compress plaintext\n      promise = promise.then(function(jwe) {\n        var pdata = content;\n        if (!props.zip) {\n          jwe.plaintext = pdata;\n          return jwe;\n        } else if (props.zip === \"DEF\") {\n          return new Promise(function(resolve, reject) {\n            try {\n              var data = pako.deflateRaw(Buffer.from(pdata, \"binary\"));\n\n              jwe.plaintext = Buffer.from(data);\n              resolve(jwe);\n            } catch (error) {\n              reject(error);\n            }\n          });\n        }\n        return Promise.reject(new Error(\"unsupported 'zip' mode\"));\n      });\n\n      // encrypt plaintext\n      promise = promise.then(function(jwe) {\n        props.adata = jwe.protected;\n        if (\"aad\" in cfg && cfg.aad != null) {\n          props.adata += \".\" + cfg.aad;\n          props.adata = Buffer.from(props.adata, \"utf8\");\n        }\n        // calculate IV\n        var iv = cfg.iv ||\n                 util.randomBytes(CONSTANTS.NONCELENGTH[encAlg] / 8);\n        if (\"string\" === typeof iv) {\n          iv = util.base64url.decode(iv);\n        }\n        props.iv = iv;\n\n        if (\"recipients\" in jwe && jwe.recipients.length === 1) {\n          props.kdata = jwe.recipients[0].encrypted_key;\n        }\n\n        if (\"epu\" in cfg && cfg.epu != null) {\n          props.epu = cfg.epu;\n        }\n\n        if (\"epv\" in cfg && cfg.epv != null) {\n          props.epv = cfg.epv;\n        }\n\n        var pdata = jwe.plaintext;\n        delete jwe.plaintext;\n        return encKey.then(function(encKey) {\n          var p = encKey.encrypt(encAlg, pdata, props);\n          p = p.then(function(result) {\n            jwe.iv = util.base64url.encode(iv, \"binary\");\n            if (\"aad\" in cfg && cfg.aad != null) {\n             jwe.aad = cfg.aad;\n            }\n            jwe.ciphertext = util.base64url.encode(result.data, \"binary\");\n            jwe.tag = util.base64url.encode(result.tag, \"binary\");\n            return jwe;\n          });\n          return p;\n        });\n      });\n\n      // (OPTIONAL) compact/flattened results\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function(jwe) {\n            var compact = new Array(5);\n\n            compact[0] = jwe.protected;\n            if (jwe.recipients && jwe.recipients[0]) {\n              compact[1] = jwe.recipients[0].encrypted_key;\n            }\n\n            compact[2] = jwe.iv;\n            compact[3] = jwe.ciphertext;\n            compact[4] = jwe.tag;\n            compact = compact.join(\".\");\n\n            return compact;\n          });\n          break;\n        case \"flattened\":\n          promise = promise.then(function(jwe) {\n            var flattened = {},\n                rcpt = jwe.recipients && jwe.recipients[0];\n\n            if (jwe.protected) {\n              flattened.protected = jwe.protected;\n            }\n            if (jwe.unprotected) {\n              flattened.unprotected = jwe.unprotected;\n            }\n            [\"header\", \"encrypted_key\"].forEach(function(f) {\n              if (!rcpt) { return; }\n              if (!(f in rcpt)) { return; }\n              if (!rcpt[f]) { return; }\n              if (\"object\" === typeof rcpt[f] && !Object.keys(rcpt[f]).length) { return; }\n              flattened[f] = rcpt[f];\n            });\n            if (jwe.aad) {\n              flattened.aad = jwe.aad;\n            }\n            flattened.iv = jwe.iv;\n            flattened.ciphertext = jwe.ciphertext;\n            flattened.tag = jwe.tag;\n\n            return flattened;\n          });\n          break;\n        case \"general\":\n          promise = promise.then(function(jwe) {\n            var recipients = jwe.recipients || [];\n            recipients = recipients.map(function (rcpt) {\n              if (!Object.keys(rcpt).length) { return undefined; }\n              return rcpt;\n            });\n            recipients = recipients.filter(function (rcpt) { return !!rcpt; });\n            if (recipients.length) {\n              jwe.recipients = recipients;\n            } else {\n              delete jwe.recipients;\n            }\n\n            return jwe;\n          });\n      }\n\n      return promise;\n    }\n  });\n}\n\nfunction createEncrypt(opts, rcpts) {\n  // fixup recipients\n  var options = opts,\n    rcptStart = 1,\n    rcptList = rcpts;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one recipient must be provided\");\n  }\n  if (arguments.length === 1) {\n    // assume opts is the recipient list\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) ||\n        (opts && \"kty\" in opts) ||\n        (opts && \"key\" in opts &&\n        (JWK.isKey(opts.key) || \"kty\" in opts.key))) {\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n  if (!Array.isArray(rcptList)) {\n    rcptList = slice(arguments, rcptStart);\n  }\n\n  // fixup options\n  options = assign(clone(DEFAULTS), options);\n\n  // setup header fields\n  var fields = clone(options.fields || {});\n  if (options.zip) {\n    fields.zip = (typeof options.zip === \"boolean\") ?\n           (options.zip ? \"DEF\" : false) :\n           options.zip;\n  }\n  options.format = (options.compact ? \"compact\" : options.format) || \"general\";\n  switch (options.format) {\n    case \"compact\":\n      if (\"aad\" in opts) {\n        throw new Error(\"additional authenticated data cannot be used for compact serialization\");\n      }\n      /* eslint no-fallthrough: [0] */\n    case \"flattened\":\n      if (rcptList.length > 1) {\n        throw new Error(\"too many recipients for compact serialization\");\n      }\n      break;\n  }\n\n  // note protected fields (globally)\n  // protected fields are global only\n  var protectAll = false;\n  if (\"compact\" === options.format || \"*\" === options.protect) {\n    protectAll = true;\n    options.protect = Object.keys(fields).concat(\"enc\");\n  } else if (typeof options.protect === \"string\") {\n    options.protect = [options.protect];\n  } else if (Array.isArray(options.protect)) {\n    options.protect = options.protect.concat();\n  } else if (!options.protect) {\n    options.protect = [];\n  } else {\n    throw new Error(\"protect must be a list of fields\");\n  }\n\n  if (protectAll && 1 < rcptList.length) {\n    throw new Error(\"too many recipients to protect all header parameters\");\n  }\n\n  rcptList = rcptList.map(function(r, idx) {\n    var p;\n\n    // resolve a key\n    if (r && \"kty\" in r) {\n      p = JWK.asKey(r);\n      p = p.then(function(k) {\n        return {\n          key: k\n        };\n      });\n    } else if (r) {\n      p = JWK.asKey(r.key);\n      p = p.then(function(k) {\n        return {\n          header: r.header,\n          reference: r.reference,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for recipient \" + idx));\n    }\n\n    // convert ephemeral key (if present)\n    if (r.epk) {\n      p = p.then(function(recipient) {\n        return JWK.asKey(r.epk).\n          then(function(epk) {\n            recipient.epk = epk;\n            return recipient;\n          });\n      });\n    }\n\n    // resolve the complete recipient\n    p = p.then(function(recipient) {\n      var key = recipient.key;\n\n      // prepare the recipient header\n      var header = recipient.header || {};\n      recipient.header = header;\n      var props = {};\n      props = assign(props, fields);\n      props = assign(props, recipient.header);\n\n      // ensure key protection algorithm is set\n      if (!props.alg) {\n        props.alg = key.algorithms(JWK.MODE_WRAP)[0];\n        header.alg = props.alg;\n      }\n      if (!props.alg) {\n        return Promise.reject(new Error(\"key not valid for encrypting to recipient \" + idx));\n      }\n      header.alg = props.alg;\n\n      // determine the key reference\n      var ref = recipient.reference;\n      delete recipient.reference;\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function(k) {\n          return (k in header);\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n      var jwk;\n      if (ref) {\n        jwk = key.toJSON();\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      }\n\n      // freeze recipient\n      recipient = Object.freeze(recipient);\n      return recipient;\n    });\n\n    return p;\n  });\n\n  // create and configure encryption\n  var cfg = {\n    aad: (\"aad\" in options) ? util.base64url.encode(options.aad || \"\") : null,\n    contentAlg: options.contentAlg,\n    format: options.format,\n    protect: options.protect,\n    cek: options.cek,\n    iv: options.iv,\n    protectAll: protectAll\n  };\n  var enc = new JWEEncrypter(cfg, fields, rcptList);\n\n  return enc;\n}\n\nmodule.exports = {\n  encrypter: JWEEncrypter,\n  createEncrypt: createEncrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZW5jcnlwdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGlFQUFTO0FBQzVCLGtCQUFrQix1R0FBZ0M7QUFDbEQsVUFBVSxtQkFBTyxDQUFDLCtEQUFRO0FBQzFCLFlBQVksaUdBQTBCO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyxnREFBTTtBQUN6QixnQkFBZ0IsbUJBQU8sQ0FBQywyRkFBeUI7O0FBRWpELGFBQWEsbUJBQU8sQ0FBQyw0REFBZTtBQUNwQyxZQUFZLG1CQUFPLENBQUMsMERBQWM7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLHNFQUFZOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTSwrQkFBK0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNLGNBQWMsVUFBVSx3QkFBd0IsTUFBTTtBQUNyRSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsZUFBZSxlQUFlO0FBQzlCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw2QkFBNkI7QUFDckU7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzREFBc0QsYUFBYTtBQUNuRTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0Isa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QixpRkFBaUY7QUFDakY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxhQUFhO0FBQ2IsNkRBQTZELGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandlL2VuY3J5cHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd2UvZW5jcnlwdC5qcyAtIEVuY3J5cHQgdG8gYSBKV0VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKSxcbiAgICBnZW5lcmF0ZUNFSyA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIikuZ2VuZXJhdGVDRUssXG4gICAgSldLID0gcmVxdWlyZShcIi4uL2p3a1wiKSxcbiAgICBzbGljZSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIikuc2xpY2UsXG4gICAgcGFrbyA9IHJlcXVpcmUoXCJwYWtvXCIpLFxuICAgIENPTlNUQU5UUyA9IHJlcXVpcmUoXCIuLi9hbGdvcml0aG1zL2NvbnN0YW50c1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCJsb2Rhc2gvYXNzaWduXCIpO1xudmFyIGNsb25lID0gcmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKTtcbnZhciBERUZBVUxUUyA9IHJlcXVpcmUoXCIuL2RlZmF1bHRzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyBKV0UuRW5jcnlwdGVyXG4gKiBAY2xhc3NkZXNjXG4gKiBHZW5lcmF0b3Igb2YgZW5jcnlwdGVkIGRhdGEuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAqKk5PVEU6KiogVGhpcyBjbGFzcyBjYW5ub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LiBJbnN0ZWFkIGNhbGwge0BsaW5rXG4gKiBKV0UuY3JlYXRlRW5jcnlwdH0uXG4gKi9cbmZ1bmN0aW9uIEpXRUVuY3J5cHRlcihjZmcsIGZpZWxkcywgcmVjaXBpZW50cykge1xuICB2YXIgZmluYWxpemVkID0gZmFsc2UsXG4gICAgZm9ybWF0ID0gY2ZnLmZvcm1hdCB8fCBcImdlbmVyYWxcIixcbiAgICBwcm90ZWN0QWxsID0gISFjZmcucHJvdGVjdEFsbCxcbiAgICBjb250ZW50ID0gQnVmZmVyLmFsbG9jKDApO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtTdHJpbmd9IEpXRS5FbmNyeXB0ZXIjemlwXG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSW5kaWNhdGVzIHRoZSBjb21wcmVzc2lvbiBhbGdvcml0aG0gYXBwbGllZCB0byB0aGUgcGxhaW50ZXh0XG4gICAqIGJlZm9yZSBpdCBpcyBlbmNyeXB0ZWQuICBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICpcbiAgICogKyAqKmBcIkRFRlwiYCoqOiBDb21wcmVzcyB0aGUgcGxhaW50ZXh0IHVzaW5nIHRoZSBERUZMQVRFIGFsZ29yaXRobS5cbiAgICogKyAqKmBcIlwiYCoqOiBEbyBub3QgY29tcHJlc3MgdGhlIHBsYWludGV4dC5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInppcFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmaWVsZHMuemlwIHx8IFwiXCI7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogQG1lbWJlciB7Qm9vbGVhbn0gSldFLkVuY3J5cHRlciNjb21wYWN0XG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG91dHB1dCBvZiB0aGlzIGVuY3J5cHRpb24gZ2VuZXJhdG9yIGlzXG4gICAqIHVzaW5nIHRoZSBDb21wYWN0IHNlcmlhbGl6YXRpb24gKGB0cnVlYCkgb3IgdGhlIEpTT05cbiAgICogc2VyaWFsaXphdGlvbiAoYGZhbHNlYCkuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb21wYWN0XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJjb21wYWN0XCIgPT09IGZvcm1hdDsgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogQG1lbWJlciB7U3RyaW5nfSBKV0UuRW5jcnlwdGVyI2Zvcm1hdFxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEluZGljYXRlcyB0aGUgZm9ybWF0IHRoZSBvdXRwdXQgb2YgdGhpcyBlbmNyeXB0aW9uIGdlbmVyYXRvciB0YWtlcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZvcm1hdFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGZvcm1hdDsgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogQG1lbWJlciB7U3RyaW5nW119IEpXRS5FbmNyeXB0ZXIjcHJvdGVjdGVkXG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIGhlYWRlciBwYXJhbWV0ZXIgbmFtZXMgdGhhdCBhcmUgcHJvdGVjdGVkLiBQcm90ZWN0ZWQgaGVhZGVyIGZpZWxkc1xuICAgKiBhcmUgZmlyc3Qgc2VyaWFsaXplZCB0byBVVEYtOCB0aGVuIGVuY29kZWQgYXMgdXRpbC5iYXNlNjR1cmwsIHRoZW4gdXNlZCBhc1xuICAgKiB0aGUgYWRkaXRpb25hbCBhdXRoZW50aWNhdGVkIGRhdGEgaW4gdGhlIGVuY3J5cHRpb24gb3BlcmF0aW9uLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvdGVjdGVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNsb25lKGNmZy5wcm90ZWN0KTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBAbWVtYmVyIHtPYmplY3R9IEpXRS5FbmNyeXB0ZXIjaGVhZGVyXG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIGdsb2JhbCBoZWFkZXIgcGFyYW1ldGVycywgYm90aCBwcm90ZWN0ZWQgYW5kIHVucHJvdGVjdGVkLiBDYWxsXG4gICAqIHtAbGluayBKV0UuRW5jcnlwdGVyI3Byb3RlY3RlZH0gdG8gZGV0ZXJtaW5lIHdoaWNoIHBhcmFtZXRlcnMgd2lsbFxuICAgKiBiZSBwcm90ZWN0ZWQuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWFkZXJcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2xvbmUoZmllbGRzKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgSldFLkVuY3J5cHRlciN1cGRhdGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFVwZGF0ZXMgdGhlIHBsYWludGV4dCBkYXRhIGZvciB0aGUgZW5jcnlwdGlvbiBnZW5lcmF0b3IuIFRoZSBwbGFpbnRleHRcbiAgICogaXMgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiBhbnkgb3RoZXIgcGxhaW50ZXh0IGFscmVhZHkgYXBwbGllZC5cbiAgICpcbiAgICogSWYge2RhdGF9IGlzIGEgQnVmZmVyLCB7ZW5jb2Rpbmd9IGlzIGlnbm9yZWQuIE90aGVyd2lzZSwge2RhdGF9IGlzXG4gICAqIGNvbnZlcnRlZCB0byBhIEJ1ZmZlciBpbnRlcm5hbGx5IHRvIHtlbmNvZGluZ30uXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gW2RhdGFdIFRoZSBwbGFpbnRleHQgdG8gYXBwbHkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2RpbmddIFRoZSBlbmNvZGluZyBvZiB0aGUgcGxhaW50ZXh0LlxuICAgKiBAcmV0dXJucyB7SldFLkVuY3J5cHRlcn0gVGhpcyBlbmNyeXB0aW9uIGdlbmVyYXRvci5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNpcGhlcnRleHQgaGFzIGFscmVhZHkgYmVlbiBnZW5lcmF0ZWQuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1cGRhdGVcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuICAgICAgaWYgKGZpbmFsaXplZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICBkYXRhID0gdXRpbC5hc0J1ZmZlcihkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRlbnQgPSBCdWZmZXIuY29uY2F0KFtjb250ZW50LCBkYXRhXSxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Lmxlbmd0aCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50ID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQG1ldGhvZCBKV0UuRW5jcnlwdGVyI2ZpbmFsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBGaW5pc2hlcyB0aGUgZW5jcnlwdGlvbiBvcGVyYXRpb24uXG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBQcm9taXNlLCB3aGVuIGZ1bGZpbGxlZCwgaXMgdGhlIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICogb2JqZWN0LCBlaXRoZXIgaW4gdGhlIENvbXBhY3QgKGlmIHtAbGluayBKV0UuRW5jcnlwdGVyI2NvbXBhY3R9IGlzXG4gICAqIGB0cnVlYCkgb3IgdGhlIEpTT04gc2VyaWFsaXphdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBbZGF0YV0gVGhlIGZpbmFsIHBsYWludGV4dCBkYXRhIHRvIGFwcGx5LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2VuY29kaW5nXSBUaGUgZW5jb2Rpbmcgb2YgdGhlIGZpbmFsIHBsYWludGV4dCBkYXRhXG4gICAqICAgICAgICAoaWYgYW55KS5cbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSBmb3IgdGhlIGVuY3J5cHRpb24gb3BlcmF0aW9uLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2lwaGVydGV4dCBoYXMgYWxyZWFkeSBiZWVuIGdlbmVyYXRlZC5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbmFsXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgIGlmIChmaW5hbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImFscmVhZHkgZmluYWxcIikpO1xuICAgICAgfVxuXG4gICAgICAvLyBsYXN0LW1pbnV0ZSBkYXRhXG4gICAgICB0aGlzLnVwZGF0ZShkYXRhLCBlbmNvZGluZyk7XG5cbiAgICAgIC8vIG1hcmsgYXMgZG9uZS4uLmlzaFxuICAgICAgZmluYWxpemVkID0gdHJ1ZTtcbiAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHt9KTtcblxuICAgICAgLy8gZGV0ZXJtaW5lIENFSyBhbmQgSVZcbiAgICAgIHZhciBlbmNBbGcgPSBmaWVsZHMuZW5jO1xuICAgICAgdmFyIGVuY0tleTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgIGlmIChjZmcuY2VrKSB7XG4gICAgICAgICAgZW5jS2V5ID0gSldLLmFzS2V5KGNmZy5jZWspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqd2U7XG4gICAgICB9KTtcblxuICAgICAgLy8gcHJvY2VzcyByZWNpcGllbnRzXG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICB2YXIgcHJvY1IgPSBmdW5jdGlvbihyLCBvbmUpIHtcbiAgICAgICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgICAgICBwcm9wcyA9IGFzc2lnbihwcm9wcywgZmllbGRzKTtcbiAgICAgICAgICBwcm9wcyA9IGFzc2lnbihwcm9wcywgci5oZWFkZXIpO1xuXG4gICAgICAgICAgdmFyIGFsZ0tleSA9IHIua2V5LFxuICAgICAgICAgICAgICBhbGdBbGcgPSBwcm9wcy5hbGc7XG5cbiAgICAgICAgICAvLyBnZW5lcmF0ZSBFcGhlbWVyYWwgRUMgS2V5XG4gICAgICAgICAgdmFyIHRrcyxcbiAgICAgICAgICAgICAgcnByb21pc2U7XG4gICAgICAgICAgaWYgKChwcm9wcy5hbGcgfHwgXCJcIikuaW5kZXhPZihcIkVDREgtRVNcIikgPT09IDApIHtcbiAgICAgICAgICAgIHRrcyA9IGFsZ0tleS5rZXlzdG9yZS50ZW1wKCk7XG4gICAgICAgICAgICBpZiAoci5lcGspIHtcbiAgICAgICAgICAgICAgcnByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoci5lcGspLlxuICAgICAgICAgICAgICAgIHRoZW4oZnVuY3Rpb24oZXBrKSB7XG4gICAgICAgICAgICAgICAgICByLmhlYWRlci5lcGsgPSBlcGsudG9KU09OKGZhbHNlLCBbXCJraWRcIl0pO1xuICAgICAgICAgICAgICAgICAgcHJvcHMuZXBrID0gZXBrLnRvT2JqZWN0KHRydWUsIFtcImtpZFwiXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBycHJvbWlzZSA9IHRrcy5nZW5lcmF0ZShcIkVDXCIsIGFsZ0tleS5nZXQoXCJjcnZcIikpLlxuICAgICAgICAgICAgICAgIHRoZW4oZnVuY3Rpb24oZXBrKSB7XG4gICAgICAgICAgICAgICAgICByLmhlYWRlci5lcGsgPSBlcGsudG9KU09OKGZhbHNlLCBbXCJraWRcIl0pO1xuICAgICAgICAgICAgICAgICAgcHJvcHMuZXBrID0gZXBrLnRvT2JqZWN0KHRydWUsIFtcImtpZFwiXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZW5jcnlwdCB0aGUgQ0VLXG4gICAgICAgICAgcnByb21pc2UgPSBycHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNlayxcbiAgICAgICAgICAgICAgICBwO1xuICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlICdhbGc9ZGlyJ1xuICAgICAgICAgICAgaWYgKFwiZGlyXCIgPT09IGFsZ0FsZyAmJiBvbmUpIHtcbiAgICAgICAgICAgICAgZW5jS2V5ID0gUHJvbWlzZS5yZXNvbHZlKGFsZ0tleSk7XG4gICAgICAgICAgICAgIHAgPSBlbmNLZXkudGhlbihmdW5jdGlvbihqd2spIHtcbiAgICAgICAgICAgICAgICAvLyBmaXh1cCBlbmNBbGdcbiAgICAgICAgICAgICAgICBpZiAoIWVuY0FsZykge1xuICAgICAgICAgICAgICAgICAgcHJvcHMuZW5jID0gZmllbGRzLmVuYyA9IGVuY0FsZyA9IGp3ay5hbGdvcml0aG1zKEpXSy5NT0RFX0VOQ1JZUFQpWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGRpcmVjdDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFlbmNLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVuY0FsZykge1xuICAgICAgICAgICAgICAgICAgcHJvcHMuZW5jID0gZmllbGRzLmVuYyA9IGVuY0FsZyA9IGNmZy5jb250ZW50QWxnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbmNLZXkgPSBnZW5lcmF0ZUNFSyhlbmNBbGcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHAgPSBlbmNLZXkudGhlbihmdW5jdGlvbihqd2spIHtcbiAgICAgICAgICAgICAgICBjZWsgPSBqd2suZ2V0KFwia1wiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBhbGdLZXkgbWF5IG9yIG1heSBub3QgYmUgYSBwcm9taXNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsZ0tleTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oYWxnS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsZ0tleS53cmFwKGFsZ0FsZywgY2VrLCBwcm9wcyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcnByb21pc2UgPSBycHJvbWlzZS50aGVuKGZ1bmN0aW9uKHdyYXBwZWQpIHtcbiAgICAgICAgICAgIGlmICh3cmFwcGVkLm9uY2UgJiYgIW9uZSkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiY2Fubm90IHVzZSAnYWxnJzonXCIgKyBhbGdBbGcgKyBcIicgd2l0aCBtdWx0aXBsZSByZWNpcGllbnRzXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJqd2UgPSB7fSxcbiAgICAgICAgICAgICAgICBjZWs7XG4gICAgICAgICAgICBpZiAod3JhcHBlZC5kYXRhKSB7XG4gICAgICAgICAgICAgIGNlayA9IHdyYXBwZWQuZGF0YTtcbiAgICAgICAgICAgICAgY2VrID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKGNlayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3cmFwcGVkLmRpcmVjdCAmJiBjZWspIHtcbiAgICAgICAgICAgICAgLy8gcmVwbGFjZSBjb250ZW50IGtleVxuICAgICAgICAgICAgICBlbmNLZXkgPSBKV0suYXNLZXkoe1xuICAgICAgICAgICAgICAgIGt0eTogXCJvY3RcIixcbiAgICAgICAgICAgICAgICBrOiBjZWtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNlaykge1xuICAgICAgICAgICAgICAvKiBlc2xpbnQgY2FtZWxjYXNlOiBbMF0gKi9cbiAgICAgICAgICAgICAgcmp3ZS5lbmNyeXB0ZWRfa2V5ID0gY2VrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoci5oZWFkZXIgJiYgT2JqZWN0LmtleXMoci5oZWFkZXIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICByandlLmhlYWRlciA9IGNsb25lKHIuaGVhZGVyIHx8IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3cmFwcGVkLmhlYWRlcikge1xuICAgICAgICAgICAgICByandlLmhlYWRlciA9IGFzc2lnbihyandlLmhlYWRlciB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVkLmhlYWRlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByandlO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgICAgcmV0dXJuIHJwcm9taXNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwID0gUHJvbWlzZS5hbGwocmVjaXBpZW50cyk7XG4gICAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24ocmNwdHMpIHtcbiAgICAgICAgICB2YXIgc2luZ2xlID0gKDEgPT09IHJjcHRzLmxlbmd0aCk7XG4gICAgICAgICAgcmNwdHMgPSByY3B0cy5tYXAoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgcmV0dXJuIHByb2NSKHIsIHNpbmdsZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJjcHRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24ocmNwdHMpIHtcbiAgICAgICAgICBqd2UucmVjaXBpZW50cyA9IHJjcHRzLmZpbHRlcihmdW5jdGlvbihyKSB7IHJldHVybiAhIXI7IH0pO1xuICAgICAgICAgIHJldHVybiBqd2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBub3JtYWxpemUgaGVhZGVyc1xuICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICB2YXIgcHJvdGVjdCxcbiAgICAgICAgICBsZW5Qcm90ZWN0LFxuICAgICAgICAgIHVucHJvdGVjdCxcbiAgICAgICAgICBsZW5VbnByb3RlY3Q7XG5cbiAgICAgICAgdW5wcm90ZWN0ID0gY2xvbmUoZmllbGRzKTtcbiAgICAgICAgaWYgKChwcm90ZWN0QWxsICYmIGp3ZS5yZWNpcGllbnRzLmxlbmd0aCA9PT0gMSkgfHwgXCJjb21wYWN0XCIgPT09IGZvcm1hdCkge1xuICAgICAgICAgIC8vIG1lcmdlIHNpbmdsZSByZWNpcGllbnQgaW50byBmaWVsZHNcbiAgICAgICAgICBwcm90ZWN0ID0ge307XG4gICAgICAgICAgcHJvdGVjdCA9IGFzc2lnbih7fSxcbiAgICAgICAgICAgICAgICAgICAgIHVucHJvdGVjdCxcbiAgICAgICAgICAgICAgICAgICAgandlLnJlY2lwaWVudHNbMF0uaGVhZGVyKTtcbiAgICAgICAgICBsZW5Qcm90ZWN0ID0gT2JqZWN0LmtleXMocHJvdGVjdCkubGVuZ3RoO1xuXG4gICAgICAgICAgdW5wcm90ZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGxlblVucHJvdGVjdCA9IDA7XG5cbiAgICAgICAgICBkZWxldGUgandlLnJlY2lwaWVudHNbMF0uaGVhZGVyO1xuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhqd2UucmVjaXBpZW50c1swXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBqd2UucmVjaXBpZW50cy5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RlY3QgPSB7fTtcbiAgICAgICAgICBsZW5Qcm90ZWN0ID0gMDtcbiAgICAgICAgICBsZW5VbnByb3RlY3QgPSBPYmplY3Qua2V5cyh1bnByb3RlY3QpLmxlbmd0aDtcbiAgICAgICAgICBjZmcucHJvdGVjdC5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBwcm90ZWN0ZWQgaGVhZGVyIHZhbHVlcyBmcm9tIGJvZHkgdW5wcm90ZWN0ZWQgaGVhZGVyXG4gICAgICAgICAgICBpZiAoIShmIGluIHVucHJvdGVjdCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvdGVjdFtmXSA9IHVucHJvdGVjdFtmXTtcbiAgICAgICAgICAgIGxlblByb3RlY3QrKztcblxuICAgICAgICAgICAgZGVsZXRlIHVucHJvdGVjdFtmXTtcbiAgICAgICAgICAgIGxlblVucHJvdGVjdC0tO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgandlLnJlY2lwaWVudHMgPSAoandlLnJlY2lwaWVudHMgfHwgW10pLm1hcChmdW5jdGlvbihyY3B0KSB7XG4gICAgICAgICAgICByY3B0ID0gcmNwdCB8fCB7fTtcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSByY3B0LmhlYWRlcjtcbiAgICAgICAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYgaW4gcHJvdGVjdCkgeyBkZWxldGUgaGVhZGVyW2ZdOyB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGhlYWRlcikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJjcHQuaGVhZGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmNwdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghandlLnJlY2lwaWVudHMgfHwgandlLnJlY2lwaWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIGp3ZS5yZWNpcGllbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gXCJzZXJpYWxpemVcIiAoYW5kIHNldHVwIG1lcmdlZCBwcm9wcylcbiAgICAgICAgaWYgKHVucHJvdGVjdCAmJiBsZW5VbnByb3RlY3QgPiAwKSB7XG4gICAgICAgICAgcHJvcHMgPSBhc3NpZ24ocHJvcHMsIHVucHJvdGVjdCk7XG4gICAgICAgICAgandlLnVucHJvdGVjdGVkID0gdW5wcm90ZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm90ZWN0ICYmIGxlblByb3RlY3QgPiAwKSB7XG4gICAgICAgICAgcHJvcHMgPSBhc3NpZ24ocHJvcHMsIHByb3RlY3QpO1xuICAgICAgICAgIHByb3RlY3QgPSBKU09OLnN0cmluZ2lmeShwcm90ZWN0KTtcbiAgICAgICAgICBqd2UucHJvdGVjdGVkID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKHByb3RlY3QsIFwidXRmOFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqd2U7XG4gICAgICB9KTtcblxuICAgICAgLy8gKE9QVElPTkFMKSBjb21wcmVzcyBwbGFpbnRleHRcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgIHZhciBwZGF0YSA9IGNvbnRlbnQ7XG4gICAgICAgIGlmICghcHJvcHMuemlwKSB7XG4gICAgICAgICAgandlLnBsYWludGV4dCA9IHBkYXRhO1xuICAgICAgICAgIHJldHVybiBqd2U7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHMuemlwID09PSBcIkRFRlwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGRhdGEgPSBwYWtvLmRlZmxhdGVSYXcoQnVmZmVyLmZyb20ocGRhdGEsIFwiYmluYXJ5XCIpKTtcblxuICAgICAgICAgICAgICBqd2UucGxhaW50ZXh0ID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoandlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkICd6aXAnIG1vZGVcIikpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGVuY3J5cHQgcGxhaW50ZXh0XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICBwcm9wcy5hZGF0YSA9IGp3ZS5wcm90ZWN0ZWQ7XG4gICAgICAgIGlmIChcImFhZFwiIGluIGNmZyAmJiBjZmcuYWFkICE9IG51bGwpIHtcbiAgICAgICAgICBwcm9wcy5hZGF0YSArPSBcIi5cIiArIGNmZy5hYWQ7XG4gICAgICAgICAgcHJvcHMuYWRhdGEgPSBCdWZmZXIuZnJvbShwcm9wcy5hZGF0YSwgXCJ1dGY4XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBJVlxuICAgICAgICB2YXIgaXYgPSBjZmcuaXYgfHxcbiAgICAgICAgICAgICAgICAgdXRpbC5yYW5kb21CeXRlcyhDT05TVEFOVFMuTk9OQ0VMRU5HVEhbZW5jQWxnXSAvIDgpO1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGl2KSB7XG4gICAgICAgICAgaXYgPSB1dGlsLmJhc2U2NHVybC5kZWNvZGUoaXYpO1xuICAgICAgICB9XG4gICAgICAgIHByb3BzLml2ID0gaXY7XG5cbiAgICAgICAgaWYgKFwicmVjaXBpZW50c1wiIGluIGp3ZSAmJiBqd2UucmVjaXBpZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBwcm9wcy5rZGF0YSA9IGp3ZS5yZWNpcGllbnRzWzBdLmVuY3J5cHRlZF9rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXCJlcHVcIiBpbiBjZmcgJiYgY2ZnLmVwdSAhPSBudWxsKSB7XG4gICAgICAgICAgcHJvcHMuZXB1ID0gY2ZnLmVwdTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcImVwdlwiIGluIGNmZyAmJiBjZmcuZXB2ICE9IG51bGwpIHtcbiAgICAgICAgICBwcm9wcy5lcHYgPSBjZmcuZXB2O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBkYXRhID0gandlLnBsYWludGV4dDtcbiAgICAgICAgZGVsZXRlIGp3ZS5wbGFpbnRleHQ7XG4gICAgICAgIHJldHVybiBlbmNLZXkudGhlbihmdW5jdGlvbihlbmNLZXkpIHtcbiAgICAgICAgICB2YXIgcCA9IGVuY0tleS5lbmNyeXB0KGVuY0FsZywgcGRhdGEsIHByb3BzKTtcbiAgICAgICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgandlLml2ID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKGl2LCBcImJpbmFyeVwiKTtcbiAgICAgICAgICAgIGlmIChcImFhZFwiIGluIGNmZyAmJiBjZmcuYWFkICE9IG51bGwpIHtcbiAgICAgICAgICAgICBqd2UuYWFkID0gY2ZnLmFhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGp3ZS5jaXBoZXJ0ZXh0ID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKHJlc3VsdC5kYXRhLCBcImJpbmFyeVwiKTtcbiAgICAgICAgICAgIGp3ZS50YWcgPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUocmVzdWx0LnRhZywgXCJiaW5hcnlcIik7XG4gICAgICAgICAgICByZXR1cm4gandlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyAoT1BUSU9OQUwpIGNvbXBhY3QvZmxhdHRlbmVkIHJlc3VsdHNcbiAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgXCJjb21wYWN0XCI6XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgICAgIHZhciBjb21wYWN0ID0gbmV3IEFycmF5KDUpO1xuXG4gICAgICAgICAgICBjb21wYWN0WzBdID0gandlLnByb3RlY3RlZDtcbiAgICAgICAgICAgIGlmIChqd2UucmVjaXBpZW50cyAmJiBqd2UucmVjaXBpZW50c1swXSkge1xuICAgICAgICAgICAgICBjb21wYWN0WzFdID0gandlLnJlY2lwaWVudHNbMF0uZW5jcnlwdGVkX2tleTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tcGFjdFsyXSA9IGp3ZS5pdjtcbiAgICAgICAgICAgIGNvbXBhY3RbM10gPSBqd2UuY2lwaGVydGV4dDtcbiAgICAgICAgICAgIGNvbXBhY3RbNF0gPSBqd2UudGFnO1xuICAgICAgICAgICAgY29tcGFjdCA9IGNvbXBhY3Quam9pbihcIi5cIik7XG5cbiAgICAgICAgICAgIHJldHVybiBjb21wYWN0O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZmxhdHRlbmVkXCI6XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgICAgIHZhciBmbGF0dGVuZWQgPSB7fSxcbiAgICAgICAgICAgICAgICByY3B0ID0gandlLnJlY2lwaWVudHMgJiYgandlLnJlY2lwaWVudHNbMF07XG5cbiAgICAgICAgICAgIGlmIChqd2UucHJvdGVjdGVkKSB7XG4gICAgICAgICAgICAgIGZsYXR0ZW5lZC5wcm90ZWN0ZWQgPSBqd2UucHJvdGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGp3ZS51bnByb3RlY3RlZCkge1xuICAgICAgICAgICAgICBmbGF0dGVuZWQudW5wcm90ZWN0ZWQgPSBqd2UudW5wcm90ZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbXCJoZWFkZXJcIiwgXCJlbmNyeXB0ZWRfa2V5XCJdLmZvckVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgICBpZiAoIXJjcHQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgIGlmICghKGYgaW4gcmNwdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgIGlmICghcmNwdFtmXSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiByY3B0W2ZdICYmICFPYmplY3Qua2V5cyhyY3B0W2ZdKS5sZW5ndGgpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgIGZsYXR0ZW5lZFtmXSA9IHJjcHRbZl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChqd2UuYWFkKSB7XG4gICAgICAgICAgICAgIGZsYXR0ZW5lZC5hYWQgPSBqd2UuYWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhdHRlbmVkLml2ID0gandlLml2O1xuICAgICAgICAgICAgZmxhdHRlbmVkLmNpcGhlcnRleHQgPSBqd2UuY2lwaGVydGV4dDtcbiAgICAgICAgICAgIGZsYXR0ZW5lZC50YWcgPSBqd2UudGFnO1xuXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlbmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZ2VuZXJhbFwiOlxuICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgICAgICB2YXIgcmVjaXBpZW50cyA9IGp3ZS5yZWNpcGllbnRzIHx8IFtdO1xuICAgICAgICAgICAgcmVjaXBpZW50cyA9IHJlY2lwaWVudHMubWFwKGZ1bmN0aW9uIChyY3B0KSB7XG4gICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMocmNwdCkubGVuZ3RoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJjcHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlY2lwaWVudHMgPSByZWNpcGllbnRzLmZpbHRlcihmdW5jdGlvbiAocmNwdCkgeyByZXR1cm4gISFyY3B0OyB9KTtcbiAgICAgICAgICAgIGlmIChyZWNpcGllbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBqd2UucmVjaXBpZW50cyA9IHJlY2lwaWVudHM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgandlLnJlY2lwaWVudHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBqd2U7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVuY3J5cHQob3B0cywgcmNwdHMpIHtcbiAgLy8gZml4dXAgcmVjaXBpZW50c1xuICB2YXIgb3B0aW9ucyA9IG9wdHMsXG4gICAgcmNwdFN0YXJ0ID0gMSxcbiAgICByY3B0TGlzdCA9IHJjcHRzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYXQgbGVhc3Qgb25lIHJlY2lwaWVudCBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gYXNzdW1lIG9wdHMgaXMgdGhlIHJlY2lwaWVudCBsaXN0XG4gICAgcmNwdExpc3QgPSBvcHRzO1xuICAgIHJjcHRTdGFydCA9IDA7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IGVsc2UgaWYgKEpXSy5pc0tleShvcHRzKSB8fFxuICAgICAgICAob3B0cyAmJiBcImt0eVwiIGluIG9wdHMpIHx8XG4gICAgICAgIChvcHRzICYmIFwia2V5XCIgaW4gb3B0cyAmJlxuICAgICAgICAoSldLLmlzS2V5KG9wdHMua2V5KSB8fCBcImt0eVwiIGluIG9wdHMua2V5KSkpIHtcbiAgICByY3B0TGlzdCA9IG9wdHM7XG4gICAgcmNwdFN0YXJ0ID0gMDtcbiAgICBvcHRpb25zID0ge307XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IGNsb25lKG9wdHMpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShyY3B0TGlzdCkpIHtcbiAgICByY3B0TGlzdCA9IHNsaWNlKGFyZ3VtZW50cywgcmNwdFN0YXJ0KTtcbiAgfVxuXG4gIC8vIGZpeHVwIG9wdGlvbnNcbiAgb3B0aW9ucyA9IGFzc2lnbihjbG9uZShERUZBVUxUUyksIG9wdGlvbnMpO1xuXG4gIC8vIHNldHVwIGhlYWRlciBmaWVsZHNcbiAgdmFyIGZpZWxkcyA9IGNsb25lKG9wdGlvbnMuZmllbGRzIHx8IHt9KTtcbiAgaWYgKG9wdGlvbnMuemlwKSB7XG4gICAgZmllbGRzLnppcCA9ICh0eXBlb2Ygb3B0aW9ucy56aXAgPT09IFwiYm9vbGVhblwiKSA/XG4gICAgICAgICAgIChvcHRpb25zLnppcCA/IFwiREVGXCIgOiBmYWxzZSkgOlxuICAgICAgICAgICBvcHRpb25zLnppcDtcbiAgfVxuICBvcHRpb25zLmZvcm1hdCA9IChvcHRpb25zLmNvbXBhY3QgPyBcImNvbXBhY3RcIiA6IG9wdGlvbnMuZm9ybWF0KSB8fCBcImdlbmVyYWxcIjtcbiAgc3dpdGNoIChvcHRpb25zLmZvcm1hdCkge1xuICAgIGNhc2UgXCJjb21wYWN0XCI6XG4gICAgICBpZiAoXCJhYWRcIiBpbiBvcHRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZGl0aW9uYWwgYXV0aGVudGljYXRlZCBkYXRhIGNhbm5vdCBiZSB1c2VkIGZvciBjb21wYWN0IHNlcmlhbGl6YXRpb25cIik7XG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IFswXSAqL1xuICAgIGNhc2UgXCJmbGF0dGVuZWRcIjpcbiAgICAgIGlmIChyY3B0TGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvbyBtYW55IHJlY2lwaWVudHMgZm9yIGNvbXBhY3Qgc2VyaWFsaXphdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gbm90ZSBwcm90ZWN0ZWQgZmllbGRzIChnbG9iYWxseSlcbiAgLy8gcHJvdGVjdGVkIGZpZWxkcyBhcmUgZ2xvYmFsIG9ubHlcbiAgdmFyIHByb3RlY3RBbGwgPSBmYWxzZTtcbiAgaWYgKFwiY29tcGFjdFwiID09PSBvcHRpb25zLmZvcm1hdCB8fCBcIipcIiA9PT0gb3B0aW9ucy5wcm90ZWN0KSB7XG4gICAgcHJvdGVjdEFsbCA9IHRydWU7XG4gICAgb3B0aW9ucy5wcm90ZWN0ID0gT2JqZWN0LmtleXMoZmllbGRzKS5jb25jYXQoXCJlbmNcIik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMucHJvdGVjdCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG9wdGlvbnMucHJvdGVjdCA9IFtvcHRpb25zLnByb3RlY3RdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5wcm90ZWN0KSkge1xuICAgIG9wdGlvbnMucHJvdGVjdCA9IG9wdGlvbnMucHJvdGVjdC5jb25jYXQoKTtcbiAgfSBlbHNlIGlmICghb3B0aW9ucy5wcm90ZWN0KSB7XG4gICAgb3B0aW9ucy5wcm90ZWN0ID0gW107XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicHJvdGVjdCBtdXN0IGJlIGEgbGlzdCBvZiBmaWVsZHNcIik7XG4gIH1cblxuICBpZiAocHJvdGVjdEFsbCAmJiAxIDwgcmNwdExpc3QubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidG9vIG1hbnkgcmVjaXBpZW50cyB0byBwcm90ZWN0IGFsbCBoZWFkZXIgcGFyYW1ldGVyc1wiKTtcbiAgfVxuXG4gIHJjcHRMaXN0ID0gcmNwdExpc3QubWFwKGZ1bmN0aW9uKHIsIGlkeCkge1xuICAgIHZhciBwO1xuXG4gICAgLy8gcmVzb2x2ZSBhIGtleVxuICAgIGlmIChyICYmIFwia3R5XCIgaW4gcikge1xuICAgICAgcCA9IEpXSy5hc0tleShyKTtcbiAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oaykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtleToga1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChyKSB7XG4gICAgICBwID0gSldLLmFzS2V5KHIua2V5KTtcbiAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oaykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhlYWRlcjogci5oZWFkZXIsXG4gICAgICAgICAgcmVmZXJlbmNlOiByLnJlZmVyZW5jZSxcbiAgICAgICAgICBrZXk6IGtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibWlzc2luZyBrZXkgZm9yIHJlY2lwaWVudCBcIiArIGlkeCkpO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgZXBoZW1lcmFsIGtleSAoaWYgcHJlc2VudClcbiAgICBpZiAoci5lcGspIHtcbiAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24ocmVjaXBpZW50KSB7XG4gICAgICAgIHJldHVybiBKV0suYXNLZXkoci5lcGspLlxuICAgICAgICAgIHRoZW4oZnVuY3Rpb24oZXBrKSB7XG4gICAgICAgICAgICByZWNpcGllbnQuZXBrID0gZXBrO1xuICAgICAgICAgICAgcmV0dXJuIHJlY2lwaWVudDtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHJlc29sdmUgdGhlIGNvbXBsZXRlIHJlY2lwaWVudFxuICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24ocmVjaXBpZW50KSB7XG4gICAgICB2YXIga2V5ID0gcmVjaXBpZW50LmtleTtcblxuICAgICAgLy8gcHJlcGFyZSB0aGUgcmVjaXBpZW50IGhlYWRlclxuICAgICAgdmFyIGhlYWRlciA9IHJlY2lwaWVudC5oZWFkZXIgfHwge307XG4gICAgICByZWNpcGllbnQuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICBwcm9wcyA9IGFzc2lnbihwcm9wcywgZmllbGRzKTtcbiAgICAgIHByb3BzID0gYXNzaWduKHByb3BzLCByZWNpcGllbnQuaGVhZGVyKTtcblxuICAgICAgLy8gZW5zdXJlIGtleSBwcm90ZWN0aW9uIGFsZ29yaXRobSBpcyBzZXRcbiAgICAgIGlmICghcHJvcHMuYWxnKSB7XG4gICAgICAgIHByb3BzLmFsZyA9IGtleS5hbGdvcml0aG1zKEpXSy5NT0RFX1dSQVApWzBdO1xuICAgICAgICBoZWFkZXIuYWxnID0gcHJvcHMuYWxnO1xuICAgICAgfVxuICAgICAgaWYgKCFwcm9wcy5hbGcpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImtleSBub3QgdmFsaWQgZm9yIGVuY3J5cHRpbmcgdG8gcmVjaXBpZW50IFwiICsgaWR4KSk7XG4gICAgICB9XG4gICAgICBoZWFkZXIuYWxnID0gcHJvcHMuYWxnO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgdGhlIGtleSByZWZlcmVuY2VcbiAgICAgIHZhciByZWYgPSByZWNpcGllbnQucmVmZXJlbmNlO1xuICAgICAgZGVsZXRlIHJlY2lwaWVudC5yZWZlcmVuY2U7XG4gICAgICBpZiAodW5kZWZpbmVkID09PSByZWYpIHtcbiAgICAgICAgLy8gaGVhZGVyIGFscmVhZHkgY29udGFpbnMgdGhlIGtleSByZWZlcmVuY2VcbiAgICAgICAgcmVmID0gW1wia2lkXCIsIFwiamt1XCIsIFwieDVjXCIsIFwieDV0XCIsIFwieDV1XCJdLnNvbWUoZnVuY3Rpb24oaykge1xuICAgICAgICAgIHJldHVybiAoayBpbiBoZWFkZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVmID0gIXJlZiA/IFwia2lkXCIgOiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHJlZikge1xuICAgICAgICAvLyBleHBsaWNpdCAocG9zaXRpdmUgfCBuZWdhdGl2ZSkgcmVxdWVzdCBmb3Iga2V5IHJlZmVyZW5jZVxuICAgICAgICByZWYgPSByZWYgPyBcImtpZFwiIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBqd2s7XG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGp3ayA9IGtleS50b0pTT04oKTtcbiAgICAgICAgaWYgKFwiandrXCIgPT09IHJlZikge1xuICAgICAgICAgIGlmIChcIm9jdFwiID09PSBrZXkua3R5KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiY2Fubm90IGVtYmVkIGtleVwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhlYWRlci5qd2sgPSBqd2s7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmIGluIGp3aykge1xuICAgICAgICAgIGhlYWRlcltyZWZdID0gandrW3JlZl07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZnJlZXplIHJlY2lwaWVudFxuICAgICAgcmVjaXBpZW50ID0gT2JqZWN0LmZyZWV6ZShyZWNpcGllbnQpO1xuICAgICAgcmV0dXJuIHJlY2lwaWVudDtcbiAgICB9KTtcblxuICAgIHJldHVybiBwO1xuICB9KTtcblxuICAvLyBjcmVhdGUgYW5kIGNvbmZpZ3VyZSBlbmNyeXB0aW9uXG4gIHZhciBjZmcgPSB7XG4gICAgYWFkOiAoXCJhYWRcIiBpbiBvcHRpb25zKSA/IHV0aWwuYmFzZTY0dXJsLmVuY29kZShvcHRpb25zLmFhZCB8fCBcIlwiKSA6IG51bGwsXG4gICAgY29udGVudEFsZzogb3B0aW9ucy5jb250ZW50QWxnLFxuICAgIGZvcm1hdDogb3B0aW9ucy5mb3JtYXQsXG4gICAgcHJvdGVjdDogb3B0aW9ucy5wcm90ZWN0LFxuICAgIGNlazogb3B0aW9ucy5jZWssXG4gICAgaXY6IG9wdGlvbnMuaXYsXG4gICAgcHJvdGVjdEFsbDogcHJvdGVjdEFsbFxuICB9O1xuICB2YXIgZW5jID0gbmV3IEpXRUVuY3J5cHRlcihjZmcsIGZpZWxkcywgcmNwdExpc3QpO1xuXG4gIHJldHVybiBlbmM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNyeXB0ZXI6IEpXRUVuY3J5cHRlcixcbiAgY3JlYXRlRW5jcnlwdDogY3JlYXRlRW5jcnlwdFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/encrypt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/helpers.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwe/helpers.js - JWE Internal Helper Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar CONSTANTS = __webpack_require__(/*! ../algorithms/constants */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\");\n\nmodule.exports = {\n  slice: function(input, start) {\n    return Array.prototype.slice.call(input, start || 0);\n  },\n  generateCEK: function(enc) {\n    var ks = JWK.createKeyStore();\n    var len = CONSTANTS.KEYLENGTH[enc];\n\n    if (len) {\n        return ks.generate(\"oct\", len);\n    }\n\n    throw new Error(\"unsupported encryption algorithm\");\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsMkZBQXlCO0FBQ2pELFVBQVUsbUJBQU8sQ0FBQywrREFBUTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ZS9oZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandlL2hlbHBlcnMuanMgLSBKV0UgSW50ZXJuYWwgSGVscGVyIEZ1bmN0aW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQ09OU1RBTlRTID0gcmVxdWlyZShcIi4uL2FsZ29yaXRobXMvY29uc3RhbnRzXCIpLFxuICAgIEpXSyA9IHJlcXVpcmUoXCIuLi9qd2tcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzbGljZTogZnVuY3Rpb24oaW5wdXQsIHN0YXJ0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGlucHV0LCBzdGFydCB8fCAwKTtcbiAgfSxcbiAgZ2VuZXJhdGVDRUs6IGZ1bmN0aW9uKGVuYykge1xuICAgIHZhciBrcyA9IEpXSy5jcmVhdGVLZXlTdG9yZSgpO1xuICAgIHZhciBsZW4gPSBDT05TVEFOVFMuS0VZTEVOR1RIW2VuY107XG5cbiAgICBpZiAobGVuKSB7XG4gICAgICAgIHJldHVybiBrcy5nZW5lcmF0ZShcIm9jdFwiLCBsZW4pO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGVuY3J5cHRpb24gYWxnb3JpdGhtXCIpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/index.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwe/index.js - JSON Web Encryption (JWE) Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar JWE = {\n  createEncrypt: (__webpack_require__(/*! ./encrypt */ \"(ssr)/./node_modules/node-jose/lib/jwe/encrypt.js\").createEncrypt),\n  createDecrypt: (__webpack_require__(/*! ./decrypt */ \"(ssr)/./node_modules/node-jose/lib/jwe/decrypt.js\").createDecrypt)\n};\n\nmodule.exports = JWE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0EsaUJBQWlCLHlHQUFrQztBQUNuRCxpQkFBaUIseUdBQWtDO0FBQ25EOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3ZS9pbmRleC5qcyAtIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSkgRW50cnkgUG9pbnRcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEpXRSA9IHtcbiAgY3JlYXRlRW5jcnlwdDogcmVxdWlyZShcIi4vZW5jcnlwdFwiKS5jcmVhdGVFbmNyeXB0LFxuICBjcmVhdGVEZWNyeXB0OiByZXF1aXJlKFwiLi9kZWNyeXB0XCIpLmNyZWF0ZURlY3J5cHRcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSldFO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/basekey.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/basekey.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/basekey.js - JWK Key Base Class Implementation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\");\nconst { v4: uuidv4 } = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/index.js\");\n\nvar assign = __webpack_require__(/*! lodash/assign */ \"(ssr)/./node_modules/lodash/assign.js\");\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\");\nvar flatten = __webpack_require__(/*! lodash/flatten */ \"(ssr)/./node_modules/lodash/flatten.js\");\nvar intersection = __webpack_require__(/*! lodash/intersection */ \"(ssr)/./node_modules/lodash/intersection.js\");\nvar omit = __webpack_require__(/*! lodash/omit */ \"(ssr)/./node_modules/lodash/omit.js\");\nvar pick = __webpack_require__(/*! lodash/pick */ \"(ssr)/./node_modules/lodash/pick.js\");\nvar uniq = __webpack_require__(/*! lodash/uniq */ \"(ssr)/./node_modules/lodash/uniq.js\");\n\nvar ALGORITHMS = __webpack_require__(/*! ../algorithms */ \"(ssr)/./node_modules/node-jose/lib/algorithms/index.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/constants.js\"),\n    HELPERS = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\"),\n    UTIL = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\n/**\n * @class JWK.Key\n * @classdesc\n * Represents a JSON Web Key instance.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call\n * {@link JWK.asKey}, {@link JWK.KeyStore#add}, or\n * {@link JWK.KeyStore#generate}.\n */\nvar JWKBaseKeyObject = function(kty, ks, props, cfg) {\n  // ### validate/coerce arguments ###\n  if (!kty) {\n    throw new Error(\"kty cannot be null\");\n  }\n\n  if (!ks) {\n    throw new Error(\"keystore cannot be null\");\n  }\n\n  if (!props) {\n    throw new Error(\"props cannot be null\");\n  } else if (\"string\" === typeof props) {\n    props = JSON.parse(props);\n  }\n\n  if (!cfg) {\n    throw new Error(\"cfg cannot be null\");\n  }\n\n  var excluded = [];\n  var keys = {},\n      json = {},\n      prints,\n      kid;\n\n  props = clone(props);\n  // strip thumbprints if present\n  prints = assign({}, props[HELPERS.INTERNALS.THUMBPRINT_KEY] || {});\n  delete props[HELPERS.INTERNALS.THUMBPRINT_KEY];\n  Object.keys(prints).forEach(function(a) {\n    var h = prints[a];\n    if (!kid) {\n      kid = h;\n      if (Buffer.isBuffer(kid)) {\n        kid = UTIL.base64url.encode(kid);\n      }\n    }\n    if (!Buffer.isBuffer(h)) {\n      h = UTIL.base64url.decode(h);\n      prints[a] = h;\n    }\n  });\n\n  // force certain values\n  props.kty = kty;\n  props.kid = props.kid || kid || uuidv4();\n\n  // setup base info\n  var included = Object.keys(HELPERS.COMMON_PROPS).map(function(p) {\n    return HELPERS.COMMON_PROPS[p].name;\n  });\n  json.base = pick(props, included);\n  excluded = excluded.concat(Object.keys(json.base));\n\n  // setup public information\n  json.public = clone(props);\n  keys.public = cfg.publicKey(json.public);\n  if (keys.public) {\n    // exclude public values from extra\n    excluded = excluded.concat(Object.keys(json.public));\n  }\n\n  // setup private information\n  json.private = clone(props);\n  keys.private = cfg.privateKey(json.private);\n  if (keys.private) {\n    // exclude private values from extra\n    excluded = excluded.concat(Object.keys(json.private));\n  }\n\n  // setup extra information\n  json.extra = omit(props, excluded);\n\n  // TODO: validate 'alg' against supported algorithms\n\n  // setup calculated values\n  var keyLen;\n  if (keys.public && (\"length\" in keys.public)) {\n    keyLen = keys.public.length;\n  } else if (keys.private && (\"length\" in keys.private)) {\n    keyLen = keys.private.length;\n  } else {\n    keyLen = NaN;\n  }\n\n  // ### Public Properties ###\n  /**\n   * @member {JWK.KeyStore} JWK.Key#keystore\n   * @description\n   * The owning keystore.\n   */\n  Object.defineProperty(this, \"keystore\", {\n    value: ks,\n    enumerable: true\n  });\n  /**\n   * @member {Number} JWK.Key#length\n   * @description\n   * The size of this Key, in bits.\n   */\n  Object.defineProperty(this, \"length\", {\n    value: keyLen,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#kty\n   * @description\n   * The type of Key.\n   */\n  Object.defineProperty(this, \"kty\", {\n    value: kty,\n    enumerable: true\n  });\n\n  /**\n   * @member {String} JWK.Key#kid\n   * @description\n   * The identifier for this Key.\n   */\n  Object.defineProperty(this, \"kid\", {\n    value: json.base.kid,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#use\n   * @description\n   * The usage for this Key.\n   */\n  Object.defineProperty(this, \"use\", {\n    value: json.base.use || \"\",\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#alg\n   * @description\n   * The sole algorithm this key can be used for.\n   */\n  Object.defineProperty(this, \"alg\", {\n    value: json.base.alg || \"\",\n    enumerable: true\n  });\n\n  // ### Public Methods ###\n  /**\n   * Generates the thumbprint of this Key.\n   *\n   * @param {String} [] The hash algorithm to use\n   * @returns {Promise} The promise for the thumbprint generation.\n   */\n  Object.defineProperty(this, \"thumbprint\", {\n    value: function(hash) {\n      hash = (hash || HELPERS.INTERNALS.THUMBPRINT_HASH).toUpperCase();\n      if (prints[hash]) {\n        // return cached value\n        return Promise.resolve(prints[hash]);\n      }\n      var p = HELPERS.thumbprint(cfg, json, hash);\n      p = p.then(function(result) {\n        if (result) {\n          prints[hash] = result;\n        }\n        return result;\n      });\n      return p;\n    }\n  });\n  /**\n   * @method JWK.Key#algorithms\n   * @description\n   * The possible algorithms this Key can be used for. The returned\n   * list is not any particular order, but is filtered based on the\n   * Key's intended usage.\n   *\n   * @param {String} mode The operation mode\n   * @returns {String[]} The list of supported algorithms\n   * @see JWK.Key#supports\n   */\n  Object.defineProperty(this, \"algorithms\", {\n    value: function(mode) {\n      var modes = [];\n      if (!this.use || this.use === \"sig\") {\n        if (!mode || CONSTANTS.MODE_SIGN === mode) {\n          modes.push(CONSTANTS.MODE_SIGN);\n        }\n        if (!mode || CONSTANTS.MODE_VERIFY === mode) {\n          modes.push(CONSTANTS.MODE_VERIFY);\n        }\n      }\n      if (!this.use || this.use === \"enc\") {\n        if (!mode || CONSTANTS.MODE_ENCRYPT === mode) {\n          modes.push(CONSTANTS.MODE_ENCRYPT);\n        }\n        if (!mode || CONSTANTS.MODE_DECRYPT === mode) {\n          modes.push(CONSTANTS.MODE_DECRYPT);\n        }\n        if (!mode || CONSTANTS.MODE_WRAP === mode) {\n          modes.push(CONSTANTS.MODE_WRAP);\n        }\n        if (!mode || CONSTANTS.MODE_UNWRAP === mode) {\n          modes.push(CONSTANTS.MODE_UNWRAP);\n        }\n      }\n\n      var self = this;\n      var algs = modes.map(function(m) {\n        return cfg.algorithms.call(self, keys, m);\n      });\n      algs = flatten(algs);\n      algs = uniq(algs);\n      if (this.alg) {\n        // TODO: fix this correctly\n        var valid;\n        if (\"oct\" === kty) {\n          valid = [this.alg, \"dir\"];\n        } else {\n          valid = [this.alg];\n        }\n        algs = intersection(algs, valid);\n      }\n\n      return algs;\n    }\n  });\n  /**\n   * @method JWK.Key#supports\n   * @description\n   * Determines if the given algorithm is supported.\n   *\n   * @param {String} alg The algorithm in question\n   * @param {String} [mode] The operation mode\n   * @returns {Boolean} `true` if {alg} is supported, and `false` otherwise.\n   * @see JWK.Key#algorithms\n   */\n  Object.defineProperty(this, \"supports\", {\n    value: function(alg, mode) {\n      return (this.algorithms(mode).indexOf(alg) !== -1);\n    }\n  });\n  /**\n   * @method JWK.Key#has\n   * @description\n   * Determines if this Key contains the given parameter.\n   *\n   * @param {String} name The name of the parameter\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        checked.\n   * @returns {Boolean} `true` if the given parameter is present; `false`\n   *          otherwise.\n   */\n  Object.defineProperty(this, \"has\", {\n    value: function(name, isPrivate) {\n      var contains = false;\n      contains = contains || !!(json.base &&\n                                (name in json.base));\n      contains = contains || !!(keys.public &&\n                                (name in keys.public));\n      contains = contains || !!(json.extra &&\n                                (name in json.extra));\n      contains = contains || !!(isPrivate &&\n                                keys.private &&\n                                (name in keys.private));\n      // TODO: check for export restrictions\n\n      return contains;\n    }\n  });\n  /**\n   * @method JWK.Key#get\n   * @description\n   * Retrieves the value of the given parameter. The value returned by this\n   * method is in its natural format, which might not exactly match its\n   * JSON encoding (e.g., a binary string rather than a base64url-encoded\n   * string).\n   *\n   * **NOTE:** This method can return `false`. Call\n   * {@link JWK.Key#has} to determine if the parameter is present.\n   *\n   * @param {String} name The name of the parameter\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should\n   *        be checked.\n   * @returns {any} The value of the named parameter, or undefined if\n   *          it is not present.\n   */\n  Object.defineProperty(this, \"get\", {\n    value: function(name, isPrivate) {\n      var src;\n      if (json.base && (name in json.base)) {\n        src = json.base;\n      } else if (keys.public && (name in keys.public)) {\n        src = keys.public;\n      } else if (json.extra && (name in json.extra)) {\n        src = json.extra;\n      } else if (isPrivate && keys.private && (name in keys.private)) {\n        // TODO: check for export restrictions\n        src = keys.private;\n      }\n\n      return src && src[name] || null;\n    }\n  });\n  /**\n   * @method JWK.Key#toJSON\n   * @description\n   * Returns the JSON representation of this Key.  All properties of the\n   * returned JSON object are properly encoded (e.g., base64url encoding for\n   * any binary strings).\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @param {String[]} [excluded] The list of parameters to exclude from\n   *        the returned JSON.\n   * @returns {Object} The plain JSON object\n   */\n  Object.defineProperty(this, \"toJSON\", {\n    value: function(isPrivate, excluded) {\n      // coerce arguments\n      if (Array.isArray(isPrivate)) {\n        excluded = isPrivate;\n        isPrivate = false;\n      }\n      var result = {};\n\n      // TODO: check for export restrictions\n      result = merge(result,\n                       json.base,\n                       json.public,\n                       (\"boolean\" === typeof isPrivate && isPrivate) ? json.private : {},\n                       json.extra);\n      result = omit(result, excluded || []);\n\n      return result;\n    }\n  });\n\n  /**\n   * @method JWK.Key#toPEM\n   * @description\n   * Returns the PEM representation of this Key as a string.\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @returns {string} The PEM-encoded string\n   */\n  Object.defineProperty(this, \"toPEM\", {\n    value: function(isPrivate) {\n      if (isPrivate === null) {\n        isPrivate = false;\n      }\n\n      if (!cfg.convertToPEM) {\n        throw new Error(\"Unsupported key type for PEM encoding\");\n      }\n      var k = (isPrivate) ? keys.private : keys.public;\n      if (!k) {\n        throw new Error(\"Invalid key\");\n      }\n      return cfg.convertToPEM.call(this, k, isPrivate);\n    }\n  });\n\n  /**\n   * @method JWK.Key#toObject\n   * @description\n   * Returns the plain object representing this Key.  All properties of the\n   * returned object are in their natural encoding (e.g., binary strings\n   * instead of base64url encoded).\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @param {String[]} [excluded] The list of parameters to exclude from\n   *        the returned object.\n   * @returns {Object} The plain Object.\n   */\n  Object.defineProperty(this, \"toObject\", {\n    value: function(isPrivate, excluded) {\n      // coerce arguments\n      if (Array.isArray(isPrivate)) {\n        excluded = isPrivate;\n        isPrivate = false;\n      }\n      var result = {};\n\n      // TODO: check for export restrictions\n      result = merge(result,\n                       json.base,\n                       keys.public,\n                       (\"boolean\" === typeof isPrivate && isPrivate) ? keys.private : {},\n                       json.extra);\n      result = omit(result, (excluded || []).concat(\"length\"));\n\n      return result;\n    }\n  });\n\n  /**\n   * @method JWK.Key#sign\n   * @description\n   * Sign the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive signing operation; the output is\n   * _**NOT**_ a JSON Web Signature (JWS) object.\n   *\n   * The Promise, when fulfilled, returns an Object with the following\n   * properties:\n   *\n   * + **data**: The data that was signed (and should be equal to {data}).\n   * + **mac**: The signature or message authentication code (MAC).\n   *\n   * @param {String} alg The signing algorithm\n   * @param {String|Buffer} data The data to sign\n   * @param {Object} [props] Additional properties for the signing\n   *        algorithm.\n   * @returns {Promise} The promise for the signing operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n  Object.defineProperty(this, \"sign\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"sign\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.signKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.signProps) {\n        props = merge(props, cfg.signProps.call(this, alg, props));\n      }\n      return ALGORITHMS.sign(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#verify\n   * @description\n   * Verify the given data and signature using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive verification operation; the input is\n   * _**NOT**_ a JSON Web Signature.</p>\n   *\n   * The Promise, when fulfilled, returns an Object with the following\n   * properties:\n   *\n   * + **data**: The data that was verified (and should be equal to\n   *   {data}).\n   * + **mac**: The signature or MAC that was verified (and should be equal\n   *   to {mac}).\n   * + **valid**: `true` if {mac} is valid for {data}.\n   *\n   * @param {String} alg The verification algorithm\n   * @param {String|Buffer} data The data to verify\n   * @param {String|Buffer} mac The signature or MAC to verify\n   * @param {Object} [props] Additional properties for the verification\n   *        algorithm.\n   * @returns {Promise} The promise for the verification operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n  Object.defineProperty(this, \"verify\", {\n    value: function(alg, data, mac, props) {\n      // validate appropriateness\n      if (this.algorithms(\"verify\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.verifyKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.verifyProps) {\n        props = merge(props, cfg.verifyProps.call(this, alg, props));\n      }\n      return ALGORITHMS.verify(alg, k, data, mac, props);\n    }\n  });\n\n  /**\n   * @method JWK.Key#encrypt\n   * @description\n   * Encrypts the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive encryption operation; the output is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#wrap}, as different algorithms and properties are often\n   * used for wrapping a key versues encrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns an object with the following\n   * properties:\n   *\n   * + **data**: The ciphertext data\n   * + **mac**: The associated message authentication code (MAC).\n   *\n   * @param {String} alg The encryption algorithm\n   * @param {Buffer|String} data The data to encrypt\n   * @param {Object} [props] Additional properties for the encryption\n   *        algorithm.\n   * @returns {Promise} The promise for the encryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n  Object.defineProperty(this, \"encrypt\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"encrypt\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.encryptKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.encryptProps) {\n        props = merge(props, cfg.encryptProps.call(this, alg, props));\n      }\n      return ALGORITHMS.encrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#decrypt\n   * @description\n   * Decrypts the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive decryption operation; the input is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#unwrap}, as different algorithms and properties are often used\n   * for unwrapping a key versues decrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns the plaintext data.\n   *\n   * @param {String} alg The decryption algorithm.\n   * @param {Buffer|String} data The data to decypt.\n   * @param {Object} [props] Additional data for the decryption operation.\n   * @returns {Promise} The promise for the decryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n  Object.defineProperty(this, \"decrypt\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"decrypt\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.decryptKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.decryptProps) {\n        props = merge(props, cfg.decryptProps.call(this, alg, props));\n      }\n      return ALGORITHMS.decrypt(alg, k, data, props);\n    }\n  });\n\n  /**\n   * @method JWK.Key#wrap\n   * @description\n   * Wraps the given key using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive encryption operation; the output is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#encrypt}, as different algorithms and properties are\n   * often used for wrapping a key versues encrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns an object with the following\n   * properties:\n   *\n   * + **data**: The ciphertext data\n   * + **headers**: The additional header parameters to apply to a JWE.\n   *\n   * @param {String} alg The encryption algorithm\n   * @param {Buffer|String} data The data to encrypt\n   * @param {Object} [props] Additional properties for the encryption\n   *        algorithm.\n   * @returns {Promise} The promise for the encryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n  Object.defineProperty(this, \"wrap\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"wrap\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.wrapKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.wrapProps) {\n        props = merge(props, cfg.wrapProps.call(this, alg, props));\n      }\n      return ALGORITHMS.encrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#unwrap\n   * @description\n   * Unwraps the given key using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive unwrap operation; the input is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#decrypt}, as different algorithms and properties are often used\n   * for unwrapping a key versues decrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns the unwrapped key.\n   *\n   * @param {String} alg The unwrap algorithm.\n   * @param {Buffer|String} data The data to unwrap.\n   * @param {Object} [props] Additional data for the unwrap operation.\n   * @returns {Promise} The promise for the unwrap operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n  Object.defineProperty(this, \"unwrap\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"unwrap\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.unwrapKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.unwrapProps) {\n        props = merge(props, cfg.unwrapProps.call(this, alg, props));\n      }\n      return ALGORITHMS.decrypt(alg, k, data, props);\n    }\n  });\n};\n\nmodule.exports = JWKBaseKeyObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svYmFzZWtleS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMscUZBQU07O0FBRXJDLGFBQWEsbUJBQU8sQ0FBQyw0REFBZTtBQUNwQyxZQUFZLG1CQUFPLENBQUMsMERBQWM7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN0QyxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBcUI7QUFDaEQsV0FBVyxtQkFBTyxDQUFDLHdEQUFhO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyx3REFBYTtBQUNoQyxXQUFXLG1CQUFPLENBQUMsd0RBQWE7O0FBRWhDLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFlO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFnQjtBQUN4QyxjQUFjLG1CQUFPLENBQUMsdUVBQWM7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGlFQUFTOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCLEdBQUcsdUJBQXVCO0FBQzlDLElBQUksNEJBQTRCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUErQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUyxXQUFXLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsZUFBZSxTQUFTLDBDQUEwQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1CQUFtQjtBQUN6QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsS0FBSztBQUN4RTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPLElBQUksS0FBSyxpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBSztBQUNiO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsNkJBQTZCLEtBQUssY0FBYyxLQUFLO0FBQ3JEO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QixhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGNBQWMsT0FBTyxJQUFJLEtBQUssaUNBQWlDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGNBQWMsT0FBTyxJQUFJLEtBQUssaUNBQWlDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixjQUFjLE9BQU8sSUFBSSxLQUFLLGlDQUFpQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsU0FBUztBQUN4QixjQUFjLE9BQU8sSUFBSSxLQUFLLGlDQUFpQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPLElBQUksS0FBSyxpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svYmFzZWtleS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3ay9iYXNla2V5LmpzIC0gSldLIEtleSBCYXNlIENsYXNzIEltcGxlbWVudGF0aW9uXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZXJnZSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmdlXCIpO1xuY29uc3QgeyB2NDogdXVpZHY0IH0gPSByZXF1aXJlKFwidXVpZFwiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCJsb2Rhc2gvYXNzaWduXCIpO1xudmFyIGNsb25lID0gcmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKTtcbnZhciBmbGF0dGVuID0gcmVxdWlyZShcImxvZGFzaC9mbGF0dGVuXCIpO1xudmFyIGludGVyc2VjdGlvbiA9IHJlcXVpcmUoXCJsb2Rhc2gvaW50ZXJzZWN0aW9uXCIpO1xudmFyIG9taXQgPSByZXF1aXJlKFwibG9kYXNoL29taXRcIik7XG52YXIgcGljayA9IHJlcXVpcmUoXCJsb2Rhc2gvcGlja1wiKTtcbnZhciB1bmlxID0gcmVxdWlyZShcImxvZGFzaC91bmlxXCIpO1xuXG52YXIgQUxHT1JJVEhNUyA9IHJlcXVpcmUoXCIuLi9hbGdvcml0aG1zXCIpLFxuICAgIENPTlNUQU5UUyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKSxcbiAgICBIRUxQRVJTID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKSxcbiAgICBVVElMID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5cbi8qKlxuICogQGNsYXNzIEpXSy5LZXlcbiAqIEBjbGFzc2Rlc2NcbiAqIFJlcHJlc2VudHMgYSBKU09OIFdlYiBLZXkgaW5zdGFuY2UuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAqKk5PVEU6KiogVGhpcyBjbGFzcyBjYW5ub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LiBJbnN0ZWFkIGNhbGxcbiAqIHtAbGluayBKV0suYXNLZXl9LCB7QGxpbmsgSldLLktleVN0b3JlI2FkZH0sIG9yXG4gKiB7QGxpbmsgSldLLktleVN0b3JlI2dlbmVyYXRlfS5cbiAqL1xudmFyIEpXS0Jhc2VLZXlPYmplY3QgPSBmdW5jdGlvbihrdHksIGtzLCBwcm9wcywgY2ZnKSB7XG4gIC8vICMjIyB2YWxpZGF0ZS9jb2VyY2UgYXJndW1lbnRzICMjI1xuICBpZiAoIWt0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImt0eSBjYW5ub3QgYmUgbnVsbFwiKTtcbiAgfVxuXG4gIGlmICgha3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzdG9yZSBjYW5ub3QgYmUgbnVsbFwiKTtcbiAgfVxuXG4gIGlmICghcHJvcHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wcyBjYW5ub3QgYmUgbnVsbFwiKTtcbiAgfSBlbHNlIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMpIHtcbiAgICBwcm9wcyA9IEpTT04ucGFyc2UocHJvcHMpO1xuICB9XG5cbiAgaWYgKCFjZmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjZmcgY2Fubm90IGJlIG51bGxcIik7XG4gIH1cblxuICB2YXIgZXhjbHVkZWQgPSBbXTtcbiAgdmFyIGtleXMgPSB7fSxcbiAgICAgIGpzb24gPSB7fSxcbiAgICAgIHByaW50cyxcbiAgICAgIGtpZDtcblxuICBwcm9wcyA9IGNsb25lKHByb3BzKTtcbiAgLy8gc3RyaXAgdGh1bWJwcmludHMgaWYgcHJlc2VudFxuICBwcmludHMgPSBhc3NpZ24oe30sIHByb3BzW0hFTFBFUlMuSU5URVJOQUxTLlRIVU1CUFJJTlRfS0VZXSB8fCB7fSk7XG4gIGRlbGV0ZSBwcm9wc1tIRUxQRVJTLklOVEVSTkFMUy5USFVNQlBSSU5UX0tFWV07XG4gIE9iamVjdC5rZXlzKHByaW50cykuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgdmFyIGggPSBwcmludHNbYV07XG4gICAgaWYgKCFraWQpIHtcbiAgICAgIGtpZCA9IGg7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGtpZCkpIHtcbiAgICAgICAga2lkID0gVVRJTC5iYXNlNjR1cmwuZW5jb2RlKGtpZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGgpKSB7XG4gICAgICBoID0gVVRJTC5iYXNlNjR1cmwuZGVjb2RlKGgpO1xuICAgICAgcHJpbnRzW2FdID0gaDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGZvcmNlIGNlcnRhaW4gdmFsdWVzXG4gIHByb3BzLmt0eSA9IGt0eTtcbiAgcHJvcHMua2lkID0gcHJvcHMua2lkIHx8IGtpZCB8fCB1dWlkdjQoKTtcblxuICAvLyBzZXR1cCBiYXNlIGluZm9cbiAgdmFyIGluY2x1ZGVkID0gT2JqZWN0LmtleXMoSEVMUEVSUy5DT01NT05fUFJPUFMpLm1hcChmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIEhFTFBFUlMuQ09NTU9OX1BST1BTW3BdLm5hbWU7XG4gIH0pO1xuICBqc29uLmJhc2UgPSBwaWNrKHByb3BzLCBpbmNsdWRlZCk7XG4gIGV4Y2x1ZGVkID0gZXhjbHVkZWQuY29uY2F0KE9iamVjdC5rZXlzKGpzb24uYmFzZSkpO1xuXG4gIC8vIHNldHVwIHB1YmxpYyBpbmZvcm1hdGlvblxuICBqc29uLnB1YmxpYyA9IGNsb25lKHByb3BzKTtcbiAga2V5cy5wdWJsaWMgPSBjZmcucHVibGljS2V5KGpzb24ucHVibGljKTtcbiAgaWYgKGtleXMucHVibGljKSB7XG4gICAgLy8gZXhjbHVkZSBwdWJsaWMgdmFsdWVzIGZyb20gZXh0cmFcbiAgICBleGNsdWRlZCA9IGV4Y2x1ZGVkLmNvbmNhdChPYmplY3Qua2V5cyhqc29uLnB1YmxpYykpO1xuICB9XG5cbiAgLy8gc2V0dXAgcHJpdmF0ZSBpbmZvcm1hdGlvblxuICBqc29uLnByaXZhdGUgPSBjbG9uZShwcm9wcyk7XG4gIGtleXMucHJpdmF0ZSA9IGNmZy5wcml2YXRlS2V5KGpzb24ucHJpdmF0ZSk7XG4gIGlmIChrZXlzLnByaXZhdGUpIHtcbiAgICAvLyBleGNsdWRlIHByaXZhdGUgdmFsdWVzIGZyb20gZXh0cmFcbiAgICBleGNsdWRlZCA9IGV4Y2x1ZGVkLmNvbmNhdChPYmplY3Qua2V5cyhqc29uLnByaXZhdGUpKTtcbiAgfVxuXG4gIC8vIHNldHVwIGV4dHJhIGluZm9ybWF0aW9uXG4gIGpzb24uZXh0cmEgPSBvbWl0KHByb3BzLCBleGNsdWRlZCk7XG5cbiAgLy8gVE9ETzogdmFsaWRhdGUgJ2FsZycgYWdhaW5zdCBzdXBwb3J0ZWQgYWxnb3JpdGhtc1xuXG4gIC8vIHNldHVwIGNhbGN1bGF0ZWQgdmFsdWVzXG4gIHZhciBrZXlMZW47XG4gIGlmIChrZXlzLnB1YmxpYyAmJiAoXCJsZW5ndGhcIiBpbiBrZXlzLnB1YmxpYykpIHtcbiAgICBrZXlMZW4gPSBrZXlzLnB1YmxpYy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoa2V5cy5wcml2YXRlICYmIChcImxlbmd0aFwiIGluIGtleXMucHJpdmF0ZSkpIHtcbiAgICBrZXlMZW4gPSBrZXlzLnByaXZhdGUubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIGtleUxlbiA9IE5hTjtcbiAgfVxuXG4gIC8vICMjIyBQdWJsaWMgUHJvcGVydGllcyAjIyNcbiAgLyoqXG4gICAqIEBtZW1iZXIge0pXSy5LZXlTdG9yZX0gSldLLktleSNrZXlzdG9yZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIG93bmluZyBrZXlzdG9yZS5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleXN0b3JlXCIsIHtcbiAgICB2YWx1ZToga3MsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZW1iZXIge051bWJlcn0gSldLLktleSNsZW5ndGhcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBzaXplIG9mIHRoaXMgS2V5LCBpbiBiaXRzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGVuZ3RoXCIsIHtcbiAgICB2YWx1ZToga2V5TGVuLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBAbWVtYmVyIHtTdHJpbmd9IEpXSy5LZXkja3R5XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgdHlwZSBvZiBLZXkuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrdHlcIiwge1xuICAgIHZhbHVlOiBrdHksXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcblxuICAvKipcbiAgICogQG1lbWJlciB7U3RyaW5nfSBKV0suS2V5I2tpZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIGlkZW50aWZpZXIgZm9yIHRoaXMgS2V5LlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2lkXCIsIHtcbiAgICB2YWx1ZToganNvbi5iYXNlLmtpZCxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogQG1lbWJlciB7U3RyaW5nfSBKV0suS2V5I3VzZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIHVzYWdlIGZvciB0aGlzIEtleS5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVzZVwiLCB7XG4gICAgdmFsdWU6IGpzb24uYmFzZS51c2UgfHwgXCJcIixcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogQG1lbWJlciB7U3RyaW5nfSBKV0suS2V5I2FsZ1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIHNvbGUgYWxnb3JpdGhtIHRoaXMga2V5IGNhbiBiZSB1c2VkIGZvci5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsZ1wiLCB7XG4gICAgdmFsdWU6IGpzb24uYmFzZS5hbGcgfHwgXCJcIixcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIC8vICMjIyBQdWJsaWMgTWV0aG9kcyAjIyNcbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgdGh1bWJwcmludCBvZiB0aGlzIEtleS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtdIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2VcbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgdGh1bWJwcmludCBnZW5lcmF0aW9uLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGh1bWJwcmludFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgIGhhc2ggPSAoaGFzaCB8fCBIRUxQRVJTLklOVEVSTkFMUy5USFVNQlBSSU5UX0hBU0gpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAocHJpbnRzW2hhc2hdKSB7XG4gICAgICAgIC8vIHJldHVybiBjYWNoZWQgdmFsdWVcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcmludHNbaGFzaF0pO1xuICAgICAgfVxuICAgICAgdmFyIHAgPSBIRUxQRVJTLnRodW1icHJpbnQoY2ZnLCBqc29uLCBoYXNoKTtcbiAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBwcmludHNbaGFzaF0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleSNhbGdvcml0aG1zXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgcG9zc2libGUgYWxnb3JpdGhtcyB0aGlzIEtleSBjYW4gYmUgdXNlZCBmb3IuIFRoZSByZXR1cm5lZFxuICAgKiBsaXN0IGlzIG5vdCBhbnkgcGFydGljdWxhciBvcmRlciwgYnV0IGlzIGZpbHRlcmVkIGJhc2VkIG9uIHRoZVxuICAgKiBLZXkncyBpbnRlbmRlZCB1c2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGUgVGhlIG9wZXJhdGlvbiBtb2RlXG4gICAqIEByZXR1cm5zIHtTdHJpbmdbXX0gVGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIGFsZ29yaXRobXNcbiAgICogQHNlZSBKV0suS2V5I3N1cHBvcnRzXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbGdvcml0aG1zXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24obW9kZSkge1xuICAgICAgdmFyIG1vZGVzID0gW107XG4gICAgICBpZiAoIXRoaXMudXNlIHx8IHRoaXMudXNlID09PSBcInNpZ1wiKSB7XG4gICAgICAgIGlmICghbW9kZSB8fCBDT05TVEFOVFMuTU9ERV9TSUdOID09PSBtb2RlKSB7XG4gICAgICAgICAgbW9kZXMucHVzaChDT05TVEFOVFMuTU9ERV9TSUdOKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vZGUgfHwgQ09OU1RBTlRTLk1PREVfVkVSSUZZID09PSBtb2RlKSB7XG4gICAgICAgICAgbW9kZXMucHVzaChDT05TVEFOVFMuTU9ERV9WRVJJRlkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMudXNlIHx8IHRoaXMudXNlID09PSBcImVuY1wiKSB7XG4gICAgICAgIGlmICghbW9kZSB8fCBDT05TVEFOVFMuTU9ERV9FTkNSWVBUID09PSBtb2RlKSB7XG4gICAgICAgICAgbW9kZXMucHVzaChDT05TVEFOVFMuTU9ERV9FTkNSWVBUKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vZGUgfHwgQ09OU1RBTlRTLk1PREVfREVDUllQVCA9PT0gbW9kZSkge1xuICAgICAgICAgIG1vZGVzLnB1c2goQ09OU1RBTlRTLk1PREVfREVDUllQVCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb2RlIHx8IENPTlNUQU5UUy5NT0RFX1dSQVAgPT09IG1vZGUpIHtcbiAgICAgICAgICBtb2Rlcy5wdXNoKENPTlNUQU5UUy5NT0RFX1dSQVApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9kZSB8fCBDT05TVEFOVFMuTU9ERV9VTldSQVAgPT09IG1vZGUpIHtcbiAgICAgICAgICBtb2Rlcy5wdXNoKENPTlNUQU5UUy5NT0RFX1VOV1JBUCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFsZ3MgPSBtb2Rlcy5tYXAoZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gY2ZnLmFsZ29yaXRobXMuY2FsbChzZWxmLCBrZXlzLCBtKTtcbiAgICAgIH0pO1xuICAgICAgYWxncyA9IGZsYXR0ZW4oYWxncyk7XG4gICAgICBhbGdzID0gdW5pcShhbGdzKTtcbiAgICAgIGlmICh0aGlzLmFsZykge1xuICAgICAgICAvLyBUT0RPOiBmaXggdGhpcyBjb3JyZWN0bHlcbiAgICAgICAgdmFyIHZhbGlkO1xuICAgICAgICBpZiAoXCJvY3RcIiA9PT0ga3R5KSB7XG4gICAgICAgICAgdmFsaWQgPSBbdGhpcy5hbGcsIFwiZGlyXCJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkID0gW3RoaXMuYWxnXTtcbiAgICAgICAgfVxuICAgICAgICBhbGdzID0gaW50ZXJzZWN0aW9uKGFsZ3MsIHZhbGlkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsZ3M7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleSNzdXBwb3J0c1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gYWxnb3JpdGhtIGlzIHN1cHBvcnRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsZyBUaGUgYWxnb3JpdGhtIGluIHF1ZXN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbW9kZV0gVGhlIG9wZXJhdGlvbiBtb2RlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYge2FsZ30gaXMgc3VwcG9ydGVkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEBzZWUgSldLLktleSNhbGdvcml0aG1zXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdXBwb3J0c1wiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGFsZywgbW9kZSkge1xuICAgICAgcmV0dXJuICh0aGlzLmFsZ29yaXRobXMobW9kZSkuaW5kZXhPZihhbGcpICE9PSAtMSk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleSNoYXNcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERldGVybWluZXMgaWYgdGhpcyBLZXkgY29udGFpbnMgdGhlIGdpdmVuIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1ByaXZhdGU9ZmFsc2VdIGB0cnVlYCBpZiBwcml2YXRlIHBhcmFtZXRlcnMgc2hvdWxkIGJlXG4gICAqICAgICAgICBjaGVja2VkLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgaXMgcHJlc2VudDsgYGZhbHNlYFxuICAgKiAgICAgICAgICBvdGhlcndpc2UuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYXNcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihuYW1lLCBpc1ByaXZhdGUpIHtcbiAgICAgIHZhciBjb250YWlucyA9IGZhbHNlO1xuICAgICAgY29udGFpbnMgPSBjb250YWlucyB8fCAhIShqc29uLmJhc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5hbWUgaW4ganNvbi5iYXNlKSk7XG4gICAgICBjb250YWlucyA9IGNvbnRhaW5zIHx8ICEhKGtleXMucHVibGljICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lIGluIGtleXMucHVibGljKSk7XG4gICAgICBjb250YWlucyA9IGNvbnRhaW5zIHx8ICEhKGpzb24uZXh0cmEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5hbWUgaW4ganNvbi5leHRyYSkpO1xuICAgICAgY29udGFpbnMgPSBjb250YWlucyB8fCAhIShpc1ByaXZhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wcml2YXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lIGluIGtleXMucHJpdmF0ZSkpO1xuICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIGV4cG9ydCByZXN0cmljdGlvbnNcblxuICAgICAgcmV0dXJuIGNvbnRhaW5zO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXkjZ2V0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBwYXJhbWV0ZXIuIFRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGlzXG4gICAqIG1ldGhvZCBpcyBpbiBpdHMgbmF0dXJhbCBmb3JtYXQsIHdoaWNoIG1pZ2h0IG5vdCBleGFjdGx5IG1hdGNoIGl0c1xuICAgKiBKU09OIGVuY29kaW5nIChlLmcuLCBhIGJpbmFyeSBzdHJpbmcgcmF0aGVyIHRoYW4gYSBiYXNlNjR1cmwtZW5jb2RlZFxuICAgKiBzdHJpbmcpLlxuICAgKlxuICAgKiAqKk5PVEU6KiogVGhpcyBtZXRob2QgY2FuIHJldHVybiBgZmFsc2VgLiBDYWxsXG4gICAqIHtAbGluayBKV0suS2V5I2hhc30gdG8gZGV0ZXJtaW5lIGlmIHRoZSBwYXJhbWV0ZXIgaXMgcHJlc2VudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1ByaXZhdGU9ZmFsc2VdIGB0cnVlYCBpZiBwcml2YXRlIHBhcmFtZXRlcnMgc2hvdWxkXG4gICAqICAgICAgICBiZSBjaGVja2VkLlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgdmFsdWUgb2YgdGhlIG5hbWVkIHBhcmFtZXRlciwgb3IgdW5kZWZpbmVkIGlmXG4gICAqICAgICAgICAgIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0XCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24obmFtZSwgaXNQcml2YXRlKSB7XG4gICAgICB2YXIgc3JjO1xuICAgICAgaWYgKGpzb24uYmFzZSAmJiAobmFtZSBpbiBqc29uLmJhc2UpKSB7XG4gICAgICAgIHNyYyA9IGpzb24uYmFzZTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5cy5wdWJsaWMgJiYgKG5hbWUgaW4ga2V5cy5wdWJsaWMpKSB7XG4gICAgICAgIHNyYyA9IGtleXMucHVibGljO1xuICAgICAgfSBlbHNlIGlmIChqc29uLmV4dHJhICYmIChuYW1lIGluIGpzb24uZXh0cmEpKSB7XG4gICAgICAgIHNyYyA9IGpzb24uZXh0cmE7XG4gICAgICB9IGVsc2UgaWYgKGlzUHJpdmF0ZSAmJiBrZXlzLnByaXZhdGUgJiYgKG5hbWUgaW4ga2V5cy5wcml2YXRlKSkge1xuICAgICAgICAvLyBUT0RPOiBjaGVjayBmb3IgZXhwb3J0IHJlc3RyaWN0aW9uc1xuICAgICAgICBzcmMgPSBrZXlzLnByaXZhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzcmMgJiYgc3JjW25hbWVdIHx8IG51bGw7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleSN0b0pTT05cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHVybnMgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBLZXkuICBBbGwgcHJvcGVydGllcyBvZiB0aGVcbiAgICogcmV0dXJuZWQgSlNPTiBvYmplY3QgYXJlIHByb3Blcmx5IGVuY29kZWQgKGUuZy4sIGJhc2U2NHVybCBlbmNvZGluZyBmb3JcbiAgICogYW55IGJpbmFyeSBzdHJpbmdzKS5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNQcml2YXRlPWZhbHNlXSBgdHJ1ZWAgaWYgcHJpdmF0ZSBwYXJhbWV0ZXJzIHNob3VsZCBiZVxuICAgKiAgICAgICAgaW5jbHVkZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IFtleGNsdWRlZF0gVGhlIGxpc3Qgb2YgcGFyYW1ldGVycyB0byBleGNsdWRlIGZyb21cbiAgICogICAgICAgIHRoZSByZXR1cm5lZCBKU09OLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGxhaW4gSlNPTiBvYmplY3RcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvSlNPTlwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGlzUHJpdmF0ZSwgZXhjbHVkZWQpIHtcbiAgICAgIC8vIGNvZXJjZSBhcmd1bWVudHNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlzUHJpdmF0ZSkpIHtcbiAgICAgICAgZXhjbHVkZWQgPSBpc1ByaXZhdGU7XG4gICAgICAgIGlzUHJpdmF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAvLyBUT0RPOiBjaGVjayBmb3IgZXhwb3J0IHJlc3RyaWN0aW9uc1xuICAgICAgcmVzdWx0ID0gbWVyZ2UocmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICBqc29uLmJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgIGpzb24ucHVibGljLFxuICAgICAgICAgICAgICAgICAgICAgICAoXCJib29sZWFuXCIgPT09IHR5cGVvZiBpc1ByaXZhdGUgJiYgaXNQcml2YXRlKSA/IGpzb24ucHJpdmF0ZSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICBqc29uLmV4dHJhKTtcbiAgICAgIHJlc3VsdCA9IG9taXQocmVzdWx0LCBleGNsdWRlZCB8fCBbXSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5I3RvUEVNXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXR1cm5zIHRoZSBQRU0gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBLZXkgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzUHJpdmF0ZT1mYWxzZV0gYHRydWVgIGlmIHByaXZhdGUgcGFyYW1ldGVycyBzaG91bGQgYmVcbiAgICogICAgICAgIGluY2x1ZGVkLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgUEVNLWVuY29kZWQgc3RyaW5nXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b1BFTVwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGlzUHJpdmF0ZSkge1xuICAgICAgaWYgKGlzUHJpdmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICBpc1ByaXZhdGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjZmcuY29udmVydFRvUEVNKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGtleSB0eXBlIGZvciBQRU0gZW5jb2RpbmdcIik7XG4gICAgICB9XG4gICAgICB2YXIgayA9IChpc1ByaXZhdGUpID8ga2V5cy5wcml2YXRlIDoga2V5cy5wdWJsaWM7XG4gICAgICBpZiAoIWspIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXlcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2ZnLmNvbnZlcnRUb1BFTS5jYWxsKHRoaXMsIGssIGlzUHJpdmF0ZSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5I3RvT2JqZWN0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXR1cm5zIHRoZSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoaXMgS2V5LiAgQWxsIHByb3BlcnRpZXMgb2YgdGhlXG4gICAqIHJldHVybmVkIG9iamVjdCBhcmUgaW4gdGhlaXIgbmF0dXJhbCBlbmNvZGluZyAoZS5nLiwgYmluYXJ5IHN0cmluZ3NcbiAgICogaW5zdGVhZCBvZiBiYXNlNjR1cmwgZW5jb2RlZCkuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzUHJpdmF0ZT1mYWxzZV0gYHRydWVgIGlmIHByaXZhdGUgcGFyYW1ldGVycyBzaG91bGQgYmVcbiAgICogICAgICAgIGluY2x1ZGVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBbZXhjbHVkZWRdIFRoZSBsaXN0IG9mIHBhcmFtZXRlcnMgdG8gZXhjbHVkZSBmcm9tXG4gICAqICAgICAgICB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGxhaW4gT2JqZWN0LlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9PYmplY3RcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihpc1ByaXZhdGUsIGV4Y2x1ZGVkKSB7XG4gICAgICAvLyBjb2VyY2UgYXJndW1lbnRzXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpc1ByaXZhdGUpKSB7XG4gICAgICAgIGV4Y2x1ZGVkID0gaXNQcml2YXRlO1xuICAgICAgICBpc1ByaXZhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIGV4cG9ydCByZXN0cmljdGlvbnNcbiAgICAgIHJlc3VsdCA9IG1lcmdlKHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAganNvbi5iYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnB1YmxpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgKFwiYm9vbGVhblwiID09PSB0eXBlb2YgaXNQcml2YXRlICYmIGlzUHJpdmF0ZSkgPyBrZXlzLnByaXZhdGUgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAganNvbi5leHRyYSk7XG4gICAgICByZXN1bHQgPSBvbWl0KHJlc3VsdCwgKGV4Y2x1ZGVkIHx8IFtdKS5jb25jYXQoXCJsZW5ndGhcIikpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleSNzaWduXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTaWduIHRoZSBnaXZlbiBkYXRhIHVzaW5nIHRoZSBzcGVjaWZpZWQgYWxnb3JpdGhtLlxuICAgKlxuICAgKiAqKk5PVEU6KiogVGhpcyBpcyB0aGUgcHJpbWl0aXZlIHNpZ25pbmcgb3BlcmF0aW9uOyB0aGUgb3V0cHV0IGlzXG4gICAqIF8qKk5PVCoqXyBhIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKSBvYmplY3QuXG4gICAqXG4gICAqIFRoZSBQcm9taXNlLCB3aGVuIGZ1bGZpbGxlZCwgcmV0dXJucyBhbiBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICsgKipkYXRhKio6IFRoZSBkYXRhIHRoYXQgd2FzIHNpZ25lZCAoYW5kIHNob3VsZCBiZSBlcXVhbCB0byB7ZGF0YX0pLlxuICAgKiArICoqbWFjKio6IFRoZSBzaWduYXR1cmUgb3IgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlIChNQUMpLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWxnIFRoZSBzaWduaW5nIGFsZ29yaXRobVxuICAgKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgdG8gc2lnblxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXMgZm9yIHRoZSBzaWduaW5nXG4gICAqICAgICAgICBhbGdvcml0aG0uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHNpZ25pbmcgb3BlcmF0aW9uLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYge2FsZ30gaXMgbm90IGFwcHJvcHJpYXRlIGZvciB0aGlzIEtleTsgb3IgaWZcbiAgICogICAgICAgICB0aGlzIEtleSBkb2VzIG5vdCBjb250YWluIHRoZSBhcHByb3ByaWF0ZSBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2lnblwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGFsZywgZGF0YSwgcHJvcHMpIHtcbiAgICAgIC8vIHZhbGlkYXRlIGFwcHJvcHJpYXRlbmVzc1xuICAgICAgaWYgKHRoaXMuYWxnb3JpdGhtcyhcInNpZ25cIikuaW5kZXhPZihhbGcpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtXCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciBrID0gY2ZnLnNpZ25LZXkuY2FsbCh0aGlzLCBhbGcsIGtleXMpO1xuICAgICAgaWYgKCFrKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbXByb3BlciBrZXlcIikpO1xuICAgICAgfVxuXG4gICAgICAvLyBwcmVwYXJlIHByb3BlcnRpZXMgKGlmIGFueSlcbiAgICAgIHByb3BzID0gKHByb3BzKSA/XG4gICAgICAgICAgICAgIGNsb25lKHByb3BzKSA6XG4gICAgICAgICAgICAgIHt9O1xuICAgICAgaWYgKGNmZy5zaWduUHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBtZXJnZShwcm9wcywgY2ZnLnNpZ25Qcm9wcy5jYWxsKHRoaXMsIGFsZywgcHJvcHMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBTEdPUklUSE1TLnNpZ24oYWxnLCBrLCBkYXRhLCBwcm9wcyk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleSN2ZXJpZnlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFZlcmlmeSB0aGUgZ2l2ZW4gZGF0YSBhbmQgc2lnbmF0dXJlIHVzaW5nIHRoZSBzcGVjaWZpZWQgYWxnb3JpdGhtLlxuICAgKlxuICAgKiAqKk5PVEU6KiogVGhpcyBpcyB0aGUgcHJpbWl0aXZlIHZlcmlmaWNhdGlvbiBvcGVyYXRpb247IHRoZSBpbnB1dCBpc1xuICAgKiBfKipOT1QqKl8gYSBKU09OIFdlYiBTaWduYXR1cmUuPC9wPlxuICAgKlxuICAgKiBUaGUgUHJvbWlzZSwgd2hlbiBmdWxmaWxsZWQsIHJldHVybnMgYW4gT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiArICoqZGF0YSoqOiBUaGUgZGF0YSB0aGF0IHdhcyB2ZXJpZmllZCAoYW5kIHNob3VsZCBiZSBlcXVhbCB0b1xuICAgKiAgIHtkYXRhfSkuXG4gICAqICsgKiptYWMqKjogVGhlIHNpZ25hdHVyZSBvciBNQUMgdGhhdCB3YXMgdmVyaWZpZWQgKGFuZCBzaG91bGQgYmUgZXF1YWxcbiAgICogICB0byB7bWFjfSkuXG4gICAqICsgKip2YWxpZCoqOiBgdHJ1ZWAgaWYge21hY30gaXMgdmFsaWQgZm9yIHtkYXRhfS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsZyBUaGUgdmVyaWZpY2F0aW9uIGFsZ29yaXRobVxuICAgKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgdG8gdmVyaWZ5XG4gICAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gbWFjIFRoZSBzaWduYXR1cmUgb3IgTUFDIHRvIHZlcmlmeVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXMgZm9yIHRoZSB2ZXJpZmljYXRpb25cbiAgICogICAgICAgIGFsZ29yaXRobS5cbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgdmVyaWZpY2F0aW9uIG9wZXJhdGlvbi5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHthbGd9IGlzIG5vdCBhcHByb3ByaWF0ZSBmb3IgdGhpcyBLZXk7IG9yIGlmXG4gICAqICAgICAgICAgdGhlIEtleSBkb2VzIG5vdCBjb250YWluIHRoZSBhcHByb3ByaWF0ZSBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyaWZ5XCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oYWxnLCBkYXRhLCBtYWMsIHByb3BzKSB7XG4gICAgICAvLyB2YWxpZGF0ZSBhcHByb3ByaWF0ZW5lc3NcbiAgICAgIGlmICh0aGlzLmFsZ29yaXRobXMoXCJ2ZXJpZnlcIikuaW5kZXhPZihhbGcpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtXCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciBrID0gY2ZnLnZlcmlmeUtleS5jYWxsKHRoaXMsIGFsZywga2V5cyk7XG4gICAgICBpZiAoIWspIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImltcHJvcGVyIGtleVwiKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXBhcmUgcHJvcGVydGllcyAoaWYgYW55KVxuICAgICAgcHJvcHMgPSAocHJvcHMpID9cbiAgICAgICAgICAgICAgY2xvbmUocHJvcHMpIDpcbiAgICAgICAgICAgICAge307XG4gICAgICBpZiAoY2ZnLnZlcmlmeVByb3BzKSB7XG4gICAgICAgIHByb3BzID0gbWVyZ2UocHJvcHMsIGNmZy52ZXJpZnlQcm9wcy5jYWxsKHRoaXMsIGFsZywgcHJvcHMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBTEdPUklUSE1TLnZlcmlmeShhbGcsIGssIGRhdGEsIG1hYywgcHJvcHMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleSNlbmNyeXB0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBFbmNyeXB0cyB0aGUgZ2l2ZW4gZGF0YSB1c2luZyB0aGUgc3BlY2lmaWVkIGFsZ29yaXRobS5cbiAgICpcbiAgICogKipOT1RFOioqIFRoaXMgaXMgdGhlIHByaW1pdGl2ZSBlbmNyeXB0aW9uIG9wZXJhdGlvbjsgdGhlIG91dHB1dCBpc1xuICAgKiBfKipOT1QqKl8gYSBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpIG9iamVjdC5cbiAgICpcbiAgICogKipOT1RFOioqIFRoaXMgb3BlcmF0aW9uIGlzIHRyZWF0ZWQgYXMgZGlzdGluY3QgZnJvbSB7QGxpbmtcbiAgICogSldLLktleSN3cmFwfSwgYXMgZGlmZmVyZW50IGFsZ29yaXRobXMgYW5kIHByb3BlcnRpZXMgYXJlIG9mdGVuXG4gICAqIHVzZWQgZm9yIHdyYXBwaW5nIGEga2V5IHZlcnN1ZXMgZW5jcnlwdGluZyBhcmJpdHJhcnkgZGF0YS5cbiAgICpcbiAgICogVGhlIFByb21pc2UsIHdoZW4gZnVsZmlsbGVkLCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogcHJvcGVydGllczpcbiAgICpcbiAgICogKyAqKmRhdGEqKjogVGhlIGNpcGhlcnRleHQgZGF0YVxuICAgKiArICoqbWFjKio6IFRoZSBhc3NvY2lhdGVkIG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZSAoTUFDKS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsZyBUaGUgZW5jcnlwdGlvbiBhbGdvcml0aG1cbiAgICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGVuY3J5cHRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzIGZvciB0aGUgZW5jcnlwdGlvblxuICAgKiAgICAgICAgYWxnb3JpdGhtLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSBlbmNyeXB0aW9uIG9wZXJhdGlvbi5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHthbGd9IGlzIG5vdCBhcHByb3ByaWF0ZSBmb3IgdGhpcyBLZXk7IG9yIGlmXG4gICAqICAgICAgICAgdGhpcyBLZXkgZG9lcyBub3QgY29udGFpbiB0aGUgYXBwcm9wcmlhdGUgcGFyYW1ldGVycy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuY3J5cHRcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihhbGcsIGRhdGEsIHByb3BzKSB7XG4gICAgICAvLyB2YWxpZGF0ZSBhcHByb3ByaWF0ZW5lc3NcbiAgICAgIGlmICh0aGlzLmFsZ29yaXRobXMoXCJlbmNyeXB0XCIpLmluZGV4T2YoYWxnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobVwiKSk7XG4gICAgICB9XG4gICAgICB2YXIgayA9IGNmZy5lbmNyeXB0S2V5LmNhbGwodGhpcywgYWxnLCBrZXlzKTtcbiAgICAgIGlmICghaykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW1wcm9wZXIga2V5XCIpKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJlcGFyZSBwcm9wZXJ0aWVzIChpZiBhbnkpXG4gICAgICBwcm9wcyA9IChwcm9wcykgP1xuICAgICAgICAgICAgICBjbG9uZShwcm9wcykgOlxuICAgICAgICAgICAgICB7fTtcbiAgICAgIGlmIChjZmcuZW5jcnlwdFByb3BzKSB7XG4gICAgICAgIHByb3BzID0gbWVyZ2UocHJvcHMsIGNmZy5lbmNyeXB0UHJvcHMuY2FsbCh0aGlzLCBhbGcsIHByb3BzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQUxHT1JJVEhNUy5lbmNyeXB0KGFsZywgaywgZGF0YSwgcHJvcHMpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXkjZGVjcnlwdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRGVjcnlwdHMgdGhlIGdpdmVuIGRhdGEgdXNpbmcgdGhlIHNwZWNpZmllZCBhbGdvcml0aG0uXG4gICAqXG4gICAqICoqTk9URToqKiBUaGlzIGlzIHRoZSBwcmltaXRpdmUgZGVjcnlwdGlvbiBvcGVyYXRpb247IHRoZSBpbnB1dCBpc1xuICAgKiBfKipOT1QqKl8gYSBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpIG9iamVjdC5cbiAgICpcbiAgICogKipOT1RFOioqIFRoaXMgb3BlcmF0aW9uIGlzIHRyZWF0ZWQgYXMgZGlzdGluY3QgZnJvbSB7QGxpbmtcbiAgICogSldLLktleSN1bndyYXB9LCBhcyBkaWZmZXJlbnQgYWxnb3JpdGhtcyBhbmQgcHJvcGVydGllcyBhcmUgb2Z0ZW4gdXNlZFxuICAgKiBmb3IgdW53cmFwcGluZyBhIGtleSB2ZXJzdWVzIGRlY3J5cHRpbmcgYXJiaXRyYXJ5IGRhdGEuXG4gICAqXG4gICAqIFRoZSBQcm9taXNlLCB3aGVuIGZ1bGZpbGxlZCwgcmV0dXJucyB0aGUgcGxhaW50ZXh0IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGcgVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtLlxuICAgKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gZGVjeXB0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBBZGRpdGlvbmFsIGRhdGEgZm9yIHRoZSBkZWNyeXB0aW9uIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgZGVjcnlwdGlvbiBvcGVyYXRpb24uXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB7YWxnfSBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIHRoaXMgS2V5OyBvciBpZlxuICAgKiAgICAgICAgIHRoZSBLZXkgZG9lcyBub3QgY29udGFpbiB0aGUgYXBwcm9wcmlhdGUgcHJvcGVydGllcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlY3J5cHRcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihhbGcsIGRhdGEsIHByb3BzKSB7XG4gICAgICAvLyB2YWxpZGF0ZSBhcHByb3ByaWF0ZW5lc3NcbiAgICAgIGlmICh0aGlzLmFsZ29yaXRobXMoXCJkZWNyeXB0XCIpLmluZGV4T2YoYWxnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobVwiKSk7XG4gICAgICB9XG4gICAgICB2YXIgayA9IGNmZy5kZWNyeXB0S2V5LmNhbGwodGhpcywgYWxnLCBrZXlzKTtcbiAgICAgIGlmICghaykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW1wcm9wZXIga2V5XCIpKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJlcGFyZSBwcm9wZXJ0aWVzIChpZiBhbnkpXG4gICAgICBwcm9wcyA9IChwcm9wcykgP1xuICAgICAgICAgICAgICBjbG9uZShwcm9wcykgOlxuICAgICAgICAgICAgICB7fTtcbiAgICAgIGlmIChjZmcuZGVjcnlwdFByb3BzKSB7XG4gICAgICAgIHByb3BzID0gbWVyZ2UocHJvcHMsIGNmZy5kZWNyeXB0UHJvcHMuY2FsbCh0aGlzLCBhbGcsIHByb3BzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQUxHT1JJVEhNUy5kZWNyeXB0KGFsZywgaywgZGF0YSwgcHJvcHMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleSN3cmFwXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBXcmFwcyB0aGUgZ2l2ZW4ga2V5IHVzaW5nIHRoZSBzcGVjaWZpZWQgYWxnb3JpdGhtLlxuICAgKlxuICAgKiAqKk5PVEU6KiogVGhpcyBpcyB0aGUgcHJpbWl0aXZlIGVuY3J5cHRpb24gb3BlcmF0aW9uOyB0aGUgb3V0cHV0IGlzXG4gICAqIF8qKk5PVCoqXyBhIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSkgb2JqZWN0LlxuICAgKlxuICAgKiAqKk5PVEU6KiogVGhpcyBvcGVyYXRpb24gaXMgdHJlYXRlZCBhcyBkaXN0aW5jdCBmcm9tIHtAbGlua1xuICAgKiBKV0suS2V5I2VuY3J5cHR9LCBhcyBkaWZmZXJlbnQgYWxnb3JpdGhtcyBhbmQgcHJvcGVydGllcyBhcmVcbiAgICogb2Z0ZW4gdXNlZCBmb3Igd3JhcHBpbmcgYSBrZXkgdmVyc3VlcyBlbmNyeXB0aW5nIGFyYml0cmFyeSBkYXRhLlxuICAgKlxuICAgKiBUaGUgUHJvbWlzZSwgd2hlbiBmdWxmaWxsZWQsIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiArICoqZGF0YSoqOiBUaGUgY2lwaGVydGV4dCBkYXRhXG4gICAqICsgKipoZWFkZXJzKio6IFRoZSBhZGRpdGlvbmFsIGhlYWRlciBwYXJhbWV0ZXJzIHRvIGFwcGx5IHRvIGEgSldFLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWxnIFRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobVxuICAgKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gZW5jcnlwdFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXMgZm9yIHRoZSBlbmNyeXB0aW9uXG4gICAqICAgICAgICBhbGdvcml0aG0uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIGVuY3J5cHRpb24gb3BlcmF0aW9uLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYge2FsZ30gaXMgbm90IGFwcHJvcHJpYXRlIGZvciB0aGlzIEtleTsgb3IgaWZcbiAgICogICAgICAgICB0aGlzIEtleSBkb2VzIG5vdCBjb250YWluIHRoZSBhcHByb3ByaWF0ZSBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid3JhcFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGFsZywgZGF0YSwgcHJvcHMpIHtcbiAgICAgIC8vIHZhbGlkYXRlIGFwcHJvcHJpYXRlbmVzc1xuICAgICAgaWYgKHRoaXMuYWxnb3JpdGhtcyhcIndyYXBcIikuaW5kZXhPZihhbGcpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtXCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciBrID0gY2ZnLndyYXBLZXkuY2FsbCh0aGlzLCBhbGcsIGtleXMpO1xuICAgICAgaWYgKCFrKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbXByb3BlciBrZXlcIikpO1xuICAgICAgfVxuXG4gICAgICAvLyBwcmVwYXJlIHByb3BlcnRpZXMgKGlmIGFueSlcbiAgICAgIHByb3BzID0gKHByb3BzKSA/XG4gICAgICAgICAgICAgIGNsb25lKHByb3BzKSA6XG4gICAgICAgICAgICAgIHt9O1xuICAgICAgaWYgKGNmZy53cmFwUHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBtZXJnZShwcm9wcywgY2ZnLndyYXBQcm9wcy5jYWxsKHRoaXMsIGFsZywgcHJvcHMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBTEdPUklUSE1TLmVuY3J5cHQoYWxnLCBrLCBkYXRhLCBwcm9wcyk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleSN1bndyYXBcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFVud3JhcHMgdGhlIGdpdmVuIGtleSB1c2luZyB0aGUgc3BlY2lmaWVkIGFsZ29yaXRobS5cbiAgICpcbiAgICogKipOT1RFOioqIFRoaXMgaXMgdGhlIHByaW1pdGl2ZSB1bndyYXAgb3BlcmF0aW9uOyB0aGUgaW5wdXQgaXNcbiAgICogXyoqTk9UKipfIGEgSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKSBvYmplY3QuXG4gICAqXG4gICAqICoqTk9URToqKiBUaGlzIG9wZXJhdGlvbiBpcyB0cmVhdGVkIGFzIGRpc3RpbmN0IGZyb20ge0BsaW5rXG4gICAqIEpXSy5LZXkjZGVjcnlwdH0sIGFzIGRpZmZlcmVudCBhbGdvcml0aG1zIGFuZCBwcm9wZXJ0aWVzIGFyZSBvZnRlbiB1c2VkXG4gICAqIGZvciB1bndyYXBwaW5nIGEga2V5IHZlcnN1ZXMgZGVjcnlwdGluZyBhcmJpdHJhcnkgZGF0YS5cbiAgICpcbiAgICogVGhlIFByb21pc2UsIHdoZW4gZnVsZmlsbGVkLCByZXR1cm5zIHRoZSB1bndyYXBwZWQga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWxnIFRoZSB1bndyYXAgYWxnb3JpdGhtLlxuICAgKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gdW53cmFwLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBBZGRpdGlvbmFsIGRhdGEgZm9yIHRoZSB1bndyYXAgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSB1bndyYXAgb3BlcmF0aW9uLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYge2FsZ30gaXMgbm90IGFwcHJvcHJpYXRlIGZvciB0aGlzIEtleTsgb3IgaWZcbiAgICogICAgICAgICB0aGUgS2V5IGRvZXMgbm90IGNvbnRhaW4gdGhlIGFwcHJvcHJpYXRlIHByb3BlcnRpZXMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1bndyYXBcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihhbGcsIGRhdGEsIHByb3BzKSB7XG4gICAgICAvLyB2YWxpZGF0ZSBhcHByb3ByaWF0ZW5lc3NcbiAgICAgIGlmICh0aGlzLmFsZ29yaXRobXMoXCJ1bndyYXBcIikuaW5kZXhPZihhbGcpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtXCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciBrID0gY2ZnLnVud3JhcEtleS5jYWxsKHRoaXMsIGFsZywga2V5cyk7XG4gICAgICBpZiAoIWspIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImltcHJvcGVyIGtleVwiKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXBhcmUgcHJvcGVydGllcyAoaWYgYW55KVxuICAgICAgcHJvcHMgPSAocHJvcHMpID9cbiAgICAgICAgICAgICAgY2xvbmUocHJvcHMpIDpcbiAgICAgICAgICAgICAge307XG4gICAgICBpZiAoY2ZnLnVud3JhcFByb3BzKSB7XG4gICAgICAgIHByb3BzID0gbWVyZ2UocHJvcHMsIGNmZy51bndyYXBQcm9wcy5jYWxsKHRoaXMsIGFsZywgcHJvcHMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBTEdPUklUSE1TLmRlY3J5cHQoYWxnLCBrLCBkYXRhLCBwcm9wcyk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSldLQmFzZUtleU9iamVjdDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/constants.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/*!\n * jwk/constants.js - Constants for JWKs\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nmodule.exports = {\n  MODE_SIGN: \"sign\",\n  MODE_VERIFY: \"verify\",\n  MODE_ENCRYPT: \"encrypt\",\n  MODE_DECRYPT: \"decrypt\",\n  MODE_WRAP: \"wrap\",\n  MODE_UNWRAP: \"unwrap\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd2svY29uc3RhbnRzLmpzIC0gQ29uc3RhbnRzIGZvciBKV0tzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNT0RFX1NJR046IFwic2lnblwiLFxuICBNT0RFX1ZFUklGWTogXCJ2ZXJpZnlcIixcbiAgTU9ERV9FTkNSWVBUOiBcImVuY3J5cHRcIixcbiAgTU9ERV9ERUNSWVBUOiBcImRlY3J5cHRcIixcbiAgTU9ERV9XUkFQOiBcIndyYXBcIixcbiAgTU9ERV9VTldSQVA6IFwidW53cmFwXCJcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/eckey.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/eckey.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/rsa.js - RSA Key Representation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar ecutil = __webpack_require__(/*! ../algorithms/ec-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js\"),\n    forge = __webpack_require__(/*! ../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    depsecc = __webpack_require__(/*! ../deps/ecc */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/index.js\");\n\nvar JWK = {\n  BaseKey: __webpack_require__(/*! ./basekey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\"),\n  helpers: __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\")\n};\n\nvar SIG_ALGS = [\n  \"ES256\",\n  \"ES384\",\n  \"ES512\"\n];\nvar WRAP_ALGS = [\n  \"ECDH-ES\",\n  \"ECDH-ES+A128KW\",\n  \"ECDH-ES+A192KW\",\n  \"ECDH-ES+A256KW\"\n];\n\nvar EC_OID = ecutil.EC_OID;\nfunction oidToCurveName(oid) {\n  switch (oid) {\n    case \"1.2.840.10045.3.1.7\":\n      return \"P-256\";\n    case \"1.3.132.0.34\":\n      return \"P-384\";\n    case \"1.3.132.0.35\":\n      return \"P-521\";\n    default:\n      return null;\n  }\n}\n\nvar JWKEcCfg = {\n  publicKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"crv\", type: \"string\"},\n      {name: \"x\", type: \"binary\"},\n      {name: \"y\", type: \"binary\"}\n    ]);\n    var pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.crv && pk.x && pk.y) {\n      pk.length = ecutil.curveSize(pk.crv);\n    } else {\n      delete pk.crv;\n      delete pk.x;\n      delete pk.y;\n    }\n\n    return pk;\n  },\n  privateKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"crv\", type: \"string\"},\n      {name: \"x\", type: \"binary\"},\n      {name: \"y\", type: \"binary\"},\n      {name: \"d\", type: \"binary\"}\n    ]);\n    var pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.crv && pk.x && pk.y && pk.d) {\n      pk.length = ecutil.curveSize(pk.crv);\n    } else {\n      pk = undefined;\n    }\n\n    return pk;\n  },\n  thumbprint: function(json) {\n    if (json.public) {\n      json = json.public;\n    }\n    var fields = {\n      crv: json.crv,\n      kty: \"EC\",\n      x: json.x,\n      y: json.y\n    };\n    return fields;\n  },\n  algorithms: function(keys, mode) {\n    var len = (keys.public && keys.public.length) ||\n              (keys.private && keys.private.length) ||\n              0;\n    // NOTE: 521 is the actual, but 512 is the expected\n    if (len === 521) {\n        len = 512;\n    }\n\n    switch (mode) {\n      case \"encrypt\":\n      case \"decrypt\":\n        return [];\n      case \"wrap\":\n        return (keys.public && WRAP_ALGS) || [];\n      case \"unwrap\":\n        return (keys.private && WRAP_ALGS) || [];\n      case \"sign\":\n        if (!keys.private) {\n          return [];\n        }\n        return SIG_ALGS.filter(function(a) {\n          return (a === (\"ES\" + len));\n        });\n      case \"verify\":\n        if (!keys.public) {\n          return [];\n        }\n        return SIG_ALGS.filter(function(a) {\n          return (a === (\"ES\" + len));\n        });\n    }\n  },\n\n  encryptKey: function(alg, keys) {\n    return keys.public;\n  },\n  decryptKey: function(alg, keys) {\n    return keys.private;\n  },\n\n  wrapKey: function(alg, keys) {\n    return keys.public;\n  },\n  unwrapKey: function(alg, keys) {\n    return keys.private;\n  },\n\n  signKey: function(alg, keys) {\n    return keys.private;\n  },\n  verifyKey: function(alg, keys) {\n    return keys.public;\n  }\n};\nJWKEcCfg.convertToPEM = ecutil.convertToPEM;\n\n// Inspired by digitalbaazar/node-forge/js/rsa.js\nvar validators = {\n  oid: EC_OID,\n  privateKey: {\n    // ECPrivateKey\n    name: \"ECPrivateKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n      {\n        // EC version\n        name: \"ECPrivateKey.version\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false\n      },\n      {\n        // private value (d)\n        name: \"ECPrivateKey.private\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: \"d\"\n      },\n      {\n        // EC parameters\n        tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n        name: \"ECPrivateKey.parameters\",\n        constructed: true,\n        value: [\n          {\n            // namedCurve (crv)\n            name: \"ECPrivateKey.namedCurve\",\n            tagClass: forge.asn1.Class.UNIVERSAL,\n            type: forge.asn1.Type.OID,\n            constructed: false,\n            capture: \"crv\"\n          }\n        ]\n      },\n      {\n        // publicKey\n        name: \"ECPrivateKey.publicKey\",\n        tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n        constructed: true,\n        value: [\n          {\n            name: \"ECPrivateKey.point\",\n            tagClass: forge.asn1.Class.UNIVERSAL,\n            type: forge.asn1.Type.BITSTRING,\n            constructed: false,\n            capture: \"point\"\n          }\n        ]\n      }\n    ]\n  },\n  embeddedPrivateKey: {\n    // ECPrivateKey\n    name: \"ECPrivateKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n      {\n        // EC version\n        name: \"ECPrivateKey.version\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false\n      },\n      {\n        // private value (d)\n        name: \"ECPrivateKey.private\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: \"d\"\n      },\n      {\n        // publicKey\n        name: \"ECPrivateKey.publicKey\",\n        tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n        constructed: true,\n        value: [\n          {\n            name: \"ECPrivateKey.point\",\n            tagClass: forge.asn1.Class.UNIVERSAL,\n            type: forge.asn1.Type.BITSTRING,\n            constructed: false,\n            capture: \"point\"\n          }\n        ]\n      }\n    ]\n  }\n};\n\nvar JWKEcFactory = {\n  kty: \"EC\",\n  validators: validators,\n  prepare: function(props) {\n    // TODO: validate key properties\n    var cfg = JWKEcCfg;\n    var p = Promise.resolve(props);\n    p = p.then(function(json) {\n      return JWK.helpers.thumbprint(cfg, json);\n    });\n    p = p.then(function(hash) {\n      var prints = {};\n      prints[JWK.helpers.INTERNALS.THUMBPRINT_HASH] = hash;\n      props[JWK.helpers.INTERNALS.THUMBPRINT_KEY] = prints;\n      return cfg;\n    });\n    return p;\n  },\n  generate: function(size) {\n    var keypair = depsecc.generateKeyPair(size);\n    var result = {\n      \"crv\": size,\n      \"x\": keypair.public.x,\n      \"y\": keypair.public.y,\n      \"d\": keypair.private.d\n    };\n    return Promise.resolve(result);\n  },\n  import: function(input) {\n    if (validators.oid !== input.keyOid) {\n      return null;\n    }\n\n    // coerce key params to OID\n    var crv;\n    if (input.keyParams && forge.asn1.Type.OID === input.keyParams.type) {\n      crv = forge.asn1.derToOid(input.keyParams.value);\n      crv = oidToCurveName(crv);\n    } else if (input.crv) {\n      crv = forge.asn1.derToOid(input.crv);\n      crv = oidToCurveName(crv);\n    }\n    if (!crv) {\n      return null;\n    }\n\n    if (!input.parsed) {\n      var capture = {},\n          errors = [];\n      if (\"private\" === input.type) {\n        // coerce capture.value to DER *iff* private\n        if (\"string\" === typeof input.keyValue) {\n          input.keyValue = forge.asn1.fromDer(input.keyValue);\n        } else if (Array.isArray(input.keyValue)) {\n          input.keyValue = input.keyValue[0];\n        }\n\n        if (!forge.asn1.validate(input.keyValue,\n                                 validators.embeddedPrivateKey,\n                                 capture,\n                                 errors)) {\n          return null;\n        }\n      } else {\n        capture.point = input.keyValue;\n      }\n      input = capture;\n    }\n\n    // convert factors to Buffers\n    var output = {\n      kty: \"EC\",\n      crv: crv\n    };\n    if (input.d) {\n      output.d = Buffer.from(input.d, \"binary\");\n    }\n    if (input.point) {\n      var pt = Buffer.from(input.point, \"binary\");\n      // only support uncompressed\n      if (4 !== pt.readUInt16BE(0)) {\n        return null;\n      }\n      pt = pt.slice(2);\n      var len = pt.length / 2;\n      output.x = pt.slice(0, len);\n      output.y = pt.slice(len);\n    }\n    return output;\n  }\n};\n// public API\nmodule.exports = Object.freeze({\n  config: JWKEcCfg,\n  factory: JWKEcFactory\n});\n\n// registration\n(function(REGISTRY) {\n  REGISTRY.register(JWKEcFactory);\n})((__webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\").registry));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svZWNrZXkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGFBQWEsbUJBQU8sQ0FBQywwRkFBMEI7QUFDL0MsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyx5RUFBYTs7QUFFbkM7QUFDQSxXQUFXLG1CQUFPLENBQUMsdUVBQWM7QUFDakMsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyw0QkFBNEI7QUFDbkMsT0FBTywwQkFBMEI7QUFDakMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxPQUFPLDRCQUE0QjtBQUNuQyxPQUFPLDBCQUEwQjtBQUNqQyxPQUFPLDBCQUEwQjtBQUNqQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsc0dBQThCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9lY2tleS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3ay9yc2EuanMgLSBSU0EgS2V5IFJlcHJlc2VudGF0aW9uXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlY3V0aWwgPSByZXF1aXJlKFwiLi4vYWxnb3JpdGhtcy9lYy11dGlsLmpzXCIpLFxuICAgIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2VcIiksXG4gICAgZGVwc2VjYyA9IHJlcXVpcmUoXCIuLi9kZXBzL2VjY1wiKTtcblxudmFyIEpXSyA9IHtcbiAgQmFzZUtleTogcmVxdWlyZShcIi4vYmFzZWtleS5qc1wiKSxcbiAgaGVscGVyczogcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKVxufTtcblxudmFyIFNJR19BTEdTID0gW1xuICBcIkVTMjU2XCIsXG4gIFwiRVMzODRcIixcbiAgXCJFUzUxMlwiXG5dO1xudmFyIFdSQVBfQUxHUyA9IFtcbiAgXCJFQ0RILUVTXCIsXG4gIFwiRUNESC1FUytBMTI4S1dcIixcbiAgXCJFQ0RILUVTK0ExOTJLV1wiLFxuICBcIkVDREgtRVMrQTI1NktXXCJcbl07XG5cbnZhciBFQ19PSUQgPSBlY3V0aWwuRUNfT0lEO1xuZnVuY3Rpb24gb2lkVG9DdXJ2ZU5hbWUob2lkKSB7XG4gIHN3aXRjaCAob2lkKSB7XG4gICAgY2FzZSBcIjEuMi44NDAuMTAwNDUuMy4xLjdcIjpcbiAgICAgIHJldHVybiBcIlAtMjU2XCI7XG4gICAgY2FzZSBcIjEuMy4xMzIuMC4zNFwiOlxuICAgICAgcmV0dXJuIFwiUC0zODRcIjtcbiAgICBjYXNlIFwiMS4zLjEzMi4wLjM1XCI6XG4gICAgICByZXR1cm4gXCJQLTUyMVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG52YXIgSldLRWNDZmcgPSB7XG4gIHB1YmxpY0tleTogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICB2YXIgZmllbGRzID0gSldLLmhlbHBlcnMuQ09NTU9OX1BST1BTLmNvbmNhdChbXG4gICAgICB7bmFtZTogXCJjcnZcIiwgdHlwZTogXCJzdHJpbmdcIn0sXG4gICAgICB7bmFtZTogXCJ4XCIsIHR5cGU6IFwiYmluYXJ5XCJ9LFxuICAgICAge25hbWU6IFwieVwiLCB0eXBlOiBcImJpbmFyeVwifVxuICAgIF0pO1xuICAgIHZhciBwayA9IEpXSy5oZWxwZXJzLnVucGFja1Byb3BzKHByb3BzLCBmaWVsZHMpO1xuICAgIGlmIChwayAmJiBway5jcnYgJiYgcGsueCAmJiBway55KSB7XG4gICAgICBway5sZW5ndGggPSBlY3V0aWwuY3VydmVTaXplKHBrLmNydik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBway5jcnY7XG4gICAgICBkZWxldGUgcGsueDtcbiAgICAgIGRlbGV0ZSBway55O1xuICAgIH1cblxuICAgIHJldHVybiBwaztcbiAgfSxcbiAgcHJpdmF0ZUtleTogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICB2YXIgZmllbGRzID0gSldLLmhlbHBlcnMuQ09NTU9OX1BST1BTLmNvbmNhdChbXG4gICAgICB7bmFtZTogXCJjcnZcIiwgdHlwZTogXCJzdHJpbmdcIn0sXG4gICAgICB7bmFtZTogXCJ4XCIsIHR5cGU6IFwiYmluYXJ5XCJ9LFxuICAgICAge25hbWU6IFwieVwiLCB0eXBlOiBcImJpbmFyeVwifSxcbiAgICAgIHtuYW1lOiBcImRcIiwgdHlwZTogXCJiaW5hcnlcIn1cbiAgICBdKTtcbiAgICB2YXIgcGsgPSBKV0suaGVscGVycy51bnBhY2tQcm9wcyhwcm9wcywgZmllbGRzKTtcbiAgICBpZiAocGsgJiYgcGsuY3J2ICYmIHBrLnggJiYgcGsueSAmJiBway5kKSB7XG4gICAgICBway5sZW5ndGggPSBlY3V0aWwuY3VydmVTaXplKHBrLmNydik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBwaztcbiAgfSxcbiAgdGh1bWJwcmludDogZnVuY3Rpb24oanNvbikge1xuICAgIGlmIChqc29uLnB1YmxpYykge1xuICAgICAganNvbiA9IGpzb24ucHVibGljO1xuICAgIH1cbiAgICB2YXIgZmllbGRzID0ge1xuICAgICAgY3J2OiBqc29uLmNydixcbiAgICAgIGt0eTogXCJFQ1wiLFxuICAgICAgeDoganNvbi54LFxuICAgICAgeToganNvbi55XG4gICAgfTtcbiAgICByZXR1cm4gZmllbGRzO1xuICB9LFxuICBhbGdvcml0aG1zOiBmdW5jdGlvbihrZXlzLCBtb2RlKSB7XG4gICAgdmFyIGxlbiA9IChrZXlzLnB1YmxpYyAmJiBrZXlzLnB1YmxpYy5sZW5ndGgpIHx8XG4gICAgICAgICAgICAgIChrZXlzLnByaXZhdGUgJiYga2V5cy5wcml2YXRlLmxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgMDtcbiAgICAvLyBOT1RFOiA1MjEgaXMgdGhlIGFjdHVhbCwgYnV0IDUxMiBpcyB0aGUgZXhwZWN0ZWRcbiAgICBpZiAobGVuID09PSA1MjEpIHtcbiAgICAgICAgbGVuID0gNTEyO1xuICAgIH1cblxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBcImVuY3J5cHRcIjpcbiAgICAgIGNhc2UgXCJkZWNyeXB0XCI6XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGNhc2UgXCJ3cmFwXCI6XG4gICAgICAgIHJldHVybiAoa2V5cy5wdWJsaWMgJiYgV1JBUF9BTEdTKSB8fCBbXTtcbiAgICAgIGNhc2UgXCJ1bndyYXBcIjpcbiAgICAgICAgcmV0dXJuIChrZXlzLnByaXZhdGUgJiYgV1JBUF9BTEdTKSB8fCBbXTtcbiAgICAgIGNhc2UgXCJzaWduXCI6XG4gICAgICAgIGlmICgha2V5cy5wcml2YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTSUdfQUxHUy5maWx0ZXIoZnVuY3Rpb24oYSkge1xuICAgICAgICAgIHJldHVybiAoYSA9PT0gKFwiRVNcIiArIGxlbikpO1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJ2ZXJpZnlcIjpcbiAgICAgICAgaWYgKCFrZXlzLnB1YmxpYykge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU0lHX0FMR1MuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICByZXR1cm4gKGEgPT09IChcIkVTXCIgKyBsZW4pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIGVuY3J5cHRLZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnB1YmxpYztcbiAgfSxcbiAgZGVjcnlwdEtleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHJpdmF0ZTtcbiAgfSxcblxuICB3cmFwS2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wdWJsaWM7XG4gIH0sXG4gIHVud3JhcEtleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHJpdmF0ZTtcbiAgfSxcblxuICBzaWduS2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wcml2YXRlO1xuICB9LFxuICB2ZXJpZnlLZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnB1YmxpYztcbiAgfVxufTtcbkpXS0VjQ2ZnLmNvbnZlcnRUb1BFTSA9IGVjdXRpbC5jb252ZXJ0VG9QRU07XG5cbi8vIEluc3BpcmVkIGJ5IGRpZ2l0YWxiYWF6YXIvbm9kZS1mb3JnZS9qcy9yc2EuanNcbnZhciB2YWxpZGF0b3JzID0ge1xuICBvaWQ6IEVDX09JRCxcbiAgcHJpdmF0ZUtleToge1xuICAgIC8vIEVDUHJpdmF0ZUtleVxuICAgIG5hbWU6IFwiRUNQcml2YXRlS2V5XCIsXG4gICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW1xuICAgICAge1xuICAgICAgICAvLyBFQyB2ZXJzaW9uXG4gICAgICAgIG5hbWU6IFwiRUNQcml2YXRlS2V5LnZlcnNpb25cIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBwcml2YXRlIHZhbHVlIChkKVxuICAgICAgICBuYW1lOiBcIkVDUHJpdmF0ZUtleS5wcml2YXRlXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBFQyBwYXJhbWV0ZXJzXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgIG5hbWU6IFwiRUNQcml2YXRlS2V5LnBhcmFtZXRlcnNcIixcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gbmFtZWRDdXJ2ZSAoY3J2KVxuICAgICAgICAgICAgbmFtZTogXCJFQ1ByaXZhdGVLZXkubmFtZWRDdXJ2ZVwiLFxuICAgICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNhcHR1cmU6IFwiY3J2XCJcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHB1YmxpY0tleVxuICAgICAgICBuYW1lOiBcIkVDUHJpdmF0ZUtleS5wdWJsaWNLZXlcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJFQ1ByaXZhdGVLZXkucG9pbnRcIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICBjYXB0dXJlOiBcInBvaW50XCJcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIGVtYmVkZGVkUHJpdmF0ZUtleToge1xuICAgIC8vIEVDUHJpdmF0ZUtleVxuICAgIG5hbWU6IFwiRUNQcml2YXRlS2V5XCIsXG4gICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW1xuICAgICAge1xuICAgICAgICAvLyBFQyB2ZXJzaW9uXG4gICAgICAgIG5hbWU6IFwiRUNQcml2YXRlS2V5LnZlcnNpb25cIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBwcml2YXRlIHZhbHVlIChkKVxuICAgICAgICBuYW1lOiBcIkVDUHJpdmF0ZUtleS5wcml2YXRlXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBwdWJsaWNLZXlcbiAgICAgICAgbmFtZTogXCJFQ1ByaXZhdGVLZXkucHVibGljS2V5XCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiRUNQcml2YXRlS2V5LnBvaW50XCIsXG4gICAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY2FwdHVyZTogXCJwb2ludFwiXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9XG59O1xuXG52YXIgSldLRWNGYWN0b3J5ID0ge1xuICBrdHk6IFwiRUNcIixcbiAgdmFsaWRhdG9yczogdmFsaWRhdG9ycyxcbiAgcHJlcGFyZTogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAvLyBUT0RPOiB2YWxpZGF0ZSBrZXkgcHJvcGVydGllc1xuICAgIHZhciBjZmcgPSBKV0tFY0NmZztcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZShwcm9wcyk7XG4gICAgcCA9IHAudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgICByZXR1cm4gSldLLmhlbHBlcnMudGh1bWJwcmludChjZmcsIGpzb24pO1xuICAgIH0pO1xuICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oaGFzaCkge1xuICAgICAgdmFyIHByaW50cyA9IHt9O1xuICAgICAgcHJpbnRzW0pXSy5oZWxwZXJzLklOVEVSTkFMUy5USFVNQlBSSU5UX0hBU0hdID0gaGFzaDtcbiAgICAgIHByb3BzW0pXSy5oZWxwZXJzLklOVEVSTkFMUy5USFVNQlBSSU5UX0tFWV0gPSBwcmludHM7XG4gICAgICByZXR1cm4gY2ZnO1xuICAgIH0pO1xuICAgIHJldHVybiBwO1xuICB9LFxuICBnZW5lcmF0ZTogZnVuY3Rpb24oc2l6ZSkge1xuICAgIHZhciBrZXlwYWlyID0gZGVwc2VjYy5nZW5lcmF0ZUtleVBhaXIoc2l6ZSk7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIFwiY3J2XCI6IHNpemUsXG4gICAgICBcInhcIjoga2V5cGFpci5wdWJsaWMueCxcbiAgICAgIFwieVwiOiBrZXlwYWlyLnB1YmxpYy55LFxuICAgICAgXCJkXCI6IGtleXBhaXIucHJpdmF0ZS5kXG4gICAgfTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gIH0sXG4gIGltcG9ydDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZiAodmFsaWRhdG9ycy5vaWQgIT09IGlucHV0LmtleU9pZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gY29lcmNlIGtleSBwYXJhbXMgdG8gT0lEXG4gICAgdmFyIGNydjtcbiAgICBpZiAoaW5wdXQua2V5UGFyYW1zICYmIGZvcmdlLmFzbjEuVHlwZS5PSUQgPT09IGlucHV0LmtleVBhcmFtcy50eXBlKSB7XG4gICAgICBjcnYgPSBmb3JnZS5hc24xLmRlclRvT2lkKGlucHV0LmtleVBhcmFtcy52YWx1ZSk7XG4gICAgICBjcnYgPSBvaWRUb0N1cnZlTmFtZShjcnYpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQuY3J2KSB7XG4gICAgICBjcnYgPSBmb3JnZS5hc24xLmRlclRvT2lkKGlucHV0LmNydik7XG4gICAgICBjcnYgPSBvaWRUb0N1cnZlTmFtZShjcnYpO1xuICAgIH1cbiAgICBpZiAoIWNydikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFpbnB1dC5wYXJzZWQpIHtcbiAgICAgIHZhciBjYXB0dXJlID0ge30sXG4gICAgICAgICAgZXJyb3JzID0gW107XG4gICAgICBpZiAoXCJwcml2YXRlXCIgPT09IGlucHV0LnR5cGUpIHtcbiAgICAgICAgLy8gY29lcmNlIGNhcHR1cmUudmFsdWUgdG8gREVSICppZmYqIHByaXZhdGVcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dC5rZXlWYWx1ZSkge1xuICAgICAgICAgIGlucHV0LmtleVZhbHVlID0gZm9yZ2UuYXNuMS5mcm9tRGVyKGlucHV0LmtleVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0LmtleVZhbHVlKSkge1xuICAgICAgICAgIGlucHV0LmtleVZhbHVlID0gaW5wdXQua2V5VmFsdWVbMF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZvcmdlLmFzbjEudmFsaWRhdGUoaW5wdXQua2V5VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3JzLmVtYmVkZGVkUHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHR1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUucG9pbnQgPSBpbnB1dC5rZXlWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlucHV0ID0gY2FwdHVyZTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGZhY3RvcnMgdG8gQnVmZmVyc1xuICAgIHZhciBvdXRwdXQgPSB7XG4gICAgICBrdHk6IFwiRUNcIixcbiAgICAgIGNydjogY3J2XG4gICAgfTtcbiAgICBpZiAoaW5wdXQuZCkge1xuICAgICAgb3V0cHV0LmQgPSBCdWZmZXIuZnJvbShpbnB1dC5kLCBcImJpbmFyeVwiKTtcbiAgICB9XG4gICAgaWYgKGlucHV0LnBvaW50KSB7XG4gICAgICB2YXIgcHQgPSBCdWZmZXIuZnJvbShpbnB1dC5wb2ludCwgXCJiaW5hcnlcIik7XG4gICAgICAvLyBvbmx5IHN1cHBvcnQgdW5jb21wcmVzc2VkXG4gICAgICBpZiAoNCAhPT0gcHQucmVhZFVJbnQxNkJFKDApKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcHQgPSBwdC5zbGljZSgyKTtcbiAgICAgIHZhciBsZW4gPSBwdC5sZW5ndGggLyAyO1xuICAgICAgb3V0cHV0LnggPSBwdC5zbGljZSgwLCBsZW4pO1xuICAgICAgb3V0cHV0LnkgPSBwdC5zbGljZShsZW4pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG59O1xuLy8gcHVibGljIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKHtcbiAgY29uZmlnOiBKV0tFY0NmZyxcbiAgZmFjdG9yeTogSldLRWNGYWN0b3J5XG59KTtcblxuLy8gcmVnaXN0cmF0aW9uXG4oZnVuY3Rpb24oUkVHSVNUUlkpIHtcbiAgUkVHSVNUUlkucmVnaXN0ZXIoSldLRWNGYWN0b3J5KTtcbn0pKHJlcXVpcmUoXCIuL2tleXN0b3JlXCIpLnJlZ2lzdHJ5KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/eckey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/helpers.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/helpers.js - JWK Internal Helper Functions and Constants\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    forge = __webpack_require__(/*! ../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\");\n\nvar ALGORITHMS = __webpack_require__(/*! ../algorithms */ \"(ssr)/./node_modules/node-jose/lib/algorithms/index.js\");\n\n// ### ASN.1 Validators\n// Adapted from digitalbazaar/node-forge/js/asn1.js\n// PrivateKeyInfo\nvar privateKeyValidator = {\n  name: \"PrivateKeyInfo\",\n  tagClass: forge.asn1.Class.UNIVERSAL,\n  type: forge.asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [\n    {\n      // Version (INTEGER)\n      name: \"PrivateKeyInfo.version\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"keyVersion\"\n    },\n    {\n      name: \"PrivateKeyInfo.privateKeyAlgorithm\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [\n        {\n          name: \"AlgorithmIdentifier.algorithm\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.OID,\n          constructed: false,\n          capture: \"keyOid\"\n        },\n        {\n          name: \"AlgorithmIdentifier.parameters\",\n          captureAsn1: \"keyParams\"\n        }\n      ]\n    },\n    {\n      name: \"PrivateKeyInfo\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: \"keyValue\"\n    }\n  ]\n};\n// Adapted from digitalbazaar/node-forge/x509.js\nvar publicKeyValidator = {\n  name: \"SubjectPublicKeyInfo\",\n  tagClass: forge.asn1.Class.UNIVERSAL,\n  type: forge.asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [\n    {\n      name: \"SubjectPublicKeyInfo.AlgorithmIdentifier\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [\n        {\n          name: \"AlgorithmIdentifier.algorithm\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.OID,\n          constructed: false,\n          capture: \"keyOid\"\n        },\n        {\n          name: \"AlgorithmIdentifier.parameters\",\n          captureAsn1: \"keyParams\"\n        }\n      ]\n    },\n    {\n      name: \"SubjectPublicKeyInfo.subjectPublicKey\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.BITSTRING,\n      constructed: false,\n      capture: \"keyValue\"\n    }\n  ]\n};\n// Adapted from digitalbazaar/node-forge/x509.js\nvar X509CertificateValidator = {\n  name: \"Certificate\",\n  tagClass: forge.asn1.Class.UNIVERSAL,\n  type: forge.asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [\n    {\n      name: \"Certificate.TBSCertificate\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: \"certificate\",\n      value: [\n        {\n          name: \"Certificate.TBSCertificate.version\",\n          tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n          type: 0,\n          constructed: true,\n          optional: true,\n          value: [\n            {\n              name: \"Certificate.TBSCertificate.version.integer\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.INTEGER,\n              constructed: false,\n              capture: \"certVersion\"\n            }\n          ]\n        },\n        {\n          name: \"Certificate.TBSCertificate.serialNumber\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.INTEGER,\n          constructed: false,\n          capture: \"certSerialNumber\"\n        },\n        {\n          name: \"Certificate.TBSCertificate.signature\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.SEQUENCE,\n          constructed: true,\n          value: [\n            {\n              name: \"Certificate.TBSCertificate.signature.algorithm\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.OID,\n              constructed: false,\n              capture: \"certSignatureOid\"\n            }, {\n              name: \"Certificate.TBSCertificate.signature.parameters\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              optional: true,\n              captureAsn1: \"certSignatureParams\"\n            }\n          ]\n        },\n        {\n          name: \"Certificate.TBSCertificate.issuer\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.SEQUENCE,\n          constructed: true,\n          captureAsn1: \"certIssuer\"\n        },\n        {\n          name: \"Certificate.TBSCertificate.validity\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.SEQUENCE,\n          constructed: true,\n          // Note: UTC and generalized times may both appear so the capture\n          // names are based on their detected order, the names used below\n          // are only for the common case, which validity time really means\n          // \"notBefore\" and which means \"notAfter\" will be determined by order\n          value: [\n            {\n              // notBefore (Time) (UTC time case)\n              name: \"Certificate.TBSCertificate.validity.notBefore (utc)\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.UTCTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity1UTCTime\"\n            },\n            {\n              // notBefore (Time) (generalized time case)\n              name: \"Certificate.TBSCertificate.validity.notBefore (generalized)\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.GENERALIZEDTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity2GeneralizedTime\"\n            },\n            {\n              // notAfter (Time) (only UTC time is supported)\n              name: \"Certificate.TBSCertificate.validity.notAfter (utc)\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.UTCTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity3UTCTime\"\n            },\n            {\n              // notAfter (Time) (only UTC time is supported)\n              name: \"Certificate.TBSCertificate.validity.notAfter (generalized)\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.GENERALIZEDTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity4GeneralizedTime\"\n            }\n          ]\n        }, {\n          // Name (subject) (RDNSequence)\n          name: \"Certificate.TBSCertificate.subject\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.SEQUENCE,\n          constructed: true,\n          captureAsn1: \"certSubject\"\n        },\n        // SubjectPublicKeyInfo\n        publicKeyValidator,\n        {\n          // issuerUniqueID (optional)\n          name: \"Certificate.TBSCertificate.issuerUniqueID\",\n          tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n          type: 1,\n          constructed: true,\n          optional: true,\n          value: [\n            {\n              name: \"Certificate.TBSCertificate.issuerUniqueID.id\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.BITSTRING,\n              constructed: false,\n              capture: \"certIssuerUniqueId\"\n            }\n          ]\n        },\n        {\n          // subjectUniqueID (optional)\n          name: \"Certificate.TBSCertificate.subjectUniqueID\",\n          tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n          type: 2,\n          constructed: true,\n          optional: true,\n          value: [\n            {\n              name: \"Certificate.TBSCertificate.subjectUniqueID.id\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.BITSTRING,\n              constructed: false,\n              capture: \"certSubjectUniqueId\"\n            }\n          ]\n        },\n        {\n          // Extensions (optional)\n          name: \"Certificate.TBSCertificate.extensions\",\n          tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n          type: 3,\n          constructed: true,\n          captureAsn1: \"certExtensions\",\n          optional: true\n        }\n      ]\n    },\n    {\n      // AlgorithmIdentifier (signature algorithm)\n      name: \"Certificate.signatureAlgorithm\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [\n        {\n          // algorithm\n          name: \"Certificate.signatureAlgorithm.algorithm\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.OID,\n          constructed: false,\n          capture: \"certSignatureOid\"\n        },\n        {\n          name: \"Certificate.TBSCertificate.signature.parameters\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          optional: true,\n          captureAsn1: \"certSignatureParams\"\n        }\n      ]\n    },\n    {\n      // SignatureValue\n      name: \"Certificate.signatureValue\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.BITSTRING,\n      constructed: false,\n      capture: \"certSignature\"\n    }\n  ]\n};\n\nvar INTERNALS = {\n  THUMBPRINT_KEY: \"internal\\u0000thumbprint\",\n  THUMBPRINT_HASH: \"SHA-256\"\n};\n\nmodule.exports = {\n  validators: {\n    privateKey: privateKeyValidator,\n    publicKey: publicKeyValidator,\n    certificate: X509CertificateValidator\n  },\n\n  thumbprint: function(cfg, json, hash) {\n    if (\"function\" !== typeof cfg.thumbprint) {\n      return Promise.reject(new Error(\"thumbprint not supported\"));\n    }\n\n    hash = (hash || INTERNALS.THUMBPRINT_HASH).toUpperCase();\n    var fields = cfg.thumbprint(json);\n    var input = Object.keys(fields).\n                sort().\n                map(function(k) {\n      var v = fields[k];\n      if (Buffer.isBuffer(v)) {\n        v = util.base64url.encode(v);\n      }\n      return JSON.stringify(k) + \":\" + JSON.stringify(v);\n    });\n    input = \"{\" + input.join(\",\") + \"}\";\n    try {\n      return ALGORITHMS.digest(hash, Buffer.from(input, \"utf8\"));\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  },\n  unpackProps: function(props, allowed) {\n    var output;\n\n    // apply all of the existing values\n    allowed.forEach(function(cfg) {\n      if (!(cfg.name in props)) {\n        return;\n      }\n      output = output || {};\n      var value = props[cfg.name];\n      switch (cfg.type) {\n        case \"binary\":\n          if (Buffer.isBuffer(value)) {\n            props[cfg.name] = util.base64url.encode(value);\n          } else {\n            value = util.base64url.decode(value);\n          }\n          break;\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n          break;\n        case \"array\":\n          value = [].concat(value);\n          break;\n        case \"object\":\n          value = clone(value);\n          break;\n        default:\n          // TODO: deep clone?\n          break;\n      }\n      output[cfg.name] = value;\n    });\n\n    // remove any from json that didn't apply\n    var check = output || {};\n    Object.keys(props).\n           forEach(function(n) {\n              if (n in check) { return; }\n              delete props[n];\n           });\n\n    return output;\n  },\n  COMMON_PROPS: [\n    {name: \"kty\", type: \"string\"},\n    {name: \"kid\", type: \"string\"},\n    {name: \"use\", type: \"string\"},\n    {name: \"alg\", type: \"string\"},\n    {name: \"x5c\", type: \"array\"},\n    {name: \"x5t\", type: \"binary\"},\n    {name: \"x5u\", type: \"string\"},\n    {name: \"key_ops\", type: \"array\"}\n  ],\n  INTERNALS: INTERNALS\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDBEQUFjO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUztBQUM1QixZQUFZLG1CQUFPLENBQUMsdUVBQWU7O0FBRW5DLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFlOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLFlBQVk7O0FBRVo7QUFDQSxHQUFHO0FBQ0g7QUFDQSxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDJCQUEyQjtBQUNoQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9oZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandrL2hlbHBlcnMuanMgLSBKV0sgSW50ZXJuYWwgSGVscGVyIEZ1bmN0aW9ucyBhbmQgQ29uc3RhbnRzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjbG9uZSA9IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpLFxuICAgIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2VcIik7XG5cbnZhciBBTEdPUklUSE1TID0gcmVxdWlyZShcIi4uL2FsZ29yaXRobXNcIik7XG5cbi8vICMjIyBBU04uMSBWYWxpZGF0b3JzXG4vLyBBZGFwdGVkIGZyb20gZGlnaXRhbGJhemFhci9ub2RlLWZvcmdlL2pzL2FzbjEuanNcbi8vIFByaXZhdGVLZXlJbmZvXG52YXIgcHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgbmFtZTogXCJQcml2YXRlS2V5SW5mb1wiLFxuICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbXG4gICAge1xuICAgICAgLy8gVmVyc2lvbiAoSU5URUdFUilcbiAgICAgIG5hbWU6IFwiUHJpdmF0ZUtleUluZm8udmVyc2lvblwiLFxuICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiBcImtleVZlcnNpb25cIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJQcml2YXRlS2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtXCIsXG4gICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkFsZ29yaXRobUlkZW50aWZpZXIuYWxnb3JpdGhtXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IFwia2V5T2lkXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiQWxnb3JpdGhtSWRlbnRpZmllci5wYXJhbWV0ZXJzXCIsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6IFwia2V5UGFyYW1zXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJQcml2YXRlS2V5SW5mb1wiLFxuICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogXCJrZXlWYWx1ZVwiXG4gICAgfVxuICBdXG59O1xuLy8gQWRhcHRlZCBmcm9tIGRpZ2l0YWxiYXphYXIvbm9kZS1mb3JnZS94NTA5LmpzXG52YXIgcHVibGljS2V5VmFsaWRhdG9yID0ge1xuICBuYW1lOiBcIlN1YmplY3RQdWJsaWNLZXlJbmZvXCIsXG4gIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFtcbiAgICB7XG4gICAgICBuYW1lOiBcIlN1YmplY3RQdWJsaWNLZXlJbmZvLkFsZ29yaXRobUlkZW50aWZpZXJcIixcbiAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG1cIixcbiAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogXCJrZXlPaWRcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJBbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtZXRlcnNcIixcbiAgICAgICAgICBjYXB0dXJlQXNuMTogXCJrZXlQYXJhbXNcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcIlN1YmplY3RQdWJsaWNLZXlJbmZvLnN1YmplY3RQdWJsaWNLZXlcIixcbiAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiBcImtleVZhbHVlXCJcbiAgICB9XG4gIF1cbn07XG4vLyBBZGFwdGVkIGZyb20gZGlnaXRhbGJhemFhci9ub2RlLWZvcmdlL3g1MDkuanNcbnZhciBYNTA5Q2VydGlmaWNhdGVWYWxpZGF0b3IgPSB7XG4gIG5hbWU6IFwiQ2VydGlmaWNhdGVcIixcbiAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW1xuICAgIHtcbiAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGVcIixcbiAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6IFwiY2VydGlmaWNhdGVcIixcbiAgICAgIHZhbHVlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZlcnNpb25cIixcbiAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgICAgIHR5cGU6IDAsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52ZXJzaW9uLmludGVnZXJcIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBjYXB0dXJlOiBcImNlcnRWZXJzaW9uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNlcmlhbE51bWJlclwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogXCJjZXJ0U2VyaWFsTnVtYmVyXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5hbGdvcml0aG1cIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuT0lELFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgIGNhcHR1cmU6IFwiY2VydFNpZ25hdHVyZU9pZFwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlLnBhcmFtZXRlcnNcIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgY2FwdHVyZUFzbjE6IFwiY2VydFNpZ25hdHVyZVBhcmFtc1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5pc3N1ZXJcIixcbiAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgIGNhcHR1cmVBc24xOiBcImNlcnRJc3N1ZXJcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eVwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgLy8gTm90ZTogVVRDIGFuZCBnZW5lcmFsaXplZCB0aW1lcyBtYXkgYm90aCBhcHBlYXIgc28gdGhlIGNhcHR1cmVcbiAgICAgICAgICAvLyBuYW1lcyBhcmUgYmFzZWQgb24gdGhlaXIgZGV0ZWN0ZWQgb3JkZXIsIHRoZSBuYW1lcyB1c2VkIGJlbG93XG4gICAgICAgICAgLy8gYXJlIG9ubHkgZm9yIHRoZSBjb21tb24gY2FzZSwgd2hpY2ggdmFsaWRpdHkgdGltZSByZWFsbHkgbWVhbnNcbiAgICAgICAgICAvLyBcIm5vdEJlZm9yZVwiIGFuZCB3aGljaCBtZWFucyBcIm5vdEFmdGVyXCIgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IG9yZGVyXG4gICAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gbm90QmVmb3JlIChUaW1lKSAoVVRDIHRpbWUgY2FzZSlcbiAgICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RCZWZvcmUgKHV0YylcIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuVVRDVElNRSxcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgY2FwdHVyZTogXCJjZXJ0VmFsaWRpdHkxVVRDVGltZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBub3RCZWZvcmUgKFRpbWUpIChnZW5lcmFsaXplZCB0aW1lIGNhc2UpXG4gICAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QmVmb3JlIChnZW5lcmFsaXplZClcIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuR0VORVJBTElaRURUSU1FLFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICBjYXB0dXJlOiBcImNlcnRWYWxpZGl0eTJHZW5lcmFsaXplZFRpbWVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gbm90QWZ0ZXIgKFRpbWUpIChvbmx5IFVUQyB0aW1lIGlzIHN1cHBvcnRlZClcbiAgICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RBZnRlciAodXRjKVwiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5VVENUSU1FLFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICBjYXB0dXJlOiBcImNlcnRWYWxpZGl0eTNVVENUaW1lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIG5vdEFmdGVyIChUaW1lKSAob25seSBVVEMgdGltZSBpcyBzdXBwb3J0ZWQpXG4gICAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QWZ0ZXIgKGdlbmVyYWxpemVkKVwiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5HRU5FUkFMSVpFRFRJTUUsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgIGNhcHR1cmU6IFwiY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgLy8gTmFtZSAoc3ViamVjdCkgKFJETlNlcXVlbmNlKVxuICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6IFwiY2VydFN1YmplY3RcIlxuICAgICAgICB9LFxuICAgICAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgICAgICBwdWJsaWNLZXlWYWxpZGF0b3IsXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBpc3N1ZXJVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5pc3N1ZXJVbmlxdWVJRFwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgICAgdHlwZTogMSxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmlzc3VlclVuaXF1ZUlELmlkXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBjYXB0dXJlOiBcImNlcnRJc3N1ZXJVbmlxdWVJZFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgLy8gc3ViamVjdFVuaXF1ZUlEIChvcHRpb25hbClcbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnN1YmplY3RVbmlxdWVJRFwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnN1YmplY3RVbmlxdWVJRC5pZFwiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgY2FwdHVyZTogXCJjZXJ0U3ViamVjdFVuaXF1ZUlkXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBFeHRlbnNpb25zIChvcHRpb25hbClcbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmV4dGVuc2lvbnNcIixcbiAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6IFwiY2VydEV4dGVuc2lvbnNcIixcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBBbGdvcml0aG1JZGVudGlmaWVyIChzaWduYXR1cmUgYWxnb3JpdGhtKVxuICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5zaWduYXR1cmVBbGdvcml0aG1cIixcbiAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFtcbiAgICAgICAge1xuICAgICAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtLmFsZ29yaXRobVwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuT0lELFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiBcImNlcnRTaWduYXR1cmVPaWRcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUucGFyYW1ldGVyc1wiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICBjYXB0dXJlQXNuMTogXCJjZXJ0U2lnbmF0dXJlUGFyYW1zXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gU2lnbmF0dXJlVmFsdWVcbiAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuc2lnbmF0dXJlVmFsdWVcIixcbiAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiBcImNlcnRTaWduYXR1cmVcIlxuICAgIH1cbiAgXVxufTtcblxudmFyIElOVEVSTkFMUyA9IHtcbiAgVEhVTUJQUklOVF9LRVk6IFwiaW50ZXJuYWxcXHUwMDAwdGh1bWJwcmludFwiLFxuICBUSFVNQlBSSU5UX0hBU0g6IFwiU0hBLTI1NlwiXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmFsaWRhdG9yczoge1xuICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXlWYWxpZGF0b3IsXG4gICAgcHVibGljS2V5OiBwdWJsaWNLZXlWYWxpZGF0b3IsXG4gICAgY2VydGlmaWNhdGU6IFg1MDlDZXJ0aWZpY2F0ZVZhbGlkYXRvclxuICB9LFxuXG4gIHRodW1icHJpbnQ6IGZ1bmN0aW9uKGNmZywganNvbiwgaGFzaCkge1xuICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjZmcudGh1bWJwcmludCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInRodW1icHJpbnQgbm90IHN1cHBvcnRlZFwiKSk7XG4gICAgfVxuXG4gICAgaGFzaCA9IChoYXNoIHx8IElOVEVSTkFMUy5USFVNQlBSSU5UX0hBU0gpLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIGZpZWxkcyA9IGNmZy50aHVtYnByaW50KGpzb24pO1xuICAgIHZhciBpbnB1dCA9IE9iamVjdC5rZXlzKGZpZWxkcykuXG4gICAgICAgICAgICAgICAgc29ydCgpLlxuICAgICAgICAgICAgICAgIG1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgdiA9IGZpZWxkc1trXTtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICAgICAgdiA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZSh2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrKSArIFwiOlwiICsgSlNPTi5zdHJpbmdpZnkodik7XG4gICAgfSk7XG4gICAgaW5wdXQgPSBcIntcIiArIGlucHV0LmpvaW4oXCIsXCIpICsgXCJ9XCI7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBBTEdPUklUSE1TLmRpZ2VzdChoYXNoLCBCdWZmZXIuZnJvbShpbnB1dCwgXCJ1dGY4XCIpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgfSxcbiAgdW5wYWNrUHJvcHM6IGZ1bmN0aW9uKHByb3BzLCBhbGxvd2VkKSB7XG4gICAgdmFyIG91dHB1dDtcblxuICAgIC8vIGFwcGx5IGFsbCBvZiB0aGUgZXhpc3RpbmcgdmFsdWVzXG4gICAgYWxsb3dlZC5mb3JFYWNoKGZ1bmN0aW9uKGNmZykge1xuICAgICAgaWYgKCEoY2ZnLm5hbWUgaW4gcHJvcHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG91dHB1dCA9IG91dHB1dCB8fCB7fTtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BzW2NmZy5uYW1lXTtcbiAgICAgIHN3aXRjaCAoY2ZnLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICBwcm9wc1tjZmcubmFtZV0gPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHV0aWwuYmFzZTY0dXJsLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgdmFsdWUgPSBbXS5jb25jYXQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgdmFsdWUgPSBjbG9uZSh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gVE9ETzogZGVlcCBjbG9uZT9cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG91dHB1dFtjZmcubmFtZV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBhbnkgZnJvbSBqc29uIHRoYXQgZGlkbid0IGFwcGx5XG4gICAgdmFyIGNoZWNrID0gb3V0cHV0IHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHByb3BzKS5cbiAgICAgICAgICAgZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgIGlmIChuIGluIGNoZWNrKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICBkZWxldGUgcHJvcHNbbl07XG4gICAgICAgICAgIH0pO1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSxcbiAgQ09NTU9OX1BST1BTOiBbXG4gICAge25hbWU6IFwia3R5XCIsIHR5cGU6IFwic3RyaW5nXCJ9LFxuICAgIHtuYW1lOiBcImtpZFwiLCB0eXBlOiBcInN0cmluZ1wifSxcbiAgICB7bmFtZTogXCJ1c2VcIiwgdHlwZTogXCJzdHJpbmdcIn0sXG4gICAge25hbWU6IFwiYWxnXCIsIHR5cGU6IFwic3RyaW5nXCJ9LFxuICAgIHtuYW1lOiBcIng1Y1wiLCB0eXBlOiBcImFycmF5XCJ9LFxuICAgIHtuYW1lOiBcIng1dFwiLCB0eXBlOiBcImJpbmFyeVwifSxcbiAgICB7bmFtZTogXCJ4NXVcIiwgdHlwZTogXCJzdHJpbmdcIn0sXG4gICAge25hbWU6IFwia2V5X29wc1wiLCB0eXBlOiBcImFycmF5XCJ9XG4gIF0sXG4gIElOVEVSTkFMUzogSU5URVJOQUxTXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/index.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * jwk/index.js - JSON Web Key (JWK) Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar JWKStore = __webpack_require__(/*! ./keystore.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\");\n\n// Public API -- Key and KeyStore methods\nObject.keys(JWKStore.KeyStore).forEach(function(name) {\n  exports[name] = JWKStore.KeyStore[name];\n});\n\n// Public API -- constants\nvar CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/constants.js\");\nObject.keys(CONSTANTS).forEach(function(name) {\n  exports[name] = CONSTANTS[name];\n});\n\n// Registered Key Types\n__webpack_require__(/*! ./octkey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/octkey.js\");\n__webpack_require__(/*! ./rsakey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/rsakey.js\");\n__webpack_require__(/*! ./eckey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/eckey.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx5RUFBZTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFnQjtBQUN4QztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLG1CQUFPLENBQUMscUVBQWE7QUFDckIsbUJBQU8sQ0FBQyxxRUFBYTtBQUNyQixtQkFBTyxDQUFDLG1FQUFZIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3ay9pbmRleC5qcyAtIEpTT04gV2ViIEtleSAoSldLKSBFbnRyeSBQb2ludFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgSldLU3RvcmUgPSByZXF1aXJlKFwiLi9rZXlzdG9yZS5qc1wiKTtcblxuLy8gUHVibGljIEFQSSAtLSBLZXkgYW5kIEtleVN0b3JlIG1ldGhvZHNcbk9iamVjdC5rZXlzKEpXS1N0b3JlLktleVN0b3JlKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgZXhwb3J0c1tuYW1lXSA9IEpXS1N0b3JlLktleVN0b3JlW25hbWVdO1xufSk7XG5cbi8vIFB1YmxpYyBBUEkgLS0gY29uc3RhbnRzXG52YXIgQ09OU1RBTlRTID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xuT2JqZWN0LmtleXMoQ09OU1RBTlRTKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgZXhwb3J0c1tuYW1lXSA9IENPTlNUQU5UU1tuYW1lXTtcbn0pO1xuXG4vLyBSZWdpc3RlcmVkIEtleSBUeXBlc1xucmVxdWlyZShcIi4vb2N0a2V5LmpzXCIpO1xucmVxdWlyZShcIi4vcnNha2V5LmpzXCIpO1xucmVxdWlyZShcIi4vZWNrZXkuanNcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/keystore.js":
/*!****************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/keystore.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/keystore.js - JWK KeyStore Implementation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    forge = __webpack_require__(/*! ../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\nvar JWK = {\n  BaseKey: __webpack_require__(/*! ./basekey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\"),\n  helpers: __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\")\n};\n\n/**\n * @class JWK.KeyStoreRegistry\n * @classdesc\n * A registry of JWK.Key types that can be used.\n *\n * @description\n * **NOTE:** This constructor cannot be called directly. Instead use the\n * global {JWK.registry}\n */\nvar JWKRegistry = function() {\n  var types = {};\n\n  Object.defineProperty(this, \"register\", {\n    value: function(factory) {\n      if (!factory || \"string\" !== typeof factory.kty || !factory.kty) {\n        throw new Error(\"invalid Key factory\");\n      }\n\n      var kty = factory.kty;\n      types[kty] = factory;\n      return this;\n    }\n  });\n  Object.defineProperty(this, \"unregister\", {\n    value: function(factory) {\n      if (!factory || \"string\" !== typeof factory.kty || !factory.kty) {\n        throw new Error(\"invalid Key factory\");\n      }\n\n      var kty = factory.kty;\n      if (factory === types[kty]) {\n        delete types[kty];\n      }\n      return this;\n    }\n  });\n\n  Object.defineProperty(this, \"get\", {\n    value: function(kty) {\n      return types[kty || \"\"] || undefined;\n    }\n  });\n  Object.defineProperty(this, \"all\", {\n    value: function() {\n      return Object.keys(types).map(function(t) { return types[t]; });\n    }\n  });\n};\n\n// Globals\nvar GLOBAL_REGISTRY = new JWKRegistry();\n\n// importer\nfunction processCert(input) {\n  // convert certIssuer to readable attributes\n  [\"certIssuer\", \"certSubject\"].forEach(function(field) {\n    /* eslint new-cap: [0] */\n    var attrs = forge.pki.RDNAttributesAsArray(input[field]);\n    var result = input[field] = {};\n    attrs.forEach(function(a) {\n      result[a.name || a.type] = a.value;\n    });\n  });\n\n  return input;\n}\n\nfunction fromPEM(input) {\n  var result = {};\n  var pems = forge.pem.decode(input);\n  var found = pems.some(function(p) {\n    switch (p.type) {\n      case \"CERTIFICATE\":\n        result.form = \"pkix\";\n        break;\n      case \"PUBLIC KEY\":\n        result.form = \"spki\";\n        break;\n      case \"PRIVATE KEY\":\n        result.form = \"pkcs8\";\n        break;\n      case \"EC PRIVATE KEY\":\n        /* eslint no-fallthrough: [0] */\n      case \"RSA PRIVATE KEY\":\n        result.form = \"private\";\n        break;\n      default:\n        return false;\n    }\n\n    result.body = p.body;\n    return true;\n  });\n  if (!found) {\n    throw new Error(\"supported PEM type not found\");\n  }\n  return result;\n}\nfunction importFrom(registry, input) {\n  // form can be one of:\n  //  'private' | 'pkcs8' | 'public' | 'spki' | 'pkix' | 'x509'\n  var capture = {},\n      errors = [],\n      result;\n\n  // conver from DER to ASN1\n  var form = input.form,\n      der = input.body,\n      thumbprint = null;\n  input = forge.asn1.fromDer(der);\n  switch(form) {\n    case \"private\":\n      registry.all().some(function(factory) {\n        if (result) {\n          return false;\n        }\n        if (!factory.validators) {\n          return false;\n        }\n\n        var oid = factory.validators.oid,\n            validator = factory.validators.privateKey;\n        if (!validator) {\n          return false;\n        }\n        capture = {};\n        errors = [];\n        result = forge.asn1.validate(input, validator, capture, errors);\n        if (result) {\n          capture.keyOid = forge.asn1.oidToDer(oid);\n          capture.parsed = true;\n        }\n        return result;\n      });\n      capture.type = \"private\";\n      break;\n    case \"pkcs8\":\n      result = forge.asn1.validate(input, JWK.helpers.validators.privateKey, capture, errors);\n      capture.type = \"private\";\n      break;\n    case \"public\":\n      // eslint no-fallthrough: [0] */\n    case \"spki\":\n      result = forge.asn1.validate(input, JWK.helpers.validators.publicKey, capture, errors);\n      capture.type = \"public\";\n      break;\n    case \"pkix\":\n      /* eslint no-fallthrough: [0] */\n    case \"x509\":\n      result = forge.asn1.validate(input, JWK.helpers.validators.certificate, capture, errors);\n      if (result) {\n        capture = processCert(capture);\n        var md = forge.md.sha1.create();\n        md.update(der);\n        thumbprint = util.base64url.encode(Buffer.from(md.digest().toHex(), \"hex\"));\n      }\n      capture.type = \"public\";\n      break;\n  }\n  if (!result) {\n    return null;\n  }\n\n  // convert oids\n  if (capture.keyOid) {\n    capture.keyOid = forge.asn1.derToOid(capture.keyOid);\n  }\n\n  // find and invoke the importer\n  result = null;\n  GLOBAL_REGISTRY.all().forEach(function(factory) {\n    if (result) {\n      return;\n    }\n    if (!factory) {\n      return;\n    }\n    if (\"function\" !== typeof factory.import) {\n      return;\n    }\n    result = factory.import(capture);\n  });\n  if (result && capture.certSubject && capture.certSubject.commonName) {\n    result.kid = capture.certSubject.commonName;\n  }\n  if (result && thumbprint) {\n    result.x5t = thumbprint;\n  }\n  return result;\n}\n\n/**\n * @class JWK.KeyStore\n * @classdesc\n * Represents a collection of Keys.\n *\n * @description\n * **NOTE:** This constructor cannot be called directly. Instead call {@link\n * JWK.createKeyStore}.\n */\nvar JWKStore = function(registry, parent) {\n  var keysets = {};\n\n  /**\n   * @method JWK.KeyStore#generate\n   * @description\n   * Generates a new random Key into this KeyStore.\n   *\n   * The type of {size} depends on the value of {kty}:\n   *\n   * + **`EC`**: String naming the curve to use, which can be one of:\n   *   `\"P-256\"`, `\"P-384\"`, or `\"P-521\"` (default is **`\"P-256\"`**).\n   * + **`RSA`**: Number describing the size of the key, in bits (default is\n   *   **`2048`**).\n   * + **`oct`**: Number describing the size of the key, in bits (default is\n   *   **`256`**).\n   *\n   * Any properties in {props} are applied before the key is generated,\n   * and are expected to be data types acceptable in JSON.  This allows the\n   * generated key to have a specific key identifier, or to specify its\n   * acceptable usage.\n   *\n   * The returned Promise, when fulfilled, returns the generated Key.\n   *\n   * @param {String} kty The type of generated key\n   * @param {String|Number} [size] The size of the generated key\n   * @param {Object} [props] Additional properties to apply to the generated\n   *        key.\n   * @returns {Promise} The promise for the generated Key\n   * @throws {Error} If {kty} is not supported\n   */\n  Object.defineProperty(this, \"generate\", {\n    value: function(kty, size, props) {\n      var keytype = registry.get(kty);\n      if (!keytype) {\n        return Promise.reject(new Error(\"unsupported key type\"));\n      }\n\n      props = clone(props || {});\n      props.kty = kty;\n\n      var self = this,\n          promise = keytype.generate(size);\n      return promise.then(function(jwk) {\n        jwk = merge(props, jwk, {\n          kty: kty\n        });\n        return self.add(jwk);\n      });\n    }\n  });\n  /**\n   * @method JWK.KeyStore#add\n   * @description\n   * Adds a Key to this KeyStore. If {jwk} is a string, it is first\n   * parsed into a plain JSON object. If {jwk} is already an instance\n   * of JWK.Key, its (public) JSON representation is first obtained\n   * then applied to a new JWK.Key object within this KeyStore.\n   *\n   * @param {String|Object} jwk The JSON Web Key (JWK)\n   * @param {String} [form] The format of a String key to expect\n   * @param {Object} [extras] extra jwk fields inserted when importing from a non json string (eg \"pem\")\n   * @returns {Promise} The promise for the added key\n   */\n  Object.defineProperty(this, \"add\", {\n    value: function(jwk, form, extras) {\n      extras = extras || {};\n\n      var factors;\n      if (Buffer.isBuffer(jwk) || typeof jwk === \"string\") {\n        // form can be 'json', 'pkcs8', 'spki', 'pkix', 'x509', 'pem'\n        form = (form || \"json\").toLowerCase();\n        if (\"json\" === form) {\n          jwk = JSON.parse(jwk.toString(\"utf8\"));\n        } else {\n          try {\n            if (\"pem\" === form) {\n              // convert *first* PEM -> DER\n              factors = fromPEM(jwk);\n            } else {\n              factors = {\n                body: jwk.toString(\"binary\"),\n                form: form\n              };\n            }\n            jwk = importFrom(registry, factors);\n            if (!jwk) {\n              throw new Error(\"no importer for key\");\n            }\n            Object.keys(extras).forEach(function(field){\n              jwk[field] = extras[field];\n            });\n          } catch (err) {\n            return Promise.reject(err);\n          }\n        }\n      } else if (JWKStore.isKey(jwk)) {\n        // assume a complete duplicate is desired\n        jwk = jwk.toJSON(true);\n      } else {\n        jwk = clone(jwk);\n      }\n\n      var keytype = registry.get(jwk.kty);\n      if (!keytype) {\n        return Promise.reject(new Error(\"unsupported key type\"));\n      }\n\n      var self = this,\n          promise = keytype.prepare(jwk);\n      return promise.then(function(cfg) {\n        return new JWK.BaseKey(jwk.kty, self, jwk, cfg);\n      }).then(function(jwk) {\n        var kid = jwk.kid || \"\";\n        var keys = keysets[kid] = keysets[kid] || [];\n        keys.push(jwk);\n\n        return jwk;\n      });\n    }\n  });\n  /**\n   * @method JWK.KeyStore#remove\n   * @description\n   * Removes a Key from this KeyStore.\n   *\n   * **NOTE:** The removed Key's {keystore} property is not changed.\n   *\n   * @param {JWK.Key} jwk The key to remove.\n   */\n  Object.defineProperty(this, \"remove\", {\n    value: function(jwk) {\n      if (!jwk) {\n        return;\n      }\n\n      var keys = keysets[jwk.kid];\n      if (!keys) {\n        return;\n      }\n\n      var pos = keys.indexOf(jwk);\n      if (pos === -1) {\n        return;\n      }\n\n      keys.splice(pos, 1);\n      if (!keys.length) {\n        delete keysets[jwk.kid];\n      }\n    }\n  });\n\n  /**\n   * @method JWK.KeyStore#all\n   * @description\n   * Retrieves all of the contained Keys that optinally match all of the\n   * given properties.\n   *\n   * If {props} are specified, this method only returns Keys which exactly\n   * match the given properties. The properties can be any of the\n   * following:\n   *\n   * + **alg**: The algorithm for the Key.\n   * + **use**: The usage for the Key.\n   * + **kid**: The identifier for the Key.\n   *\n   * If no properties are given, this method returns all of the Keys for this\n   * KeyStore.\n   *\n   * @param {Object} [props] The properties to match against\n   * @param {Boolean} [local = false] `true` if only the Keys\n   *        directly contained by this KeyStore should be returned, or\n   *        `false` if it should return all Keys of this KeyStore and\n   *        its ancestors.\n   * @returns {JWK.Key[]} The list of matching Keys, or an empty array if no\n   *          matches are found.\n   */\n  Object.defineProperty(this, \"all\", {\n    value: function(props, local) {\n      props = props || {};\n\n      // workaround for issues/109\n      if (props.kid !== undefined && props.kid !== null && typeof props.kid !== \"string\") {\n        props.kid = String(props.kid);\n      }\n\n      var candidates = [];\n      var matches = function(key) {\n        // match on 'kty'\n        if (props.kty &&\n            key.kty &&\n            props.kty !== key.kty) {\n          return false;\n        }\n        // match on 'use'\n        if (props.use &&\n            key.use &&\n            props.use !== key.use) {\n          return false;\n        }\n        // match on 'alg'\n        if (props.alg) {\n          if (props.alg !== \"dir\" &&\n              key.alg &&\n              props.alg !== key.alg) {\n            return false;\n          }\n          return key.supports(props.alg);\n        }\n        //TODO: match on 'key_ops'\n\n        return true;\n      };\n      Object.keys(keysets).forEach(function(id) {\n        if (props.kid && props.kid !== id) {\n          return;\n        }\n\n        var keys = keysets[id].filter(matches);\n        if (keys.length) {\n          candidates = candidates.concat(keys);\n        }\n      });\n\n      if (!local && parent) {\n        candidates = candidates.concat(parent.all(props));\n      }\n\n      return candidates;\n    }\n  });\n  /**\n   * @method JWK.KeyStore#get\n   * @description\n   * Retrieves the contained Key matching the given {kid}, and optionally\n   * all of the given properties.  This method equivalent to calling\n   * {@link JWK.Store#all}, then returning the first Key whose\n   * \"kid\" is {kid}. If {kid} is undefined, then the first Key that\n   * is returned from `all()` is returned.\n   *\n   * @param {String} [kid] The key identifier to match against.\n   * @param {Object} [props] The properties to match against.\n   * @param {Boolean} [local = false] `true` if only the Keys\n   *        directly contained by this KeyStore should be returned, or\n   *        `false` if it should return all Keys of this KeyStore and\n   *        its ancestors.\n   * @returns {JWK.Key} The Key matching {kid} and {props}, or `null`\n   *          if no match is found.\n   */\n  Object.defineProperty(this, \"get\", {\n    value: function(kid, props, local) {\n      // reconcile arguments\n      if (typeof kid === \"boolean\") {\n        local = kid;\n        props = kid = null;\n      } else if (typeof kid === \"object\") {\n        local = props;\n        props = kid;\n        kid = null;\n      }\n\n      // fixup props\n      props = props || {};\n      if (kid) {\n        props.kid = kid;\n      }\n\n      // workaround for issues/109\n      if (props.kid !== undefined && props.kid !== null && typeof props.kid !== \"string\") {\n       props.kid = String(props.kid);\n      }\n\n      var candidates = this.all(props, true);\n      if (!candidates.length && parent && !local) {\n        candidates = parent.get(props, local);\n      }\n      return candidates[0] || null;\n    }\n  });\n\n  /**\n   * @method JWK.KeyStore#temp\n   * @description\n   * Creates a temporary KeyStore based on this KeyStore.\n   *\n   * @returns {JWK.KeyStore} The temporary KeyStore.\n   */\n  Object.defineProperty(this, \"temp\", {\n    value: function() {\n      return new JWKStore(registry, this);\n    }\n  });\n\n  /**\n   * @method JWK.KeyStore#toJSON\n   * @description\n   * Generates a JSON representation of this KeyStore, which conforms\n   * to a JWK Set from {I-D.ietf-jose-json-web-key}.\n   *\n   * @param {Boolean} [isPrivate = false] `true` if the private fields\n   *        of stored keys are to be included.\n   * @returns {Object} The JSON representation of this KeyStore.\n   */\n  Object.defineProperty(this, \"toJSON\", {\n    value: function(isPrivate) {\n      var keys = [];\n\n      Object.keys(keysets).forEach(function(kid) {\n        var items = keysets[kid].map(function(k) {\n          return k.toJSON(isPrivate);\n        });\n        keys = keys.concat(items);\n      });\n\n      return {\n        keys: keys\n      };\n    }\n  });\n};\n\n/**\n * Determines if the given object is an instance of JWK.KeyStore.\n *\n * @param {Object} obj The object to test\n * @returns {Boolean} `true` if {obj} is an instance of JWK.KeyStore,\n *          and `false` otherwise.\n */\nJWKStore.isKeyStore = function(obj) {\n  if (!obj) {\n    return false;\n  }\n\n  if (\"object\" !== typeof obj) {\n    return false;\n  }\n\n  if (\"function\" !== typeof obj.get ||\n      \"function\" !== typeof obj.all ||\n      \"function\" !== typeof obj.generate ||\n      \"function\" !== typeof obj.add ||\n      \"function\" !== typeof obj.remove) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Creates a new empty KeyStore.\n *\n * @returns {JWK.KeyStore} The empty KeyStore.\n */\nJWKStore.createKeyStore = function() {\n  return new JWKStore(GLOBAL_REGISTRY);\n};\n\n/**\n * Coerces the given object into a KeyStore. This method uses the following\n * algorithm to coerce {ks}:\n *\n * 1. if {ks} is an instance of JWK.KeyStore, it is returned directly\n * 2. if {ks} is a string, it is parsed into a JSON value\n * 3. if {ks} is an array, it creates a new JWK.KeyStore and calls {@link\n *    JWK.KeyStore#add} for each element in the {ks} array.\n * 4. if {ks} is a JSON object, it creates a new JWK.KeyStore and calls {@link\n *    JWK.KeyStore#add} for each element in the \"keys\" property.\n *\n * @param {Object|String} ks The value to coerce into a\n *        KeyStore\n * @returns {Promise(JWK.KeyStore)} A promise for the coerced KeyStore.\n */\nJWKStore.asKeyStore = function(ks) {\n  if (JWKStore.isKeyStore(ks)) {\n    return Promise.resolve(ks);\n  }\n\n  var store = JWKStore.createKeyStore(),\n      keys;\n\n  if (typeof ks === \"string\") {\n    ks = JSON.parse(ks);\n  }\n\n  if (Array.isArray(ks)) {\n    keys = ks;\n  } else if (\"keys\" in ks) {\n    keys = ks.keys;\n  } else {\n    return Promise.reject(new Error(\"invalid keystore\"));\n  }\n\n  keys = keys.map(function(k) {\n    return store.add(k);\n  });\n\n  var promise = Promise.all(keys);\n  promise = promise.then(function() {\n    return store;\n  });\n\n  return promise;\n};\n\n\n/**\n * Determines if the given object is a JWK.Key instance.\n *\n * @param {Object} obj The object to test\n * @returns `true` if {obj} is a JWK.Key\n */\nJWKStore.isKey = function(obj) {\n  if (!obj) {\n    return false;\n  }\n\n  if (\"object\" !== typeof obj) {\n    return false;\n  }\n\n  if (!JWKStore.isKeyStore(obj.keystore)) {\n    return false;\n  }\n\n  if (\"string\" !== typeof obj.kty ||\n      \"number\" !== typeof obj.length ||\n      \"function\" !== typeof obj.algorithms ||\n      \"function\" !== typeof obj.supports ||\n      \"function\" !== typeof obj.encrypt ||\n      \"function\" !== typeof obj.decrypt ||\n      \"function\" !== typeof obj.wrap ||\n      \"function\" !== typeof obj.unwrap ||\n      \"function\" !== typeof obj.sign ||\n      \"function\" !== typeof obj.verify) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Creates a new key with the given properties.  This method is a convenience\n * to calling `JWK.createKeyStore()` then `generate()` on the returned keystore.\n *\n * @param {String} kty The type of generated key\n * @param {String|Number} [size] The size of the generated key\n * @param {Object} [props] Additional properties to apply to the generated\n *        key.\n * @returns {Promise} The promise for the generated Key\n * @throws {Error} If {kty} is not supported\n * @see JWKStore#generate\n */\nJWKStore.createKey = function(kty, size, props) {\n  var ks = JWKStore.createKeyStore();\n  return ks.generate(kty, size, props);\n}\n\n/**\n * Coerces the given object into a Key. If {key} is an instance of JWK.Key,\n * it is returned directly. Otherwise, this method first creates a new\n * JWK.KeyStore and calls {@link JWK.KeyStore#add} on this new KeyStore.\n *\n * @param {Object|String} key The value to coerce into a Key\n * @param {String} [form] The format of a String Key to expect\n * @param {Object} [extras] extra jwk fields inserted when importing from a non json string (eg \"pem\")\n * @returns {Promise(JWK.Key)} A promise for the coerced Key.\n */\nJWKStore.asKey = function(key, form, extras) {\n  if (JWKStore.isKey(key)) {\n    return Promise.resolve(key);\n  }\n\n  var ks = JWKStore.createKeyStore();\n  key = ks.add(key, form, extras);\n\n  return key;\n};\n\nmodule.exports = {\n  KeyRegistry: JWKRegistry,\n  KeyStore: JWKStore,\n  registry: GLOBAL_REGISTRY\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2sva2V5c3RvcmUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBYztBQUNsQyxZQUFZLG1CQUFPLENBQUMsdUVBQWU7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUzs7QUFFNUI7QUFDQSxXQUFXLG1CQUFPLENBQUMsdUVBQWM7QUFDakMsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTSx5QkFBeUIsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPLElBQUksS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQywwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsSUFBSTtBQUN6RDtBQUNBLE1BQU0sb0JBQW9CO0FBQzFCLGVBQWUsSUFBSSxNQUFNLEtBQUs7QUFDOUI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUyxrQkFBa0IsS0FBSyxLQUFLLE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTLFdBQVcsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRztBQUMzQjtBQUNBLFVBQVUsSUFBSTtBQUNkLFVBQVUsSUFBSTtBQUNkLFVBQVUsSUFBSSxzREFBc0Q7QUFDcEUsd0JBQXdCLHlCQUF5QixJQUFJO0FBQ3JELFVBQVUsSUFBSSwyREFBMkQ7QUFDekUsd0JBQXdCO0FBQ3hCO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEIsWUFBWSxPQUFPLElBQUksS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9rZXlzdG9yZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3ay9rZXlzdG9yZS5qcyAtIEpXSyBLZXlTdG9yZSBJbXBsZW1lbnRhdGlvblxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2xvbmUgPSByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpLFxuICAgIG1lcmdlID0gcmVxdWlyZShcIi4uL3V0aWwvbWVyZ2VcIiksXG4gICAgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZVwiKSxcbiAgICB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5cbnZhciBKV0sgPSB7XG4gIEJhc2VLZXk6IHJlcXVpcmUoXCIuL2Jhc2VrZXkuanNcIiksXG4gIGhlbHBlcnM6IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIilcbn07XG5cbi8qKlxuICogQGNsYXNzIEpXSy5LZXlTdG9yZVJlZ2lzdHJ5XG4gKiBAY2xhc3NkZXNjXG4gKiBBIHJlZ2lzdHJ5IG9mIEpXSy5LZXkgdHlwZXMgdGhhdCBjYW4gYmUgdXNlZC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqICoqTk9URToqKiBUaGlzIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuIEluc3RlYWQgdXNlIHRoZVxuICogZ2xvYmFsIHtKV0sucmVnaXN0cnl9XG4gKi9cbnZhciBKV0tSZWdpc3RyeSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZXMgPSB7fTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWdpc3RlclwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAgIGlmICghZmFjdG9yeSB8fCBcInN0cmluZ1wiICE9PSB0eXBlb2YgZmFjdG9yeS5rdHkgfHwgIWZhY3Rvcnkua3R5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgS2V5IGZhY3RvcnlcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBrdHkgPSBmYWN0b3J5Lmt0eTtcbiAgICAgIHR5cGVzW2t0eV0gPSBmYWN0b3J5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidW5yZWdpc3RlclwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAgIGlmICghZmFjdG9yeSB8fCBcInN0cmluZ1wiICE9PSB0eXBlb2YgZmFjdG9yeS5rdHkgfHwgIWZhY3Rvcnkua3R5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgS2V5IGZhY3RvcnlcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBrdHkgPSBmYWN0b3J5Lmt0eTtcbiAgICAgIGlmIChmYWN0b3J5ID09PSB0eXBlc1trdHldKSB7XG4gICAgICAgIGRlbGV0ZSB0eXBlc1trdHldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihrdHkpIHtcbiAgICAgIHJldHVybiB0eXBlc1trdHkgfHwgXCJcIl0gfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsbFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHR5cGVzKS5tYXAoZnVuY3Rpb24odCkgeyByZXR1cm4gdHlwZXNbdF07IH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBHbG9iYWxzXG52YXIgR0xPQkFMX1JFR0lTVFJZID0gbmV3IEpXS1JlZ2lzdHJ5KCk7XG5cbi8vIGltcG9ydGVyXG5mdW5jdGlvbiBwcm9jZXNzQ2VydChpbnB1dCkge1xuICAvLyBjb252ZXJ0IGNlcnRJc3N1ZXIgdG8gcmVhZGFibGUgYXR0cmlidXRlc1xuICBbXCJjZXJ0SXNzdWVyXCIsIFwiY2VydFN1YmplY3RcIl0uZm9yRWFjaChmdW5jdGlvbihmaWVsZCkge1xuICAgIC8qIGVzbGludCBuZXctY2FwOiBbMF0gKi9cbiAgICB2YXIgYXR0cnMgPSBmb3JnZS5wa2kuUkROQXR0cmlidXRlc0FzQXJyYXkoaW5wdXRbZmllbGRdKTtcbiAgICB2YXIgcmVzdWx0ID0gaW5wdXRbZmllbGRdID0ge307XG4gICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICByZXN1bHRbYS5uYW1lIHx8IGEudHlwZV0gPSBhLnZhbHVlO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gaW5wdXQ7XG59XG5cbmZ1bmN0aW9uIGZyb21QRU0oaW5wdXQpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgcGVtcyA9IGZvcmdlLnBlbS5kZWNvZGUoaW5wdXQpO1xuICB2YXIgZm91bmQgPSBwZW1zLnNvbWUoZnVuY3Rpb24ocCkge1xuICAgIHN3aXRjaCAocC50eXBlKSB7XG4gICAgICBjYXNlIFwiQ0VSVElGSUNBVEVcIjpcbiAgICAgICAgcmVzdWx0LmZvcm0gPSBcInBraXhcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUFVCTElDIEtFWVwiOlxuICAgICAgICByZXN1bHQuZm9ybSA9IFwic3BraVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJQUklWQVRFIEtFWVwiOlxuICAgICAgICByZXN1bHQuZm9ybSA9IFwicGtjczhcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRUMgUFJJVkFURSBLRVlcIjpcbiAgICAgICAgLyogZXNsaW50IG5vLWZhbGx0aHJvdWdoOiBbMF0gKi9cbiAgICAgIGNhc2UgXCJSU0EgUFJJVkFURSBLRVlcIjpcbiAgICAgICAgcmVzdWx0LmZvcm0gPSBcInByaXZhdGVcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzdWx0LmJvZHkgPSBwLmJvZHk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICBpZiAoIWZvdW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwic3VwcG9ydGVkIFBFTSB0eXBlIG5vdCBmb3VuZFwiKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaW1wb3J0RnJvbShyZWdpc3RyeSwgaW5wdXQpIHtcbiAgLy8gZm9ybSBjYW4gYmUgb25lIG9mOlxuICAvLyAgJ3ByaXZhdGUnIHwgJ3BrY3M4JyB8ICdwdWJsaWMnIHwgJ3Nwa2knIHwgJ3BraXgnIHwgJ3g1MDknXG4gIHZhciBjYXB0dXJlID0ge30sXG4gICAgICBlcnJvcnMgPSBbXSxcbiAgICAgIHJlc3VsdDtcblxuICAvLyBjb252ZXIgZnJvbSBERVIgdG8gQVNOMVxuICB2YXIgZm9ybSA9IGlucHV0LmZvcm0sXG4gICAgICBkZXIgPSBpbnB1dC5ib2R5LFxuICAgICAgdGh1bWJwcmludCA9IG51bGw7XG4gIGlucHV0ID0gZm9yZ2UuYXNuMS5mcm9tRGVyKGRlcik7XG4gIHN3aXRjaChmb3JtKSB7XG4gICAgY2FzZSBcInByaXZhdGVcIjpcbiAgICAgIHJlZ2lzdHJ5LmFsbCgpLnNvbWUoZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmFjdG9yeS52YWxpZGF0b3JzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9pZCA9IGZhY3RvcnkudmFsaWRhdG9ycy5vaWQsXG4gICAgICAgICAgICB2YWxpZGF0b3IgPSBmYWN0b3J5LnZhbGlkYXRvcnMucHJpdmF0ZUtleTtcbiAgICAgICAgaWYgKCF2YWxpZGF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2FwdHVyZSA9IHt9O1xuICAgICAgICBlcnJvcnMgPSBbXTtcbiAgICAgICAgcmVzdWx0ID0gZm9yZ2UuYXNuMS52YWxpZGF0ZShpbnB1dCwgdmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgY2FwdHVyZS5rZXlPaWQgPSBmb3JnZS5hc24xLm9pZFRvRGVyKG9pZCk7XG4gICAgICAgICAgY2FwdHVyZS5wYXJzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIGNhcHR1cmUudHlwZSA9IFwicHJpdmF0ZVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInBrY3M4XCI6XG4gICAgICByZXN1bHQgPSBmb3JnZS5hc24xLnZhbGlkYXRlKGlucHV0LCBKV0suaGVscGVycy52YWxpZGF0b3JzLnByaXZhdGVLZXksIGNhcHR1cmUsIGVycm9ycyk7XG4gICAgICBjYXB0dXJlLnR5cGUgPSBcInByaXZhdGVcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwdWJsaWNcIjpcbiAgICAgIC8vIGVzbGludCBuby1mYWxsdGhyb3VnaDogWzBdICovXG4gICAgY2FzZSBcInNwa2lcIjpcbiAgICAgIHJlc3VsdCA9IGZvcmdlLmFzbjEudmFsaWRhdGUoaW5wdXQsIEpXSy5oZWxwZXJzLnZhbGlkYXRvcnMucHVibGljS2V5LCBjYXB0dXJlLCBlcnJvcnMpO1xuICAgICAgY2FwdHVyZS50eXBlID0gXCJwdWJsaWNcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwa2l4XCI6XG4gICAgICAvKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IFswXSAqL1xuICAgIGNhc2UgXCJ4NTA5XCI6XG4gICAgICByZXN1bHQgPSBmb3JnZS5hc24xLnZhbGlkYXRlKGlucHV0LCBKV0suaGVscGVycy52YWxpZGF0b3JzLmNlcnRpZmljYXRlLCBjYXB0dXJlLCBlcnJvcnMpO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBjYXB0dXJlID0gcHJvY2Vzc0NlcnQoY2FwdHVyZSk7XG4gICAgICAgIHZhciBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICAgIG1kLnVwZGF0ZShkZXIpO1xuICAgICAgICB0aHVtYnByaW50ID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKEJ1ZmZlci5mcm9tKG1kLmRpZ2VzdCgpLnRvSGV4KCksIFwiaGV4XCIpKTtcbiAgICAgIH1cbiAgICAgIGNhcHR1cmUudHlwZSA9IFwicHVibGljXCI7XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoIXJlc3VsdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gY29udmVydCBvaWRzXG4gIGlmIChjYXB0dXJlLmtleU9pZCkge1xuICAgIGNhcHR1cmUua2V5T2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmtleU9pZCk7XG4gIH1cblxuICAvLyBmaW5kIGFuZCBpbnZva2UgdGhlIGltcG9ydGVyXG4gIHJlc3VsdCA9IG51bGw7XG4gIEdMT0JBTF9SRUdJU1RSWS5hbGwoKS5mb3JFYWNoKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZmFjdG9yeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgZmFjdG9yeS5pbXBvcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzdWx0ID0gZmFjdG9yeS5pbXBvcnQoY2FwdHVyZSk7XG4gIH0pO1xuICBpZiAocmVzdWx0ICYmIGNhcHR1cmUuY2VydFN1YmplY3QgJiYgY2FwdHVyZS5jZXJ0U3ViamVjdC5jb21tb25OYW1lKSB7XG4gICAgcmVzdWx0LmtpZCA9IGNhcHR1cmUuY2VydFN1YmplY3QuY29tbW9uTmFtZTtcbiAgfVxuICBpZiAocmVzdWx0ICYmIHRodW1icHJpbnQpIHtcbiAgICByZXN1bHQueDV0ID0gdGh1bWJwcmludDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBjbGFzcyBKV0suS2V5U3RvcmVcbiAqIEBjbGFzc2Rlc2NcbiAqIFJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIEtleXMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAqKk5PVEU6KiogVGhpcyBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5LiBJbnN0ZWFkIGNhbGwge0BsaW5rXG4gKiBKV0suY3JlYXRlS2V5U3RvcmV9LlxuICovXG52YXIgSldLU3RvcmUgPSBmdW5jdGlvbihyZWdpc3RyeSwgcGFyZW50KSB7XG4gIHZhciBrZXlzZXRzID0ge307XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleVN0b3JlI2dlbmVyYXRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBHZW5lcmF0ZXMgYSBuZXcgcmFuZG9tIEtleSBpbnRvIHRoaXMgS2V5U3RvcmUuXG4gICAqXG4gICAqIFRoZSB0eXBlIG9mIHtzaXplfSBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiB7a3R5fTpcbiAgICpcbiAgICogKyAqKmBFQ2AqKjogU3RyaW5nIG5hbWluZyB0aGUgY3VydmUgdG8gdXNlLCB3aGljaCBjYW4gYmUgb25lIG9mOlxuICAgKiAgIGBcIlAtMjU2XCJgLCBgXCJQLTM4NFwiYCwgb3IgYFwiUC01MjFcImAgKGRlZmF1bHQgaXMgKipgXCJQLTI1NlwiYCoqKS5cbiAgICogKyAqKmBSU0FgKio6IE51bWJlciBkZXNjcmliaW5nIHRoZSBzaXplIG9mIHRoZSBrZXksIGluIGJpdHMgKGRlZmF1bHQgaXNcbiAgICogICAqKmAyMDQ4YCoqKS5cbiAgICogKyAqKmBvY3RgKio6IE51bWJlciBkZXNjcmliaW5nIHRoZSBzaXplIG9mIHRoZSBrZXksIGluIGJpdHMgKGRlZmF1bHQgaXNcbiAgICogICAqKmAyNTZgKiopLlxuICAgKlxuICAgKiBBbnkgcHJvcGVydGllcyBpbiB7cHJvcHN9IGFyZSBhcHBsaWVkIGJlZm9yZSB0aGUga2V5IGlzIGdlbmVyYXRlZCxcbiAgICogYW5kIGFyZSBleHBlY3RlZCB0byBiZSBkYXRhIHR5cGVzIGFjY2VwdGFibGUgaW4gSlNPTi4gIFRoaXMgYWxsb3dzIHRoZVxuICAgKiBnZW5lcmF0ZWQga2V5IHRvIGhhdmUgYSBzcGVjaWZpYyBrZXkgaWRlbnRpZmllciwgb3IgdG8gc3BlY2lmeSBpdHNcbiAgICogYWNjZXB0YWJsZSB1c2FnZS5cbiAgICpcbiAgICogVGhlIHJldHVybmVkIFByb21pc2UsIHdoZW4gZnVsZmlsbGVkLCByZXR1cm5zIHRoZSBnZW5lcmF0ZWQgS2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga3R5IFRoZSB0eXBlIG9mIGdlbmVyYXRlZCBrZXlcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbc2l6ZV0gVGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBrZXlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGFwcGx5IHRvIHRoZSBnZW5lcmF0ZWRcbiAgICogICAgICAgIGtleS5cbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgZ2VuZXJhdGVkIEtleVxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYge2t0eX0gaXMgbm90IHN1cHBvcnRlZFxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2VuZXJhdGVcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihrdHksIHNpemUsIHByb3BzKSB7XG4gICAgICB2YXIga2V5dHlwZSA9IHJlZ2lzdHJ5LmdldChrdHkpO1xuICAgICAgaWYgKCFrZXl0eXBlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXkgdHlwZVwiKSk7XG4gICAgICB9XG5cbiAgICAgIHByb3BzID0gY2xvbmUocHJvcHMgfHwge30pO1xuICAgICAgcHJvcHMua3R5ID0ga3R5O1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgcHJvbWlzZSA9IGtleXR5cGUuZ2VuZXJhdGUoc2l6ZSk7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3aykge1xuICAgICAgICBqd2sgPSBtZXJnZShwcm9wcywgandrLCB7XG4gICAgICAgICAga3R5OiBrdHlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZWxmLmFkZChqd2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleVN0b3JlI2FkZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQWRkcyBhIEtleSB0byB0aGlzIEtleVN0b3JlLiBJZiB7andrfSBpcyBhIHN0cmluZywgaXQgaXMgZmlyc3RcbiAgICogcGFyc2VkIGludG8gYSBwbGFpbiBKU09OIG9iamVjdC4gSWYge2p3a30gaXMgYWxyZWFkeSBhbiBpbnN0YW5jZVxuICAgKiBvZiBKV0suS2V5LCBpdHMgKHB1YmxpYykgSlNPTiByZXByZXNlbnRhdGlvbiBpcyBmaXJzdCBvYnRhaW5lZFxuICAgKiB0aGVuIGFwcGxpZWQgdG8gYSBuZXcgSldLLktleSBvYmplY3Qgd2l0aGluIHRoaXMgS2V5U3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gandrIFRoZSBKU09OIFdlYiBLZXkgKEpXSylcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtmb3JtXSBUaGUgZm9ybWF0IG9mIGEgU3RyaW5nIGtleSB0byBleHBlY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRyYXNdIGV4dHJhIGp3ayBmaWVsZHMgaW5zZXJ0ZWQgd2hlbiBpbXBvcnRpbmcgZnJvbSBhIG5vbiBqc29uIHN0cmluZyAoZWcgXCJwZW1cIilcbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgYWRkZWQga2V5XG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhZGRcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihqd2ssIGZvcm0sIGV4dHJhcykge1xuICAgICAgZXh0cmFzID0gZXh0cmFzIHx8IHt9O1xuXG4gICAgICB2YXIgZmFjdG9ycztcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoandrKSB8fCB0eXBlb2YgandrID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIGZvcm0gY2FuIGJlICdqc29uJywgJ3BrY3M4JywgJ3Nwa2knLCAncGtpeCcsICd4NTA5JywgJ3BlbSdcbiAgICAgICAgZm9ybSA9IChmb3JtIHx8IFwianNvblwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXCJqc29uXCIgPT09IGZvcm0pIHtcbiAgICAgICAgICBqd2sgPSBKU09OLnBhcnNlKGp3ay50b1N0cmluZyhcInV0ZjhcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoXCJwZW1cIiA9PT0gZm9ybSkge1xuICAgICAgICAgICAgICAvLyBjb252ZXJ0ICpmaXJzdCogUEVNIC0+IERFUlxuICAgICAgICAgICAgICBmYWN0b3JzID0gZnJvbVBFTShqd2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmFjdG9ycyA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiBqd2sudG9TdHJpbmcoXCJiaW5hcnlcIiksXG4gICAgICAgICAgICAgICAgZm9ybTogZm9ybVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgandrID0gaW1wb3J0RnJvbShyZWdpc3RyeSwgZmFjdG9ycyk7XG4gICAgICAgICAgICBpZiAoIWp3aykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBpbXBvcnRlciBmb3Iga2V5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoZXh0cmFzKS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgICAgICAgandrW2ZpZWxkXSA9IGV4dHJhc1tmaWVsZF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChKV0tTdG9yZS5pc0tleShqd2spKSB7XG4gICAgICAgIC8vIGFzc3VtZSBhIGNvbXBsZXRlIGR1cGxpY2F0ZSBpcyBkZXNpcmVkXG4gICAgICAgIGp3ayA9IGp3ay50b0pTT04odHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqd2sgPSBjbG9uZShqd2spO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5dHlwZSA9IHJlZ2lzdHJ5LmdldChqd2sua3R5KTtcbiAgICAgIGlmICgha2V5dHlwZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5IHR5cGVcIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgcHJvbWlzZSA9IGtleXR5cGUucHJlcGFyZShqd2spO1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihjZmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKV0suQmFzZUtleShqd2sua3R5LCBzZWxmLCBqd2ssIGNmZyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKGp3aykge1xuICAgICAgICB2YXIga2lkID0gandrLmtpZCB8fCBcIlwiO1xuICAgICAgICB2YXIga2V5cyA9IGtleXNldHNba2lkXSA9IGtleXNldHNba2lkXSB8fCBbXTtcbiAgICAgICAga2V5cy5wdXNoKGp3ayk7XG5cbiAgICAgICAgcmV0dXJuIGp3aztcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXlTdG9yZSNyZW1vdmVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJlbW92ZXMgYSBLZXkgZnJvbSB0aGlzIEtleVN0b3JlLlxuICAgKlxuICAgKiAqKk5PVEU6KiogVGhlIHJlbW92ZWQgS2V5J3Mge2tleXN0b3JlfSBwcm9wZXJ0eSBpcyBub3QgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtKV0suS2V5fSBqd2sgVGhlIGtleSB0byByZW1vdmUuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZW1vdmVcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihqd2spIHtcbiAgICAgIGlmICghandrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXMgPSBrZXlzZXRzW2p3ay5raWRdO1xuICAgICAgaWYgKCFrZXlzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvcyA9IGtleXMuaW5kZXhPZihqd2spO1xuICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBrZXlzLnNwbGljZShwb3MsIDEpO1xuICAgICAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUga2V5c2V0c1tqd2sua2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXlTdG9yZSNhbGxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHJpZXZlcyBhbGwgb2YgdGhlIGNvbnRhaW5lZCBLZXlzIHRoYXQgb3B0aW5hbGx5IG1hdGNoIGFsbCBvZiB0aGVcbiAgICogZ2l2ZW4gcHJvcGVydGllcy5cbiAgICpcbiAgICogSWYge3Byb3BzfSBhcmUgc3BlY2lmaWVkLCB0aGlzIG1ldGhvZCBvbmx5IHJldHVybnMgS2V5cyB3aGljaCBleGFjdGx5XG4gICAqIG1hdGNoIHRoZSBnaXZlbiBwcm9wZXJ0aWVzLiBUaGUgcHJvcGVydGllcyBjYW4gYmUgYW55IG9mIHRoZVxuICAgKiBmb2xsb3dpbmc6XG4gICAqXG4gICAqICsgKiphbGcqKjogVGhlIGFsZ29yaXRobSBmb3IgdGhlIEtleS5cbiAgICogKyAqKnVzZSoqOiBUaGUgdXNhZ2UgZm9yIHRoZSBLZXkuXG4gICAqICsgKipraWQqKjogVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBLZXkuXG4gICAqXG4gICAqIElmIG5vIHByb3BlcnRpZXMgYXJlIGdpdmVuLCB0aGlzIG1ldGhvZCByZXR1cm5zIGFsbCBvZiB0aGUgS2V5cyBmb3IgdGhpc1xuICAgKiBLZXlTdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gVGhlIHByb3BlcnRpZXMgdG8gbWF0Y2ggYWdhaW5zdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb2NhbCA9IGZhbHNlXSBgdHJ1ZWAgaWYgb25seSB0aGUgS2V5c1xuICAgKiAgICAgICAgZGlyZWN0bHkgY29udGFpbmVkIGJ5IHRoaXMgS2V5U3RvcmUgc2hvdWxkIGJlIHJldHVybmVkLCBvclxuICAgKiAgICAgICAgYGZhbHNlYCBpZiBpdCBzaG91bGQgcmV0dXJuIGFsbCBLZXlzIG9mIHRoaXMgS2V5U3RvcmUgYW5kXG4gICAqICAgICAgICBpdHMgYW5jZXN0b3JzLlxuICAgKiBAcmV0dXJucyB7SldLLktleVtdfSBUaGUgbGlzdCBvZiBtYXRjaGluZyBLZXlzLCBvciBhbiBlbXB0eSBhcnJheSBpZiBub1xuICAgKiAgICAgICAgICBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsbFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKHByb3BzLCBsb2NhbCkge1xuICAgICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaXNzdWVzLzEwOVxuICAgICAgaWYgKHByb3BzLmtpZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmtpZCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcHMua2lkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHByb3BzLmtpZCA9IFN0cmluZyhwcm9wcy5raWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FuZGlkYXRlcyA9IFtdO1xuICAgICAgdmFyIG1hdGNoZXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgLy8gbWF0Y2ggb24gJ2t0eSdcbiAgICAgICAgaWYgKHByb3BzLmt0eSAmJlxuICAgICAgICAgICAga2V5Lmt0eSAmJlxuICAgICAgICAgICAgcHJvcHMua3R5ICE9PSBrZXkua3R5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1hdGNoIG9uICd1c2UnXG4gICAgICAgIGlmIChwcm9wcy51c2UgJiZcbiAgICAgICAgICAgIGtleS51c2UgJiZcbiAgICAgICAgICAgIHByb3BzLnVzZSAhPT0ga2V5LnVzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXRjaCBvbiAnYWxnJ1xuICAgICAgICBpZiAocHJvcHMuYWxnKSB7XG4gICAgICAgICAgaWYgKHByb3BzLmFsZyAhPT0gXCJkaXJcIiAmJlxuICAgICAgICAgICAgICBrZXkuYWxnICYmXG4gICAgICAgICAgICAgIHByb3BzLmFsZyAhPT0ga2V5LmFsZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ga2V5LnN1cHBvcnRzKHByb3BzLmFsZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy9UT0RPOiBtYXRjaCBvbiAna2V5X29wcydcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBPYmplY3Qua2V5cyhrZXlzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmIChwcm9wcy5raWQgJiYgcHJvcHMua2lkICE9PSBpZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXlzID0ga2V5c2V0c1tpZF0uZmlsdGVyKG1hdGNoZXMpO1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5jb25jYXQoa2V5cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWxvY2FsICYmIHBhcmVudCkge1xuICAgICAgICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5jb25jYXQocGFyZW50LmFsbChwcm9wcykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FuZGlkYXRlcztcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5U3RvcmUjZ2V0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXRyaWV2ZXMgdGhlIGNvbnRhaW5lZCBLZXkgbWF0Y2hpbmcgdGhlIGdpdmVuIHtraWR9LCBhbmQgb3B0aW9uYWxseVxuICAgKiBhbGwgb2YgdGhlIGdpdmVuIHByb3BlcnRpZXMuICBUaGlzIG1ldGhvZCBlcXVpdmFsZW50IHRvIGNhbGxpbmdcbiAgICoge0BsaW5rIEpXSy5TdG9yZSNhbGx9LCB0aGVuIHJldHVybmluZyB0aGUgZmlyc3QgS2V5IHdob3NlXG4gICAqIFwia2lkXCIgaXMge2tpZH0uIElmIHtraWR9IGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgZmlyc3QgS2V5IHRoYXRcbiAgICogaXMgcmV0dXJuZWQgZnJvbSBgYWxsKClgIGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tpZF0gVGhlIGtleSBpZGVudGlmaWVyIHRvIG1hdGNoIGFnYWluc3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIFRoZSBwcm9wZXJ0aWVzIHRvIG1hdGNoIGFnYWluc3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xvY2FsID0gZmFsc2VdIGB0cnVlYCBpZiBvbmx5IHRoZSBLZXlzXG4gICAqICAgICAgICBkaXJlY3RseSBjb250YWluZWQgYnkgdGhpcyBLZXlTdG9yZSBzaG91bGQgYmUgcmV0dXJuZWQsIG9yXG4gICAqICAgICAgICBgZmFsc2VgIGlmIGl0IHNob3VsZCByZXR1cm4gYWxsIEtleXMgb2YgdGhpcyBLZXlTdG9yZSBhbmRcbiAgICogICAgICAgIGl0cyBhbmNlc3RvcnMuXG4gICAqIEByZXR1cm5zIHtKV0suS2V5fSBUaGUgS2V5IG1hdGNoaW5nIHtraWR9IGFuZCB7cHJvcHN9LCBvciBgbnVsbGBcbiAgICogICAgICAgICAgaWYgbm8gbWF0Y2ggaXMgZm91bmQuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihraWQsIHByb3BzLCBsb2NhbCkge1xuICAgICAgLy8gcmVjb25jaWxlIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBraWQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIGxvY2FsID0ga2lkO1xuICAgICAgICBwcm9wcyA9IGtpZCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBraWQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbG9jYWwgPSBwcm9wcztcbiAgICAgICAgcHJvcHMgPSBraWQ7XG4gICAgICAgIGtpZCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpeHVwIHByb3BzXG4gICAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgICAgaWYgKGtpZCkge1xuICAgICAgICBwcm9wcy5raWQgPSBraWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIGlzc3Vlcy8xMDlcbiAgICAgIGlmIChwcm9wcy5raWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5raWQgIT09IG51bGwgJiYgdHlwZW9mIHByb3BzLmtpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgIHByb3BzLmtpZCA9IFN0cmluZyhwcm9wcy5raWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FuZGlkYXRlcyA9IHRoaXMuYWxsKHByb3BzLCB0cnVlKTtcbiAgICAgIGlmICghY2FuZGlkYXRlcy5sZW5ndGggJiYgcGFyZW50ICYmICFsb2NhbCkge1xuICAgICAgICBjYW5kaWRhdGVzID0gcGFyZW50LmdldChwcm9wcywgbG9jYWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbmRpZGF0ZXNbMF0gfHwgbnVsbDtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXlTdG9yZSN0ZW1wXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDcmVhdGVzIGEgdGVtcG9yYXJ5IEtleVN0b3JlIGJhc2VkIG9uIHRoaXMgS2V5U3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtKV0suS2V5U3RvcmV9IFRoZSB0ZW1wb3JhcnkgS2V5U3RvcmUuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZW1wXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IEpXS1N0b3JlKHJlZ2lzdHJ5LCB0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXlTdG9yZSN0b0pTT05cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEdlbmVyYXRlcyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBLZXlTdG9yZSwgd2hpY2ggY29uZm9ybXNcbiAgICogdG8gYSBKV0sgU2V0IGZyb20ge0ktRC5pZXRmLWpvc2UtanNvbi13ZWIta2V5fS5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNQcml2YXRlID0gZmFsc2VdIGB0cnVlYCBpZiB0aGUgcHJpdmF0ZSBmaWVsZHNcbiAgICogICAgICAgIG9mIHN0b3JlZCBrZXlzIGFyZSB0byBiZSBpbmNsdWRlZC5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBLZXlTdG9yZS5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvSlNPTlwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGlzUHJpdmF0ZSkge1xuICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgT2JqZWN0LmtleXMoa2V5c2V0cykuZm9yRWFjaChmdW5jdGlvbihraWQpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0ga2V5c2V0c1traWRdLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgcmV0dXJuIGsudG9KU09OKGlzUHJpdmF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoaXRlbXMpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleXM6IGtleXNcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIEpXSy5LZXlTdG9yZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gdGVzdFxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB7b2JqfSBpcyBhbiBpbnN0YW5jZSBvZiBKV0suS2V5U3RvcmUsXG4gKiAgICAgICAgICBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbkpXS1N0b3JlLmlzS2V5U3RvcmUgPSBmdW5jdGlvbihvYmopIHtcbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9iaikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBvYmouZ2V0IHx8XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBvYmouYWxsIHx8XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBvYmouZ2VuZXJhdGUgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai5hZGQgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai5yZW1vdmUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBlbXB0eSBLZXlTdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7SldLLktleVN0b3JlfSBUaGUgZW1wdHkgS2V5U3RvcmUuXG4gKi9cbkpXS1N0b3JlLmNyZWF0ZUtleVN0b3JlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgSldLU3RvcmUoR0xPQkFMX1JFR0lTVFJZKTtcbn07XG5cbi8qKlxuICogQ29lcmNlcyB0aGUgZ2l2ZW4gb2JqZWN0IGludG8gYSBLZXlTdG9yZS4gVGhpcyBtZXRob2QgdXNlcyB0aGUgZm9sbG93aW5nXG4gKiBhbGdvcml0aG0gdG8gY29lcmNlIHtrc306XG4gKlxuICogMS4gaWYge2tzfSBpcyBhbiBpbnN0YW5jZSBvZiBKV0suS2V5U3RvcmUsIGl0IGlzIHJldHVybmVkIGRpcmVjdGx5XG4gKiAyLiBpZiB7a3N9IGlzIGEgc3RyaW5nLCBpdCBpcyBwYXJzZWQgaW50byBhIEpTT04gdmFsdWVcbiAqIDMuIGlmIHtrc30gaXMgYW4gYXJyYXksIGl0IGNyZWF0ZXMgYSBuZXcgSldLLktleVN0b3JlIGFuZCBjYWxscyB7QGxpbmtcbiAqICAgIEpXSy5LZXlTdG9yZSNhZGR9IGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHtrc30gYXJyYXkuXG4gKiA0LiBpZiB7a3N9IGlzIGEgSlNPTiBvYmplY3QsIGl0IGNyZWF0ZXMgYSBuZXcgSldLLktleVN0b3JlIGFuZCBjYWxscyB7QGxpbmtcbiAqICAgIEpXSy5LZXlTdG9yZSNhZGR9IGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIFwia2V5c1wiIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30ga3MgVGhlIHZhbHVlIHRvIGNvZXJjZSBpbnRvIGFcbiAqICAgICAgICBLZXlTdG9yZVxuICogQHJldHVybnMge1Byb21pc2UoSldLLktleVN0b3JlKX0gQSBwcm9taXNlIGZvciB0aGUgY29lcmNlZCBLZXlTdG9yZS5cbiAqL1xuSldLU3RvcmUuYXNLZXlTdG9yZSA9IGZ1bmN0aW9uKGtzKSB7XG4gIGlmIChKV0tTdG9yZS5pc0tleVN0b3JlKGtzKSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa3MpO1xuICB9XG5cbiAgdmFyIHN0b3JlID0gSldLU3RvcmUuY3JlYXRlS2V5U3RvcmUoKSxcbiAgICAgIGtleXM7XG5cbiAgaWYgKHR5cGVvZiBrcyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGtzID0gSlNPTi5wYXJzZShrcyk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShrcykpIHtcbiAgICBrZXlzID0ga3M7XG4gIH0gZWxzZSBpZiAoXCJrZXlzXCIgaW4ga3MpIHtcbiAgICBrZXlzID0ga3Mua2V5cztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBrZXlzdG9yZVwiKSk7XG4gIH1cblxuICBrZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBzdG9yZS5hZGQoayk7XG4gIH0pO1xuXG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5hbGwoa2V5cyk7XG4gIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0b3JlO1xuICB9KTtcblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBKV0suS2V5IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byB0ZXN0XG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYge29ian0gaXMgYSBKV0suS2V5XG4gKi9cbkpXS1N0b3JlLmlzS2V5ID0gZnVuY3Rpb24ob2JqKSB7XG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmopIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIUpXS1N0b3JlLmlzS2V5U3RvcmUob2JqLmtleXN0b3JlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygb2JqLmt0eSB8fFxuICAgICAgXCJudW1iZXJcIiAhPT0gdHlwZW9mIG9iai5sZW5ndGggfHxcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai5hbGdvcml0aG1zIHx8XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBvYmouc3VwcG9ydHMgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai5lbmNyeXB0IHx8XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBvYmouZGVjcnlwdCB8fFxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLndyYXAgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai51bndyYXAgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai5zaWduIHx8XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBvYmoudmVyaWZ5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcga2V5IHdpdGggdGhlIGdpdmVuIHByb3BlcnRpZXMuICBUaGlzIG1ldGhvZCBpcyBhIGNvbnZlbmllbmNlXG4gKiB0byBjYWxsaW5nIGBKV0suY3JlYXRlS2V5U3RvcmUoKWAgdGhlbiBgZ2VuZXJhdGUoKWAgb24gdGhlIHJldHVybmVkIGtleXN0b3JlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrdHkgVGhlIHR5cGUgb2YgZ2VuZXJhdGVkIGtleVxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbc2l6ZV0gVGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIEFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBhcHBseSB0byB0aGUgZ2VuZXJhdGVkXG4gKiAgICAgICAga2V5LlxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgZ2VuZXJhdGVkIEtleVxuICogQHRocm93cyB7RXJyb3J9IElmIHtrdHl9IGlzIG5vdCBzdXBwb3J0ZWRcbiAqIEBzZWUgSldLU3RvcmUjZ2VuZXJhdGVcbiAqL1xuSldLU3RvcmUuY3JlYXRlS2V5ID0gZnVuY3Rpb24oa3R5LCBzaXplLCBwcm9wcykge1xuICB2YXIga3MgPSBKV0tTdG9yZS5jcmVhdGVLZXlTdG9yZSgpO1xuICByZXR1cm4ga3MuZ2VuZXJhdGUoa3R5LCBzaXplLCBwcm9wcyk7XG59XG5cbi8qKlxuICogQ29lcmNlcyB0aGUgZ2l2ZW4gb2JqZWN0IGludG8gYSBLZXkuIElmIHtrZXl9IGlzIGFuIGluc3RhbmNlIG9mIEpXSy5LZXksXG4gKiBpdCBpcyByZXR1cm5lZCBkaXJlY3RseS4gT3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCBmaXJzdCBjcmVhdGVzIGEgbmV3XG4gKiBKV0suS2V5U3RvcmUgYW5kIGNhbGxzIHtAbGluayBKV0suS2V5U3RvcmUjYWRkfSBvbiB0aGlzIG5ldyBLZXlTdG9yZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGtleSBUaGUgdmFsdWUgdG8gY29lcmNlIGludG8gYSBLZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZm9ybV0gVGhlIGZvcm1hdCBvZiBhIFN0cmluZyBLZXkgdG8gZXhwZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gW2V4dHJhc10gZXh0cmEgandrIGZpZWxkcyBpbnNlcnRlZCB3aGVuIGltcG9ydGluZyBmcm9tIGEgbm9uIGpzb24gc3RyaW5nIChlZyBcInBlbVwiKVxuICogQHJldHVybnMge1Byb21pc2UoSldLLktleSl9IEEgcHJvbWlzZSBmb3IgdGhlIGNvZXJjZWQgS2V5LlxuICovXG5KV0tTdG9yZS5hc0tleSA9IGZ1bmN0aW9uKGtleSwgZm9ybSwgZXh0cmFzKSB7XG4gIGlmIChKV0tTdG9yZS5pc0tleShrZXkpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXkpO1xuICB9XG5cbiAgdmFyIGtzID0gSldLU3RvcmUuY3JlYXRlS2V5U3RvcmUoKTtcbiAga2V5ID0ga3MuYWRkKGtleSwgZm9ybSwgZXh0cmFzKTtcblxuICByZXR1cm4ga2V5O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtleVJlZ2lzdHJ5OiBKV0tSZWdpc3RyeSxcbiAgS2V5U3RvcmU6IEpXS1N0b3JlLFxuICByZWdpc3RyeTogR0xPQkFMX1JFR0lTVFJZXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/octkey.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/octkey.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/octkey.js - Symmetric Octet Key Representation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\nvar JWK = {\n  BaseKey: __webpack_require__(/*! ./basekey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\"),\n  helpers: __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\")\n};\n\nvar SIG_ALGS = [\n  \"HS256\",\n  \"HS384\",\n  \"HS512\"\n];\nvar ENC_ALGS = [\n  \"A128GCM\",\n  \"A192GCM\",\n  \"A256GCM\",\n  \"A128CBC-HS256\",\n  \"A192CBC-HS384\",\n  \"A256CBC-HS512\",\n  \"A128CBC+HS256\",\n  \"A192CBC+HS384\",\n  \"A256CBC+HS512\"\n];\nvar WRAP_ALGS = [\n  \"A128KW\",\n  \"A192KW\",\n  \"A256KW\",\n  \"A128GCMKW\",\n  \"A192GCMKW\",\n  \"A256GCMKW\",\n  \"PBES2-HS256+A128KW\",\n  \"PBES2-HS384+A192KW\",\n  \"PBES2-HS512+A256KW\",\n  \"dir\"\n];\n\nfunction adjustDecryptProps(alg, props) {\n  if (\"iv\" in props) {\n    props.iv = Buffer.isBuffer(props.iv) ?\n               props.iv :\n               util.base64url.decode(props.iv || \"\");\n  }\n  if (\"adata\" in props) {\n    props.adata = Buffer.isBuffer(props.adata) ?\n                  props.adata :\n                  Buffer.from(props.adata || \"\", \"utf8\");\n  }\n  if (\"mac\" in props) {\n    props.mac = Buffer.isBuffer(props.mac) ?\n                props.mac :\n                util.base64url.decode(props.mac || \"\");\n  }\n  if (\"tag\" in props) {\n    props.tag = Buffer.isBuffer(props.tag) ?\n                props.tag :\n                util.base64url.decode(props.tag || \"\");\n  }\n\n  return props;\n}\nfunction adjustEncryptProps(alg, props) {\n  if (\"iv\" in props) {\n    props.iv = Buffer.isBuffer(props.iv) ?\n               props.iv :\n               util.base64url.decode(props.iv || \"\");\n  }\n  if (\"adata\" in props) {\n    props.adata = Buffer.isBuffer(props.adata) ?\n                  props.adata :\n                  Buffer.from(props.adata || \"\", \"utf8\");\n  }\n\n  return props;\n}\n\nvar JWKOctetCfg = {\n  publicKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n    ]);\n\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n\n    return pk;\n  },\n  privateKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"k\", type: \"binary\"}\n    ]);\n\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.k) {\n      pk.length = pk.k.length * 8;\n    } else {\n      pk = undefined;\n    }\n\n    return pk;\n  },\n\n  thumbprint: function(json) {\n    if (json.private) {\n      json = json.private;\n    }\n    var fields;\n    fields = {\n      k: json.k || \"\",\n      kty: \"oct\"\n    };\n    return fields;\n  },\n  algorithms: function(keys, mode) {\n    var len = keys.private && (keys.private.k.length * 8);\n    var mins = [256, 384, 512];\n\n    if (!len) {\n      return [];\n    }\n    switch (mode) {\n      case \"encrypt\":\n      case \"decrypt\":\n        return ENC_ALGS.filter(function(a) {\n          return (a === (\"A\" + (len / 2) + \"CBC-HS\" + len)) ||\n                 (a === (\"A\" + (len / 2) + \"CBC+HS\" + len)) ||\n                 (a === (\"A\" + len + \"GCM\"));\n        });\n      case \"sign\":\n      case \"verify\":\n        // TODO: allow for HS{less-than-keysize}\n        return SIG_ALGS.filter(function(a) {\n          var result = false;\n          mins.forEach(function(m) {\n            if (m > len) { return; }\n            result = result | (a === (\"HS\" + m));\n          });\n          return result;\n        });\n      case \"wrap\":\n      case \"unwrap\":\n        return WRAP_ALGS.filter(function(a) {\n          return (a === (\"A\" + len + \"KW\")) ||\n                 (a === (\"A\" + len + \"GCMKW\")) ||\n                 (a.indexOf(\"PBES2-\") === 0) ||\n                 (a === \"dir\");\n        });\n    }\n\n    return [];\n  },\n  encryptKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  encryptProps: adjustEncryptProps,\n\n  decryptKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  decryptProps: adjustDecryptProps,\n\n  wrapKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  wrapProps: adjustEncryptProps,\n\n  unwrapKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  unwrapProps: adjustDecryptProps,\n\n  signKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  verifyKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  }\n};\n\n// Factory\nvar JWKOctetFactory = {\n  kty: \"oct\",\n  prepare: function(props) {\n    // TODO: validate key properties\n    var cfg = JWKOctetCfg;\n    var p = Promise.resolve(props);\n    p = p.then(function(json) {\n      return JWK.helpers.thumbprint(cfg, json);\n    });\n    p = p.then(function(hash) {\n      var prints = {};\n      prints[JWK.helpers.INTERNALS.THUMBPRINT_HASH] = hash;\n      props[JWK.helpers.INTERNALS.THUMBPRINT_KEY] = prints;\n      return cfg;\n    });\n    return p;\n  },\n  generate: function(size) {\n    // TODO: validate key sizes\n    var key = util.randomBytes(size / 8);\n\n    return Promise.resolve({\n      k: key\n    });\n  }\n};\n\n// public API\nmodule.exports = Object.freeze({\n  config: JWKOctetCfg,\n  factory: JWKOctetFactory\n});\n\n// registration\n(function(REGISTRY) {\n  REGISTRY.register(JWKOctetFactory);\n})((__webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\").registry));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svb2N0a2V5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsaUVBQVM7O0FBRTVCO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyx1RUFBYztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsc0dBQThCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9vY3RrZXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd2svb2N0a2V5LmpzIC0gU3ltbWV0cmljIE9jdGV0IEtleSBSZXByZXNlbnRhdGlvblxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuXG52YXIgSldLID0ge1xuICBCYXNlS2V5OiByZXF1aXJlKFwiLi9iYXNla2V5LmpzXCIpLFxuICBoZWxwZXJzOiByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpXG59O1xuXG52YXIgU0lHX0FMR1MgPSBbXG4gIFwiSFMyNTZcIixcbiAgXCJIUzM4NFwiLFxuICBcIkhTNTEyXCJcbl07XG52YXIgRU5DX0FMR1MgPSBbXG4gIFwiQTEyOEdDTVwiLFxuICBcIkExOTJHQ01cIixcbiAgXCJBMjU2R0NNXCIsXG4gIFwiQTEyOENCQy1IUzI1NlwiLFxuICBcIkExOTJDQkMtSFMzODRcIixcbiAgXCJBMjU2Q0JDLUhTNTEyXCIsXG4gIFwiQTEyOENCQytIUzI1NlwiLFxuICBcIkExOTJDQkMrSFMzODRcIixcbiAgXCJBMjU2Q0JDK0hTNTEyXCJcbl07XG52YXIgV1JBUF9BTEdTID0gW1xuICBcIkExMjhLV1wiLFxuICBcIkExOTJLV1wiLFxuICBcIkEyNTZLV1wiLFxuICBcIkExMjhHQ01LV1wiLFxuICBcIkExOTJHQ01LV1wiLFxuICBcIkEyNTZHQ01LV1wiLFxuICBcIlBCRVMyLUhTMjU2K0ExMjhLV1wiLFxuICBcIlBCRVMyLUhTMzg0K0ExOTJLV1wiLFxuICBcIlBCRVMyLUhTNTEyK0EyNTZLV1wiLFxuICBcImRpclwiXG5dO1xuXG5mdW5jdGlvbiBhZGp1c3REZWNyeXB0UHJvcHMoYWxnLCBwcm9wcykge1xuICBpZiAoXCJpdlwiIGluIHByb3BzKSB7XG4gICAgcHJvcHMuaXYgPSBCdWZmZXIuaXNCdWZmZXIocHJvcHMuaXYpID9cbiAgICAgICAgICAgICAgIHByb3BzLml2IDpcbiAgICAgICAgICAgICAgIHV0aWwuYmFzZTY0dXJsLmRlY29kZShwcm9wcy5pdiB8fCBcIlwiKTtcbiAgfVxuICBpZiAoXCJhZGF0YVwiIGluIHByb3BzKSB7XG4gICAgcHJvcHMuYWRhdGEgPSBCdWZmZXIuaXNCdWZmZXIocHJvcHMuYWRhdGEpID9cbiAgICAgICAgICAgICAgICAgIHByb3BzLmFkYXRhIDpcbiAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKHByb3BzLmFkYXRhIHx8IFwiXCIsIFwidXRmOFwiKTtcbiAgfVxuICBpZiAoXCJtYWNcIiBpbiBwcm9wcykge1xuICAgIHByb3BzLm1hYyA9IEJ1ZmZlci5pc0J1ZmZlcihwcm9wcy5tYWMpID9cbiAgICAgICAgICAgICAgICBwcm9wcy5tYWMgOlxuICAgICAgICAgICAgICAgIHV0aWwuYmFzZTY0dXJsLmRlY29kZShwcm9wcy5tYWMgfHwgXCJcIik7XG4gIH1cbiAgaWYgKFwidGFnXCIgaW4gcHJvcHMpIHtcbiAgICBwcm9wcy50YWcgPSBCdWZmZXIuaXNCdWZmZXIocHJvcHMudGFnKSA/XG4gICAgICAgICAgICAgICAgcHJvcHMudGFnIDpcbiAgICAgICAgICAgICAgICB1dGlsLmJhc2U2NHVybC5kZWNvZGUocHJvcHMudGFnIHx8IFwiXCIpO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufVxuZnVuY3Rpb24gYWRqdXN0RW5jcnlwdFByb3BzKGFsZywgcHJvcHMpIHtcbiAgaWYgKFwiaXZcIiBpbiBwcm9wcykge1xuICAgIHByb3BzLml2ID0gQnVmZmVyLmlzQnVmZmVyKHByb3BzLml2KSA/XG4gICAgICAgICAgICAgICBwcm9wcy5pdiA6XG4gICAgICAgICAgICAgICB1dGlsLmJhc2U2NHVybC5kZWNvZGUocHJvcHMuaXYgfHwgXCJcIik7XG4gIH1cbiAgaWYgKFwiYWRhdGFcIiBpbiBwcm9wcykge1xuICAgIHByb3BzLmFkYXRhID0gQnVmZmVyLmlzQnVmZmVyKHByb3BzLmFkYXRhKSA/XG4gICAgICAgICAgICAgICAgICBwcm9wcy5hZGF0YSA6XG4gICAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShwcm9wcy5hZGF0YSB8fCBcIlwiLCBcInV0ZjhcIik7XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59XG5cbnZhciBKV0tPY3RldENmZyA9IHtcbiAgcHVibGljS2V5OiBmdW5jdGlvbihwcm9wcykge1xuICAgIHZhciBmaWVsZHMgPSBKV0suaGVscGVycy5DT01NT05fUFJPUFMuY29uY2F0KFtcbiAgICBdKTtcblxuICAgIHZhciBwaztcbiAgICBwayA9IEpXSy5oZWxwZXJzLnVucGFja1Byb3BzKHByb3BzLCBmaWVsZHMpO1xuXG4gICAgcmV0dXJuIHBrO1xuICB9LFxuICBwcml2YXRlS2V5OiBmdW5jdGlvbihwcm9wcykge1xuICAgIHZhciBmaWVsZHMgPSBKV0suaGVscGVycy5DT01NT05fUFJPUFMuY29uY2F0KFtcbiAgICAgIHtuYW1lOiBcImtcIiwgdHlwZTogXCJiaW5hcnlcIn1cbiAgICBdKTtcblxuICAgIHZhciBwaztcbiAgICBwayA9IEpXSy5oZWxwZXJzLnVucGFja1Byb3BzKHByb3BzLCBmaWVsZHMpO1xuICAgIGlmIChwayAmJiBway5rKSB7XG4gICAgICBway5sZW5ndGggPSBway5rLmxlbmd0aCAqIDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBwaztcbiAgfSxcblxuICB0aHVtYnByaW50OiBmdW5jdGlvbihqc29uKSB7XG4gICAgaWYgKGpzb24ucHJpdmF0ZSkge1xuICAgICAganNvbiA9IGpzb24ucHJpdmF0ZTtcbiAgICB9XG4gICAgdmFyIGZpZWxkcztcbiAgICBmaWVsZHMgPSB7XG4gICAgICBrOiBqc29uLmsgfHwgXCJcIixcbiAgICAgIGt0eTogXCJvY3RcIlxuICAgIH07XG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfSxcbiAgYWxnb3JpdGhtczogZnVuY3Rpb24oa2V5cywgbW9kZSkge1xuICAgIHZhciBsZW4gPSBrZXlzLnByaXZhdGUgJiYgKGtleXMucHJpdmF0ZS5rLmxlbmd0aCAqIDgpO1xuICAgIHZhciBtaW5zID0gWzI1NiwgMzg0LCA1MTJdO1xuXG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIFwiZW5jcnlwdFwiOlxuICAgICAgY2FzZSBcImRlY3J5cHRcIjpcbiAgICAgICAgcmV0dXJuIEVOQ19BTEdTLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgICAgICAgcmV0dXJuIChhID09PSAoXCJBXCIgKyAobGVuIC8gMikgKyBcIkNCQy1IU1wiICsgbGVuKSkgfHxcbiAgICAgICAgICAgICAgICAgKGEgPT09IChcIkFcIiArIChsZW4gLyAyKSArIFwiQ0JDK0hTXCIgKyBsZW4pKSB8fFxuICAgICAgICAgICAgICAgICAoYSA9PT0gKFwiQVwiICsgbGVuICsgXCJHQ01cIikpO1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJzaWduXCI6XG4gICAgICBjYXNlIFwidmVyaWZ5XCI6XG4gICAgICAgIC8vIFRPRE86IGFsbG93IGZvciBIU3tsZXNzLXRoYW4ta2V5c2l6ZX1cbiAgICAgICAgcmV0dXJuIFNJR19BTEdTLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIG1pbnMuZm9yRWFjaChmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICBpZiAobSA+IGxlbikgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8IChhID09PSAoXCJIU1wiICsgbSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcIndyYXBcIjpcbiAgICAgIGNhc2UgXCJ1bndyYXBcIjpcbiAgICAgICAgcmV0dXJuIFdSQVBfQUxHUy5maWx0ZXIoZnVuY3Rpb24oYSkge1xuICAgICAgICAgIHJldHVybiAoYSA9PT0gKFwiQVwiICsgbGVuICsgXCJLV1wiKSkgfHxcbiAgICAgICAgICAgICAgICAgKGEgPT09IChcIkFcIiArIGxlbiArIFwiR0NNS1dcIikpIHx8XG4gICAgICAgICAgICAgICAgIChhLmluZGV4T2YoXCJQQkVTMi1cIikgPT09IDApIHx8XG4gICAgICAgICAgICAgICAgIChhID09PSBcImRpclwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9LFxuICBlbmNyeXB0S2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wcml2YXRlICYmIGtleXMucHJpdmF0ZS5rO1xuICB9LFxuICBlbmNyeXB0UHJvcHM6IGFkanVzdEVuY3J5cHRQcm9wcyxcblxuICBkZWNyeXB0S2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wcml2YXRlICYmIGtleXMucHJpdmF0ZS5rO1xuICB9LFxuICBkZWNyeXB0UHJvcHM6IGFkanVzdERlY3J5cHRQcm9wcyxcblxuICB3cmFwS2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wcml2YXRlICYmIGtleXMucHJpdmF0ZS5rO1xuICB9LFxuICB3cmFwUHJvcHM6IGFkanVzdEVuY3J5cHRQcm9wcyxcblxuICB1bndyYXBLZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnByaXZhdGUgJiYga2V5cy5wcml2YXRlLms7XG4gIH0sXG4gIHVud3JhcFByb3BzOiBhZGp1c3REZWNyeXB0UHJvcHMsXG5cbiAgc2lnbktleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHJpdmF0ZSAmJiBrZXlzLnByaXZhdGUuaztcbiAgfSxcbiAgdmVyaWZ5S2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wcml2YXRlICYmIGtleXMucHJpdmF0ZS5rO1xuICB9XG59O1xuXG4vLyBGYWN0b3J5XG52YXIgSldLT2N0ZXRGYWN0b3J5ID0ge1xuICBrdHk6IFwib2N0XCIsXG4gIHByZXBhcmU6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgLy8gVE9ETzogdmFsaWRhdGUga2V5IHByb3BlcnRpZXNcbiAgICB2YXIgY2ZnID0gSldLT2N0ZXRDZmc7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUocHJvcHMpO1xuICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgICAgcmV0dXJuIEpXSy5oZWxwZXJzLnRodW1icHJpbnQoY2ZnLCBqc29uKTtcbiAgICB9KTtcbiAgICBwID0gcC50aGVuKGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgIHZhciBwcmludHMgPSB7fTtcbiAgICAgIHByaW50c1tKV0suaGVscGVycy5JTlRFUk5BTFMuVEhVTUJQUklOVF9IQVNIXSA9IGhhc2g7XG4gICAgICBwcm9wc1tKV0suaGVscGVycy5JTlRFUk5BTFMuVEhVTUJQUklOVF9LRVldID0gcHJpbnRzO1xuICAgICAgcmV0dXJuIGNmZztcbiAgICB9KTtcbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAvLyBUT0RPOiB2YWxpZGF0ZSBrZXkgc2l6ZXNcbiAgICB2YXIga2V5ID0gdXRpbC5yYW5kb21CeXRlcyhzaXplIC8gOCk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGs6IGtleVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBwdWJsaWMgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoe1xuICBjb25maWc6IEpXS09jdGV0Q2ZnLFxuICBmYWN0b3J5OiBKV0tPY3RldEZhY3Rvcnlcbn0pO1xuXG4vLyByZWdpc3RyYXRpb25cbihmdW5jdGlvbihSRUdJU1RSWSkge1xuICBSRUdJU1RSWS5yZWdpc3RlcihKV0tPY3RldEZhY3RvcnkpO1xufSkocmVxdWlyZShcIi4va2V5c3RvcmVcIikucmVnaXN0cnkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/octkey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/rsakey.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/rsakey.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/rsa.js - RSA Key Representation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    rsau = __webpack_require__(/*! ../algorithms/rsa-util */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js\"),\n    nodeCrypto = (__webpack_require__(/*! ../algorithms/helpers */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\").nodeCrypto);\n\nvar JWK = {\n  BaseKey: __webpack_require__(/*! ./basekey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\"),\n  helpers: __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\")\n};\n\nvar SIG_ALGS = [\n  \"RS256\",\n  \"RS384\",\n  \"RS512\",\n  \"PS256\",\n  \"PS384\",\n  \"PS512\"\n];\nvar WRAP_ALGS = [\n  \"RSA-OAEP\",\n  \"RSA-OAEP-256\",\n  \"RSA1_5\"\n];\n\nvar JWKRsaCfg = {\n  publicKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"n\", type: \"binary\"},\n      {name: \"e\", type: \"binary\"}\n    ]);\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.n && pk.e) {\n      pk.length = pk.n.length * 8;\n    } else {\n      delete pk.e;\n      delete pk.n;\n    }\n\n    return pk;\n  },\n  privateKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"n\", type: \"binary\"},\n      {name: \"e\", type: \"binary\"},\n      {name: \"d\", type: \"binary\"},\n      {name: \"p\", type: \"binary\"},\n      {name: \"q\", type: \"binary\"},\n      {name: \"dp\", type: \"binary\"},\n      {name: \"dq\", type: \"binary\"},\n      {name: \"qi\", type: \"binary\"}\n    ]);\n\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.d && pk.n && pk.e && pk.p && pk.q && pk.dp && pk.dq && pk.qi) {\n      pk.length = pk.d.length * 8;\n    } else {\n      pk = undefined;\n    }\n\n    return pk;\n  },\n  thumbprint: function(json) {\n    if (json.public) {\n      json = json.public;\n    }\n    var fields = {\n      e: json.e,\n      kty: \"RSA\",\n      n: json.n\n    };\n    return fields;\n  },\n  algorithms: function(keys, mode) {\n    switch (mode) {\n    case \"encrypt\":\n    case \"decrypt\":\n      return [];\n    case \"wrap\":\n      return (keys.public && WRAP_ALGS.slice()) || [];\n    case \"unwrap\":\n      return (keys.private && WRAP_ALGS.slice()) || [];\n    case \"sign\":\n      return (keys.private && SIG_ALGS.slice()) || [];\n    case \"verify\":\n      return (keys.public && SIG_ALGS.slice()) || [];\n    }\n\n    return [];\n  },\n\n  wrapKey: function(alg, keys) {\n    return keys.public;\n  },\n  unwrapKey: function(alg, keys) {\n    return keys.private;\n  },\n\n  signKey: function(alg, keys) {\n    return keys.private;\n  },\n  verifyKey: function(alg, keys) {\n    return keys.public;\n  },\n\n  convertToPEM: function(key, isPrivate) {\n    var k = rsau.convertToForge(key, !isPrivate);\n    if (!isPrivate) {\n      return forge.pki.publicKeyToPem(k);\n    }\n    return forge.pki.privateKeyToPem(k);\n  }\n};\n\nfunction convertBNtoBuffer(bn) {\n  bn = bn.toString(16);\n  if (bn.length % 2) {\n    bn = \"0\" + bn;\n  }\n  return Buffer.from(bn, \"hex\");\n}\n\n// Adapted from digitalbaazar/node-forge/js/rsa.js\nvar validators = {\n  oid: \"1.2.840.113549.1.1.1\",\n  privateKey: {\n    name: \"RSAPrivateKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n      {\n        // Version (INTEGER)\n        name: \"RSAPrivateKey.version\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"version\"\n      },\n      {\n        // modulus (n)\n        name: \"RSAPrivateKey.modulus\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"n\"\n      },\n      {\n        // publicExponent (e)\n        name: \"RSAPrivateKey.publicExponent\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"e\"\n      },\n      {\n        // privateExponent (d)\n        name: \"RSAPrivateKey.privateExponent\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"d\"\n      },\n      {\n        // prime1 (p)\n        name: \"RSAPrivateKey.prime1\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"p\"\n      },\n      {\n        // prime2 (q)\n        name: \"RSAPrivateKey.prime2\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"q\"\n      },\n      {\n        // exponent1 (d mod (p-1))\n        name: \"RSAPrivateKey.exponent1\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"dp\"\n      },\n      {\n        // exponent2 (d mod (q-1))\n        name: \"RSAPrivateKey.exponent2\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"dq\"\n      },\n      {\n        // coefficient ((inverse of q) mod p)\n        name: \"RSAPrivateKey.coefficient\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"qi\"\n      }\n    ]\n  },\n  publicKey: {\n    // RSAPublicKey\n    name: \"RSAPublicKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n      {\n        // modulus (n)\n        name: \"RSAPublicKey.modulus\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"n\"\n      },\n      {\n        // publicExponent (e)\n        name: \"RSAPublicKey.exponent\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"e\"\n      }\n    ]\n  }\n};\n\n// Factory\nvar JWKRsaFactory = {\n  kty: \"RSA\",\n  validators: validators,\n  prepare: function(props) {\n    // TODO: validate key properties\n    var cfg = JWKRsaCfg;\n    var p = Promise.resolve(props);\n    p = p.then(function(json) {\n      return JWK.helpers.thumbprint(cfg, json);\n    });\n    p = p.then(function(hash) {\n      var prints = {};\n      prints[JWK.helpers.INTERNALS.THUMBPRINT_HASH] = hash;\n      props[JWK.helpers.INTERNALS.THUMBPRINT_KEY] = prints;\n      return cfg;\n    });\n    return p;\n  },\n  generate: function(size) {\n    // TODO: validate key sizes\n    var promise;\n\n    if (nodeCrypto) {\n      promise = new Promise(function (resolve, reject) {\n        forge.pki.rsa.generateKeyPair({\n          bits: size,\n          e: 0x010001\n        }, function (err, key) {\n          if (err) return reject(err);\n          resolve(key.privateKey);\n        });\n      });\n    } else {\n      var key = forge.pki.rsa.generateKeyPair({\n        bits: size,\n        e: 0x010001\n      });\n      promise = Promise.resolve(key.privateKey);\n    }\n\n    return promise.then(function (key) {\n\n      // convert to JSON-ish\n      var result = {};\n      [\n        \"e\",\n        \"n\",\n        \"d\",\n        \"p\",\n        \"q\",\n        {incoming: \"dP\", outgoing: \"dp\"},\n        {incoming: \"dQ\", outgoing: \"dq\"},\n        {incoming: \"qInv\", outgoing: \"qi\"}\n      ].forEach(function(f) {\n        var incoming,\n            outgoing;\n\n        if (\"string\" === typeof f) {\n          incoming = outgoing = f;\n        } else {\n          incoming = f.incoming;\n          outgoing = f.outgoing;\n        }\n\n        if (incoming in key) {\n          result[outgoing] = convertBNtoBuffer(key[incoming]);\n        }\n      });\n\n      return result;\n    });\n  },\n  import: function(input) {\n    if (validators.oid !== input.keyOid) {\n      return null;\n    }\n\n    if (!input.parsed) {\n      // coerce capture.keyValue to DER\n      if (\"string\" === typeof input.keyValue) {\n        input.keyValue = forge.asn1.fromDer(input.keyValue);\n      } else if (Array.isArray(input.keyValue)) {\n        input.keyValue = input.keyValue[0];\n      }\n      // capture key factors\n      var validator = (\"private\" === input.type) ?\n                      validators.privateKey :\n                      validators.publicKey;\n      var capture = {},\n          errors = [];\n      if (!forge.asn1.validate(input.keyValue, validator, capture, errors)) {\n        return null;\n      }\n      input = capture;\n    }\n\n    // convert factors to Buffers\n    var output = {\n      kty: \"RSA\"\n    };\n    [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"].forEach(function(f) {\n      if (!(f in input)) {\n        return;\n      }\n      var b = Buffer.from(input[f], \"binary\");\n      // remove leading zero padding if any\n      if (0 === b[0]) {\n        b = b.slice(1);\n      }\n      output[f] = b;\n    });\n    return output;\n  }\n};\n\n// public API\nmodule.exports = Object.freeze({\n  config: JWKRsaCfg,\n  factory: JWKRsaFactory\n});\n\n// registration\n(function(REGISTRY) {\n  REGISTRY.register(JWKRsaFactory);\n})((__webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\").registry));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svcnNha2V5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyx5RkFBd0I7QUFDM0MsaUJBQWlCLHlIQUEyQzs7QUFFNUQ7QUFDQSxXQUFXLG1CQUFPLENBQUMsdUVBQWM7QUFDakMsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMEJBQTBCO0FBQ2pDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsT0FBTywwQkFBMEI7QUFDakMsT0FBTywwQkFBMEI7QUFDakMsT0FBTywwQkFBMEI7QUFDakMsT0FBTywwQkFBMEI7QUFDakMsT0FBTywwQkFBMEI7QUFDakMsT0FBTywyQkFBMkI7QUFDbEMsT0FBTywyQkFBMkI7QUFDbEMsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQkFBK0I7QUFDeEMsU0FBUywrQkFBK0I7QUFDeEMsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsc0dBQThCIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9yc2FrZXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd2svcnNhLmpzIC0gUlNBIEtleSBSZXByZXNlbnRhdGlvblxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZS5qc1wiKSxcbiAgICByc2F1ID0gcmVxdWlyZShcIi4uL2FsZ29yaXRobXMvcnNhLXV0aWxcIiksXG4gICAgbm9kZUNyeXB0byA9IHJlcXVpcmUoXCIuLi9hbGdvcml0aG1zL2hlbHBlcnNcIikubm9kZUNyeXB0bztcblxudmFyIEpXSyA9IHtcbiAgQmFzZUtleTogcmVxdWlyZShcIi4vYmFzZWtleS5qc1wiKSxcbiAgaGVscGVyczogcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKVxufTtcblxudmFyIFNJR19BTEdTID0gW1xuICBcIlJTMjU2XCIsXG4gIFwiUlMzODRcIixcbiAgXCJSUzUxMlwiLFxuICBcIlBTMjU2XCIsXG4gIFwiUFMzODRcIixcbiAgXCJQUzUxMlwiXG5dO1xudmFyIFdSQVBfQUxHUyA9IFtcbiAgXCJSU0EtT0FFUFwiLFxuICBcIlJTQS1PQUVQLTI1NlwiLFxuICBcIlJTQTFfNVwiXG5dO1xuXG52YXIgSldLUnNhQ2ZnID0ge1xuICBwdWJsaWNLZXk6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgdmFyIGZpZWxkcyA9IEpXSy5oZWxwZXJzLkNPTU1PTl9QUk9QUy5jb25jYXQoW1xuICAgICAge25hbWU6IFwiblwiLCB0eXBlOiBcImJpbmFyeVwifSxcbiAgICAgIHtuYW1lOiBcImVcIiwgdHlwZTogXCJiaW5hcnlcIn1cbiAgICBdKTtcbiAgICB2YXIgcGs7XG4gICAgcGsgPSBKV0suaGVscGVycy51bnBhY2tQcm9wcyhwcm9wcywgZmllbGRzKTtcbiAgICBpZiAocGsgJiYgcGsubiAmJiBway5lKSB7XG4gICAgICBway5sZW5ndGggPSBway5uLmxlbmd0aCAqIDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBway5lO1xuICAgICAgZGVsZXRlIHBrLm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHBrO1xuICB9LFxuICBwcml2YXRlS2V5OiBmdW5jdGlvbihwcm9wcykge1xuICAgIHZhciBmaWVsZHMgPSBKV0suaGVscGVycy5DT01NT05fUFJPUFMuY29uY2F0KFtcbiAgICAgIHtuYW1lOiBcIm5cIiwgdHlwZTogXCJiaW5hcnlcIn0sXG4gICAgICB7bmFtZTogXCJlXCIsIHR5cGU6IFwiYmluYXJ5XCJ9LFxuICAgICAge25hbWU6IFwiZFwiLCB0eXBlOiBcImJpbmFyeVwifSxcbiAgICAgIHtuYW1lOiBcInBcIiwgdHlwZTogXCJiaW5hcnlcIn0sXG4gICAgICB7bmFtZTogXCJxXCIsIHR5cGU6IFwiYmluYXJ5XCJ9LFxuICAgICAge25hbWU6IFwiZHBcIiwgdHlwZTogXCJiaW5hcnlcIn0sXG4gICAgICB7bmFtZTogXCJkcVwiLCB0eXBlOiBcImJpbmFyeVwifSxcbiAgICAgIHtuYW1lOiBcInFpXCIsIHR5cGU6IFwiYmluYXJ5XCJ9XG4gICAgXSk7XG5cbiAgICB2YXIgcGs7XG4gICAgcGsgPSBKV0suaGVscGVycy51bnBhY2tQcm9wcyhwcm9wcywgZmllbGRzKTtcbiAgICBpZiAocGsgJiYgcGsuZCAmJiBway5uICYmIHBrLmUgJiYgcGsucCAmJiBway5xICYmIHBrLmRwICYmIHBrLmRxICYmIHBrLnFpKSB7XG4gICAgICBway5sZW5ndGggPSBway5kLmxlbmd0aCAqIDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBwaztcbiAgfSxcbiAgdGh1bWJwcmludDogZnVuY3Rpb24oanNvbikge1xuICAgIGlmIChqc29uLnB1YmxpYykge1xuICAgICAganNvbiA9IGpzb24ucHVibGljO1xuICAgIH1cbiAgICB2YXIgZmllbGRzID0ge1xuICAgICAgZToganNvbi5lLFxuICAgICAga3R5OiBcIlJTQVwiLFxuICAgICAgbjoganNvbi5uXG4gICAgfTtcbiAgICByZXR1cm4gZmllbGRzO1xuICB9LFxuICBhbGdvcml0aG1zOiBmdW5jdGlvbihrZXlzLCBtb2RlKSB7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBcImVuY3J5cHRcIjpcbiAgICBjYXNlIFwiZGVjcnlwdFwiOlxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNhc2UgXCJ3cmFwXCI6XG4gICAgICByZXR1cm4gKGtleXMucHVibGljICYmIFdSQVBfQUxHUy5zbGljZSgpKSB8fCBbXTtcbiAgICBjYXNlIFwidW53cmFwXCI6XG4gICAgICByZXR1cm4gKGtleXMucHJpdmF0ZSAmJiBXUkFQX0FMR1Muc2xpY2UoKSkgfHwgW107XG4gICAgY2FzZSBcInNpZ25cIjpcbiAgICAgIHJldHVybiAoa2V5cy5wcml2YXRlICYmIFNJR19BTEdTLnNsaWNlKCkpIHx8IFtdO1xuICAgIGNhc2UgXCJ2ZXJpZnlcIjpcbiAgICAgIHJldHVybiAoa2V5cy5wdWJsaWMgJiYgU0lHX0FMR1Muc2xpY2UoKSkgfHwgW107XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9LFxuXG4gIHdyYXBLZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnB1YmxpYztcbiAgfSxcbiAgdW53cmFwS2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wcml2YXRlO1xuICB9LFxuXG4gIHNpZ25LZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnByaXZhdGU7XG4gIH0sXG4gIHZlcmlmeUtleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHVibGljO1xuICB9LFxuXG4gIGNvbnZlcnRUb1BFTTogZnVuY3Rpb24oa2V5LCBpc1ByaXZhdGUpIHtcbiAgICB2YXIgayA9IHJzYXUuY29udmVydFRvRm9yZ2Uoa2V5LCAhaXNQcml2YXRlKTtcbiAgICBpZiAoIWlzUHJpdmF0ZSkge1xuICAgICAgcmV0dXJuIGZvcmdlLnBraS5wdWJsaWNLZXlUb1BlbShrKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcmdlLnBraS5wcml2YXRlS2V5VG9QZW0oayk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNvbnZlcnRCTnRvQnVmZmVyKGJuKSB7XG4gIGJuID0gYm4udG9TdHJpbmcoMTYpO1xuICBpZiAoYm4ubGVuZ3RoICUgMikge1xuICAgIGJuID0gXCIwXCIgKyBibjtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20oYm4sIFwiaGV4XCIpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gZGlnaXRhbGJhYXphci9ub2RlLWZvcmdlL2pzL3JzYS5qc1xudmFyIHZhbGlkYXRvcnMgPSB7XG4gIG9pZDogXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiLFxuICBwcml2YXRlS2V5OiB7XG4gICAgbmFtZTogXCJSU0FQcml2YXRlS2V5XCIsXG4gICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW1xuICAgICAge1xuICAgICAgICAvLyBWZXJzaW9uIChJTlRFR0VSKVxuICAgICAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXkudmVyc2lvblwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwidmVyc2lvblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBtb2R1bHVzIChuKVxuICAgICAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXkubW9kdWx1c1wiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICAgICAgbmFtZTogXCJSU0FQcml2YXRlS2V5LnB1YmxpY0V4cG9uZW50XCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJlXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHByaXZhdGVFeHBvbmVudCAoZClcbiAgICAgICAgbmFtZTogXCJSU0FQcml2YXRlS2V5LnByaXZhdGVFeHBvbmVudFwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiZFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBwcmltZTEgKHApXG4gICAgICAgIG5hbWU6IFwiUlNBUHJpdmF0ZUtleS5wcmltZTFcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcInBcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gcHJpbWUyIChxKVxuICAgICAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXkucHJpbWUyXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJxXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIGV4cG9uZW50MSAoZCBtb2QgKHAtMSkpXG4gICAgICAgIG5hbWU6IFwiUlNBUHJpdmF0ZUtleS5leHBvbmVudDFcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcImRwXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIGV4cG9uZW50MiAoZCBtb2QgKHEtMSkpXG4gICAgICAgIG5hbWU6IFwiUlNBUHJpdmF0ZUtleS5leHBvbmVudDJcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcImRxXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIGNvZWZmaWNpZW50ICgoaW52ZXJzZSBvZiBxKSBtb2QgcClcbiAgICAgICAgbmFtZTogXCJSU0FQcml2YXRlS2V5LmNvZWZmaWNpZW50XCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJxaVwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICBwdWJsaWNLZXk6IHtcbiAgICAvLyBSU0FQdWJsaWNLZXlcbiAgICBuYW1lOiBcIlJTQVB1YmxpY0tleVwiLFxuICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFtcbiAgICAgIHtcbiAgICAgICAgLy8gbW9kdWx1cyAobilcbiAgICAgICAgbmFtZTogXCJSU0FQdWJsaWNLZXkubW9kdWx1c1wiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICAgICAgbmFtZTogXCJSU0FQdWJsaWNLZXkuZXhwb25lbnRcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcImVcIlxuICAgICAgfVxuICAgIF1cbiAgfVxufTtcblxuLy8gRmFjdG9yeVxudmFyIEpXS1JzYUZhY3RvcnkgPSB7XG4gIGt0eTogXCJSU0FcIixcbiAgdmFsaWRhdG9yczogdmFsaWRhdG9ycyxcbiAgcHJlcGFyZTogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAvLyBUT0RPOiB2YWxpZGF0ZSBrZXkgcHJvcGVydGllc1xuICAgIHZhciBjZmcgPSBKV0tSc2FDZmc7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUocHJvcHMpO1xuICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgICAgcmV0dXJuIEpXSy5oZWxwZXJzLnRodW1icHJpbnQoY2ZnLCBqc29uKTtcbiAgICB9KTtcbiAgICBwID0gcC50aGVuKGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgIHZhciBwcmludHMgPSB7fTtcbiAgICAgIHByaW50c1tKV0suaGVscGVycy5JTlRFUk5BTFMuVEhVTUJQUklOVF9IQVNIXSA9IGhhc2g7XG4gICAgICBwcm9wc1tKV0suaGVscGVycy5JTlRFUk5BTFMuVEhVTUJQUklOVF9LRVldID0gcHJpbnRzO1xuICAgICAgcmV0dXJuIGNmZztcbiAgICB9KTtcbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAvLyBUT0RPOiB2YWxpZGF0ZSBrZXkgc2l6ZXNcbiAgICB2YXIgcHJvbWlzZTtcblxuICAgIGlmIChub2RlQ3J5cHRvKSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmb3JnZS5wa2kucnNhLmdlbmVyYXRlS2V5UGFpcih7XG4gICAgICAgICAgYml0czogc2l6ZSxcbiAgICAgICAgICBlOiAweDAxMDAwMVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCBrZXkpIHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgcmVzb2x2ZShrZXkucHJpdmF0ZUtleSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXkgPSBmb3JnZS5wa2kucnNhLmdlbmVyYXRlS2V5UGFpcih7XG4gICAgICAgIGJpdHM6IHNpemUsXG4gICAgICAgIGU6IDB4MDEwMDAxXG4gICAgICB9KTtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoa2V5LnByaXZhdGVLZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKGtleSkge1xuXG4gICAgICAvLyBjb252ZXJ0IHRvIEpTT04taXNoXG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBbXG4gICAgICAgIFwiZVwiLFxuICAgICAgICBcIm5cIixcbiAgICAgICAgXCJkXCIsXG4gICAgICAgIFwicFwiLFxuICAgICAgICBcInFcIixcbiAgICAgICAge2luY29taW5nOiBcImRQXCIsIG91dGdvaW5nOiBcImRwXCJ9LFxuICAgICAgICB7aW5jb21pbmc6IFwiZFFcIiwgb3V0Z29pbmc6IFwiZHFcIn0sXG4gICAgICAgIHtpbmNvbWluZzogXCJxSW52XCIsIG91dGdvaW5nOiBcInFpXCJ9XG4gICAgICBdLmZvckVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICB2YXIgaW5jb21pbmcsXG4gICAgICAgICAgICBvdXRnb2luZztcblxuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGYpIHtcbiAgICAgICAgICBpbmNvbWluZyA9IG91dGdvaW5nID0gZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmNvbWluZyA9IGYuaW5jb21pbmc7XG4gICAgICAgICAgb3V0Z29pbmcgPSBmLm91dGdvaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluY29taW5nIGluIGtleSkge1xuICAgICAgICAgIHJlc3VsdFtvdXRnb2luZ10gPSBjb252ZXJ0Qk50b0J1ZmZlcihrZXlbaW5jb21pbmddKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH0sXG4gIGltcG9ydDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZiAodmFsaWRhdG9ycy5vaWQgIT09IGlucHV0LmtleU9pZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFpbnB1dC5wYXJzZWQpIHtcbiAgICAgIC8vIGNvZXJjZSBjYXB0dXJlLmtleVZhbHVlIHRvIERFUlxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dC5rZXlWYWx1ZSkge1xuICAgICAgICBpbnB1dC5rZXlWYWx1ZSA9IGZvcmdlLmFzbjEuZnJvbURlcihpbnB1dC5rZXlWYWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQua2V5VmFsdWUpKSB7XG4gICAgICAgIGlucHV0LmtleVZhbHVlID0gaW5wdXQua2V5VmFsdWVbMF07XG4gICAgICB9XG4gICAgICAvLyBjYXB0dXJlIGtleSBmYWN0b3JzXG4gICAgICB2YXIgdmFsaWRhdG9yID0gKFwicHJpdmF0ZVwiID09PSBpbnB1dC50eXBlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9ycy5wcml2YXRlS2V5IDpcbiAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3JzLnB1YmxpY0tleTtcbiAgICAgIHZhciBjYXB0dXJlID0ge30sXG4gICAgICAgICAgZXJyb3JzID0gW107XG4gICAgICBpZiAoIWZvcmdlLmFzbjEudmFsaWRhdGUoaW5wdXQua2V5VmFsdWUsIHZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlucHV0ID0gY2FwdHVyZTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGZhY3RvcnMgdG8gQnVmZmVyc1xuICAgIHZhciBvdXRwdXQgPSB7XG4gICAgICBrdHk6IFwiUlNBXCJcbiAgICB9O1xuICAgIFtcIm5cIiwgXCJlXCIsIFwiZFwiLCBcInBcIiwgXCJxXCIsIFwiZHBcIiwgXCJkcVwiLCBcInFpXCJdLmZvckVhY2goZnVuY3Rpb24oZikge1xuICAgICAgaWYgKCEoZiBpbiBpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGIgPSBCdWZmZXIuZnJvbShpbnB1dFtmXSwgXCJiaW5hcnlcIik7XG4gICAgICAvLyByZW1vdmUgbGVhZGluZyB6ZXJvIHBhZGRpbmcgaWYgYW55XG4gICAgICBpZiAoMCA9PT0gYlswXSkge1xuICAgICAgICBiID0gYi5zbGljZSgxKTtcbiAgICAgIH1cbiAgICAgIG91dHB1dFtmXSA9IGI7XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcblxuLy8gcHVibGljIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKHtcbiAgY29uZmlnOiBKV0tSc2FDZmcsXG4gIGZhY3Rvcnk6IEpXS1JzYUZhY3Rvcnlcbn0pO1xuXG4vLyByZWdpc3RyYXRpb25cbihmdW5jdGlvbihSRUdJU1RSWSkge1xuICBSRUdJU1RSWS5yZWdpc3RlcihKV0tSc2FGYWN0b3J5KTtcbn0pKHJlcXVpcmUoXCIuL2tleXN0b3JlXCIpLnJlZ2lzdHJ5KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/rsakey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/defaults.js":
/*!****************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/defaults.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/*!\n * jws/defaults.js - Defaults for JWSs\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\n/**\n * @description\n * The default options for {@link JWS.createSign}.\n *\n * @property {Boolean} compact Determines if the output is the Compact\n *           serialization (`true`) or the JSON serialization (**`false`**,\n *           the default).\n * @property {String|String[]} protect The names of the headers to integrity\n *           protect.  The value `\"\"` means that none of header parameters\n *           are integrity protected, while `\"*\"` (the default) means that all\n *           headers parameter sare integrity protected.\n */\nvar JWSDefaults = {\n    compact: false,\n    protect: \"*\"\n};\n\nmodule.exports = JWSDefaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3cy9kZWZhdWx0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3cy9kZWZhdWx0cy5qcyAtIERlZmF1bHRzIGZvciBKV1NzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB7QGxpbmsgSldTLmNyZWF0ZVNpZ259LlxuICpcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29tcGFjdCBEZXRlcm1pbmVzIGlmIHRoZSBvdXRwdXQgaXMgdGhlIENvbXBhY3RcbiAqICAgICAgICAgICBzZXJpYWxpemF0aW9uIChgdHJ1ZWApIG9yIHRoZSBKU09OIHNlcmlhbGl6YXRpb24gKCoqYGZhbHNlYCoqLFxuICogICAgICAgICAgIHRoZSBkZWZhdWx0KS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfFN0cmluZ1tdfSBwcm90ZWN0IFRoZSBuYW1lcyBvZiB0aGUgaGVhZGVycyB0byBpbnRlZ3JpdHlcbiAqICAgICAgICAgICBwcm90ZWN0LiAgVGhlIHZhbHVlIGBcIlwiYCBtZWFucyB0aGF0IG5vbmUgb2YgaGVhZGVyIHBhcmFtZXRlcnNcbiAqICAgICAgICAgICBhcmUgaW50ZWdyaXR5IHByb3RlY3RlZCwgd2hpbGUgYFwiKlwiYCAodGhlIGRlZmF1bHQpIG1lYW5zIHRoYXQgYWxsXG4gKiAgICAgICAgICAgaGVhZGVycyBwYXJhbWV0ZXIgc2FyZSBpbnRlZ3JpdHkgcHJvdGVjdGVkLlxuICovXG52YXIgSldTRGVmYXVsdHMgPSB7XG4gICAgY29tcGFjdDogZmFsc2UsXG4gICAgcHJvdGVjdDogXCIqXCJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSldTRGVmYXVsdHM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/defaults.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/helpers.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/*!\n * jws/helpers.js - JWS Internal Helper Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nmodule.exports = {\n  slice: function(input, start) {\n    return Array.prototype.slice.call(input, start || 0);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvaGVscGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3cy9oZWxwZXJzLmpzIC0gSldTIEludGVybmFsIEhlbHBlciBGdW5jdGlvbnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNsaWNlOiBmdW5jdGlvbihpbnB1dCwgc3RhcnQpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5wdXQsIHN0YXJ0IHx8IDApO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/index.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jws/index.js - JSON Web Signature (JWS) Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar JWS = {\n  createSign: (__webpack_require__(/*! ./sign */ \"(ssr)/./node_modules/node-jose/lib/jws/sign.js\").createSign),\n  createVerify: (__webpack_require__(/*! ./verify */ \"(ssr)/./node_modules/node-jose/lib/jws/verify.js\").createVerify)\n};\n\nmodule.exports = JWS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0EsY0FBYyxnR0FBNEI7QUFDMUMsZ0JBQWdCLHNHQUFnQztBQUNoRDs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd3MvaW5kZXguanMgLSBKU09OIFdlYiBTaWduYXR1cmUgKEpXUykgRW50cnkgUG9pbnRcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEpXUyA9IHtcbiAgY3JlYXRlU2lnbjogcmVxdWlyZShcIi4vc2lnblwiKS5jcmVhdGVTaWduLFxuICBjcmVhdGVWZXJpZnk6IHJlcXVpcmUoXCIuL3ZlcmlmeVwiKS5jcmVhdGVWZXJpZnlcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSldTO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/sign.js":
/*!************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/sign.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jws/sign.js - Sign to JWS\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\"),\n    slice = (__webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/node-jose/lib/jws/helpers.js\").slice);\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\");\nvar uniq = __webpack_require__(/*! lodash/uniq */ \"(ssr)/./node_modules/lodash/uniq.js\");\n\nvar DEFAULTS = __webpack_require__(/*! ./defaults */ \"(ssr)/./node_modules/node-jose/lib/jws/defaults.js\");\n\n/**\n * @class JWS.Signer\n * @classdesc Generator of signed content.\n *\n * @description\n * **NOTE:** this class cannot be instantiated directly. Instead call {@link\n * JWS.createSign}.\n */\nvar JWSSigner = function(cfg, signatories) {\n  var finalized = false,\n      format = cfg.format || \"general\",\n      content = Buffer.alloc(0);\n\n  /**\n  * @member {Boolean} JWS.Signer#compact\n  * @description\n  * Indicates whether the outuput of this signature generator is using\n  * the Compact serialization (`true`) or the JSON serialization\n  * (`false`).\n  */\n  Object.defineProperty(this, \"compact\", {\n    get: function() {\n      return \"compact\" === format;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"format\", {\n    get: function() {\n      return format;\n    },\n    enumerable: true\n  });\n\n  /**\n  * @method JWS.Signer#update\n  * @description\n  * Updates the signing content for this signature content. The content\n  * is appended to the end of any other content already applied.\n  *\n  * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n  * converted to a Buffer internally to {encoding}.\n  *\n  * @param {Buffer|String} data The data to sign.\n  * @param {String} [encoding=\"binary\"] The encoding of {data}.\n  * @returns {JWS.Signer} This signature generator.\n  * @throws {Error} If a signature has already been generated.\n  */\n  Object.defineProperty(this, \"update\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n        if (content.length) {\n          content = Buffer.concat([content, data],\n                      content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n  * @method JWS.Signer#final\n  * @description\n  * Finishes the signature operation.\n  *\n  * The returned Promise, when fulfilled, is the JSON Web Signature (JWS)\n  * object, either in the Compact (if {@link JWS.Signer#format} is\n  * `\"compact\"`), the flattened JSON (if {@link JWS.Signer#format} is\n  * \"flattened\"), or the general JSON serialization.\n  *\n  * @param {Buffer|String} [data] The final content to apply.\n  * @param {String} [encoding=\"binary\"] The encoding of the final content\n  *        (if any).\n  * @returns {Promise} The promise for the signatures\n  * @throws {Error} If a signature has already been generated.\n  */\n  Object.defineProperty(this, \"final\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      }\n\n      // last-minute data\n      this.update(data, encoding);\n\n      // mark as done...ish\n      finalized = true;\n      var promise;\n\n      // map signatory promises to just signatories\n      promise = Promise.all(signatories);\n      promise = promise.then(function(sigs) {\n        // prepare content\n        content = util.base64url.encode(content);\n\n        sigs = sigs.map(function(s) {\n          // prepare protected\n          var protect = {},\n              lenProtect = 0,\n              unprotect = clone(s.header),\n              lenUnprotect = Object.keys(unprotect).length;\n          s.protected.forEach(function(h) {\n            if (!(h in unprotect)) {\n              return;\n            }\n            protect[h] = unprotect[h];\n            lenProtect++;\n            delete unprotect[h];\n            lenUnprotect--;\n          });\n          if (lenProtect > 0) {\n            protect = JSON.stringify(protect);\n            protect = util.base64url.encode(protect);\n          } else {\n            protect = \"\";\n          }\n\n          // signit!\n          var data = Buffer.from(protect + \".\" + content, \"ascii\");\n          s = s.key.sign(s.header.alg, data, s.header);\n          s = s.then(function(result) {\n            var sig = {};\n            if (0 < lenProtect) {\n              sig.protected = protect;\n            }\n            if (0 < lenUnprotect) {\n              sig.header = unprotect;\n            }\n            sig.signature = util.base64url.encode(result.mac);\n            return sig;\n          });\n          return s;\n        });\n        sigs = [Promise.resolve(content)].concat(sigs);\n        return Promise.all(sigs);\n      });\n      promise = promise.then(function(results) {\n        var content = results[0];\n        return {\n          payload: content,\n          signatures: results.slice(1)\n        };\n      });\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function(jws) {\n            var compact = [\n              jws.signatures[0].protected,\n              jws.payload,\n              jws.signatures[0].signature\n            ];\n            compact = compact.join(\".\");\n            return compact;\n          });\n          break;\n        case \"flattened\":\n          promise = promise.then(function(jws) {\n            var flattened = {};\n            flattened.payload = jws.payload;\n\n            var sig = jws.signatures[0];\n            if (sig.protected) {\n              flattened.protected = sig.protected;\n            }\n            if (sig.header) {\n              flattened.header = sig.header;\n            }\n            flattened.signature = sig.signature;\n\n            return flattened;\n          });\n          break;\n      }\n\n      return promise;\n    }\n  });\n};\n\n\n/**\n * @description\n * Creates a new JWS.Signer with the given options and signatories.\n *\n * @param {Object} [opts] The signing options\n * @param {Boolean} [opts.compact] Use compact serialization?\n * @param {String} [opts.format] The serialization format to use (\"compact\",\n *                 \"flattened\", \"general\")\n * @param {Object} [opts.fields] Additional header fields\n * @param {JWK.Key[]|Object[]} [signs] Signatories, either as an array of\n *        JWK.Key instances; or an array of objects, each with the following\n *        properties\n * @param {JWK.Key} signs.key Key used to sign content\n * @param {Object} [signs.header] Per-signatory header fields\n * @param {String} [signs.reference] Reference field to identify the key\n * @param {String[]|String} [signs.protect] List of fields to integrity\n *        protect (\"*\" to protect all fields)\n * @returns {JWS.Signer} The signature generator.\n * @throws {Error} If Compact serialization is requested but there are\n *         multiple signatories\n */\nfunction createSign(opts, signs) {\n  // fixup signatories\n  var options = opts,\n      signStart = 1,\n      signList = signs;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one signatory must be provided\");\n  }\n  if (arguments.length === 1) {\n    signList = opts;\n    signStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) ||\n            (opts && \"kty\" in opts) ||\n            (opts && \"key\" in opts &&\n            (JWK.isKey(opts.key) || \"kty\" in opts.key))) {\n    signList = opts;\n    signStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n  if (!Array.isArray(signList)) {\n    signList = slice(arguments, signStart);\n  }\n\n  // fixup options\n  options = merge(clone(DEFAULTS), options);\n\n  // setup header fields\n  var allFields = options.fields || {};\n  // setup serialization format\n  var format = options.format;\n  if (!format) {\n    format = options.compact ? \"compact\" : \"general\";\n  }\n  if ((\"compact\" === format || \"flattened\" === format) && 1 < signList.length) {\n    throw new Error(\"too many signatories for compact or flattened JSON serialization\");\n  }\n\n  // note protected fields (globally)\n  // protected fields are per signature\n  var protectAll = (\"*\" === options.protect);\n  if (options.compact) {\n    protectAll = true;\n  }\n\n  signList = signList.map(function(s, idx) {\n    var p;\n\n    // resolve a key\n    if (s && \"kty\" in s) {\n      p = JWK.asKey(s);\n      p = p.then(function(k) {\n        return {\n          key: k\n        };\n      });\n    } else if (s) {\n      p = JWK.asKey(s.key);\n      p = p.then(function(k) {\n        return {\n          header: s.header,\n          reference: s.reference,\n          protect: s.protect,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for signatory \" + idx));\n    }\n\n    // resolve the complete signatory\n    p = p.then(function(signatory) {\n      var key = signatory.key;\n\n      // make sure there is a header\n      var header = signatory.header || {};\n      header = merge(merge({}, allFields), header);\n      signatory.header = header;\n\n      // ensure an algorithm\n      if (!header.alg) {\n        header.alg = key.algorithms(JWK.MODE_SIGN)[0] || \"\";\n      }\n\n      // determine the key reference\n      var ref = signatory.reference;\n      delete signatory.reference;\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function(k) {\n          return (k in header);\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n      var jwk;\n      if (ref) {\n        jwk = key.toJSON();\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      }\n\n      // determine protected fields\n      var protect = signatory.protect;\n      if (protectAll || \"*\" === protect) {\n        protect = Object.keys(header);\n      } else if (\"string\" === protect) {\n        protect = [protect];\n      } else if (Array.isArray(protect)) {\n        protect = protect.concat();\n      } else if (!protect) {\n        protect = [];\n      } else {\n        return Promise.reject(new Error(\"protect must be a list of fields\"));\n      }\n      protect = uniq(protect);\n      signatory.protected = protect;\n\n      // freeze signatory\n      signatory = Object.freeze(signatory);\n      return signatory;\n    });\n\n    return p;\n  });\n\n  var cfg = {\n    format: format\n  };\n  return new JWSSigner(cfg,\n                       signList);\n}\n\nmodule.exports = {\n  signer: JWSSigner,\n  createSign: createSign\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3Mvc2lnbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUztBQUM1QixVQUFVLG1CQUFPLENBQUMsK0RBQVE7QUFDMUIsWUFBWSxpR0FBMEI7O0FBRXRDLFlBQVksbUJBQU8sQ0FBQywwREFBYztBQUNsQyxXQUFXLG1CQUFPLENBQUMsd0RBQWE7O0FBRWhDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxNQUFNLGNBQWMsVUFBVSx3QkFBd0IsTUFBTTtBQUNwRSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLFFBQVEscUNBQXFDLEtBQUs7QUFDOUQsY0FBYyxZQUFZO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5QkFBeUI7QUFDaEUsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWMsU0FBUztBQUN2QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxvQkFBb0I7QUFDL0IsNkJBQTZCO0FBQzdCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxhQUFhLFlBQVk7QUFDekIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3cy9zaWduLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandzL3NpZ24uanMgLSBTaWduIHRvIEpXU1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi4vdXRpbC9tZXJnZVwiKSxcbiAgICB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIiksXG4gICAgSldLID0gcmVxdWlyZShcIi4uL2p3a1wiKSxcbiAgICBzbGljZSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIikuc2xpY2U7XG5cbnZhciBjbG9uZSA9IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIik7XG52YXIgdW5pcSA9IHJlcXVpcmUoXCJsb2Rhc2gvdW5pcVwiKTtcblxudmFyIERFRkFVTFRTID0gcmVxdWlyZShcIi4vZGVmYXVsdHNcIik7XG5cbi8qKlxuICogQGNsYXNzIEpXUy5TaWduZXJcbiAqIEBjbGFzc2Rlc2MgR2VuZXJhdG9yIG9mIHNpZ25lZCBjb250ZW50LlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogKipOT1RFOioqIHRoaXMgY2xhc3MgY2Fubm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS4gSW5zdGVhZCBjYWxsIHtAbGlua1xuICogSldTLmNyZWF0ZVNpZ259LlxuICovXG52YXIgSldTU2lnbmVyID0gZnVuY3Rpb24oY2ZnLCBzaWduYXRvcmllcykge1xuICB2YXIgZmluYWxpemVkID0gZmFsc2UsXG4gICAgICBmb3JtYXQgPSBjZmcuZm9ybWF0IHx8IFwiZ2VuZXJhbFwiLFxuICAgICAgY29udGVudCA9IEJ1ZmZlci5hbGxvYygwKTtcblxuICAvKipcbiAgKiBAbWVtYmVyIHtCb29sZWFufSBKV1MuU2lnbmVyI2NvbXBhY3RcbiAgKiBAZGVzY3JpcHRpb25cbiAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgb3V0dXB1dCBvZiB0aGlzIHNpZ25hdHVyZSBnZW5lcmF0b3IgaXMgdXNpbmdcbiAgKiB0aGUgQ29tcGFjdCBzZXJpYWxpemF0aW9uIChgdHJ1ZWApIG9yIHRoZSBKU09OIHNlcmlhbGl6YXRpb25cbiAgKiAoYGZhbHNlYCkuXG4gICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbXBhY3RcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJjb21wYWN0XCIgPT09IGZvcm1hdDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZvcm1hdFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIC8qKlxuICAqIEBtZXRob2QgSldTLlNpZ25lciN1cGRhdGVcbiAgKiBAZGVzY3JpcHRpb25cbiAgKiBVcGRhdGVzIHRoZSBzaWduaW5nIGNvbnRlbnQgZm9yIHRoaXMgc2lnbmF0dXJlIGNvbnRlbnQuIFRoZSBjb250ZW50XG4gICogaXMgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiBhbnkgb3RoZXIgY29udGVudCBhbHJlYWR5IGFwcGxpZWQuXG4gICpcbiAgKiBJZiB7ZGF0YX0gaXMgYSBCdWZmZXIsIHtlbmNvZGluZ30gaXMgaWdub3JlZC4gT3RoZXJ3aXNlLCB7ZGF0YX0gaXNcbiAgKiBjb252ZXJ0ZWQgdG8gYSBCdWZmZXIgaW50ZXJuYWxseSB0byB7ZW5jb2Rpbmd9LlxuICAqXG4gICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIHNpZ24uXG4gICogQHBhcmFtIHtTdHJpbmd9IFtlbmNvZGluZz1cImJpbmFyeVwiXSBUaGUgZW5jb2Rpbmcgb2Yge2RhdGF9LlxuICAqIEByZXR1cm5zIHtKV1MuU2lnbmVyfSBUaGlzIHNpZ25hdHVyZSBnZW5lcmF0b3IuXG4gICogQHRocm93cyB7RXJyb3J9IElmIGEgc2lnbmF0dXJlIGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkLlxuICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1cGRhdGVcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuICAgICAgaWYgKGZpbmFsaXplZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICBkYXRhID0gdXRpbC5hc0J1ZmZlcihkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRlbnQgPSBCdWZmZXIuY29uY2F0KFtjb250ZW50LCBkYXRhXSxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Lmxlbmd0aCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50ID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgKiBAbWV0aG9kIEpXUy5TaWduZXIjZmluYWxcbiAgKiBAZGVzY3JpcHRpb25cbiAgKiBGaW5pc2hlcyB0aGUgc2lnbmF0dXJlIG9wZXJhdGlvbi5cbiAgKlxuICAqIFRoZSByZXR1cm5lZCBQcm9taXNlLCB3aGVuIGZ1bGZpbGxlZCwgaXMgdGhlIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKVxuICAqIG9iamVjdCwgZWl0aGVyIGluIHRoZSBDb21wYWN0IChpZiB7QGxpbmsgSldTLlNpZ25lciNmb3JtYXR9IGlzXG4gICogYFwiY29tcGFjdFwiYCksIHRoZSBmbGF0dGVuZWQgSlNPTiAoaWYge0BsaW5rIEpXUy5TaWduZXIjZm9ybWF0fSBpc1xuICAqIFwiZmxhdHRlbmVkXCIpLCBvciB0aGUgZ2VuZXJhbCBKU09OIHNlcmlhbGl6YXRpb24uXG4gICpcbiAgKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IFtkYXRhXSBUaGUgZmluYWwgY29udGVudCB0byBhcHBseS5cbiAgKiBAcGFyYW0ge1N0cmluZ30gW2VuY29kaW5nPVwiYmluYXJ5XCJdIFRoZSBlbmNvZGluZyBvZiB0aGUgZmluYWwgY29udGVudFxuICAqICAgICAgICAoaWYgYW55KS5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSBzaWduYXR1cmVzXG4gICogQHRocm93cyB7RXJyb3J9IElmIGEgc2lnbmF0dXJlIGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkLlxuICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaW5hbFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgICBpZiAoZmluYWxpemVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsXCIpKTtcbiAgICAgIH1cblxuICAgICAgLy8gbGFzdC1taW51dGUgZGF0YVxuICAgICAgdGhpcy51cGRhdGUoZGF0YSwgZW5jb2RpbmcpO1xuXG4gICAgICAvLyBtYXJrIGFzIGRvbmUuLi5pc2hcbiAgICAgIGZpbmFsaXplZCA9IHRydWU7XG4gICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgLy8gbWFwIHNpZ25hdG9yeSBwcm9taXNlcyB0byBqdXN0IHNpZ25hdG9yaWVzXG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5hbGwoc2lnbmF0b3JpZXMpO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihzaWdzKSB7XG4gICAgICAgIC8vIHByZXBhcmUgY29udGVudFxuICAgICAgICBjb250ZW50ID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKGNvbnRlbnQpO1xuXG4gICAgICAgIHNpZ3MgPSBzaWdzLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgLy8gcHJlcGFyZSBwcm90ZWN0ZWRcbiAgICAgICAgICB2YXIgcHJvdGVjdCA9IHt9LFxuICAgICAgICAgICAgICBsZW5Qcm90ZWN0ID0gMCxcbiAgICAgICAgICAgICAgdW5wcm90ZWN0ID0gY2xvbmUocy5oZWFkZXIpLFxuICAgICAgICAgICAgICBsZW5VbnByb3RlY3QgPSBPYmplY3Qua2V5cyh1bnByb3RlY3QpLmxlbmd0aDtcbiAgICAgICAgICBzLnByb3RlY3RlZC5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIGlmICghKGggaW4gdW5wcm90ZWN0KSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm90ZWN0W2hdID0gdW5wcm90ZWN0W2hdO1xuICAgICAgICAgICAgbGVuUHJvdGVjdCsrO1xuICAgICAgICAgICAgZGVsZXRlIHVucHJvdGVjdFtoXTtcbiAgICAgICAgICAgIGxlblVucHJvdGVjdC0tO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChsZW5Qcm90ZWN0ID4gMCkge1xuICAgICAgICAgICAgcHJvdGVjdCA9IEpTT04uc3RyaW5naWZ5KHByb3RlY3QpO1xuICAgICAgICAgICAgcHJvdGVjdCA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZShwcm90ZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvdGVjdCA9IFwiXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc2lnbml0IVxuICAgICAgICAgIHZhciBkYXRhID0gQnVmZmVyLmZyb20ocHJvdGVjdCArIFwiLlwiICsgY29udGVudCwgXCJhc2NpaVwiKTtcbiAgICAgICAgICBzID0gcy5rZXkuc2lnbihzLmhlYWRlci5hbGcsIGRhdGEsIHMuaGVhZGVyKTtcbiAgICAgICAgICBzID0gcy50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIHNpZyA9IHt9O1xuICAgICAgICAgICAgaWYgKDAgPCBsZW5Qcm90ZWN0KSB7XG4gICAgICAgICAgICAgIHNpZy5wcm90ZWN0ZWQgPSBwcm90ZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDAgPCBsZW5VbnByb3RlY3QpIHtcbiAgICAgICAgICAgICAgc2lnLmhlYWRlciA9IHVucHJvdGVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpZy5zaWduYXR1cmUgPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUocmVzdWx0Lm1hYyk7XG4gICAgICAgICAgICByZXR1cm4gc2lnO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9KTtcbiAgICAgICAgc2lncyA9IFtQcm9taXNlLnJlc29sdmUoY29udGVudCldLmNvbmNhdChzaWdzKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHNpZ3MpO1xuICAgICAgfSk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSByZXN1bHRzWzBdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBheWxvYWQ6IGNvbnRlbnQsXG4gICAgICAgICAgc2lnbmF0dXJlczogcmVzdWx0cy5zbGljZSgxKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICBjYXNlIFwiY29tcGFjdFwiOlxuICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandzKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFjdCA9IFtcbiAgICAgICAgICAgICAgandzLnNpZ25hdHVyZXNbMF0ucHJvdGVjdGVkLFxuICAgICAgICAgICAgICBqd3MucGF5bG9hZCxcbiAgICAgICAgICAgICAgandzLnNpZ25hdHVyZXNbMF0uc2lnbmF0dXJlXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29tcGFjdCA9IGNvbXBhY3Quam9pbihcIi5cIik7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFjdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImZsYXR0ZW5lZFwiOlxuICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandzKSB7XG4gICAgICAgICAgICB2YXIgZmxhdHRlbmVkID0ge307XG4gICAgICAgICAgICBmbGF0dGVuZWQucGF5bG9hZCA9IGp3cy5wYXlsb2FkO1xuXG4gICAgICAgICAgICB2YXIgc2lnID0gandzLnNpZ25hdHVyZXNbMF07XG4gICAgICAgICAgICBpZiAoc2lnLnByb3RlY3RlZCkge1xuICAgICAgICAgICAgICBmbGF0dGVuZWQucHJvdGVjdGVkID0gc2lnLnByb3RlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaWcuaGVhZGVyKSB7XG4gICAgICAgICAgICAgIGZsYXR0ZW5lZC5oZWFkZXIgPSBzaWcuaGVhZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhdHRlbmVkLnNpZ25hdHVyZSA9IHNpZy5zaWduYXR1cmU7XG5cbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDcmVhdGVzIGEgbmV3IEpXUy5TaWduZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgc2lnbmF0b3JpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBUaGUgc2lnbmluZyBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRzLmNvbXBhY3RdIFVzZSBjb21wYWN0IHNlcmlhbGl6YXRpb24/XG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdHMuZm9ybWF0XSBUaGUgc2VyaWFsaXphdGlvbiBmb3JtYXQgdG8gdXNlIChcImNvbXBhY3RcIixcbiAqICAgICAgICAgICAgICAgICBcImZsYXR0ZW5lZFwiLCBcImdlbmVyYWxcIilcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5maWVsZHNdIEFkZGl0aW9uYWwgaGVhZGVyIGZpZWxkc1xuICogQHBhcmFtIHtKV0suS2V5W118T2JqZWN0W119IFtzaWduc10gU2lnbmF0b3JpZXMsIGVpdGhlciBhcyBhbiBhcnJheSBvZlxuICogICAgICAgIEpXSy5LZXkgaW5zdGFuY2VzOyBvciBhbiBhcnJheSBvZiBvYmplY3RzLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZ1xuICogICAgICAgIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7SldLLktleX0gc2lnbnMua2V5IEtleSB1c2VkIHRvIHNpZ24gY29udGVudFxuICogQHBhcmFtIHtPYmplY3R9IFtzaWducy5oZWFkZXJdIFBlci1zaWduYXRvcnkgaGVhZGVyIGZpZWxkc1xuICogQHBhcmFtIHtTdHJpbmd9IFtzaWducy5yZWZlcmVuY2VdIFJlZmVyZW5jZSBmaWVsZCB0byBpZGVudGlmeSB0aGUga2V5XG4gKiBAcGFyYW0ge1N0cmluZ1tdfFN0cmluZ30gW3NpZ25zLnByb3RlY3RdIExpc3Qgb2YgZmllbGRzIHRvIGludGVncml0eVxuICogICAgICAgIHByb3RlY3QgKFwiKlwiIHRvIHByb3RlY3QgYWxsIGZpZWxkcylcbiAqIEByZXR1cm5zIHtKV1MuU2lnbmVyfSBUaGUgc2lnbmF0dXJlIGdlbmVyYXRvci5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBDb21wYWN0IHNlcmlhbGl6YXRpb24gaXMgcmVxdWVzdGVkIGJ1dCB0aGVyZSBhcmVcbiAqICAgICAgICAgbXVsdGlwbGUgc2lnbmF0b3JpZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2lnbihvcHRzLCBzaWducykge1xuICAvLyBmaXh1cCBzaWduYXRvcmllc1xuICB2YXIgb3B0aW9ucyA9IG9wdHMsXG4gICAgICBzaWduU3RhcnQgPSAxLFxuICAgICAgc2lnbkxpc3QgPSBzaWducztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImF0IGxlYXN0IG9uZSBzaWduYXRvcnkgbXVzdCBiZSBwcm92aWRlZFwiKTtcbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHNpZ25MaXN0ID0gb3B0cztcbiAgICBzaWduU3RhcnQgPSAwO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSBlbHNlIGlmIChKV0suaXNLZXkob3B0cykgfHxcbiAgICAgICAgICAgIChvcHRzICYmIFwia3R5XCIgaW4gb3B0cykgfHxcbiAgICAgICAgICAgIChvcHRzICYmIFwia2V5XCIgaW4gb3B0cyAmJlxuICAgICAgICAgICAgKEpXSy5pc0tleShvcHRzLmtleSkgfHwgXCJrdHlcIiBpbiBvcHRzLmtleSkpKSB7XG4gICAgc2lnbkxpc3QgPSBvcHRzO1xuICAgIHNpZ25TdGFydCA9IDA7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBjbG9uZShvcHRzKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoc2lnbkxpc3QpKSB7XG4gICAgc2lnbkxpc3QgPSBzbGljZShhcmd1bWVudHMsIHNpZ25TdGFydCk7XG4gIH1cblxuICAvLyBmaXh1cCBvcHRpb25zXG4gIG9wdGlvbnMgPSBtZXJnZShjbG9uZShERUZBVUxUUyksIG9wdGlvbnMpO1xuXG4gIC8vIHNldHVwIGhlYWRlciBmaWVsZHNcbiAgdmFyIGFsbEZpZWxkcyA9IG9wdGlvbnMuZmllbGRzIHx8IHt9O1xuICAvLyBzZXR1cCBzZXJpYWxpemF0aW9uIGZvcm1hdFxuICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQ7XG4gIGlmICghZm9ybWF0KSB7XG4gICAgZm9ybWF0ID0gb3B0aW9ucy5jb21wYWN0ID8gXCJjb21wYWN0XCIgOiBcImdlbmVyYWxcIjtcbiAgfVxuICBpZiAoKFwiY29tcGFjdFwiID09PSBmb3JtYXQgfHwgXCJmbGF0dGVuZWRcIiA9PT0gZm9ybWF0KSAmJiAxIDwgc2lnbkxpc3QubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidG9vIG1hbnkgc2lnbmF0b3JpZXMgZm9yIGNvbXBhY3Qgb3IgZmxhdHRlbmVkIEpTT04gc2VyaWFsaXphdGlvblwiKTtcbiAgfVxuXG4gIC8vIG5vdGUgcHJvdGVjdGVkIGZpZWxkcyAoZ2xvYmFsbHkpXG4gIC8vIHByb3RlY3RlZCBmaWVsZHMgYXJlIHBlciBzaWduYXR1cmVcbiAgdmFyIHByb3RlY3RBbGwgPSAoXCIqXCIgPT09IG9wdGlvbnMucHJvdGVjdCk7XG4gIGlmIChvcHRpb25zLmNvbXBhY3QpIHtcbiAgICBwcm90ZWN0QWxsID0gdHJ1ZTtcbiAgfVxuXG4gIHNpZ25MaXN0ID0gc2lnbkxpc3QubWFwKGZ1bmN0aW9uKHMsIGlkeCkge1xuICAgIHZhciBwO1xuXG4gICAgLy8gcmVzb2x2ZSBhIGtleVxuICAgIGlmIChzICYmIFwia3R5XCIgaW4gcykge1xuICAgICAgcCA9IEpXSy5hc0tleShzKTtcbiAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oaykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtleToga1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzKSB7XG4gICAgICBwID0gSldLLmFzS2V5KHMua2V5KTtcbiAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oaykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhlYWRlcjogcy5oZWFkZXIsXG4gICAgICAgICAgcmVmZXJlbmNlOiBzLnJlZmVyZW5jZSxcbiAgICAgICAgICBwcm90ZWN0OiBzLnByb3RlY3QsXG4gICAgICAgICAga2V5OiBrXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcCA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm1pc3Npbmcga2V5IGZvciBzaWduYXRvcnkgXCIgKyBpZHgpKTtcbiAgICB9XG5cbiAgICAvLyByZXNvbHZlIHRoZSBjb21wbGV0ZSBzaWduYXRvcnlcbiAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHNpZ25hdG9yeSkge1xuICAgICAgdmFyIGtleSA9IHNpZ25hdG9yeS5rZXk7XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhIGhlYWRlclxuICAgICAgdmFyIGhlYWRlciA9IHNpZ25hdG9yeS5oZWFkZXIgfHwge307XG4gICAgICBoZWFkZXIgPSBtZXJnZShtZXJnZSh7fSwgYWxsRmllbGRzKSwgaGVhZGVyKTtcbiAgICAgIHNpZ25hdG9yeS5oZWFkZXIgPSBoZWFkZXI7XG5cbiAgICAgIC8vIGVuc3VyZSBhbiBhbGdvcml0aG1cbiAgICAgIGlmICghaGVhZGVyLmFsZykge1xuICAgICAgICBoZWFkZXIuYWxnID0ga2V5LmFsZ29yaXRobXMoSldLLk1PREVfU0lHTilbMF0gfHwgXCJcIjtcbiAgICAgIH1cblxuICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBrZXkgcmVmZXJlbmNlXG4gICAgICB2YXIgcmVmID0gc2lnbmF0b3J5LnJlZmVyZW5jZTtcbiAgICAgIGRlbGV0ZSBzaWduYXRvcnkucmVmZXJlbmNlO1xuICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcmVmKSB7XG4gICAgICAgIC8vIGhlYWRlciBhbHJlYWR5IGNvbnRhaW5zIHRoZSBrZXkgcmVmZXJlbmNlXG4gICAgICAgIHJlZiA9IFtcImtpZFwiLCBcImprdVwiLCBcIng1Y1wiLCBcIng1dFwiLCBcIng1dVwiXS5zb21lKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICByZXR1cm4gKGsgaW4gaGVhZGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlZiA9ICFyZWYgPyBcImtpZFwiIDogbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoXCJib29sZWFuXCIgPT09IHR5cGVvZiByZWYpIHtcbiAgICAgICAgLy8gZXhwbGljaXQgKHBvc2l0aXZlIHwgbmVnYXRpdmUpIHJlcXVlc3QgZm9yIGtleSByZWZlcmVuY2VcbiAgICAgICAgcmVmID0gcmVmID8gXCJraWRcIiA6IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgandrO1xuICAgICAgaWYgKHJlZikge1xuICAgICAgICBqd2sgPSBrZXkudG9KU09OKCk7XG4gICAgICAgIGlmIChcImp3a1wiID09PSByZWYpIHtcbiAgICAgICAgICBpZiAoXCJvY3RcIiA9PT0ga2V5Lmt0eSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImNhbm5vdCBlbWJlZCBrZXlcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoZWFkZXIuandrID0gandrO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZiBpbiBqd2spIHtcbiAgICAgICAgICBoZWFkZXJbcmVmXSA9IGp3a1tyZWZdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGRldGVybWluZSBwcm90ZWN0ZWQgZmllbGRzXG4gICAgICB2YXIgcHJvdGVjdCA9IHNpZ25hdG9yeS5wcm90ZWN0O1xuICAgICAgaWYgKHByb3RlY3RBbGwgfHwgXCIqXCIgPT09IHByb3RlY3QpIHtcbiAgICAgICAgcHJvdGVjdCA9IE9iamVjdC5rZXlzKGhlYWRlcik7XG4gICAgICB9IGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHByb3RlY3QpIHtcbiAgICAgICAgcHJvdGVjdCA9IFtwcm90ZWN0XTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwcm90ZWN0KSkge1xuICAgICAgICBwcm90ZWN0ID0gcHJvdGVjdC5jb25jYXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb3RlY3QpIHtcbiAgICAgICAgcHJvdGVjdCA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInByb3RlY3QgbXVzdCBiZSBhIGxpc3Qgb2YgZmllbGRzXCIpKTtcbiAgICAgIH1cbiAgICAgIHByb3RlY3QgPSB1bmlxKHByb3RlY3QpO1xuICAgICAgc2lnbmF0b3J5LnByb3RlY3RlZCA9IHByb3RlY3Q7XG5cbiAgICAgIC8vIGZyZWV6ZSBzaWduYXRvcnlcbiAgICAgIHNpZ25hdG9yeSA9IE9iamVjdC5mcmVlemUoc2lnbmF0b3J5KTtcbiAgICAgIHJldHVybiBzaWduYXRvcnk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcDtcbiAgfSk7XG5cbiAgdmFyIGNmZyA9IHtcbiAgICBmb3JtYXQ6IGZvcm1hdFxuICB9O1xuICByZXR1cm4gbmV3IEpXU1NpZ25lcihjZmcsXG4gICAgICAgICAgICAgICAgICAgICAgIHNpZ25MaXN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNpZ25lcjogSldTU2lnbmVyLFxuICBjcmVhdGVTaWduOiBjcmVhdGVTaWduXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/sign.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/verify.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/verify.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jws/verify.js - Verifies from a JWS\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    base64url = __webpack_require__(/*! ../util/base64url */ \"(ssr)/./node_modules/node-jose/lib/util/base64url.js\"),\n    AlgConfig = __webpack_require__(/*! ../util/algconfig */ \"(ssr)/./node_modules/node-jose/lib/util/algconfig.js\"),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\");\n\nvar DEFAULT_OPTIONS = {\n  algorithms: \"*\",\n  allowEmbeddedKey: false\n};\n\n/**\n * @class JWS.Verifier\n * @classdesc Parser of signed content.\n *\n * @description\n * **NOTE:** this class cannot be instantiated directly. Instead call {@link\n * JWS.createVerify}.\n */\nvar JWSVerifier = function(ks, globalOpts) {\n  var assumedKey,\n      keystore;\n\n  if (JWK.isKey(ks)) {\n    assumedKey = ks;\n    keystore = assumedKey.keystore;\n  } else if (JWK.isKeyStore(ks)) {\n    keystore = ks;\n  } else {\n    keystore = JWK.createKeyStore();\n  }\n\n  globalOpts = merge(DEFAULT_OPTIONS, globalOpts);\n\n  Object.defineProperty(this, \"defaultKey\", {\n    value: assumedKey || undefined,\n    enumerable: true\n  });\n  Object.defineProperty(this, \"keystore\", {\n    value: keystore,\n    enumerable: true\n  });\n\n  Object.defineProperty(this, \"verify\", {\n    value: function(input, opts) {\n      opts = merge({}, globalOpts, opts || {});\n      var extraHandlers = opts.handlers || {};\n      var handlerKeys = Object.keys(extraHandlers);\n      var algSpec = new AlgConfig(opts.algorithms);\n\n      if (\"string\" === typeof input) {\n        input = input.split(\".\");\n        input = {\n          payload: input[1],\n          signatures: [\n            {\n              protected: input[0],\n              signature: input[2]\n            }\n          ]\n        };\n      } else if (!input || \"object\" !== typeof input) {\n        throw new Error(\"invalid input\");\n      }\n\n      // fixup \"flattened JSON\" to look like \"general JSON\"\n      if (input.signature) {\n        input.signatures = [\n          {\n            protected: input.protected || undefined,\n            header: input.header || undefined,\n            signature: input.signature\n          }\n        ];\n      }\n\n      // ensure signatories exists\n      var sigList = input.signatures || [{}];\n\n      // combine fields and decode signature per signatory\n      sigList = sigList.map(function(s) {\n        var header = clone(s.header || {});\n        var protect = s.protected ?\n                      JSON.parse(base64url.decode(s.protected, \"utf8\")) :\n                      {};\n        header = merge(header, protect);\n        var signature = base64url.decode(s.signature);\n\n        // process allowed algorithims\n        if (!algSpec.match(header.alg)) {\n          return Promise.reject(new Error(\"Algorithm not allowed: \" + header.alg));\n        }\n\n        // process \"crit\" first\n        var crit = protect.crit;\n        if (crit) {\n          if (!Array.isArray(crit)) {\n            return Promise.reject(new Error(\"Invalid 'crit' header\"));\n          }\n          for (var idx = 0; crit.length > idx; idx++) {\n            if (-1 === handlerKeys.indexOf(crit[idx])) {\n              return Promise.reject(new Error(\n                  \"Critical extension is not supported: \" + crit[idx]\n              ));\n            }\n          }\n        }\n        protect = Object.keys(protect);\n\n        return Promise.resolve({\n          protected: protect,\n          aad: s.protected || \"\",\n          header: header,\n          signature: signature\n        });\n      });\n\n      var promise = Promise.all(sigList);\n      promise = promise.then(function(sigList) {\n        return new Promise(function(resolve, reject) {\n          var processSig = function() {\n            var sig = sigList.shift();\n            if (!sig) {\n              reject(new Error(\"no key found\"));\n              return;\n            }\n\n            sig = merge({}, sig, {\n              payload: input.payload\n            });\n            var p = Promise.resolve(sig);\n            // find the key\n            p = p.then(function(sig) {\n              var algKey;\n              // TODO: resolve jku, x5c, x5u\n              if (opts.allowEmbeddedKey && sig.header.jwk) {\n                algKey = JWK.asKey(sig.header.jwk);\n              } else if (opts.allowEmbeddedKey && sig.header.x5c) {\n                algKey = sig.header.x5c[0];\n                algKey = Buffer.from(algKey, \"base64\");\n                // TODO: callback to validate chain\n                algKey = JWK.asKey(algKey, \"pkix\");\n              } else {\n                algKey = Promise.resolve(assumedKey || keystore.get({\n                  use: \"sig\",\n                  alg: sig.header.alg,\n                  kid: sig.header.kid\n                }));\n              }\n              return algKey.then(function(k) {\n                if (!k) {\n                  return Promise.reject(new Error(\"key does not match\"));\n                }\n                sig.key = k;\n                return sig;\n              });\n            });\n\n            // process any prepare-verify handlers\n            p = p.then(function(sig) {\n              var processing = [];\n              handlerKeys.forEach(function(h) {\n                h = extraHandlers[h];\n                var p;\n                if (\"function\" === typeof h) {\n                  p = h(sig);\n                } else if (\"object\" === typeof h && \"function\" === typeof h.prepare) {\n                  p = h.prepare(sig);\n                }\n                if (p) {\n                  processing.push(Promise.resolve(p));\n                }\n              });\n              return Promise.all(processing).then(function() {\n                // don't actually care about individual handler results\n                // assume {sig} is updated\n                return sig;\n              });\n            });\n\n            // prepare verify inputs\n            p = p.then(function(sig) {\n              var aad = sig.aad || \"\",\n                  payload = sig.payload || \"\";\n              var content = Buffer.alloc(1 + aad.length + payload.length),\n                  pos = 0;\n              content.write(aad, pos, \"ascii\");\n              pos += aad.length;\n              content.write(\".\", pos, \"ascii\");\n              pos++;\n\n              if (Buffer.isBuffer(payload)) {\n                payload.copy(content, pos);\n              } else {\n                content.write(payload, pos, \"binary\");\n              }\n              sig.content = content;\n              return sig;\n            });\n\n            p = p.then(function(sig) {\n              return sig.key.verify(sig.header.alg,\n                                    sig.content,\n                                    sig.signature);\n            });\n\n            p = p.then(function(result) {\n              var payload = sig.payload;\n              payload = base64url.decode(payload);\n              return {\n                protected: sig.protected,\n                header: sig.header,\n                payload: payload,\n                signature: result.mac,\n                key: sig.key\n              };\n            });\n\n            // process any post-verify handlers\n            p = p.then(function(jws) {\n              var processing = [];\n              handlerKeys.forEach(function(h) {\n                h = extraHandlers[h];\n                var p;\n                if (\"object\" === typeof h && \"function\" === typeof h.complete) {\n                  p = h.complete(jws);\n                }\n                if (p) {\n                  processing.push(Promise.resolve(p));\n                }\n              });\n              return Promise.all(processing).then(function() {\n                // don't actually care about individual handler results\n                // assume {jws} is updated\n                return jws;\n              });\n            });\n            p.then(resolve, processSig);\n          };\n          processSig();\n        });\n      });\n      return promise;\n    }\n  });\n};\n\n/**\n * @description\n * Creates a new JWS.Verifier with the given Key or KeyStore.\n *\n * @param {JWK.Key|JWK.KeyStore} ks The Key or KeyStore to use for verification.\n * @returns {JWS.Verifier} The new Verifier.\n */\nfunction createVerify(ks, opts) {\n  var vfy = new JWSVerifier(ks, opts);\n\n  return vfy;\n}\n\nmodule.exports = {\n  verifier: JWSVerifier,\n  createVerify: createVerify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvdmVyaWZ5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMERBQWM7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFtQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBbUI7QUFDM0MsVUFBVSxtQkFBTyxDQUFDLCtEQUFROztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBLGVBQWU7QUFDZixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3cy92ZXJpZnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd3MvdmVyaWZ5LmpzIC0gVmVyaWZpZXMgZnJvbSBhIEpXU1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2xvbmUgPSByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpLFxuICAgIG1lcmdlID0gcmVxdWlyZShcIi4uL3V0aWwvbWVyZ2VcIiksXG4gICAgYmFzZTY0dXJsID0gcmVxdWlyZShcIi4uL3V0aWwvYmFzZTY0dXJsXCIpLFxuICAgIEFsZ0NvbmZpZyA9IHJlcXVpcmUoXCIuLi91dGlsL2FsZ2NvbmZpZ1wiKSxcbiAgICBKV0sgPSByZXF1aXJlKFwiLi4vandrXCIpO1xuXG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBhbGdvcml0aG1zOiBcIipcIixcbiAgYWxsb3dFbWJlZGRlZEtleTogZmFsc2Vcbn07XG5cbi8qKlxuICogQGNsYXNzIEpXUy5WZXJpZmllclxuICogQGNsYXNzZGVzYyBQYXJzZXIgb2Ygc2lnbmVkIGNvbnRlbnQuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAqKk5PVEU6KiogdGhpcyBjbGFzcyBjYW5ub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LiBJbnN0ZWFkIGNhbGwge0BsaW5rXG4gKiBKV1MuY3JlYXRlVmVyaWZ5fS5cbiAqL1xudmFyIEpXU1ZlcmlmaWVyID0gZnVuY3Rpb24oa3MsIGdsb2JhbE9wdHMpIHtcbiAgdmFyIGFzc3VtZWRLZXksXG4gICAgICBrZXlzdG9yZTtcblxuICBpZiAoSldLLmlzS2V5KGtzKSkge1xuICAgIGFzc3VtZWRLZXkgPSBrcztcbiAgICBrZXlzdG9yZSA9IGFzc3VtZWRLZXkua2V5c3RvcmU7XG4gIH0gZWxzZSBpZiAoSldLLmlzS2V5U3RvcmUoa3MpKSB7XG4gICAga2V5c3RvcmUgPSBrcztcbiAgfSBlbHNlIHtcbiAgICBrZXlzdG9yZSA9IEpXSy5jcmVhdGVLZXlTdG9yZSgpO1xuICB9XG5cbiAgZ2xvYmFsT3B0cyA9IG1lcmdlKERFRkFVTFRfT1BUSU9OUywgZ2xvYmFsT3B0cyk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdEtleVwiLCB7XG4gICAgdmFsdWU6IGFzc3VtZWRLZXkgfHwgdW5kZWZpbmVkLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleXN0b3JlXCIsIHtcbiAgICB2YWx1ZToga2V5c3RvcmUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJpZnlcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihpbnB1dCwgb3B0cykge1xuICAgICAgb3B0cyA9IG1lcmdlKHt9LCBnbG9iYWxPcHRzLCBvcHRzIHx8IHt9KTtcbiAgICAgIHZhciBleHRyYUhhbmRsZXJzID0gb3B0cy5oYW5kbGVycyB8fCB7fTtcbiAgICAgIHZhciBoYW5kbGVyS2V5cyA9IE9iamVjdC5rZXlzKGV4dHJhSGFuZGxlcnMpO1xuICAgICAgdmFyIGFsZ1NwZWMgPSBuZXcgQWxnQ29uZmlnKG9wdHMuYWxnb3JpdGhtcyk7XG5cbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaW5wdXQpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zcGxpdChcIi5cIik7XG4gICAgICAgIGlucHV0ID0ge1xuICAgICAgICAgIHBheWxvYWQ6IGlucHV0WzFdLFxuICAgICAgICAgIHNpZ25hdHVyZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkOiBpbnB1dFswXSxcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiBpbnB1dFsyXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoIWlucHV0IHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBpbnB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0XCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBmaXh1cCBcImZsYXR0ZW5lZCBKU09OXCIgdG8gbG9vayBsaWtlIFwiZ2VuZXJhbCBKU09OXCJcbiAgICAgIGlmIChpbnB1dC5zaWduYXR1cmUpIHtcbiAgICAgICAgaW5wdXQuc2lnbmF0dXJlcyA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcm90ZWN0ZWQ6IGlucHV0LnByb3RlY3RlZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBoZWFkZXI6IGlucHV0LmhlYWRlciB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGlucHV0LnNpZ25hdHVyZVxuICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgLy8gZW5zdXJlIHNpZ25hdG9yaWVzIGV4aXN0c1xuICAgICAgdmFyIHNpZ0xpc3QgPSBpbnB1dC5zaWduYXR1cmVzIHx8IFt7fV07XG5cbiAgICAgIC8vIGNvbWJpbmUgZmllbGRzIGFuZCBkZWNvZGUgc2lnbmF0dXJlIHBlciBzaWduYXRvcnlcbiAgICAgIHNpZ0xpc3QgPSBzaWdMaXN0Lm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSBjbG9uZShzLmhlYWRlciB8fCB7fSk7XG4gICAgICAgIHZhciBwcm90ZWN0ID0gcy5wcm90ZWN0ZWQgP1xuICAgICAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoYmFzZTY0dXJsLmRlY29kZShzLnByb3RlY3RlZCwgXCJ1dGY4XCIpKSA6XG4gICAgICAgICAgICAgICAgICAgICAge307XG4gICAgICAgIGhlYWRlciA9IG1lcmdlKGhlYWRlciwgcHJvdGVjdCk7XG4gICAgICAgIHZhciBzaWduYXR1cmUgPSBiYXNlNjR1cmwuZGVjb2RlKHMuc2lnbmF0dXJlKTtcblxuICAgICAgICAvLyBwcm9jZXNzIGFsbG93ZWQgYWxnb3JpdGhpbXNcbiAgICAgICAgaWYgKCFhbGdTcGVjLm1hdGNoKGhlYWRlci5hbGcpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkFsZ29yaXRobSBub3QgYWxsb3dlZDogXCIgKyBoZWFkZXIuYWxnKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcm9jZXNzIFwiY3JpdFwiIGZpcnN0XG4gICAgICAgIHZhciBjcml0ID0gcHJvdGVjdC5jcml0O1xuICAgICAgICBpZiAoY3JpdCkge1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjcml0KSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgJ2NyaXQnIGhlYWRlclwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGNyaXQubGVuZ3RoID4gaWR4OyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKC0xID09PSBoYW5kbGVyS2V5cy5pbmRleE9mKGNyaXRbaWR4XSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQ3JpdGljYWwgZXh0ZW5zaW9uIGlzIG5vdCBzdXBwb3J0ZWQ6IFwiICsgY3JpdFtpZHhdXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm90ZWN0ID0gT2JqZWN0LmtleXMocHJvdGVjdCk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgcHJvdGVjdGVkOiBwcm90ZWN0LFxuICAgICAgICAgIGFhZDogcy5wcm90ZWN0ZWQgfHwgXCJcIixcbiAgICAgICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UuYWxsKHNpZ0xpc3QpO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihzaWdMaXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgcHJvY2Vzc1NpZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNpZyA9IHNpZ0xpc3Quc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghc2lnKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJubyBrZXkgZm91bmRcIikpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNpZyA9IG1lcmdlKHt9LCBzaWcsIHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogaW5wdXQucGF5bG9hZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZShzaWcpO1xuICAgICAgICAgICAgLy8gZmluZCB0aGUga2V5XG4gICAgICAgICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAgICAgICB2YXIgYWxnS2V5O1xuICAgICAgICAgICAgICAvLyBUT0RPOiByZXNvbHZlIGprdSwgeDVjLCB4NXVcbiAgICAgICAgICAgICAgaWYgKG9wdHMuYWxsb3dFbWJlZGRlZEtleSAmJiBzaWcuaGVhZGVyLmp3aykge1xuICAgICAgICAgICAgICAgIGFsZ0tleSA9IEpXSy5hc0tleShzaWcuaGVhZGVyLmp3ayk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5hbGxvd0VtYmVkZGVkS2V5ICYmIHNpZy5oZWFkZXIueDVjKSB7XG4gICAgICAgICAgICAgICAgYWxnS2V5ID0gc2lnLmhlYWRlci54NWNbMF07XG4gICAgICAgICAgICAgICAgYWxnS2V5ID0gQnVmZmVyLmZyb20oYWxnS2V5LCBcImJhc2U2NFwiKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBjYWxsYmFjayB0byB2YWxpZGF0ZSBjaGFpblxuICAgICAgICAgICAgICAgIGFsZ0tleSA9IEpXSy5hc0tleShhbGdLZXksIFwicGtpeFwiKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbGdLZXkgPSBQcm9taXNlLnJlc29sdmUoYXNzdW1lZEtleSB8fCBrZXlzdG9yZS5nZXQoe1xuICAgICAgICAgICAgICAgICAgdXNlOiBcInNpZ1wiLFxuICAgICAgICAgICAgICAgICAgYWxnOiBzaWcuaGVhZGVyLmFsZyxcbiAgICAgICAgICAgICAgICAgIGtpZDogc2lnLmhlYWRlci5raWRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGFsZ0tleS50aGVuKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWspIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJrZXkgZG9lcyBub3QgbWF0Y2hcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaWcua2V5ID0gaztcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBwcm9jZXNzIGFueSBwcmVwYXJlLXZlcmlmeSBoYW5kbGVyc1xuICAgICAgICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihzaWcpIHtcbiAgICAgICAgICAgICAgdmFyIHByb2Nlc3NpbmcgPSBbXTtcbiAgICAgICAgICAgICAgaGFuZGxlcktleXMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICAgICAgaCA9IGV4dHJhSGFuZGxlcnNbaF07XG4gICAgICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGgpIHtcbiAgICAgICAgICAgICAgICAgIHAgPSBoKHNpZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgaCAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBoLnByZXBhcmUpIHtcbiAgICAgICAgICAgICAgICAgIHAgPSBoLnByZXBhcmUoc2lnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcucHVzaChQcm9taXNlLnJlc29sdmUocCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9jZXNzaW5nKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFjdHVhbGx5IGNhcmUgYWJvdXQgaW5kaXZpZHVhbCBoYW5kbGVyIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAvLyBhc3N1bWUge3NpZ30gaXMgdXBkYXRlZFxuICAgICAgICAgICAgICAgIHJldHVybiBzaWc7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHByZXBhcmUgdmVyaWZ5IGlucHV0c1xuICAgICAgICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihzaWcpIHtcbiAgICAgICAgICAgICAgdmFyIGFhZCA9IHNpZy5hYWQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBzaWcucGF5bG9hZCB8fCBcIlwiO1xuICAgICAgICAgICAgICB2YXIgY29udGVudCA9IEJ1ZmZlci5hbGxvYygxICsgYWFkLmxlbmd0aCArIHBheWxvYWQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgICAgICAgIGNvbnRlbnQud3JpdGUoYWFkLCBwb3MsIFwiYXNjaWlcIik7XG4gICAgICAgICAgICAgIHBvcyArPSBhYWQubGVuZ3RoO1xuICAgICAgICAgICAgICBjb250ZW50LndyaXRlKFwiLlwiLCBwb3MsIFwiYXNjaWlcIik7XG4gICAgICAgICAgICAgIHBvcysrO1xuXG4gICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIocGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmNvcHkoY29udGVudCwgcG9zKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LndyaXRlKHBheWxvYWQsIHBvcywgXCJiaW5hcnlcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2lnLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgICByZXR1cm4gc2lnO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oc2lnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzaWcua2V5LnZlcmlmeShzaWcuaGVhZGVyLmFsZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZy5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnLnNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBzaWcucGF5bG9hZDtcbiAgICAgICAgICAgICAgcGF5bG9hZCA9IGJhc2U2NHVybC5kZWNvZGUocGF5bG9hZCk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkOiBzaWcucHJvdGVjdGVkLFxuICAgICAgICAgICAgICAgIGhlYWRlcjogc2lnLmhlYWRlcixcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogcmVzdWx0Lm1hYyxcbiAgICAgICAgICAgICAgICBrZXk6IHNpZy5rZXlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBwcm9jZXNzIGFueSBwb3N0LXZlcmlmeSBoYW5kbGVyc1xuICAgICAgICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihqd3MpIHtcbiAgICAgICAgICAgICAgdmFyIHByb2Nlc3NpbmcgPSBbXTtcbiAgICAgICAgICAgICAgaGFuZGxlcktleXMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICAgICAgaCA9IGV4dHJhSGFuZGxlcnNbaF07XG4gICAgICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBoICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGguY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgIHAgPSBoLmNvbXBsZXRlKGp3cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzaW5nLnB1c2goUHJvbWlzZS5yZXNvbHZlKHApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvY2Vzc2luZykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBhY3R1YWxseSBjYXJlIGFib3V0IGluZGl2aWR1YWwgaGFuZGxlciByZXN1bHRzXG4gICAgICAgICAgICAgICAgLy8gYXNzdW1lIHtqd3N9IGlzIHVwZGF0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gandzO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcC50aGVuKHJlc29sdmUsIHByb2Nlc3NTaWcpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcHJvY2Vzc1NpZygpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDcmVhdGVzIGEgbmV3IEpXUy5WZXJpZmllciB3aXRoIHRoZSBnaXZlbiBLZXkgb3IgS2V5U3RvcmUuXG4gKlxuICogQHBhcmFtIHtKV0suS2V5fEpXSy5LZXlTdG9yZX0ga3MgVGhlIEtleSBvciBLZXlTdG9yZSB0byB1c2UgZm9yIHZlcmlmaWNhdGlvbi5cbiAqIEByZXR1cm5zIHtKV1MuVmVyaWZpZXJ9IFRoZSBuZXcgVmVyaWZpZXIuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZlcmlmeShrcywgb3B0cykge1xuICB2YXIgdmZ5ID0gbmV3IEpXU1ZlcmlmaWVyKGtzLCBvcHRzKTtcblxuICByZXR1cm4gdmZ5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmVyaWZpZXI6IEpXU1ZlcmlmaWVyLFxuICBjcmVhdGVWZXJpZnk6IGNyZWF0ZVZlcmlmeVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/verify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/parse/compact.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-jose/lib/parse/compact.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * parse/compact.js - JOSE Compact Serialization Parser\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar jose = {\n  JWE: __webpack_require__(/*! ../jwe */ \"(ssr)/./node_modules/node-jose/lib/jwe/index.js\"),\n  JWS: __webpack_require__(/*! ../jws */ \"(ssr)/./node_modules/node-jose/lib/jws/index.js\"),\n  util: __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\")\n};\n\nfunction parseCompact(input) {\n  var parts = input.split(\".\");\n\n  var type,\n      op;\n  if (3 === parts.length) {\n    // JWS\n    type = \"JWS\";\n    op = function(ks, opts) {\n      return jose.JWS.createVerify(ks).\n             verify(input, opts);\n    };\n  } else if (5 === parts.length) {\n    // JWE\n    type = \"JWE\";\n    op = function(ks, opts) {\n      return jose.JWE.createDecrypt(ks).\n             decrypt(input, opts);\n    };\n  } else {\n    throw new TypeError(\"invalid jose serialization\");\n  }\n\n  // parse header\n  var header;\n  header = jose.util.base64url.decode(parts[0], \"utf8\");\n  header = JSON.parse(header);\n  return {\n    type: type,\n    format: \"compact\",\n    input: input,\n    header: header,\n    perform: op\n  };\n}\n\nmodule.exports = parseCompact;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9jb21wYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBLE9BQU8sbUJBQU8sQ0FBQywrREFBUTtBQUN2QixPQUFPLG1CQUFPLENBQUMsK0RBQVE7QUFDdkIsUUFBUSxtQkFBTyxDQUFDLGlFQUFTO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9jb21wYWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogcGFyc2UvY29tcGFjdC5qcyAtIEpPU0UgQ29tcGFjdCBTZXJpYWxpemF0aW9uIFBhcnNlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgam9zZSA9IHtcbiAgSldFOiByZXF1aXJlKFwiLi4vandlXCIpLFxuICBKV1M6IHJlcXVpcmUoXCIuLi9qd3NcIiksXG4gIHV0aWw6IHJlcXVpcmUoXCIuLi91dGlsXCIpXG59O1xuXG5mdW5jdGlvbiBwYXJzZUNvbXBhY3QoaW5wdXQpIHtcbiAgdmFyIHBhcnRzID0gaW5wdXQuc3BsaXQoXCIuXCIpO1xuXG4gIHZhciB0eXBlLFxuICAgICAgb3A7XG4gIGlmICgzID09PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAvLyBKV1NcbiAgICB0eXBlID0gXCJKV1NcIjtcbiAgICBvcCA9IGZ1bmN0aW9uKGtzLCBvcHRzKSB7XG4gICAgICByZXR1cm4gam9zZS5KV1MuY3JlYXRlVmVyaWZ5KGtzKS5cbiAgICAgICAgICAgICB2ZXJpZnkoaW5wdXQsIG9wdHMpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoNSA9PT0gcGFydHMubGVuZ3RoKSB7XG4gICAgLy8gSldFXG4gICAgdHlwZSA9IFwiSldFXCI7XG4gICAgb3AgPSBmdW5jdGlvbihrcywgb3B0cykge1xuICAgICAgcmV0dXJuIGpvc2UuSldFLmNyZWF0ZURlY3J5cHQoa3MpLlxuICAgICAgICAgICAgIGRlY3J5cHQoaW5wdXQsIG9wdHMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgam9zZSBzZXJpYWxpemF0aW9uXCIpO1xuICB9XG5cbiAgLy8gcGFyc2UgaGVhZGVyXG4gIHZhciBoZWFkZXI7XG4gIGhlYWRlciA9IGpvc2UudXRpbC5iYXNlNjR1cmwuZGVjb2RlKHBhcnRzWzBdLCBcInV0ZjhcIik7XG4gIGhlYWRlciA9IEpTT04ucGFyc2UoaGVhZGVyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGZvcm1hdDogXCJjb21wYWN0XCIsXG4gICAgaW5wdXQ6IGlucHV0LFxuICAgIGhlYWRlcjogaGVhZGVyLFxuICAgIHBlcmZvcm06IG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VDb21wYWN0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/parse/compact.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/parse/index.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/parse/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * parse/index.js - JOSE Parser Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar compact = __webpack_require__(/*! ./compact */ \"(ssr)/./node_modules/node-jose/lib/parse/compact.js\"),\n    json = __webpack_require__(/*! ./json */ \"(ssr)/./node_modules/node-jose/lib/parse/json.js\");\n\nvar parse = module.exports = function(input) {\n  if (Buffer.isBuffer(input)) {\n    // assume buffer holds a Compact Serialization string\n    return compact(input.toString(\"ascii\"));\n  } else if (\"string\" === typeof input) {\n    return compact(input);\n  } else if (input) {\n    return json(input);\n  } else {\n    throw new TypeError(\"invalid input\");\n  }\n};\n\nparse.compact = compact;\nparse.json = json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHNFQUFXO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxnRUFBUTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvcGFyc2UvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBwYXJzZS9pbmRleC5qcyAtIEpPU0UgUGFyc2VyIEVudHJ5IFBvaW50XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb21wYWN0ID0gcmVxdWlyZShcIi4vY29tcGFjdFwiKSxcbiAgICBqc29uID0gcmVxdWlyZShcIi4vanNvblwiKTtcblxudmFyIHBhcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgIC8vIGFzc3VtZSBidWZmZXIgaG9sZHMgYSBDb21wYWN0IFNlcmlhbGl6YXRpb24gc3RyaW5nXG4gICAgcmV0dXJuIGNvbXBhY3QoaW5wdXQudG9TdHJpbmcoXCJhc2NpaVwiKSk7XG4gIH0gZWxzZSBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlucHV0KSB7XG4gICAgcmV0dXJuIGNvbXBhY3QoaW5wdXQpO1xuICB9IGVsc2UgaWYgKGlucHV0KSB7XG4gICAgcmV0dXJuIGpzb24oaW5wdXQpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGlucHV0XCIpO1xuICB9XG59O1xuXG5wYXJzZS5jb21wYWN0ID0gY29tcGFjdDtcbnBhcnNlLmpzb24gPSBqc29uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/parse/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/parse/json.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/parse/json.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * parse/compact.js - JOSE JSON Serialization Parser\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\");\n\nvar jose = {\n  JWE: __webpack_require__(/*! ../jwe */ \"(ssr)/./node_modules/node-jose/lib/jwe/index.js\"),\n  JWS: __webpack_require__(/*! ../jws */ \"(ssr)/./node_modules/node-jose/lib/jws/index.js\"),\n  util: __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\")\n};\n\nfunction parseJSON(input) {\n  var type,\n      op,\n      headers;\n\n  if (\"signatures\" in input || \"signature\" in input) {\n    // JWS\n    type = \"JWS\";\n    op = function(ks, opts) {\n      return jose.JWS.createVerify(ks).\n             verify(input, opts);\n    };\n    // headers can be (signatures[].protected, signatures[].header, signature.protected, signature.header)\n    headers = input.signatures ||\n              [ {\n                protected: input.protected,\n                header: input.header,\n                signature: input.signature\n              }];\n    headers = headers.map(function(sig) {\n      var all = {};\n      if (sig.header) {\n        all = merge(all, sig.header);\n      }\n\n      var prot;\n      if (sig.protected) {\n        prot = sig.protected;\n        prot = jose.util.base64url.decode(prot, \"utf8\");\n        prot = JSON.parse(prot);\n        all = merge(all, prot);\n      }\n\n      return all;\n    });\n  } else if (\"ciphertext\" in input) {\n    // JWE\n    type = \"JWE\";\n    op = function(ks, opts) {\n      return jose.JWE.createDecrypt(ks).\n             decrypt(input, opts);\n    };\n    // headers can be (protected, unprotected, recipients[].header)\n    var root = {};\n    if (input.protected) {\n      root.protected = input.protected;\n      root.protected = jose.util.base64url.decode(root.protected, \"utf8\");\n      root.protected = JSON.parse(root.protected);\n    }\n    if (input.unprotected) {\n      root.unprotected = input.unprotected;\n    }\n\n    headers = input.recipients || [{}];\n    headers = headers.map(function(rcpt) {\n      var all = {};\n      if (rcpt.header) {\n        all = merge(all, rcpt.header);\n      }\n      if (root.unprotected) {\n        all = merge(all, root.unprotected);\n      }\n      if (root.protected) {\n        all = merge(all, root.protected);\n      }\n\n      return all;\n    });\n  }\n\n  return {\n    type: type,\n    format: \"json\",\n    input: input,\n    all: headers,\n    perform: op\n  };\n}\n\nmodule.exports = parseJSON;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9qc29uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsdUVBQWU7O0FBRW5DO0FBQ0EsT0FBTyxtQkFBTyxDQUFDLCtEQUFRO0FBQ3ZCLE9BQU8sbUJBQU8sQ0FBQywrREFBUTtBQUN2QixRQUFRLG1CQUFPLENBQUMsaUVBQVM7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9qc29uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogcGFyc2UvY29tcGFjdC5qcyAtIEpPU0UgSlNPTiBTZXJpYWxpemF0aW9uIFBhcnNlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi4vdXRpbC9tZXJnZVwiKTtcblxudmFyIGpvc2UgPSB7XG4gIEpXRTogcmVxdWlyZShcIi4uL2p3ZVwiKSxcbiAgSldTOiByZXF1aXJlKFwiLi4vandzXCIpLFxuICB1dGlsOiByZXF1aXJlKFwiLi4vdXRpbFwiKVxufTtcblxuZnVuY3Rpb24gcGFyc2VKU09OKGlucHV0KSB7XG4gIHZhciB0eXBlLFxuICAgICAgb3AsXG4gICAgICBoZWFkZXJzO1xuXG4gIGlmIChcInNpZ25hdHVyZXNcIiBpbiBpbnB1dCB8fCBcInNpZ25hdHVyZVwiIGluIGlucHV0KSB7XG4gICAgLy8gSldTXG4gICAgdHlwZSA9IFwiSldTXCI7XG4gICAgb3AgPSBmdW5jdGlvbihrcywgb3B0cykge1xuICAgICAgcmV0dXJuIGpvc2UuSldTLmNyZWF0ZVZlcmlmeShrcykuXG4gICAgICAgICAgICAgdmVyaWZ5KGlucHV0LCBvcHRzKTtcbiAgICB9O1xuICAgIC8vIGhlYWRlcnMgY2FuIGJlIChzaWduYXR1cmVzW10ucHJvdGVjdGVkLCBzaWduYXR1cmVzW10uaGVhZGVyLCBzaWduYXR1cmUucHJvdGVjdGVkLCBzaWduYXR1cmUuaGVhZGVyKVxuICAgIGhlYWRlcnMgPSBpbnB1dC5zaWduYXR1cmVzIHx8XG4gICAgICAgICAgICAgIFsge1xuICAgICAgICAgICAgICAgIHByb3RlY3RlZDogaW5wdXQucHJvdGVjdGVkLFxuICAgICAgICAgICAgICAgIGhlYWRlcjogaW5wdXQuaGVhZGVyLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogaW5wdXQuc2lnbmF0dXJlXG4gICAgICAgICAgICAgIH1dO1xuICAgIGhlYWRlcnMgPSBoZWFkZXJzLm1hcChmdW5jdGlvbihzaWcpIHtcbiAgICAgIHZhciBhbGwgPSB7fTtcbiAgICAgIGlmIChzaWcuaGVhZGVyKSB7XG4gICAgICAgIGFsbCA9IG1lcmdlKGFsbCwgc2lnLmhlYWRlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm90O1xuICAgICAgaWYgKHNpZy5wcm90ZWN0ZWQpIHtcbiAgICAgICAgcHJvdCA9IHNpZy5wcm90ZWN0ZWQ7XG4gICAgICAgIHByb3QgPSBqb3NlLnV0aWwuYmFzZTY0dXJsLmRlY29kZShwcm90LCBcInV0ZjhcIik7XG4gICAgICAgIHByb3QgPSBKU09OLnBhcnNlKHByb3QpO1xuICAgICAgICBhbGwgPSBtZXJnZShhbGwsIHByb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxsO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKFwiY2lwaGVydGV4dFwiIGluIGlucHV0KSB7XG4gICAgLy8gSldFXG4gICAgdHlwZSA9IFwiSldFXCI7XG4gICAgb3AgPSBmdW5jdGlvbihrcywgb3B0cykge1xuICAgICAgcmV0dXJuIGpvc2UuSldFLmNyZWF0ZURlY3J5cHQoa3MpLlxuICAgICAgICAgICAgIGRlY3J5cHQoaW5wdXQsIG9wdHMpO1xuICAgIH07XG4gICAgLy8gaGVhZGVycyBjYW4gYmUgKHByb3RlY3RlZCwgdW5wcm90ZWN0ZWQsIHJlY2lwaWVudHNbXS5oZWFkZXIpXG4gICAgdmFyIHJvb3QgPSB7fTtcbiAgICBpZiAoaW5wdXQucHJvdGVjdGVkKSB7XG4gICAgICByb290LnByb3RlY3RlZCA9IGlucHV0LnByb3RlY3RlZDtcbiAgICAgIHJvb3QucHJvdGVjdGVkID0gam9zZS51dGlsLmJhc2U2NHVybC5kZWNvZGUocm9vdC5wcm90ZWN0ZWQsIFwidXRmOFwiKTtcbiAgICAgIHJvb3QucHJvdGVjdGVkID0gSlNPTi5wYXJzZShyb290LnByb3RlY3RlZCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC51bnByb3RlY3RlZCkge1xuICAgICAgcm9vdC51bnByb3RlY3RlZCA9IGlucHV0LnVucHJvdGVjdGVkO1xuICAgIH1cblxuICAgIGhlYWRlcnMgPSBpbnB1dC5yZWNpcGllbnRzIHx8IFt7fV07XG4gICAgaGVhZGVycyA9IGhlYWRlcnMubWFwKGZ1bmN0aW9uKHJjcHQpIHtcbiAgICAgIHZhciBhbGwgPSB7fTtcbiAgICAgIGlmIChyY3B0LmhlYWRlcikge1xuICAgICAgICBhbGwgPSBtZXJnZShhbGwsIHJjcHQuaGVhZGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChyb290LnVucHJvdGVjdGVkKSB7XG4gICAgICAgIGFsbCA9IG1lcmdlKGFsbCwgcm9vdC51bnByb3RlY3RlZCk7XG4gICAgICB9XG4gICAgICBpZiAocm9vdC5wcm90ZWN0ZWQpIHtcbiAgICAgICAgYWxsID0gbWVyZ2UoYWxsLCByb290LnByb3RlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGw7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZm9ybWF0OiBcImpzb25cIixcbiAgICBpbnB1dDogaW5wdXQsXG4gICAgYWxsOiBoZWFkZXJzLFxuICAgIHBlcmZvcm06IG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VKU09OO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/parse/json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/algconfig.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/util/algconfig.js ***!
  \******************************************************/
/***/ ((module) => {

eval("/*!\n * util/algconfig.js - Functions for managing algorithm set options\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nfunction quoteRE(str) {\n  return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"\\\\$&\");\n}\n\nfunction makeRE(prefix, wildcard, suffix) {\n  var parts = [];\n\n  parts.push(\"^\");\n  if (prefix) {\n    prefix = quoteRE(prefix);\n    parts.push(prefix);\n  }\n  if (wildcard) {\n    parts.push((prefix || suffix) ? \".*\" : \".+\");\n  }\n  if (suffix) {\n    suffix = quoteRE(suffix);\n    parts.push(suffix);\n  }\n  parts.push(\"$\");\n\n  return parts.join(\"\");\n}\n\nvar AlgConfig = function(algspec) {\n  if (!algspec) {\n    algspec = [];\n  } else if (\"string\" === typeof algspec) {\n    algspec = algspec.split(\" \");\n  }\n\n  var specAllowed = [], specDisallowed = [];\n  var ptnAllowed = [], ptnDisallowed = [];\n  var ptn = /^(!)?([^*]*)(\\*?)([^*]*)$/, fmt;\n  algspec.forEach(function (a) {\n    if (!a) { return; }\n\n    ptn.lastIndex = 0;\n    var parts = ptn.exec(a);\n    if (!parts) { return; }\n\n    fmt = \"(\" + makeRE(parts[2], parts[3], parts[4]) + \")\";\n    if (!parts[1]) {\n      // allowed pattern\n      ptnAllowed.push(fmt);\n      specAllowed.push(parts[0]);\n    } else {\n      // disallowed pattern\n      ptnDisallowed.push(fmt);\n      specDisallowed.push(parts[0]);\n    }\n  });\n\n  ptnAllowed = (ptnAllowed.length) ?\n            new RegExp(ptnAllowed.join(\"|\")) :\n            null;\n  ptnDisallowed = (ptnDisallowed.length) ?\n               new RegExp(ptnDisallowed.join(\"|\")) :\n               null;\n  if (!specAllowed.length) {\n    specAllowed = [\"*\"];\n  }\n\n  Object.defineProperty(this, \"spec\", {\n    value: specAllowed.join(\" \") + \" \" + specDisallowed.join(\" \"),\n    enumerable: true\n  });\n  Object.defineProperty(this, \"match\", {\n    value: function(alg) {\n      var result = Boolean(alg);\n\n      if (result && ptnAllowed) {\n        ptnAllowed.lastIndex = 0;\n        result = ptnAllowed.test(alg);\n      }\n      if (result && ptnDisallowed) {\n        ptnDisallowed.lastIndex = 0;\n        result = !ptnDisallowed.test(alg);\n      }\n\n      return result;\n    }\n  });\n}\n\nmodule.exports = AlgConfig;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2FsZ2NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvdXRpbC9hbGdjb25maWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiB1dGlsL2FsZ2NvbmZpZy5qcyAtIEZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgYWxnb3JpdGhtIHNldCBvcHRpb25zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIHF1b3RlUkUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuZnVuY3Rpb24gbWFrZVJFKHByZWZpeCwgd2lsZGNhcmQsIHN1ZmZpeCkge1xuICB2YXIgcGFydHMgPSBbXTtcblxuICBwYXJ0cy5wdXNoKFwiXlwiKTtcbiAgaWYgKHByZWZpeCkge1xuICAgIHByZWZpeCA9IHF1b3RlUkUocHJlZml4KTtcbiAgICBwYXJ0cy5wdXNoKHByZWZpeCk7XG4gIH1cbiAgaWYgKHdpbGRjYXJkKSB7XG4gICAgcGFydHMucHVzaCgocHJlZml4IHx8IHN1ZmZpeCkgPyBcIi4qXCIgOiBcIi4rXCIpO1xuICB9XG4gIGlmIChzdWZmaXgpIHtcbiAgICBzdWZmaXggPSBxdW90ZVJFKHN1ZmZpeCk7XG4gICAgcGFydHMucHVzaChzdWZmaXgpO1xuICB9XG4gIHBhcnRzLnB1c2goXCIkXCIpO1xuXG4gIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xufVxuXG52YXIgQWxnQ29uZmlnID0gZnVuY3Rpb24oYWxnc3BlYykge1xuICBpZiAoIWFsZ3NwZWMpIHtcbiAgICBhbGdzcGVjID0gW107XG4gIH0gZWxzZSBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGFsZ3NwZWMpIHtcbiAgICBhbGdzcGVjID0gYWxnc3BlYy5zcGxpdChcIiBcIik7XG4gIH1cblxuICB2YXIgc3BlY0FsbG93ZWQgPSBbXSwgc3BlY0Rpc2FsbG93ZWQgPSBbXTtcbiAgdmFyIHB0bkFsbG93ZWQgPSBbXSwgcHRuRGlzYWxsb3dlZCA9IFtdO1xuICB2YXIgcHRuID0gL14oISk/KFteKl0qKShcXCo/KShbXipdKikkLywgZm10O1xuICBhbGdzcGVjLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICBpZiAoIWEpIHsgcmV0dXJuOyB9XG5cbiAgICBwdG4ubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgcGFydHMgPSBwdG4uZXhlYyhhKTtcbiAgICBpZiAoIXBhcnRzKSB7IHJldHVybjsgfVxuXG4gICAgZm10ID0gXCIoXCIgKyBtYWtlUkUocGFydHNbMl0sIHBhcnRzWzNdLCBwYXJ0c1s0XSkgKyBcIilcIjtcbiAgICBpZiAoIXBhcnRzWzFdKSB7XG4gICAgICAvLyBhbGxvd2VkIHBhdHRlcm5cbiAgICAgIHB0bkFsbG93ZWQucHVzaChmbXQpO1xuICAgICAgc3BlY0FsbG93ZWQucHVzaChwYXJ0c1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRpc2FsbG93ZWQgcGF0dGVyblxuICAgICAgcHRuRGlzYWxsb3dlZC5wdXNoKGZtdCk7XG4gICAgICBzcGVjRGlzYWxsb3dlZC5wdXNoKHBhcnRzWzBdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHB0bkFsbG93ZWQgPSAocHRuQWxsb3dlZC5sZW5ndGgpID9cbiAgICAgICAgICAgIG5ldyBSZWdFeHAocHRuQWxsb3dlZC5qb2luKFwifFwiKSkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgcHRuRGlzYWxsb3dlZCA9IChwdG5EaXNhbGxvd2VkLmxlbmd0aCkgP1xuICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChwdG5EaXNhbGxvd2VkLmpvaW4oXCJ8XCIpKSA6XG4gICAgICAgICAgICAgICBudWxsO1xuICBpZiAoIXNwZWNBbGxvd2VkLmxlbmd0aCkge1xuICAgIHNwZWNBbGxvd2VkID0gW1wiKlwiXTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNwZWNcIiwge1xuICAgIHZhbHVlOiBzcGVjQWxsb3dlZC5qb2luKFwiIFwiKSArIFwiIFwiICsgc3BlY0Rpc2FsbG93ZWQuam9pbihcIiBcIiksXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF0Y2hcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihhbGcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBCb29sZWFuKGFsZyk7XG5cbiAgICAgIGlmIChyZXN1bHQgJiYgcHRuQWxsb3dlZCkge1xuICAgICAgICBwdG5BbGxvd2VkLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJlc3VsdCA9IHB0bkFsbG93ZWQudGVzdChhbGcpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAmJiBwdG5EaXNhbGxvd2VkKSB7XG4gICAgICAgIHB0bkRpc2FsbG93ZWQubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmVzdWx0ID0gIXB0bkRpc2FsbG93ZWQudGVzdChhbGcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWxnQ29uZmlnO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/algconfig.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/base64url.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/util/base64url.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * util/base64url.js - Implementation of web-safe Base64 Encoder/Decoder\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar impl = __webpack_require__(/*! base64url */ \"(ssr)/./node_modules/base64url/index.js\");\n\n/**\n * @namespace base64url\n * @description\n * Provides methods to encode and decode data according to the\n * base64url alphabet.\n */\nvar base64url = {\n  /**\n   * @function\n   * Encodes the input to base64url.\n   *\n   * If {input} is a Buffer, then {encoding} is ignored. Otherwise,\n   * {encoding} can be one of \"binary\", \"base64\", \"hex\", \"utf8\".\n   *\n   * @param {Buffer|String} input The data to encode.\n   * @param {String} [encoding = binary] The input encoding format.\n   * @returns {String} the base64url encoding of {input}.\n   */\n  encode: function encode(buffer, encoding) {\n    if (buffer instanceof ArrayBuffer) {\n      buffer = new Uint8Array(buffer);\n    }\n\n    if (!Buffer.isBuffer(buffer)) {\n      buffer = Buffer.from(buffer, encoding);\n    }\n\n    return impl.encode(buffer);\n  },\n  /**\n   * @function\n   * Decodes the input from base64url.\n   *\n   * @param {String} input The data to decode.\n   * @returns {Buffer|String} the base64url decoding of {input}.\n   */\n  decode: impl.toBuffer\n};\n\nmodule.exports = base64url;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2Jhc2U2NHVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLDBEQUFXOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPLG1CQUFtQixVQUFVO0FBQzdDLE1BQU0sVUFBVTtBQUNoQjtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRLDJCQUEyQixNQUFNO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsZUFBZSwyQkFBMkIsTUFBTTtBQUMvRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvdXRpbC9iYXNlNjR1cmwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiB1dGlsL2Jhc2U2NHVybC5qcyAtIEltcGxlbWVudGF0aW9uIG9mIHdlYi1zYWZlIEJhc2U2NCBFbmNvZGVyL0RlY29kZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGltcGwgPSByZXF1aXJlKFwiYmFzZTY0dXJsXCIpO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgYmFzZTY0dXJsXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVzIG1ldGhvZHMgdG8gZW5jb2RlIGFuZCBkZWNvZGUgZGF0YSBhY2NvcmRpbmcgdG8gdGhlXG4gKiBiYXNlNjR1cmwgYWxwaGFiZXQuXG4gKi9cbnZhciBiYXNlNjR1cmwgPSB7XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogRW5jb2RlcyB0aGUgaW5wdXQgdG8gYmFzZTY0dXJsLlxuICAgKlxuICAgKiBJZiB7aW5wdXR9IGlzIGEgQnVmZmVyLCB0aGVuIHtlbmNvZGluZ30gaXMgaWdub3JlZC4gT3RoZXJ3aXNlLFxuICAgKiB7ZW5jb2Rpbmd9IGNhbiBiZSBvbmUgb2YgXCJiaW5hcnlcIiwgXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJ1dGY4XCIuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gaW5wdXQgVGhlIGRhdGEgdG8gZW5jb2RlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2VuY29kaW5nID0gYmluYXJ5XSBUaGUgaW5wdXQgZW5jb2RpbmcgZm9ybWF0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgYmFzZTY0dXJsIGVuY29kaW5nIG9mIHtpbnB1dH0uXG4gICAqL1xuICBlbmNvZGU6IGZ1bmN0aW9uIGVuY29kZShidWZmZXIsIGVuY29kaW5nKSB7XG4gICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIH1cblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJ1ZmZlciwgZW5jb2RpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiBpbXBsLmVuY29kZShidWZmZXIpO1xuICB9LFxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIERlY29kZXMgdGhlIGlucHV0IGZyb20gYmFzZTY0dXJsLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRhdGEgdG8gZGVjb2RlLlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfFN0cmluZ30gdGhlIGJhc2U2NHVybCBkZWNvZGluZyBvZiB7aW5wdXR9LlxuICAgKi9cbiAgZGVjb2RlOiBpbXBsLnRvQnVmZmVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2U2NHVybDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/base64url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/databuffer.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/util/databuffer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * util/databuffer.js - Forge-compatible Buffer based on Node.js Buffers\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    base64url = __webpack_require__(/*! ./base64url.js */ \"(ssr)/./node_modules/node-jose/lib/util/base64url.js\");\n\n/**\n *\n */\nfunction DataBuffer(b, options) {\n  options = options || {};\n\n  // treat (views of) (Array)Buffers special\n  // NOTE: default implementation creates copies, but efficiently\n  //       wherever possible\n  if (Buffer.isBuffer(b)) {\n    this.data = b;\n  } else if (forge.util.isArrayBuffer(b)) {\n    b = new Uint8Array(b);\n    this.data = Buffer.from(b);\n  } else if (forge.util.isArrayBufferView(b)) {\n    b = new Uint8Array(b.buffer, b.byteOffset, b.byteLength);\n    this.data = Buffer.from(b);\n  }\n\n  if (this.data) {\n    this.write = this.data.length;\n    b = undefined;\n  }\n\n  // setup growth rate\n  this.growSize = options.growSize || DataBuffer.DEFAULT_GROW_SIZE;\n\n  // initialize pointers and data\n  this.write = this.write || 0;\n  this.read = this.read || 0;\n  if (b) {\n    this.putBytes(b);\n  } else if (!this.data) {\n    this.accommodate(0);\n  }\n\n  // massage read/write pointers\n  options.readOffset = (\"readOffset\" in options) ?\n                       options.readOffset :\n                       this.read;\n  this.write = (\"writeOffset\" in options) ?\n               options.writeOffset :\n               this.write;\n  this.read = Math.min(options.readOffset, this.write);\n}\nDataBuffer.DEFAULT_GROW_SIZE = 16;\n\nDataBuffer.prototype.length = function() {\n  return this.write - this.read;\n};\nDataBuffer.prototype.available = function() {\n  return this.data.length - this.write;\n};\nDataBuffer.prototype.isEmpty = function() {\n  return this.length() <= 0;\n};\n\nDataBuffer.prototype.accommodate = function(length) {\n  if (!this.data) {\n    // initializes a new buffer\n    length = Math.max(this.write + length, this.growSize);\n\n    this.data = Buffer.alloc(length);\n  } else if (this.available() < length) {\n    length = Math.max(length, this.growSize);\n\n    // create a new empty buffer, and copy current one into it\n    var src = this.data;\n    var dst = Buffer.alloc(src.length + length);\n    src.copy(dst, 0);\n\n    // set data as the new buffer\n    this.data = dst;\n  }\n  // ensure the rest is 0\n  this.data.fill(0, this.write);\n\n  return this;\n};\nDataBuffer.prototype.clear = function() {\n  this.read = this.write = 0;\n  this.data = Buffer.alloc(0);\n  return this;\n};\nDataBuffer.prototype.truncate = function(count) {\n  // chop off <count> bytes from the end\n  this.write = this.read + Math.max(0, this.length() - count);\n  // ensure the remainder is 0\n  this.data.fill(0, this.write);\n  return this;\n};\nDataBuffer.prototype.compact = function() {\n  if (this.read > 0) {\n    if (this.write === this.read) {\n      this.read = this.write = 0;\n    } else {\n      this.data.copy(this.data, 0, this.read, this.write);\n      this.write = this.write - this.read;\n      this.read = 0;\n    }\n    // ensure remainder is 0\n    this.data.fill(0, this.write);\n  }\n  return this;\n};\nDataBuffer.prototype.copy = function() {\n  return new DataBuffer(this, {\n    readOffset: this.read,\n    writeOffset: this.write,\n    growSize: this.growSize\n  });\n};\n\nDataBuffer.prototype.equals = function(test) {\n  if (!DataBuffer.isBuffer(test)) {\n    return false;\n  }\n\n  if (test.length() !== this.length()) {\n    return false;\n  }\n\n  var rval = true,\n      delta = this.read - test.read;\n  // constant time\n  for (var idx = test.read; test.write > idx; idx++) {\n    rval = rval && (this.data[idx + delta] === test.data[idx]);\n  }\n  return rval;\n};\nDataBuffer.prototype.at = function(idx) {\n  return this.data[this.read + idx];\n};\nDataBuffer.prototype.setAt = function(idx, b) {\n  this.data[this.read + idx] = b;\n  return this;\n};\nDataBuffer.prototype.last = function() {\n  return this.data[this.write - 1];\n};\nDataBuffer.prototype.bytes = function(count) {\n  var rval;\n  if (undefined === count) {\n    count = this.length();\n  } else if (count) {\n    count = Math.min(count, this.length());\n  }\n\n  if (0 === count) {\n    rval = \"\";\n  } else {\n    var begin = this.read,\n        end = begin + count,\n        data = this.data.slice(begin, end);\n    rval = String.fromCharCode.apply(null, data);\n  }\n\n  return rval;\n};\nDataBuffer.prototype.buffer = function(count) {\n  var rval;\n  if (undefined === count) {\n    count = this.length();\n  } else if (count) {\n    count = Math.min(count, this.length());\n  }\n\n  if (0 === count) {\n    rval = new ArrayBuffer(0);\n  } else {\n    var begin = this.read,\n        end = begin + count,\n        data = this.data.slice(begin, end);\n    rval = new Uint8Array(end - begin);\n    rval.set(data);\n  }\n\n  return rval;\n};\nDataBuffer.prototype.native = function(count) {\n  var rval;\n  if (\"undefined\" === typeof count) {\n    count = this.length();\n  } else if (count) {\n    count = Math.min(count, this.length());\n  }\n\n  if (0 === count) {\n    rval = Buffer.alloc(0);\n  } else {\n    var begin = this.read,\n        end = begin + count;\n    rval = this.data.slice(begin, end);\n  }\n\n  return rval;\n};\n\nDataBuffer.prototype.toHex = function() {\n  return this.toString(\"hex\");\n};\nDataBuffer.prototype.toString = function(encoding) {\n  // short circuit empty string\n  if (0 === this.length()) {\n    return \"\";\n  }\n\n  var view = this.data.slice(this.read, this.write);\n  encoding = encoding || \"utf8\";\n  // special cases, then built-in support\n  switch (encoding) {\n    case \"raw\":\n      return view.toString(\"binary\");\n    case \"base64url\":\n      return base64url.encode(view);\n    case \"utf16\":\n      return view.toString(\"ucs2\");\n    default:\n      return view.toString(encoding);\n  }\n};\n\nDataBuffer.prototype.fillWithByte = function(b, n) {\n  if (!n) {\n    n = this.available();\n  }\n  this.accommodate(n);\n  this.data.fill(b, this.write, this.write + n);\n  this.write += n;\n\n  return this;\n};\n\nDataBuffer.prototype.getBuffer = function(count) {\n  var rval = this.buffer(count);\n  this.read += rval.byteLength;\n\n  return rval;\n};\nDataBuffer.prototype.putBuffer = function(bytes) {\n  return this.putBytes(bytes);\n};\n\nDataBuffer.prototype.getBytes = function(count) {\n  var rval = this.bytes(count);\n  this.read += rval.length;\n  return rval;\n};\nDataBuffer.prototype.putBytes = function(bytes, encoding) {\n  if (\"string\" === typeof bytes) {\n    // fixup encoding\n    encoding = encoding || \"binary\";\n    switch (encoding) {\n      case \"utf16\":\n        // treat as UCS-2/UTF-16BE\n        encoding = \"ucs-2\";\n        break;\n      case \"raw\":\n        encoding = \"binary\";\n        break;\n      case \"base64url\":\n        // NOTE: this returns a Buffer\n        bytes = base64url.decode(bytes);\n        break;\n    }\n\n    // replace bytes with decoded Buffer (if not already)\n    if (!Buffer.isBuffer(bytes)) {\n      bytes = Buffer.from(bytes, encoding);\n    }\n  }\n\n  var src, dst;\n  if (bytes instanceof DataBuffer) {\n    // be slightly more efficient\n    var orig = bytes;\n    bytes = orig.data.slice(orig.read, orig.write);\n    orig.read = orig.write;\n  } else if (bytes instanceof forge.util.ByteStringBuffer) {\n    bytes = bytes.getBytes();\n  }\n\n  // process array\n  if (Buffer.isBuffer(bytes)) {\n    src = bytes;\n  } else if (Array.isArray(bytes)) {\n    src = Buffer.from(bytes);\n  } else if (forge.util.isArrayBuffer(bytes)) {\n    src = new Uint8Array(bytes);\n    src = Buffer.from(src);\n  } else if (forge.util.isArrayBufferView(bytes)) {\n    src = (bytes instanceof Uint8Array) ?\n              bytes :\n              new Uint8Array(bytes.buffer,\n                             bytes.byteOffset,\n                             bytes.byteLength);\n    src = Buffer.from(src);\n  } else {\n    throw new TypeError(\"invalid source type\");\n  }\n\n  this.accommodate(src.length);\n  dst = this.data;\n  src.copy(dst, this.write);\n  this.write += src.length;\n\n  return this;\n};\n\nDataBuffer.prototype.getNative = function(count) {\n  var rval = this.native(count);\n  this.read += rval.length;\n  return rval;\n};\nDataBuffer.prototype.putNative = DataBuffer.prototype.putBuffer;\n\nDataBuffer.prototype.getByte = function() {\n  var b = this.data[this.read];\n  this.read = Math.min(this.read + 1, this.write);\n  return b;\n};\nDataBuffer.prototype.putByte = function(b) {\n  this.accommodate(1);\n  this.data[this.write] = b & 0xff;\n  this.write++;\n\n  return this;\n};\n\nDataBuffer.prototype.getInt16 = function() {\n  var n = (this.data[this.read] << 8) ^\n          (this.data[this.read + 1]);\n  this.read = Math.min(this.read + 2, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt16 = function(n) {\n  this.accommodate(2);\n  this.data[this.write] = (n >>> 8) & 0xff;\n  this.data[this.write + 1] = n & 0xff;\n  this.write += 2;\n  return this;\n};\n\nDataBuffer.prototype.getInt24 = function() {\n  var n = (this.data[this.read] << 16) ^\n          (this.data[this.read + 1] << 8) ^\n          this.data[this.read + 2];\n  this.read = Math.min(this.read + 3, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt24 = function(n) {\n  this.accommodate(3);\n  this.data[this.write] = (n >>> 16) & 0xff;\n  this.data[this.write + 1] = (n >>> 8) & 0xff;\n  this.data[this.write + 2] = n & 0xff;\n  this.write += 3;\n  return this;\n};\n\nDataBuffer.prototype.getInt32 = function() {\n  var n = (this.data[this.read] << 24) ^\n          (this.data[this.read + 1] << 16) ^\n          (this.data[this.read + 2] << 8) ^\n          this.data[this.read + 3];\n  this.read = Math.min(this.read + 4, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt32 = function(n) {\n  this.accommodate(4);\n  this.data[this.write] = (n >>> 24) & 0xff;\n  this.data[this.write + 1] = (n >>> 16) & 0xff;\n  this.data[this.write + 2] = (n >>> 8) & 0xff;\n  this.data[this.write + 3] = n & 0xff;\n  this.write += 4;\n  return this;\n};\n\nDataBuffer.prototype.getInt16Le = function() {\n  var n = (this.data[this.read + 1] << 8) ^\n          this.data[this.read];\n  this.read = Math.min(this.read + 2, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt16Le = function(n) {\n  this.accommodate(2);\n  this.data[this.write + 1] = (n >>> 8) & 0xff;\n  this.data[this.write] = n & 0xff;\n  this.write += 2;\n  return this;\n};\n\nDataBuffer.prototype.getInt24Le = function() {\n  var n = (this.data[this.read + 2] << 16) ^\n          (this.data[this.read + 1] << 8) ^\n          this.data[this.read];\n  this.read = Math.min(this.read + 3, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt24Le = function(n) {\n  this.accommodate(3);\n  this.data[this.write + 2] = (n >>> 16) & 0xff;\n  this.data[this.write + 1] = (n >>> 8) & 0xff;\n  this.data[this.write] = n & 0xff;\n  this.write += 3;\n  return this;\n};\nDataBuffer.prototype.getInt32Le = function() {\n  var n = (this.data[this.read + 3] << 24) ^\n          (this.data[this.read + 2] << 16) ^\n          (this.data[this.read + 1] << 8) ^\n          this.data[this.read];\n  this.read = Math.min(this.read + 4, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt32Le = function(n) {\n  this.accommodate(4);\n  this.data[this.write + 3] = (n >>> 24) & 0xff;\n  this.data[this.write + 2] = (n >>> 16) & 0xff;\n  this.data[this.write + 1] = (n >>> 8) & 0xff;\n  this.data[this.write] = n & 0xff;\n  this.write += 4;\n  return this;\n};\n\nDataBuffer.prototype.getInt = function(bits) {\n  var rval = 0;\n  do {\n    rval = (rval << 8) | this.getByte();\n    bits -= 8;\n  } while (bits > 0);\n  return rval;\n};\nDataBuffer.prototype.putInt = function(n, bits) {\n  this.accommodate(Math.ceil(bits / 8));\n  do {\n    bits -= 8;\n    this.putByte((n >> bits) & 0xff);\n  } while (bits > 0);\n  return this;\n};\n\nDataBuffer.prototype.putSignedInt = function(n, bits) {\n  if (n < 0) {\n    n += 2 << (bits - 1);\n  }\n  return this.putInt(n, bits);\n};\n\nDataBuffer.prototype.putString = function(str) {\n  return this.putBytes(str, \"utf16\");\n};\n\nDataBuffer.isBuffer = function(test) {\n  return (test instanceof DataBuffer);\n};\nDataBuffer.asBuffer = function(orig) {\n  return DataBuffer.isBuffer(orig) ?\n         orig :\n         orig ?\n         new DataBuffer(orig) :\n         new DataBuffer();\n};\n\nmodule.exports = DataBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2RhdGFidWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwRUFBa0I7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsNEVBQWdCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvdXRpbC9kYXRhYnVmZmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogdXRpbC9kYXRhYnVmZmVyLmpzIC0gRm9yZ2UtY29tcGF0aWJsZSBCdWZmZXIgYmFzZWQgb24gTm9kZS5qcyBCdWZmZXJzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlLmpzXCIpLFxuICAgIGJhc2U2NHVybCA9IHJlcXVpcmUoXCIuL2Jhc2U2NHVybC5qc1wiKTtcblxuLyoqXG4gKlxuICovXG5mdW5jdGlvbiBEYXRhQnVmZmVyKGIsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdHJlYXQgKHZpZXdzIG9mKSAoQXJyYXkpQnVmZmVycyBzcGVjaWFsXG4gIC8vIE5PVEU6IGRlZmF1bHQgaW1wbGVtZW50YXRpb24gY3JlYXRlcyBjb3BpZXMsIGJ1dCBlZmZpY2llbnRseVxuICAvLyAgICAgICB3aGVyZXZlciBwb3NzaWJsZVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhpcy5kYXRhID0gYjtcbiAgfSBlbHNlIGlmIChmb3JnZS51dGlsLmlzQXJyYXlCdWZmZXIoYikpIHtcbiAgICBiID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYik7XG4gIH0gZWxzZSBpZiAoZm9yZ2UudXRpbC5pc0FycmF5QnVmZmVyVmlldyhiKSkge1xuICAgIGIgPSBuZXcgVWludDhBcnJheShiLmJ1ZmZlciwgYi5ieXRlT2Zmc2V0LCBiLmJ5dGVMZW5ndGgpO1xuICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGIpO1xuICB9XG5cbiAgaWYgKHRoaXMuZGF0YSkge1xuICAgIHRoaXMud3JpdGUgPSB0aGlzLmRhdGEubGVuZ3RoO1xuICAgIGIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBzZXR1cCBncm93dGggcmF0ZVxuICB0aGlzLmdyb3dTaXplID0gb3B0aW9ucy5ncm93U2l6ZSB8fCBEYXRhQnVmZmVyLkRFRkFVTFRfR1JPV19TSVpFO1xuXG4gIC8vIGluaXRpYWxpemUgcG9pbnRlcnMgYW5kIGRhdGFcbiAgdGhpcy53cml0ZSA9IHRoaXMud3JpdGUgfHwgMDtcbiAgdGhpcy5yZWFkID0gdGhpcy5yZWFkIHx8IDA7XG4gIGlmIChiKSB7XG4gICAgdGhpcy5wdXRCeXRlcyhiKTtcbiAgfSBlbHNlIGlmICghdGhpcy5kYXRhKSB7XG4gICAgdGhpcy5hY2NvbW1vZGF0ZSgwKTtcbiAgfVxuXG4gIC8vIG1hc3NhZ2UgcmVhZC93cml0ZSBwb2ludGVyc1xuICBvcHRpb25zLnJlYWRPZmZzZXQgPSAoXCJyZWFkT2Zmc2V0XCIgaW4gb3B0aW9ucykgP1xuICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlYWRPZmZzZXQgOlxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWQ7XG4gIHRoaXMud3JpdGUgPSAoXCJ3cml0ZU9mZnNldFwiIGluIG9wdGlvbnMpID9cbiAgICAgICAgICAgICAgIG9wdGlvbnMud3JpdGVPZmZzZXQgOlxuICAgICAgICAgICAgICAgdGhpcy53cml0ZTtcbiAgdGhpcy5yZWFkID0gTWF0aC5taW4ob3B0aW9ucy5yZWFkT2Zmc2V0LCB0aGlzLndyaXRlKTtcbn1cbkRhdGFCdWZmZXIuREVGQVVMVF9HUk9XX1NJWkUgPSAxNjtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndyaXRlIC0gdGhpcy5yZWFkO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLmF2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aCAtIHRoaXMud3JpdGU7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGgoKSA8PSAwO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUuYWNjb21tb2RhdGUgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgaWYgKCF0aGlzLmRhdGEpIHtcbiAgICAvLyBpbml0aWFsaXplcyBhIG5ldyBidWZmZXJcbiAgICBsZW5ndGggPSBNYXRoLm1heCh0aGlzLndyaXRlICsgbGVuZ3RoLCB0aGlzLmdyb3dTaXplKTtcblxuICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICB9IGVsc2UgaWYgKHRoaXMuYXZhaWxhYmxlKCkgPCBsZW5ndGgpIHtcbiAgICBsZW5ndGggPSBNYXRoLm1heChsZW5ndGgsIHRoaXMuZ3Jvd1NpemUpO1xuXG4gICAgLy8gY3JlYXRlIGEgbmV3IGVtcHR5IGJ1ZmZlciwgYW5kIGNvcHkgY3VycmVudCBvbmUgaW50byBpdFxuICAgIHZhciBzcmMgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGRzdCA9IEJ1ZmZlci5hbGxvYyhzcmMubGVuZ3RoICsgbGVuZ3RoKTtcbiAgICBzcmMuY29weShkc3QsIDApO1xuXG4gICAgLy8gc2V0IGRhdGEgYXMgdGhlIG5ldyBidWZmZXJcbiAgICB0aGlzLmRhdGEgPSBkc3Q7XG4gIH1cbiAgLy8gZW5zdXJlIHRoZSByZXN0IGlzIDBcbiAgdGhpcy5kYXRhLmZpbGwoMCwgdGhpcy53cml0ZSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWFkID0gdGhpcy53cml0ZSA9IDA7XG4gIHRoaXMuZGF0YSA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihjb3VudCkge1xuICAvLyBjaG9wIG9mZiA8Y291bnQ+IGJ5dGVzIGZyb20gdGhlIGVuZFxuICB0aGlzLndyaXRlID0gdGhpcy5yZWFkICsgTWF0aC5tYXgoMCwgdGhpcy5sZW5ndGgoKSAtIGNvdW50KTtcbiAgLy8gZW5zdXJlIHRoZSByZW1haW5kZXIgaXMgMFxuICB0aGlzLmRhdGEuZmlsbCgwLCB0aGlzLndyaXRlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5yZWFkID4gMCkge1xuICAgIGlmICh0aGlzLndyaXRlID09PSB0aGlzLnJlYWQpIHtcbiAgICAgIHRoaXMucmVhZCA9IHRoaXMud3JpdGUgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRhdGEuY29weSh0aGlzLmRhdGEsIDAsIHRoaXMucmVhZCwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlID0gdGhpcy53cml0ZSAtIHRoaXMucmVhZDtcbiAgICAgIHRoaXMucmVhZCA9IDA7XG4gICAgfVxuICAgIC8vIGVuc3VyZSByZW1haW5kZXIgaXMgMFxuICAgIHRoaXMuZGF0YS5maWxsKDAsIHRoaXMud3JpdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBEYXRhQnVmZmVyKHRoaXMsIHtcbiAgICByZWFkT2Zmc2V0OiB0aGlzLnJlYWQsXG4gICAgd3JpdGVPZmZzZXQ6IHRoaXMud3JpdGUsXG4gICAgZ3Jvd1NpemU6IHRoaXMuZ3Jvd1NpemVcbiAgfSk7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbih0ZXN0KSB7XG4gIGlmICghRGF0YUJ1ZmZlci5pc0J1ZmZlcih0ZXN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0ZXN0Lmxlbmd0aCgpICE9PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHJ2YWwgPSB0cnVlLFxuICAgICAgZGVsdGEgPSB0aGlzLnJlYWQgLSB0ZXN0LnJlYWQ7XG4gIC8vIGNvbnN0YW50IHRpbWVcbiAgZm9yICh2YXIgaWR4ID0gdGVzdC5yZWFkOyB0ZXN0LndyaXRlID4gaWR4OyBpZHgrKykge1xuICAgIHJ2YWwgPSBydmFsICYmICh0aGlzLmRhdGFbaWR4ICsgZGVsdGFdID09PSB0ZXN0LmRhdGFbaWR4XSk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihpZHgpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLnJlYWQgKyBpZHhdO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24oaWR4LCBiKSB7XG4gIHRoaXMuZGF0YVt0aGlzLnJlYWQgKyBpZHhdID0gYjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhW3RoaXMud3JpdGUgLSAxXTtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBydmFsO1xuICBpZiAodW5kZWZpbmVkID09PSBjb3VudCkge1xuICAgIGNvdW50ID0gdGhpcy5sZW5ndGgoKTtcbiAgfSBlbHNlIGlmIChjb3VudCkge1xuICAgIGNvdW50ID0gTWF0aC5taW4oY291bnQsIHRoaXMubGVuZ3RoKCkpO1xuICB9XG5cbiAgaWYgKDAgPT09IGNvdW50KSB7XG4gICAgcnZhbCA9IFwiXCI7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJlZ2luID0gdGhpcy5yZWFkLFxuICAgICAgICBlbmQgPSBiZWdpbiArIGNvdW50LFxuICAgICAgICBkYXRhID0gdGhpcy5kYXRhLnNsaWNlKGJlZ2luLCBlbmQpO1xuICAgIHJ2YWwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUuYnVmZmVyID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIHJ2YWw7XG4gIGlmICh1bmRlZmluZWQgPT09IGNvdW50KSB7XG4gICAgY291bnQgPSB0aGlzLmxlbmd0aCgpO1xuICB9IGVsc2UgaWYgKGNvdW50KSB7XG4gICAgY291bnQgPSBNYXRoLm1pbihjb3VudCwgdGhpcy5sZW5ndGgoKSk7XG4gIH1cblxuICBpZiAoMCA9PT0gY291bnQpIHtcbiAgICBydmFsID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9IGVsc2Uge1xuICAgIHZhciBiZWdpbiA9IHRoaXMucmVhZCxcbiAgICAgICAgZW5kID0gYmVnaW4gKyBjb3VudCxcbiAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zbGljZShiZWdpbiwgZW5kKTtcbiAgICBydmFsID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gYmVnaW4pO1xuICAgIHJ2YWwuc2V0KGRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUubmF0aXZlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIHJ2YWw7XG4gIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgY291bnQpIHtcbiAgICBjb3VudCA9IHRoaXMubGVuZ3RoKCk7XG4gIH0gZWxzZSBpZiAoY291bnQpIHtcbiAgICBjb3VudCA9IE1hdGgubWluKGNvdW50LCB0aGlzLmxlbmd0aCgpKTtcbiAgfVxuXG4gIGlmICgwID09PSBjb3VudCkge1xuICAgIHJ2YWwgPSBCdWZmZXIuYWxsb2MoMCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJlZ2luID0gdGhpcy5yZWFkLFxuICAgICAgICBlbmQgPSBiZWdpbiArIGNvdW50O1xuICAgIHJ2YWwgPSB0aGlzLmRhdGEuc2xpY2UoYmVnaW4sIGVuZCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKFwiaGV4XCIpO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgLy8gc2hvcnQgY2lyY3VpdCBlbXB0eSBzdHJpbmdcbiAgaWYgKDAgPT09IHRoaXMubGVuZ3RoKCkpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIHZhciB2aWV3ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy53cml0ZSk7XG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgXCJ1dGY4XCI7XG4gIC8vIHNwZWNpYWwgY2FzZXMsIHRoZW4gYnVpbHQtaW4gc3VwcG9ydFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSBcInJhd1wiOlxuICAgICAgcmV0dXJuIHZpZXcudG9TdHJpbmcoXCJiaW5hcnlcIik7XG4gICAgY2FzZSBcImJhc2U2NHVybFwiOlxuICAgICAgcmV0dXJuIGJhc2U2NHVybC5lbmNvZGUodmlldyk7XG4gICAgY2FzZSBcInV0ZjE2XCI6XG4gICAgICByZXR1cm4gdmlldy50b1N0cmluZyhcInVjczJcIik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2aWV3LnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgfVxufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZmlsbFdpdGhCeXRlID0gZnVuY3Rpb24oYiwgbikge1xuICBpZiAoIW4pIHtcbiAgICBuID0gdGhpcy5hdmFpbGFibGUoKTtcbiAgfVxuICB0aGlzLmFjY29tbW9kYXRlKG4pO1xuICB0aGlzLmRhdGEuZmlsbChiLCB0aGlzLndyaXRlLCB0aGlzLndyaXRlICsgbik7XG4gIHRoaXMud3JpdGUgKz0gbjtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBydmFsID0gdGhpcy5idWZmZXIoY291bnQpO1xuICB0aGlzLnJlYWQgKz0gcnZhbC5ieXRlTGVuZ3RoO1xuXG4gIHJldHVybiBydmFsO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEJ1ZmZlciA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKGJ5dGVzKTtcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmJ5dGVzKGNvdW50KTtcbiAgdGhpcy5yZWFkICs9IHJ2YWwubGVuZ3RoO1xuICByZXR1cm4gcnZhbDtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlcyA9IGZ1bmN0aW9uKGJ5dGVzLCBlbmNvZGluZykge1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGJ5dGVzKSB7XG4gICAgLy8gZml4dXAgZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IFwiYmluYXJ5XCI7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSBcInV0ZjE2XCI6XG4gICAgICAgIC8vIHRyZWF0IGFzIFVDUy0yL1VURi0xNkJFXG4gICAgICAgIGVuY29kaW5nID0gXCJ1Y3MtMlwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyYXdcIjpcbiAgICAgICAgZW5jb2RpbmcgPSBcImJpbmFyeVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiYXNlNjR1cmxcIjpcbiAgICAgICAgLy8gTk9URTogdGhpcyByZXR1cm5zIGEgQnVmZmVyXG4gICAgICAgIGJ5dGVzID0gYmFzZTY0dXJsLmRlY29kZShieXRlcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgYnl0ZXMgd2l0aCBkZWNvZGVkIEJ1ZmZlciAoaWYgbm90IGFscmVhZHkpXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnl0ZXMpKSB7XG4gICAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCBlbmNvZGluZyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNyYywgZHN0O1xuICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBEYXRhQnVmZmVyKSB7XG4gICAgLy8gYmUgc2xpZ2h0bHkgbW9yZSBlZmZpY2llbnRcbiAgICB2YXIgb3JpZyA9IGJ5dGVzO1xuICAgIGJ5dGVzID0gb3JpZy5kYXRhLnNsaWNlKG9yaWcucmVhZCwgb3JpZy53cml0ZSk7XG4gICAgb3JpZy5yZWFkID0gb3JpZy53cml0ZTtcbiAgfSBlbHNlIGlmIChieXRlcyBpbnN0YW5jZW9mIGZvcmdlLnV0aWwuQnl0ZVN0cmluZ0J1ZmZlcikge1xuICAgIGJ5dGVzID0gYnl0ZXMuZ2V0Qnl0ZXMoKTtcbiAgfVxuXG4gIC8vIHByb2Nlc3MgYXJyYXlcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihieXRlcykpIHtcbiAgICBzcmMgPSBieXRlcztcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIHNyYyA9IEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSBlbHNlIGlmIChmb3JnZS51dGlsLmlzQXJyYXlCdWZmZXIoYnl0ZXMpKSB7XG4gICAgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIHNyYyA9IEJ1ZmZlci5mcm9tKHNyYyk7XG4gIH0gZWxzZSBpZiAoZm9yZ2UudXRpbC5pc0FycmF5QnVmZmVyVmlldyhieXRlcykpIHtcbiAgICBzcmMgPSAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSA/XG4gICAgICAgICAgICAgIGJ5dGVzIDpcbiAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcy5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICBzcmMgPSBCdWZmZXIuZnJvbShzcmMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHNvdXJjZSB0eXBlXCIpO1xuICB9XG5cbiAgdGhpcy5hY2NvbW1vZGF0ZShzcmMubGVuZ3RoKTtcbiAgZHN0ID0gdGhpcy5kYXRhO1xuICBzcmMuY29weShkc3QsIHRoaXMud3JpdGUpO1xuICB0aGlzLndyaXRlICs9IHNyYy5sZW5ndGg7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXROYXRpdmUgPSBmdW5jdGlvbihjb3VudCkge1xuICB2YXIgcnZhbCA9IHRoaXMubmF0aXZlKGNvdW50KTtcbiAgdGhpcy5yZWFkICs9IHJ2YWwubGVuZ3RoO1xuICByZXR1cm4gcnZhbDtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXROYXRpdmUgPSBEYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCdWZmZXI7XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGIgPSB0aGlzLmRhdGFbdGhpcy5yZWFkXTtcbiAgdGhpcy5yZWFkID0gTWF0aC5taW4odGhpcy5yZWFkICsgMSwgdGhpcy53cml0ZSk7XG4gIHJldHVybiBiO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGUgPSBmdW5jdGlvbihiKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMSk7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlXSA9IGIgJiAweGZmO1xuICB0aGlzLndyaXRlKys7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9ICh0aGlzLmRhdGFbdGhpcy5yZWFkXSA8PCA4KSBeXG4gICAgICAgICAgKHRoaXMuZGF0YVt0aGlzLnJlYWQgKyAxXSk7XG4gIHRoaXMucmVhZCA9IE1hdGgubWluKHRoaXMucmVhZCArIDIsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gbjtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQxNiA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgyKTtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGVdID0gKG4gPj4+IDgpICYgMHhmZjtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGUgKyAxXSA9IG4gJiAweGZmO1xuICB0aGlzLndyaXRlICs9IDI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSAodGhpcy5kYXRhW3RoaXMucmVhZF0gPDwgMTYpIF5cbiAgICAgICAgICAodGhpcy5kYXRhW3RoaXMucmVhZCArIDFdIDw8IDgpIF5cbiAgICAgICAgICB0aGlzLmRhdGFbdGhpcy5yZWFkICsgMl07XG4gIHRoaXMucmVhZCA9IE1hdGgubWluKHRoaXMucmVhZCArIDMsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gbjtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNCA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgzKTtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGVdID0gKG4gPj4+IDE2KSAmIDB4ZmY7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlICsgMV0gPSAobiA+Pj4gOCkgJiAweGZmO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZSArIDJdID0gbiAmIDB4ZmY7XG4gIHRoaXMud3JpdGUgKz0gMztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9ICh0aGlzLmRhdGFbdGhpcy5yZWFkXSA8PCAyNCkgXlxuICAgICAgICAgICh0aGlzLmRhdGFbdGhpcy5yZWFkICsgMV0gPDwgMTYpIF5cbiAgICAgICAgICAodGhpcy5kYXRhW3RoaXMucmVhZCArIDJdIDw8IDgpIF5cbiAgICAgICAgICB0aGlzLmRhdGFbdGhpcy5yZWFkICsgM107XG4gIHRoaXMucmVhZCA9IE1hdGgubWluKHRoaXMucmVhZCArIDQsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gbjtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMiA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSg0KTtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGVdID0gKG4gPj4+IDI0KSAmIDB4ZmY7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlICsgMV0gPSAobiA+Pj4gMTYpICYgMHhmZjtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGUgKyAyXSA9IChuID4+PiA4KSAmIDB4ZmY7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlICsgM10gPSBuICYgMHhmZjtcbiAgdGhpcy53cml0ZSArPSA0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDE2TGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSAodGhpcy5kYXRhW3RoaXMucmVhZCArIDFdIDw8IDgpIF5cbiAgICAgICAgICB0aGlzLmRhdGFbdGhpcy5yZWFkXTtcbiAgdGhpcy5yZWFkID0gTWF0aC5taW4odGhpcy5yZWFkICsgMiwgdGhpcy53cml0ZSk7XG4gIHJldHVybiBuO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlICsgMV0gPSAobiA+Pj4gOCkgJiAweGZmO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZV0gPSBuICYgMHhmZjtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDI0TGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSAodGhpcy5kYXRhW3RoaXMucmVhZCArIDJdIDw8IDE2KSBeXG4gICAgICAgICAgKHRoaXMuZGF0YVt0aGlzLnJlYWQgKyAxXSA8PCA4KSBeXG4gICAgICAgICAgdGhpcy5kYXRhW3RoaXMucmVhZF07XG4gIHRoaXMucmVhZCA9IE1hdGgubWluKHRoaXMucmVhZCArIDMsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gbjtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNExlID0gZnVuY3Rpb24obikge1xuICB0aGlzLmFjY29tbW9kYXRlKDMpO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZSArIDJdID0gKG4gPj4+IDE2KSAmIDB4ZmY7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlICsgMV0gPSAobiA+Pj4gOCkgJiAweGZmO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZV0gPSBuICYgMHhmZjtcbiAgdGhpcy53cml0ZSArPSAzO1xuICByZXR1cm4gdGhpcztcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuID0gKHRoaXMuZGF0YVt0aGlzLnJlYWQgKyAzXSA8PCAyNCkgXlxuICAgICAgICAgICh0aGlzLmRhdGFbdGhpcy5yZWFkICsgMl0gPDwgMTYpIF5cbiAgICAgICAgICAodGhpcy5kYXRhW3RoaXMucmVhZCArIDFdIDw8IDgpIF5cbiAgICAgICAgICB0aGlzLmRhdGFbdGhpcy5yZWFkXTtcbiAgdGhpcy5yZWFkID0gTWF0aC5taW4odGhpcy5yZWFkICsgNCwgdGhpcy53cml0ZSk7XG4gIHJldHVybiBuO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDMyTGUgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoNCk7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlICsgM10gPSAobiA+Pj4gMjQpICYgMHhmZjtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGUgKyAyXSA9IChuID4+PiAxNikgJiAweGZmO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZSArIDFdID0gKG4gPj4+IDgpICYgMHhmZjtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGVdID0gbiAmIDB4ZmY7XG4gIHRoaXMud3JpdGUgKz0gNDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQgPSBmdW5jdGlvbihiaXRzKSB7XG4gIHZhciBydmFsID0gMDtcbiAgZG8ge1xuICAgIHJ2YWwgPSAocnZhbCA8PCA4KSB8IHRoaXMuZ2V0Qnl0ZSgpO1xuICAgIGJpdHMgLT0gODtcbiAgfSB3aGlsZSAoYml0cyA+IDApO1xuICByZXR1cm4gcnZhbDtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQgPSBmdW5jdGlvbihuLCBiaXRzKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoTWF0aC5jZWlsKGJpdHMgLyA4KSk7XG4gIGRvIHtcbiAgICBiaXRzIC09IDg7XG4gICAgdGhpcy5wdXRCeXRlKChuID4+IGJpdHMpICYgMHhmZik7XG4gIH0gd2hpbGUgKGJpdHMgPiAwKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRTaWduZWRJbnQgPSBmdW5jdGlvbihuLCBiaXRzKSB7XG4gIGlmIChuIDwgMCkge1xuICAgIG4gKz0gMiA8PCAoYml0cyAtIDEpO1xuICB9XG4gIHJldHVybiB0aGlzLnB1dEludChuLCBiaXRzKTtcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhzdHIsIFwidXRmMTZcIik7XG59O1xuXG5EYXRhQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24odGVzdCkge1xuICByZXR1cm4gKHRlc3QgaW5zdGFuY2VvZiBEYXRhQnVmZmVyKTtcbn07XG5EYXRhQnVmZmVyLmFzQnVmZmVyID0gZnVuY3Rpb24ob3JpZykge1xuICByZXR1cm4gRGF0YUJ1ZmZlci5pc0J1ZmZlcihvcmlnKSA/XG4gICAgICAgICBvcmlnIDpcbiAgICAgICAgIG9yaWcgP1xuICAgICAgICAgbmV3IERhdGFCdWZmZXIob3JpZykgOlxuICAgICAgICAgbmV3IERhdGFCdWZmZXIoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YUJ1ZmZlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/databuffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/index.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/util/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * util/index.js - Utilities Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\");\n\nvar util;\n\nfunction asBuffer(input, encoding) {\n  if (Buffer.isBuffer(input)) {\n    return input;\n  }\n\n  if (\"string\" === typeof input) {\n    encoding = encoding || \"binary\";\n    if (\"base64url\" === encoding) {\n      return util.base64url.decode(input);\n    }\n    return Buffer.from(input, encoding);\n  }\n\n  // assume input is an Array, ArrayBuffer, or ArrayBufferView\n  if (forge.util.isArrayBufferView(input)) {\n    input = (input instanceof Uint8Array) ?\n            input :\n            new Uint8Array(input.buffer, input.byteOffset, input.byteOffset + input.byteLength);\n  } else if (forge.util.isArrayBuffer(input)) {\n    input = new Uint8Array(input);\n  }\n\n  var output;\n  output = Buffer.from(input);\n\n  return output;\n}\n\nfunction randomBytes(len) {\n  return Buffer.from(forge.random.getBytes(len), \"binary\");\n}\n\nutil = {\n  base64url: __webpack_require__(/*! ./base64url.js */ \"(ssr)/./node_modules/node-jose/lib/util/base64url.js\"),\n  utf8: __webpack_require__(/*! ./utf8.js */ \"(ssr)/./node_modules/node-jose/lib/util/utf8.js\"),\n  asBuffer: asBuffer,\n  randomBytes: randomBytes\n};\nmodule.exports = util;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQWtCOztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDckMsUUFBUSxtQkFBTyxDQUFDLGtFQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL3V0aWwvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiB1dGlsL2luZGV4LmpzIC0gVXRpbGl0aWVzIEVudHJ5IFBvaW50XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlLmpzXCIpO1xuXG52YXIgdXRpbDtcblxuZnVuY3Rpb24gYXNCdWZmZXIoaW5wdXQsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dCkge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgXCJiaW5hcnlcIjtcbiAgICBpZiAoXCJiYXNlNjR1cmxcIiA9PT0gZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiB1dGlsLmJhc2U2NHVybC5kZWNvZGUoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaW5wdXQsIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIGFzc3VtZSBpbnB1dCBpcyBhbiBBcnJheSwgQXJyYXlCdWZmZXIsIG9yIEFycmF5QnVmZmVyVmlld1xuICBpZiAoZm9yZ2UudXRpbC5pc0FycmF5QnVmZmVyVmlldyhpbnB1dCkpIHtcbiAgICBpbnB1dCA9IChpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpID9cbiAgICAgICAgICAgIGlucHV0IDpcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGlucHV0LmJ1ZmZlciwgaW5wdXQuYnl0ZU9mZnNldCwgaW5wdXQuYnl0ZU9mZnNldCArIGlucHV0LmJ5dGVMZW5ndGgpO1xuICB9IGVsc2UgaWYgKGZvcmdlLnV0aWwuaXNBcnJheUJ1ZmZlcihpbnB1dCkpIHtcbiAgICBpbnB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgfVxuXG4gIHZhciBvdXRwdXQ7XG4gIG91dHB1dCA9IEJ1ZmZlci5mcm9tKGlucHV0KTtcblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiByYW5kb21CeXRlcyhsZW4pIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhsZW4pLCBcImJpbmFyeVwiKTtcbn1cblxudXRpbCA9IHtcbiAgYmFzZTY0dXJsOiByZXF1aXJlKFwiLi9iYXNlNjR1cmwuanNcIiksXG4gIHV0Zjg6IHJlcXVpcmUoXCIuL3V0ZjguanNcIiksXG4gIGFzQnVmZmVyOiBhc0J1ZmZlcixcbiAgcmFuZG9tQnl0ZXM6IHJhbmRvbUJ5dGVzXG59O1xubW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/merge.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/util/merge.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * util/utf8.js - Implementation of UTF-8 Encoder/Decoder\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar partialRight = __webpack_require__(/*! lodash/partialRight */ \"(ssr)/./node_modules/lodash/partialRight.js\");\nvar merge = __webpack_require__(/*! lodash/merge */ \"(ssr)/./node_modules/lodash/merge.js\");\n\nvar typedArrayCtors = (function() {\n  var ctors = [];\n  if (\"undefined\" !== typeof Uint8ClampedArray) {\n    ctors.push(Uint8ClampedArray);\n  }\n  if (\"undefined\" !== typeof Uint8Array) {\n    ctors.push(Uint8Array);\n  }\n  if (\"undefined\" !== typeof Uint16Array) {\n    ctors.push(Uint16Array);\n  }\n  if (\"undefined\" !== typeof Uint32Array) {\n    ctors.push(Uint32Array);\n  }\n  if (\"undefined\" !== typeof Float32Array) {\n    ctors.push(Float32Array);\n  }\n  if (\"undefined\" !== typeof Float64Array) {\n    ctors.push(Float64Array);\n  }\n  return ctors;\n})();\n\nfunction findTypedArrayFor(ta) {\n  var ctor;\n  for (var idx = 0; !ctor && typedArrayCtors.length > idx; idx++) {\n    if (ta instanceof typedArrayCtors[idx]) {\n      ctor = typedArrayCtors[idx];\n    }\n  }\n  return ctor;\n}\n\nfunction mergeBuffer(a, b) {\n  // TODO: should this be a copy, or the reference itself?\n  if (Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  } else {\n    var Ctor = findTypedArrayFor(b);\n    b = Ctor ?\n        new Ctor(b, b.byteOffset, b.byteLength) :\n        undefined;\n  }\n\n  // TODO: QUESTION: create a merged <whatever-a-is>??\n  // for now, a is b\n  a = b;\n\n  return b;\n}\n\nmodule.exports = partialRight(merge, mergeBuffer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL21lcmdlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBcUI7QUFDaEQsWUFBWSxtQkFBTyxDQUFDLDBEQUFjOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL3V0aWwvbWVyZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiB1dGlsL3V0ZjguanMgLSBJbXBsZW1lbnRhdGlvbiBvZiBVVEYtOCBFbmNvZGVyL0RlY29kZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHBhcnRpYWxSaWdodCA9IHJlcXVpcmUoXCJsb2Rhc2gvcGFydGlhbFJpZ2h0XCIpO1xudmFyIG1lcmdlID0gcmVxdWlyZShcImxvZGFzaC9tZXJnZVwiKTtcblxudmFyIHR5cGVkQXJyYXlDdG9ycyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGN0b3JzID0gW107XG4gIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICBjdG9ycy5wdXNoKFVpbnQ4Q2xhbXBlZEFycmF5KTtcbiAgfVxuICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBjdG9ycy5wdXNoKFVpbnQ4QXJyYXkpO1xuICB9XG4gIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgVWludDE2QXJyYXkpIHtcbiAgICBjdG9ycy5wdXNoKFVpbnQxNkFycmF5KTtcbiAgfVxuICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgY3RvcnMucHVzaChVaW50MzJBcnJheSk7XG4gIH1cbiAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICBjdG9ycy5wdXNoKEZsb2F0MzJBcnJheSk7XG4gIH1cbiAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICBjdG9ycy5wdXNoKEZsb2F0NjRBcnJheSk7XG4gIH1cbiAgcmV0dXJuIGN0b3JzO1xufSkoKTtcblxuZnVuY3Rpb24gZmluZFR5cGVkQXJyYXlGb3IodGEpIHtcbiAgdmFyIGN0b3I7XG4gIGZvciAodmFyIGlkeCA9IDA7ICFjdG9yICYmIHR5cGVkQXJyYXlDdG9ycy5sZW5ndGggPiBpZHg7IGlkeCsrKSB7XG4gICAgaWYgKHRhIGluc3RhbmNlb2YgdHlwZWRBcnJheUN0b3JzW2lkeF0pIHtcbiAgICAgIGN0b3IgPSB0eXBlZEFycmF5Q3RvcnNbaWR4XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN0b3I7XG59XG5cbmZ1bmN0aW9uIG1lcmdlQnVmZmVyKGEsIGIpIHtcbiAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgYSBjb3B5LCBvciB0aGUgcmVmZXJlbmNlIGl0c2VsZj9cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIGIgPSBCdWZmZXIuZnJvbShiKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgQ3RvciA9IGZpbmRUeXBlZEFycmF5Rm9yKGIpO1xuICAgIGIgPSBDdG9yID9cbiAgICAgICAgbmV3IEN0b3IoYiwgYi5ieXRlT2Zmc2V0LCBiLmJ5dGVMZW5ndGgpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gVE9ETzogUVVFU1RJT046IGNyZWF0ZSBhIG1lcmdlZCA8d2hhdGV2ZXItYS1pcz4/P1xuICAvLyBmb3Igbm93LCBhIGlzIGJcbiAgYSA9IGI7XG5cbiAgcmV0dXJuIGI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFydGlhbFJpZ2h0KG1lcmdlLCBtZXJnZUJ1ZmZlcik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/merge.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/utf8.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/util/utf8.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*!\n * util/utf8.js - Implementation of UTF-8 Encoder/Decoder\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar utf8 = exports;\n\nutf8.encode = function(input) {\n  var output = encodeURIComponent(input || \"\");\n  output = output.replace(/%([0-9a-fA-F]{2})/g, function(m, code) {\n    code = parseInt(code, 16);\n    return String.fromCharCode(code);\n  });\n\n  return output;\n};\nutf8.decode = function(input) {\n  var output = (input || \"\").replace(/[\\u0080-\\u00ff]/g, function(m) {\n    var code = (0x100 | m.charCodeAt(0)).toString(16).substring(1);\n    return \"%\" + code;\n  });\n  output = decodeURIComponent(output);\n\n  return output;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL3V0ZjguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsRUFBRTtBQUMzQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL3V0ZjguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiB1dGlsL3V0ZjguanMgLSBJbXBsZW1lbnRhdGlvbiBvZiBVVEYtOCBFbmNvZGVyL0RlY29kZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHV0ZjggPSBleHBvcnRzO1xuXG51dGY4LmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBvdXRwdXQgPSBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQgfHwgXCJcIik7XG4gIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC8lKFswLTlhLWZBLUZdezJ9KS9nLCBmdW5jdGlvbihtLCBjb2RlKSB7XG4gICAgY29kZSA9IHBhcnNlSW50KGNvZGUsIDE2KTtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG51dGY4LmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBvdXRwdXQgPSAoaW5wdXQgfHwgXCJcIikucmVwbGFjZSgvW1xcdTAwODAtXFx1MDBmZl0vZywgZnVuY3Rpb24obSkge1xuICAgIHZhciBjb2RlID0gKDB4MTAwIHwgbS5jaGFyQ29kZUF0KDApKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgIHJldHVybiBcIiVcIiArIGNvZGU7XG4gIH0pO1xuICBvdXRwdXQgPSBkZWNvZGVVUklDb21wb25lbnQob3V0cHV0KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/utf8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/version.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDUTtBQUNFO0FBQ0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgYXMgdjEgfSBmcm9tICcuL3YxLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjMgfSBmcm9tICcuL3YzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjQgfSBmcm9tICcuL3Y0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjUgfSBmcm9tICcuL3Y1LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTklMIH0gZnJvbSAnLi9uaWwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmFsaWRhdGUgfSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZSB9IGZyb20gJy4vcGFyc2UuanMnOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/md5.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/md5.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsU0FBUyx3REFBaUI7QUFDMUI7O0FBRUEsaUVBQWUsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG5cbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZDU7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/md5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/native.js":
/*!**************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/native.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0QjtBQUM1QixpRUFBZTtBQUNmLGNBQWMsMERBQWlCO0FBQy9CLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25hdGl2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5leHBvcnQgZGVmYXVsdCB7XG4gIHJhbmRvbVVVSUQ6IGNyeXB0by5yYW5kb21VVUlEXG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/nil.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/nil.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25pbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJzsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/nil.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUsiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3BhcnNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gcGFyc2UodXVpZCkge1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIGxldCB2O1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7IC8vIFBhcnNlICMjIyMjIyMjLS4uLi4tLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0jIyMjLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0jIyMjLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tIyMjIy0uLi4uLi4uLi4uLi5cblxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0uLi4uLSMjIyMjIyMjIyMjI1xuICAvLyAoVXNlIFwiL1wiIHRvIGF2b2lkIDMyLWJpdCB0cnVuY2F0aW9uIHdoZW4gYml0LXNoaWZ0aW5nIGhpZ2gtb3JkZXIgYnl0ZXMpXG5cbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/regex.js":
/*!*************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/regex.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyx5Q0FBeUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JlZ2V4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0QjtBQUM1Qix1Q0FBdUM7O0FBRXZDO0FBQ2U7QUFDZjtBQUNBLElBQUksNERBQXFCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmNvbnN0IHJuZHM4UG9vbCA9IG5ldyBVaW50OEFycmF5KDI1Nik7IC8vICMgb2YgcmFuZG9tIHZhbHVlcyB0byBwcmUtYWxsb2NhdGVcblxubGV0IHBvb2xQdHIgPSBybmRzOFBvb2wubGVuZ3RoO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICBpZiAocG9vbFB0ciA+IHJuZHM4UG9vbC5sZW5ndGggLSAxNikge1xuICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhybmRzOFBvb2wpO1xuICAgIHBvb2xQdHIgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJuZHM4UG9vbC5zbGljZShwb29sUHRyLCBwb29sUHRyICs9IDE2KTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/sha1.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/sha1.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc2hhMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLFNBQVMsd0RBQWlCO0FBQzFCOztBQUVBLGlFQUFlLElBQUkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3NoYTEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG5cbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGJ5dGVzKS5kaWdlc3QoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hhMTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyIvVXNlcnMvcmlhbi1pc2hpa2F3YS9EZXNrdG9wL+isjuino+OBjeaUr+aJleOBhC9uYXpvdG9raV9wYXltZW50L25vZGVfbW9kdWxlcy9ub2RlLWpvc2Uvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zdHJpbmdpZnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zbGljZSgxKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICByZXR1cm4gYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV07XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v1.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v1.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCLENBQUM7QUFDbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWU7OztBQUdmO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QsK0NBQUc7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0Esd0VBQXdFO0FBQ3hFOztBQUVBLDRFQUE0RTs7QUFFNUUsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCLG9DQUFvQzs7QUFFcEMsOEJBQThCOztBQUU5QixrQ0FBa0M7O0FBRWxDLDRCQUE0Qjs7QUFFNUIsa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQSxnQkFBZ0IsOERBQWU7QUFDL0I7O0FBRUEsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7IC8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxubGV0IF9ub2RlSWQ7XG5cbmxldCBfY2xvY2tzZXE7IC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuXG5cbmxldCBfbGFzdE1TZWNzID0gMDtcbmxldCBfbGFzdE5TZWNzID0gMDsgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCBmb3IgQVBJIGRldGFpbHNcblxuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgbGV0IGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIGNvbnN0IGIgPSBidWYgfHwgbmV3IEFycmF5KDE2KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxldCBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIGxldCBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7IC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuXG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlZWRCeXRlcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgICAgIG5vZGUgPSBfbm9kZUlkID0gW3NlZWRCeXRlc1swXSB8IDB4MDEsIHNlZWRCeXRlc1sxXSwgc2VlZEJ5dGVzWzJdLCBzZWVkQnl0ZXNbM10sIHNlZWRCeXRlc1s0XSwgc2VlZEJ5dGVzWzVdXTtcbiAgICB9XG5cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgICAgIGNsb2Nrc2VxID0gX2Nsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcbiAgICB9XG4gIH0gLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG5cblxuICBsZXQgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogRGF0ZS5ub3coKTsgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuXG4gIGxldCBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTsgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuXG4gIGNvbnN0IGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDsgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH0gLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuXG5cbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH0gLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuXG5cbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXVpZC52MSgpOiBDYW4ndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWNcIik7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7IC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwOyAvLyBgdGltZV9sb3dgXG5cbiAgY29uc3QgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmOyAvLyBgdGltZV9taWRgXG5cbiAgY29uc3QgdG1oID0gbXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmOyAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjsgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG5cbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwOyAvLyBgY2xvY2tfc2VxX2xvd2BcblxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7IC8vIGBub2RlYFxuXG4gIGZvciAobGV0IG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCB1bnNhZmVTdHJpbmdpZnkoYik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHYxOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v3.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v3.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0E7QUFDM0IsV0FBVyxtREFBRyxhQUFhLCtDQUFHO0FBQzlCLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IG1kNSBmcm9tICcuL21kNS5qcyc7XG5jb25zdCB2MyA9IHYzNSgndjMnLCAweDMwLCBtZDUpO1xuZXhwb3J0IGRlZmF1bHQgdjM7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* binding */ v35)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlEO0FBQ2xCOztBQUUvQjtBQUNBLDJDQUEyQzs7QUFFM0M7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDQTtBQUNRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyw4REFBZTtBQUMxQixJQUFJOzs7QUFHSjtBQUNBLDhCQUE4QjtBQUM5QixJQUFJLGVBQWU7OztBQUduQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JpYW4taXNoaWthd2EvRGVza3RvcC/orI7op6PjgY3mlK/miZXjgYQvbmF6b3Rva2lfcGF5bWVudC9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlLmpzJztcblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIGNvbnN0IGJ5dGVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuZXhwb3J0IGNvbnN0IEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGNvbnN0IFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjM1KG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBfbmFtZXNwYWNlO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lc3BhY2UgPSBwYXJzZShuYW1lc3BhY2UpO1xuICAgIH1cblxuICAgIGlmICgoKF9uYW1lc3BhY2UgPSBuYW1lc3BhY2UpID09PSBudWxsIHx8IF9uYW1lc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9uYW1lc3BhY2UubGVuZ3RoKSAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH0gLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcbiAgICAvLyBGdXR1cmU6IFVzZSBzcHJlYWQgc3ludGF4IHdoZW4gc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMsIGUuZy4gYGJ5dGVzID1cbiAgICAvLyBoYXNoZnVuYyhbLi4ubmFtZXNwYWNlLCAuLi4gdmFsdWVdKWBcblxuXG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShieXRlcyk7XG4gIH0gLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG5cblxuICB0cnkge1xuICAgIGdlbmVyYXRlVVVJRC5uYW1lID0gbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gIH0gY2F0Y2ggKGVycikge30gLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcblxuXG4gIGdlbmVyYXRlVVVJRC5ETlMgPSBETlM7XG4gIGdlbmVyYXRlVVVJRC5VUkwgPSBVUkw7XG4gIHJldHVybiBnZW5lcmF0ZVVVSUQ7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v4.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v4.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCOztBQUVqRDtBQUNBLE1BQU0sa0RBQU07QUFDWixXQUFXLGtEQUFNO0FBQ2pCOztBQUVBO0FBQ0EsaURBQWlELCtDQUFHLEtBQUs7O0FBRXpEO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLDhEQUFlO0FBQ3hCOztBQUVBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBuYXRpdmUgZnJvbSAnLi9uYXRpdmUuanMnO1xuaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGlmIChuYXRpdmUucmFuZG9tVVVJRCAmJiAhYnVmICYmICFvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5hdGl2ZS5yYW5kb21VVUlEKCk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiB1bnNhZmVTdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v5.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v5.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0U7QUFDN0IsV0FBVyxtREFBRyxhQUFhLGdEQUFJO0FBQy9CLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IHNoYTEgZnJvbSAnLi9zaGExLmpzJztcbmNvbnN0IHY1ID0gdjM1KCd2NScsIDB4NTAsIHNoYTEpO1xuZXhwb3J0IGRlZmF1bHQgdjU7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js":
/*!****************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7O0FBRS9CO0FBQ0EscUNBQXFDLGlEQUFLO0FBQzFDOztBQUVBLGlFQUFlLFFBQVEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZhbGlkYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/version.js":
/*!***************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/version.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.slice(14, 15), 16);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQzs7QUFFckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLE9BQU8iLCJzb3VyY2VzIjpbIi9Vc2Vycy9yaWFuLWlzaGlrYXdhL0Rlc2t0b3Av6KyO6Kej44GN5pSv5omV44GEL25hem90b2tpX3BheW1lbnQvbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiB2ZXJzaW9uKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTUpLCAxNik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZlcnNpb247Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/version.js\n");

/***/ })

};
;